<serverConfiguration version="3.4.2">
  <date>2017-07-17 15:33:05</date>
  <channelGroups>
    <channelGroup version="3.4.2">
      <id>1ac0b1be-0225-412b-ae6b-e3d625a49029</id>
      <name>DEX Orders and Results</name>
      <revision>67</revision>
      <lastModified>
        <time>1497220436906</time>
        <timezone>UTC</timezone>
      </lastModified>
      <description></description>
      <channels>
        <channel version="3.4.2">
          <id>e0f422e1-0550-40f1-8a37-e148e0b5f636</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>4c7bc0bd-aede-4e90-9ce8-cde50750f1e8</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>9eeed45d-4613-4501-86f1-236e91808742</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>b21b42cb-5080-4b45-ad37-e761ff386050</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
      </channels>
    </channelGroup>
    <channelGroup version="3.4.2">
      <id>4c98837b-2cd8-43f4-908d-fce16b2529b2</id>
      <name>FHIR Population and Manipulation</name>
      <revision>13</revision>
      <lastModified>
        <time>1497222046239</time>
        <timezone>UTC</timezone>
      </lastModified>
      <description></description>
      <channels>
        <channel version="3.4.2">
          <id>f24a2bfd-8f45-4170-b6d6-6410f426ec66</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>6dacfc8f-4e4a-4baa-8996-635d9fc36cc8</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>0e065234-bc37-4b39-8bef-64905497ec91</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
      </channels>
    </channelGroup>
    <channelGroup version="3.4.2">
      <id>8a5e4e58-a5e8-4a50-aa81-8ae1fb3c6625</id>
      <name>Interpretation Engine</name>
      <revision>2</revision>
      <lastModified>
        <time>1494872427620</time>
        <timezone>UTC</timezone>
      </lastModified>
      <description></description>
      <channels>
        <channel version="3.4.2">
          <id>10bbdc06-7736-4608-b057-4ba3e427bd5d</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
      </channels>
    </channelGroup>
    <channelGroup version="3.4.2">
      <id>929b305c-58c8-4b17-bf76-685a68232f15</id>
      <name>Obsolete</name>
      <revision>7</revision>
      <lastModified>
        <time>1497222046235</time>
        <timezone>UTC</timezone>
      </lastModified>
      <description></description>
      <channels>
        <channel version="3.4.2">
          <id>829fe0c9-9229-4cb3-9cc3-1250213f284f</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>9b81980c-9c03-4c6d-bb30-46bd533aaed5</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>e37e8a4a-f586-4ce6-9b4d-fbda18225fb2</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>fe611e68-b10f-49b0-bbf9-3f64882fa904</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>21a56174-3525-4cfe-bb7d-f6e5eb4bd236</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>ae149084-1aaa-4867-a7e3-b66860874f05</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>20fb74a5-8bfe-4b1c-a2b7-2dbaa17d7fce</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>4f329e32-3a0a-44cd-8bf1-7dd309df7967</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>e38ce6d8-cdfc-4a8a-877a-6688edb368ee</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>7e3d40fd-a84d-41df-9994-7a405c6a3bad</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>e2430412-c499-4f5a-b1ef-6409cd34b2d3</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
      </channels>
    </channelGroup>
    <channelGroup version="3.4.2">
      <id>0cc617ce-4929-461d-bde1-45a94cdaec0d</id>
      <name>Test Harness</name>
      <revision>2</revision>
      <lastModified>
        <time>1495397207406</time>
        <timezone>UTC</timezone>
      </lastModified>
      <description></description>
      <channels>
        <channel version="3.4.2">
          <id>041540bc-16e7-43fe-a9eb-1ca3c5ea17db</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>b73a73d9-b589-4dd7-8a5b-d24fe9ed522d</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>9a84542d-ad54-4f5e-99a5-7733114fc95d</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
      </channels>
    </channelGroup>
    <channelGroup version="3.4.2">
      <id>6bd0e613-0ec7-4c82-a681-6f6dc1d70c92</id>
      <name>Test JSON HTTP Receivers</name>
      <revision>1</revision>
      <lastModified>
        <time>1493499651282</time>
        <timezone>UTC</timezone>
      </lastModified>
      <description></description>
      <channels>
        <channel version="3.4.2">
          <id>b690aebe-457f-494c-8231-8a2050152907</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
        <channel version="3.4.2">
          <id>b8496491-c20f-4799-9732-87d95032edb3</id>
          <enabled>false</enabled>
          <revision>0</revision>
        </channel>
      </channels>
    </channelGroup>
  </channelGroups>
  <channels>
    <channel version="3.4.2">
      <id>e2430412-c499-4f5a-b1ef-6409cd34b2d3</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>CSV to Processor</name>
      <description></description>
      <enabled>false</enabled>
      <lastModified>
        <time>1493601549551</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>4</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.js.JavaScriptReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <pollConnectorProperties version="3.4.2">
            <pollingType>INTERVAL</pollingType>
            <pollOnStart>false</pollOnStart>
            <pollingFrequency>5000</pollingFrequency>
            <pollingHour>0</pollingHour>
            <pollingMinute>0</pollingMinute>
            <cronJobs/>
            <pollConnectorPropertiesAdvanced>
              <weekly>true</weekly>
              <inactiveDays>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
              </inactiveDays>
              <dayOfMonth>1</dayOfMonth>
              <allDay>true</allDay>
              <startingHour>8</startingHour>
              <startingMinute>0</startingMinute>
              <endingHour>17</endingHour>
              <endingMinute>0</endingMinute>
            </pollConnectorPropertiesAdvanced>
          </pollConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <script>var HeaderLine = &quot;accession,first_name,last_name,dob,gender,address1,address2,city,state,zip,fast,date_collected,date_lab_rec,date_lab_reported,date_rec,date_reviewed,notes,MEASLES ANTIBODY (IGG),MUMPS VIRUS ANTIBODY (IGG),RUBELLA ANTIBODY (IGG)&quot;;
var DataLine   = &quot;XXXXXXXXX,FIRST,LAST,1/1/2000,F,,,,,,,3/10/2017 12:00,3/11/2017 6:16,3/14/2017 13:39,3/14/2017 13:36,3/14/2017 14:54,\&quot;Measles, Mumps, Rubella and Varicella antibody titers indicate immunity (Immune). Hepatitis B surface antibody titer is low or negative indicating no immunity (Non-Immune).\&quot;,4.76,3.19,4.43,&lt;5,1.26&quot;;

var HeaderArray = HeaderLine.split(&quot;,&quot;);
var DataArray =   DataLine.split(&quot;,&quot;);


</script>
        </properties>
        <transformer version="3.4.2">
          <steps/>
          <inboundDataType>HL7V2</inboundDataType>
          <outboundDataType>HL7V2</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>JavaScript Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Destination 1</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>HL7V2</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>HL7V2</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set">
          <string>RKW</string>
        </tags>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>9a84542d-ad54-4f5e-99a5-7733114fc95d</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>FHIR Contained Resource Test</name>
      <description></description>
      <enabled>false</enabled>
      <lastModified>
        <time>1497195992987</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>25</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Dummy</name>
              <script>channelMap.put( &quot;Dummy&quot;, &quot;Dummy&quot; );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>channelMap.put( &quot;Dummy&quot;, &quot;Dummy&quot; );</string>
                </entry>
              </data>
            </step>
            <step>
              <sequenceNumber>1</sequenceNumber>
              <name>New Step</name>
              <script></script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string></string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64">PERpYWdub3N0aWNSZXBvcnQ+Cgk8Y29udGFpbmVkPgoJCTxPYnNlcnZhdGlvbj4KCQkJPGlkIHZh
bHVlPSI1NTAxOTMwMCIvPgoJCQk8aWRlbnRpZmllcj4KCQkJCTx2YWx1ZSB2YWx1ZT0iNTUwMTkz
MDAiLz4KCQkJPC9pZGVudGlmaWVyPgoJCQk8c3RhdHVzIHZhbHVlPSJmaW5hbCIvPgoJCQk8Y29k
ZT4KCQkJCTxjb2Rpbmc+CgkJCQkJPHN5c3RlbSB2YWx1ZT0iaHR0cDovL2xvaW5jLm9yZyIvPgoJ
CQkJCTxjb2RlIHZhbHVlPSI1MTk2LTEiLz4KCQkJCQk8ZGlzcGxheSB2YWx1ZT0iSEJWIHN1cmZh
Y2UgQWcgU2VyUGwgUWwgSUEiLz4KCQkJCTwvY29kaW5nPgoJCQkJPGNvZGluZz4KCQkJCQk8c3lz
dGVtIHZhbHVlPSI5OVFESSIvPgoJCQkJCTxjb2RlIHZhbHVlPSI1NTAxOTMwMCIvPgoJCQkJCTxk
aXNwbGF5IHZhbHVlPSJIRVBBVElUSVMgQiBTVVJGQUNFIEFOVElHRU4iLz4KCQkJCTwvY29kaW5n
PgoJCQk8L2NvZGU+CgkJCTxpc3N1ZWQgdmFsdWU9IjIwMTctMDUtMTFUMTU6MzM6MTQuMDAwWiIv
PgoJCQk8aW50ZXJwcmV0YXRpb24+CgkJCQk8dGV4dCB2YWx1ZT0iQSIvPgoJCQk8L2ludGVycHJl
dGF0aW9uPgoJCQk8cmVmZXJlbmNlUmFuZ2U+CgkJCQk8bWVhbmluZz4KCQkJCQk8Y29kaW5nPgoJ
CQkJCQk8c3lzdGVtIHZhbHVlPSIiLz4KCQkJCQk8L2NvZGluZz4KCQkJCTwvbWVhbmluZz4KCQkJ
CTx0ZXh0IHZhbHVlPSJOT04tUkVBQ1RJVkUiLz4KCQkJPC9yZWZlcmVuY2VSYW5nZT4KCQk8L09i
c2VydmF0aW9uPgoJCTxPYnNlcnZhdGlvbj4KCQkJPGlkIHZhbHVlPSI1NTAxOTYwMCIvPgoJCQk8
aWRlbnRpZmllcj4KCQkJCTx2YWx1ZSB2YWx1ZT0iNTUwMTk2MDAiLz4KCQkJPC9pZGVudGlmaWVy
PgoJCQk8c3RhdHVzIHZhbHVlPSJ1bmtub3duIi8+CgkJCTxjb2RlPgoJCQkJPGNvZGluZz4KCQkJ
CQk8c3lzdGVtIHZhbHVlPSJodHRwOi8vbG9pbmMub3JnIi8+CgkJCQkJPGNvZGUgdmFsdWU9Ijc5
MDUtMyIvPgoJCQkJCTxkaXNwbGF5IHZhbHVlPSJIQlYgc3VyZmFjZSBBZyBTZXJQbCBRbCBOdCIv
PgoJCQkJPC9jb2Rpbmc+CgkJCQk8Y29kaW5nPgoJCQkJCTxzeXN0ZW0gdmFsdWU9Ijk5UURJIi8+
CgkJCQkJPGNvZGUgdmFsdWU9IjU1MDE5NjAwIi8+CgkJCQkJPGRpc3BsYXkgdmFsdWU9IkNPTkZJ
Uk1BVElPTiIvPgoJCQkJPC9jb2Rpbmc+CgkJCTwvY29kZT4KCQkJPGlzc3VlZCB2YWx1ZT0iMjAx
Ny0wNS0xMVQxNTozMzoxNC4wMDBaIi8+CgkJCTxpbnRlcnByZXRhdGlvbj4KCQkJCTx0ZXh0IHZh
bHVlPSJOIi8+CgkJCTwvaW50ZXJwcmV0YXRpb24+CgkJCTxyZWZlcmVuY2VSYW5nZT4KCQkJCTxt
ZWFuaW5nPgoJCQkJCTxjb2Rpbmc+CgkJCQkJCTxzeXN0ZW0gdmFsdWU9IiIvPgoJCQkJCTwvY29k
aW5nPgoJCQkJPC9tZWFuaW5nPgoJCQk8L3JlZmVyZW5jZVJhbmdlPgoJCTwvT2JzZXJ2YXRpb24+
Cgk8L2NvbnRhaW5lZD4KCTxzdGF0dXMgdmFsdWU9ImZpbmFsIi8+Cgk8Y29kZSBpZD0iNDk4Ii8+
Cgk8c3ViamVjdD4KCQk8cmVmZXJlbmNlIHZhbHVlPSJQYXRpZW50LyIvPgoJPC9zdWJqZWN0PgoJ
PHJlc3VsdD4KCQk8cmVmZXJlbmNlIHZhbHVlPSIjNTUwMTkzMDAiLz4KCQk8cmVmZXJlbmNlIHZh
bHVlPSIjNTUwMTk2MDAiLz4KCTwvcmVzdWx0Pgo8L0RpYWdub3N0aWNSZXBvcnQ+</outboundTemplate>
          <inboundDataType>RAW</inboundDataType>
          <outboundDataType>XML</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>true</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Destination 1</name>
          <properties class="com.mirth.connect.connectors.http.HttpDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <host>http://52.36.33.171:8080/fhir/fhir/DiagnosticReport</host>
            <useProxyServer>false</useProxyServer>
            <proxyAddress></proxyAddress>
            <proxyPort></proxyPort>
            <method>post</method>
            <headers class="linked-hash-map">
              <entry>
                <string>Accept</string>
                <list>
                  <string>application/xml</string>
                </list>
              </entry>
              <entry>
                <string>Content-Type</string>
                <list>
                  <string>application/json</string>
                </list>
              </entry>
            </headers>
            <parameters class="linked-hash-map"/>
            <responseXmlBody>true</responseXmlBody>
            <responseParseMultipart>true</responseParseMultipart>
            <responseIncludeMetadata>false</responseIncludeMetadata>
            <responseBinaryMimeTypes>application/.*(?&lt;!json+fhir|xml+fhir)</responseBinaryMimeTypes>
            <responseBinaryMimeTypesRegex>true</responseBinaryMimeTypesRegex>
            <multipart>false</multipart>
            <useAuthentication>false</useAuthentication>
            <authenticationType>Basic</authenticationType>
            <usePreemptiveAuthentication>false</usePreemptiveAuthentication>
            <username></username>
            <password></password>
            <content>${message.encodedData}</content>
            <contentType>text/xml</contentType>
            <dataTypeBinary>false</dataTypeBinary>
            <charset>UTF-8</charset>
            <socketTimeout>30000</socketTimeout>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>HTTP Sender</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>ae149084-1aaa-4867-a7e3-b66860874f05</id>
      <nextMetaDataId>3</nextMetaDataId>
      <name>Gateway</name>
      <description>Receives SubmitOrder XML feed, transforms to JSON and routes to Quest or LabCorp SubmitOrder channels.

Last updated: March 11, 2017</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1489352132059</time>
        <timezone>UTC</timezone>
      </lastModified>
      <revision>12</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.fhir.shared.FhirReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>9099</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>OperationOutcome</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <contextPath></contextPath>
          <timeout>0</timeout>
          <conformanceTemplate></conformanceTemplate>
          <conformanceURL></conformanceURL>
          <conformanceName></conformanceName>
          <supportsXML>true</supportsXML>
          <supportsJSON>true</supportsJSON>
          <systemInteractions>
            <com.mirth.connect.connectors.fhir.shared.FhirRestfulInteraction>FHIR_HISTORY_SYSTEM</com.mirth.connect.connectors.fhir.shared.FhirRestfulInteraction>
            <com.mirth.connect.connectors.fhir.shared.FhirRestfulInteraction>FHIR_SEARCH_SYSTEM</com.mirth.connect.connectors.fhir.shared.FhirRestfulInteraction>
            <com.mirth.connect.connectors.fhir.shared.FhirRestfulInteraction>FHIR_TRANSACTION</com.mirth.connect.connectors.fhir.shared.FhirRestfulInteraction>
          </systemInteractions>
          <resourceProperties>
            <disabledInteractions/>
          </resourceProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Route to destination</name>
              <script>if (msg[&apos;id&apos;][&apos;@value&apos;].toString().indexOf(&quot;OML-O21&quot;) &gt; -1) {
	
	// Route to Quest SubmitOrder	
	destinationSet.removeAllExcept([&quot;SubmitOrder Quest&quot;]);
	
} else {
	// TODO: Route to LabCorp SubmitOrder
	destinationSet.removeAll();
}</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>if (msg[&apos;id&apos;][&apos;@value&apos;].toString().indexOf(&quot;OML-O21&quot;) &gt; -1) {
	
	// Route to Quest SubmitOrder	
	destinationSet.removeAllExcept([&quot;SubmitOrder Quest&quot;]);
	
} else {
	// TODO: Route to LabCorp SubmitOrder
	destinationSet.removeAll();
}</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">PEJ1bmRsZT4KCTxpZCB2YWx1ZT0iT01MLU8yMS1yZXF1aXNpdGlvbi0xIi8+Cgk8dHlwZSB2YWx1
ZT0ic2VhcmNoc2V0Ii8+Cgk8ZW50cnk+PCEtLSBQYXRpZW50IChQSUQpIC0tPgoJCTxyZXNvdXJj
ZT4KCQkJPFBhdGllbnQ+CgkJCQk8aWQgdmFsdWU9IlBJRC1wYXRpZW50LWlkZW50aWZpY2F0aW9u
Ii8+CgkJCQk8IS0tIFBJRC4yIFtFeHRlcm5hbCBJRF0gLSBUaGUgcGxhY2VyJ3MgcGF0aWVudCBJ
RCBhc3NpZ25lZCB0byB0aGlzIG9yZGVyLiAtLT4KCQkJCTxpZGVudGlmaWVyPgoJCQkJCTwhLS0g
KFNOKSBIYXJkLWNvZGVkIC0tPgoJCQkJCTx1c2UgdmFsdWU9InNlY29uZGFyeSIvPgoJCQkJCTx0
eXBlPgoJCQkJCQk8Y29kaW5nPgoJCQkJCQkJPCEtLSBQSUQuMi43IFtJZGVudGlmaWVyIFR5cGUg
Q29kZV0gLSBPcHRpb25hbCAtLT4KCQkJCQkJCTxjb2RlIHZhbHVlPSJQVCIvPgoJCQkJCQk8L2Nv
ZGluZz4KCQkJCQk8L3R5cGU+CgkJCQkJPCEtLSBQSUQuMi4xIFtQYXRpZW50IElEIChJbnRlcm5h
bCldIC0gUmVxdWlyZWQgLS0+CgkJCQkJPHZhbHVlIHZhbHVlPSIyMDUyNjYxOSIvPgoJCQkJPC9p
ZGVudGlmaWVyPgoJCQkJPCEtLSBQSUQuMyBbUGF0aWVudCBJZGVudGlmaWVyIExpc3RdIC0gVGhl
IHBsYWNlcidzIHBhdGllbnQgSUQgYXNzaWduZWQgdG8gdGhpcyBvcmRlci4gLS0+CgkJCQk8aWRl
bnRpZmllcj4KCQkJCQk8IS0tIChTTikgSGFyZC1jb2RlZCAtLT4KCQkJCQk8dXNlIHZhbHVlPSJv
ZmZpY2lhbCIvPgoJCQkJCTx0eXBlPgoJCQkJCQk8Y29kaW5nPgoJCQkJCQkJPCEtLSBQSUQuMi43
IFtJZGVudGlmaWVyIFR5cGUgQ29kZV0gLSBPcHRpb25hbCAtLT4KCQkJCQkJCTxjb2RlIHZhbHVl
PSJQVCIvPgoJCQkJCQk8L2NvZGluZz4KCQkJCQk8L3R5cGU+CgkJCQkJPCEtLSBQSUQuMi4xIFtQ
YXRpZW50IElEIChJbnRlcm5hbCldIC0gUmVxdWlyZWQgLS0+CgkJCQkJPHZhbHVlIHZhbHVlPSIy
MDUyNjYxOSIvPgoJCQkJCTwhLS0gUElELjMuNCBbQXNzaWduaW5nIEF1dGhvcml0eV0gLSBPcHRp
b25hbCAtLT4KCQkJCQk8IS0tIChTTikgSWYgdmFsdWUgaXMgbm90IGtub3duLCBkbyBub3QgaW5j
bHVkZSAtLT4KCQkJCQk8YXNzaWduZXI+CgkJCQkJCTwhLS0gVmFsaWQgdmFsdWVzIGZvciBBc3Np
Z25pbmcgQXV0aG9yaXR5IGluY2x1ZGU6IE1STiAoTWVkaWNhbCBSZWNvcmQgTnVtYmVyKSBvciBD
SUQgKENoYXJ0IElEKSAtLT4KCQkJCQkJPGRpc3BsYXkgdmFsdWU9Ik1STiIvPgoJCQkJCTwvYXNz
aWduZXI+CgkJCQk8L2lkZW50aWZpZXI+CgkJCQk8IS0tIFBJRC41IFtQYXRpZW50IE5hbWVdIC0g
UmVxdWlyZWQgLS0+CgkJCQk8IS0tIChTTikgVGhlIGVudGlyZSBwYXRpZW50IG5hbWUgKGV4Y2x1
ZGluZyB0aGUgZGVsaW1pdGVyKSBjYW5ub3QgZXhjZWVkIDI0IGNoYXJhY3RlcnMuIC0tPgoJCQkJ
PG5hbWU+CgkJCQkJPCEtLSAoU04pICJ1c2UiIGVsZW1lbnQgaXMgaGFyZGNvZGVkIGZvciBwcmlt
YXJ5IHBhdGllbnQgbmFtZSAtLT4KCQkJCQk8dXNlIHZhbHVlPSJvZmZpY2lhbCIvPgoJCQkJCTwh
LS0gUElELjUuMSBbRmFtaWx5IE5hbWVdIC0tPgoJCQkJCTwhLS0gKFNOKSBUaGUgbGFzdCBuYW1l
IGNhbiBiZSBhIG1heGltdW0gb2YgMjAgY2hhcmFjdGVycy4gQW55IGxhc3QgbmFtZSBsb25nZXIg
dGhhbiB0aGUgYWxsb3dlZCBsaW1pdCBpcyB0cnVuY2F0ZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcg
cmVzdWx0IG1lc3NhZ2UuIC0tPgoJCQkJCTxmYW1pbHkgdmFsdWU9IlRFU1QiLz4KCQkJCQk8IS0t
IFBJRC41LjIgW0dpdmVuIE5hbWVdIC0tPgoJCQkJCTwhLS0gKFNOKSBUaGUgZmlyc3QgbmFtZSBp
cyBsaW1pdGVkIHRvIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG51bWJlciBvZiBjaGFyYWN0
ZXJzIGluIHRoZSBsYXN0IG5hbWUgYW5kIDI0LiAtLT4KCQkJCQk8Z2l2ZW4gdmFsdWU9IlRDMSIv
PgoJCQkJPC9uYW1lPgoJCQkJPCEtLSBQSUQuMTMgW1Bob25lIE51bWJlciAtIEhvbWVdIC0gQ29u
ZGl0aW9uYWwgLS0+CgkJCQk8IS0tIChTTikgVGhpcyBmaWVsZCBpcyByZXF1aXJlZCBpZiBJTjEu
NDcgKENvdmVyYWdlIFR5cGUpIGlzIFAgKFBhdGllbnQgQmlsbCkgb3IgVCAoVGhpcmQtUGFydHkg
QmlsbCkuIC0tPgoJCQkJPHRlbGVjb20+CgkJCQkJPHN5c3RlbSB2YWx1ZT0icGhvbmUiLz4KCQkJ
CQk8dmFsdWUgdmFsdWU9Ijk3Mi05MTYtMzAwMCIvPgoJCQkJCTx1c2UgdmFsdWU9ImhvbWUiLz4K
CQkJCTwvdGVsZWNvbT4KCQkJCTwhLS0gUElELjggW0FkbWluaXN0cmF0aXZlIEdlbmRlcl0gLSBS
ZXF1aXJlZCAtLT4KCQkJCTxnZW5kZXIgdmFsdWU9ImZlbWFsZSIvPgoJCQkJPCEtLSBQSUQuNyBb
RGF0ZSBvZiBCaXJ0aF0gLSBSZXF1aXJlZCAtLT4KCQkJCTxiaXJ0aERhdGUgdmFsdWU9IjE5NTAt
MDEtMTYiLz4KCQkJCTwhLS0gUElELjExIFtQYXRpZW50IEFkZHJlc3NdIC0gQ29uZGl0aW9uYWwg
LS0+CgkJCQk8IS0tIChTTikgVGhpcyBmaWVsZCBpcyByZXF1aXJlZCBpZiBJTjEuNDcgKENvdmVy
YWdlIFR5cGUpIGlzIFAgKFBhdGllbnQgQmlsbCkgb3IgVCAoVGhpcmQtUGFydHkgQmlsbCkuIC0t
PgoJCQkJPGFkZHJlc3M+CgkJCQkJPHVzZSB2YWx1ZT0iaG9tZSIvPgoJCQkJCTxsaW5lIHZhbHVl
PSI0NzcwIFJlZ2VudCBCbHZkLiIvPgoJCQkJCTxjaXR5IHZhbHVlPSJJcnZpbmciLz4KCQkJCQk8
c3RhdGUgdmFsdWU9IlRYIi8+CgkJCQkJPHBvc3RhbENvZGUgdmFsdWU9Ijc1MDYzIi8+CgkJCQk8
L2FkZHJlc3M+CgkJCTwvUGF0aWVudD4KCQk8L3Jlc291cmNlPgoJPC9lbnRyeT4KCTxlbnRyeT48
IS0tIERpYWdub3N0aWNSZXBvcnQgKE9SQykgLS0+CgkJPHJlc291cmNlPgoJCQk8IS0tIFRoZSBP
UkMgc2VnbWVudCBpcyByZXF1aXJlZCBpbiB0aGUgT01MIG1lc3NhZ2UuIE9ubHkgb25lIHBlciBv
cmRlci4gLS0+CgkJCTwhLS0gKFNOKSBPcHRpb25hbCBPUkMuMTIgW09yZGVyaW5nIFByb3ZpZGVy
XSBpcyBkZWZpbmVkIGluIGFzIE9CUi4xNiBpbiB0aGUgRGlhZ25vc3RpY09yZGVyIHJlc291cmNl
IC0tPgoJCQk8RGlhZ25vc3RpY1JlcG9ydD4KCQkJCTxpZCB2YWx1ZT0iT1JDLWNvbW1vbi1vcmRl
ci0xIi8+CgkJCQk8IS0tIFRRMSBbVGltaW5nL1F1YW50aXR5XSAtIFJlcXVpcmVkIC0tPgoJCQkJ
PCEtLSAoU04pIFJlcXVpcmVkIGlmIGNvbW1vbiBvcmRlciAoT1JDKSBpcyBwcmVzZW50LCBvbmx5
IG9uZSBwZXIgb3JkZXIgLS0+CgkJCQk8ZXh0ZW5zaW9uIHVybD0iaHR0cDovL2hsNy5vcmcvZmhp
ci92Mi90cTEiPgoJCQkJCTx2YWx1ZVRpbWluZz4KCQkJCQkJPCEtLSBUUTEuNyBbU3RhcnQgRGF0
ZS9UaW1lXSAtIE9wdGlvbmFsIC0tPgoJCQkJCQk8ZXZlbnQgdmFsdWU9IjIwMTYtMDEtMDdUMDk6
MDA6MDAtMDU6MDAiLz4KCQkJCQkJPCEtLSBUUTEuOSBbUHJpb3JpdHldIC0gT3B0aW9uYWwgLS0+
CgkJCQkJCTxjb2RlPgoJCQkJCQkJPGNvZGluZz4KCQkJCQkJCQk8IS0tIChTTikgRm9yIHZhbHVl
cyBzZWUgSEw3djIuNS4xIENoYXB0ZXIgMDQsIFVzZXItRGVmaW5lZCBUYWJsZSAwNDg1IO+/vSBF
eHRlbmRlZCBQcmlvcml0eSBDb2RlcyAtLT4KCQkJCQkJCQk8c3lzdGVtIHZhbHVlPSJodHRwOi8v
aGw3Lm9yZy9maGlyL3YyLzA0ODUiLz4KCQkJCQkJCQk8Y29kZSB2YWx1ZT0iUyIvPgoJCQkJCQkJ
CTxkaXNwbGF5IHZhbHVlPSJTdGF0Ii8+CgkJCQkJCQk8L2NvZGluZz4KCQkJCQkJPC9jb2RlPgoJ
CQkJCTwvdmFsdWVUaW1pbmc+CgkJCQk8L2V4dGVuc2lvbj4JCQkJCgkJCQk8IS0tIE9SQy4yIFtQ
bGFjZXIgT3JkZXIgTnVtYmVyXSAtIFJlcXVpcmVkIC0tPgoJCQkJPCEtLSBUaGUgdmFsdWUgaW4g
T1JDLjAyLjAxIChFbnRpdHkgSWRlbnRpZmllcikgaXMgdGhlIHNhbWUgYXMgdGhlIHZhbHVlIGlu
IE9CUi4wMi4wMSAoRW50aXR5IElkZW50aWZpZXIpLiAtLT4KCQkJCTwhLS0gQWxsIHZhbHVlcyBm
b3IgdGhpcyBmaWVsZCBpbiBhbGwgT1JDIGFuZCBPQlIgc2VnbWVudHMgYXJlIGlkZW50aWNhbC4g
T3RoZXJ3aXNlLCB0aGUgb3JkZXIgd2lsbCBiZSByZWplY3RlZC4gLS0+CgkJCQk8aWRlbnRpZmll
cj4KCQkJCQk8IS0tIE9SQy4yLjEgW0VudGl0eSBJZGVudGlmaWVyIC8gVW5pcXVlIFBsYWNlciBJ
RF0gLSBSZXF1aXJlZCAtLT4KCQkJCQk8IS0tIChTTikgTXVzdCBtYXRjaCBPQlIuMi4wMSBbRW50
aXR5IElkZW50aWZpZXJdIG9yIHRoZSBvcmRlciB3aWxsIGJlIHJlamVjdGVkLiAtLT4KCQkJCQk8
dmFsdWUgdmFsdWU9Ijk4NzY1NDMyMSIvPgoJCQkJPC9pZGVudGlmaWVyPgoJCQkJPCEtLSAoU04p
IFJlcXVpcmVkIGJ5IEZISVIgLS0+CgkJCQk8c3RhdHVzIHZhbHVlPSJmaW5hbCIvPgoJCQkJPCEt
LSBPQlIuNC40IFtBbHRlcm5hdGUgSWRlbnRpZmllcl0gLSBSZXF1aXJlZCAtLT4KCQkJCTwhLS0g
KFNOKSBJZGVudGlmaWNhdGlvbiBjb2RlIGZvciB0aGUgb3JkZXJlZCB0ZXN0ICAtLT4KCQkJCTxj
b2RlIGlkPSIxMDEyNCIvPgoJCQkJPHN1YmplY3Q+CgkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iUGF0
aWVudCIvPgoJCQkJPC9zdWJqZWN0PgoJCQkJPCEtLSAoU04pIFJlcXVpcmVkIGJ5IEZISVIgLS0+
CgkJCQk8ZWZmZWN0aXZlRGF0ZVRpbWU+CgkJCQkJPGV4dGVuc2lvbiB1cmw9Imh0dHA6Ly9obDcu
b3JnL2ZoaXIvdjMvTnVsbEZsYXZvci9OSSIvPgoJCQkJPC9lZmZlY3RpdmVEYXRlVGltZT4KCQkJ
CTwhLS0gKFNOKSBSZXF1aXJlZCBieSBGSElSIC0tPgoJCQkJPGlzc3VlZD4KCQkJCQk8ZXh0ZW5z
aW9uIHVybD0iaHR0cDovL2hsNy5vcmcvZmhpci92My9OdWxsRmxhdm9yL05JIi8+CgkJCQk8L2lz
c3VlZD4KCQkJCTwhLS0gT1JDLjEyIFtPcmRlcmluZyBQcm92aWRlcl0gLSBPcHRpb25hbCAtLT4K
CQkJCTxwZXJmb3JtZXI+CgkJCQkJPCEtLSAoU04pIFJlZmVyZW5jZSB0byB0aGUgUHJhY3RpdGlv
bmVyIHJlc291cnNlIC0tPgoJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IlByYWN0aXRpb25lci9vcmRl
cmluZy1wcm92aWRlci0xIi8+CgkJCQk8L3BlcmZvcm1lcj4KCQkJCTwhLS0gKFNOKSBEZXRhaWxz
IGNvbmNlcm5pbmcgYSB0ZXN0IG9yIHByb2NlZHVyZSByZXF1ZXN0ZWQuIC0tPgoJCQkJPHJlcXVl
c3Q+CgkJCQkJPCEtLSAoU04pIFJlZmVyZW5jZSB0byAgRGlhZ25vc3RpY09yZGVyL2lkL0B2YWx1
ZSAtLT4KCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSJEaWFnbm9zdGljT3JkZXIvT0JSLW9ic2VydmF0
aW9uLXJlcXVlc3QtMSIvPgoJCQkJPC9yZXF1ZXN0PgoJCQk8L0RpYWdub3N0aWNSZXBvcnQ+CgkJ
PC9yZXNvdXJjZT4KCTwvZW50cnk+Cgk8ZW50cnk+PCEtLSBEaWFnbm9zdGljUmVwb3J0IChPUkMp
IC0tPgoJCTxyZXNvdXJjZT4KCQkJPCEtLSBUaGUgT1JDIHNlZ21lbnQgaXMgcmVxdWlyZWQgaW4g
dGhlIE9NTCBtZXNzYWdlLiBPbmx5IG9uZSBwZXIgb3JkZXIuIC0tPgoJCQk8IS0tIChTTikgT3B0
aW9uYWwgT1JDLjEyIFtPcmRlcmluZyBQcm92aWRlcl0gaXMgZGVmaW5lZCBpbiBhcyBPQlIuMTYg
aW4gdGhlIERpYWdub3N0aWNPcmRlciByZXNvdXJjZSAtLT4KCQkJPERpYWdub3N0aWNSZXBvcnQ+
CgkJCQk8aWQgdmFsdWU9Ik9SQy1jb21tb24tb3JkZXItMiIvPgoJCQkJPCEtLSBUUTEgW1RpbWlu
Zy9RdWFudGl0eV0gLSBSZXF1aXJlZCAtLT4KCQkJCTwhLS0gKFNOKSBSZXF1aXJlZCBpZiBjb21t
b24gb3JkZXIgKE9SQykgaXMgcHJlc2VudCwgb25seSBvbmUgcGVyIG9yZGVyIC0tPgoJCQkJPGV4
dGVuc2lvbiB1cmw9Imh0dHA6Ly9obDcub3JnL2ZoaXIvdjIvdHExIj4KCQkJCQk8dmFsdWVUaW1p
bmc+CgkJCQkJCTwhLS0gVFExLjcgW1N0YXJ0IERhdGUvVGltZV0gLSBPcHRpb25hbCAtLT4KCQkJ
CQkJPGV2ZW50IHZhbHVlPSIyMDE2LTAxLTA3VDA5OjAwOjAwLTA1OjAwIi8+CgkJCQkJCTwhLS0g
VFExLjkgW1ByaW9yaXR5XSAtIE9wdGlvbmFsIC0tPgoJCQkJCQk8Y29kZT4KCQkJCQkJCTxjb2Rp
bmc+CgkJCQkJCQkJPCEtLSAoU04pIEZvciB2YWx1ZXMgc2VlIEhMN3YyLjUuMSBDaGFwdGVyIDA0
LCBVc2VyLURlZmluZWQgVGFibGUgMDQ4NSDvv70gRXh0ZW5kZWQgUHJpb3JpdHkgQ29kZXMgLS0+
CgkJCQkJCQkJPHN5c3RlbSB2YWx1ZT0iaHR0cDovL2hsNy5vcmcvZmhpci92Mi8wNDg1Ii8+CgkJ
CQkJCQkJPGNvZGUgdmFsdWU9IlMiLz4KCQkJCQkJCQk8ZGlzcGxheSB2YWx1ZT0iU3RhdCIvPgoJ
CQkJCQkJPC9jb2Rpbmc+CgkJCQkJCTwvY29kZT4KCQkJCQk8L3ZhbHVlVGltaW5nPgoJCQkJPC9l
eHRlbnNpb24+CQkJCQoJCQkJPCEtLSBPUkMuMiBbUGxhY2VyIE9yZGVyIE51bWJlcl0gLSBSZXF1
aXJlZCAtLT4KCQkJCTwhLS0gVGhlIHZhbHVlIGluIE9SQy4wMi4wMSAoRW50aXR5IElkZW50aWZp
ZXIpIGlzIHRoZSBzYW1lIGFzIHRoZSB2YWx1ZSBpbiBPQlIuMDIuMDEgKEVudGl0eSBJZGVudGlm
aWVyKS4gLS0+CgkJCQk8IS0tIEFsbCB2YWx1ZXMgZm9yIHRoaXMgZmllbGQgaW4gYWxsIE9SQyBh
bmQgT0JSIHNlZ21lbnRzIGFyZSBpZGVudGljYWwuIE90aGVyd2lzZSwgdGhlIG9yZGVyIHdpbGwg
YmUgcmVqZWN0ZWQuIC0tPgoJCQkJPGlkZW50aWZpZXI+CgkJCQkJPCEtLSBPUkMuMi4xIFtFbnRp
dHkgSWRlbnRpZmllciAvIFVuaXF1ZSBQbGFjZXIgSURdIC0gUmVxdWlyZWQgLS0+CgkJCQkJPCEt
LSAoU04pIE11c3QgbWF0Y2ggT0JSLjIuMDEgW0VudGl0eSBJZGVudGlmaWVyXSBvciB0aGUgb3Jk
ZXIgd2lsbCBiZSByZWplY3RlZC4gLS0+CgkJCQkJPHZhbHVlIHZhbHVlPSI5ODc2NTQzMjEiLz4K
CQkJCTwvaWRlbnRpZmllcj4KCQkJCTwhLS0gKFNOKSBSZXF1aXJlZCBieSBGSElSIC0tPgoJCQkJ
PHN0YXR1cyB2YWx1ZT0iZmluYWwiLz4KCQkJCTwhLS0gT0JSLjQuNCBbQWx0ZXJuYXRlIElkZW50
aWZpZXJdIC0gUmVxdWlyZWQgLS0+CgkJCQk8IS0tIChTTikgSWRlbnRpZmljYXRpb24gY29kZSBm
b3IgdGhlIG9yZGVyZWQgdGVzdCAgLS0+CgkJCQk8Y29kZSBpZD0iMTAxMjUiLz4KCQkJCTxzdWJq
ZWN0PgoJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IlBhdGllbnQiLz4KCQkJCTwvc3ViamVjdD4KCQkJ
CTwhLS0gKFNOKSBSZXF1aXJlZCBieSBGSElSIC0tPgoJCQkJPGVmZmVjdGl2ZURhdGVUaW1lPgoJ
CQkJCTxleHRlbnNpb24gdXJsPSJodHRwOi8vaGw3Lm9yZy9maGlyL3YzL051bGxGbGF2b3IvTkki
Lz4KCQkJCTwvZWZmZWN0aXZlRGF0ZVRpbWU+CgkJCQk8IS0tIChTTikgUmVxdWlyZWQgYnkgRkhJ
UiAtLT4KCQkJCTxpc3N1ZWQ+CgkJCQkJPGV4dGVuc2lvbiB1cmw9Imh0dHA6Ly9obDcub3JnL2Zo
aXIvdjMvTnVsbEZsYXZvci9OSSIvPgoJCQkJPC9pc3N1ZWQ+CgkJCQk8IS0tIE9SQy4xMiBbT3Jk
ZXJpbmcgUHJvdmlkZXJdIC0gT3B0aW9uYWwgLS0+CgkJCQk8cGVyZm9ybWVyPgoJCQkJCTwhLS0g
KFNOKSBSZWZlcmVuY2UgdG8gdGhlIFByYWN0aXRpb25lciByZXNvdXJzZSAtLT4KCQkJCQk8cmVm
ZXJlbmNlIHZhbHVlPSJQcmFjdGl0aW9uZXIvb3JkZXJpbmctcHJvdmlkZXItMSIvPgoJCQkJPC9w
ZXJmb3JtZXI+CgkJCQk8IS0tIChTTikgRGV0YWlscyBjb25jZXJuaW5nIGEgdGVzdCBvciBwcm9j
ZWR1cmUgcmVxdWVzdGVkLiAtLT4KCQkJCTxyZXF1ZXN0PgoJCQkJCTwhLS0gKFNOKSBSZWZlcmVu
Y2UgdG8gIERpYWdub3N0aWNPcmRlci9pZC9AdmFsdWUgLS0+CgkJCQkJPHJlZmVyZW5jZSB2YWx1
ZT0iRGlhZ25vc3RpY09yZGVyL09CUi1vYnNlcnZhdGlvbi1yZXF1ZXN0LTIiLz4KCQkJCTwvcmVx
dWVzdD4KCQkJPC9EaWFnbm9zdGljUmVwb3J0PgoJCTwvcmVzb3VyY2U+Cgk8L2VudHJ5PgkKCTxl
bnRyeT48IS0tIERpYWdub3N0aWNPcmRlciAoT0JSKSAtLT4KCQk8cmVzb3VyY2U+CgkJCTwhLS0g
T0JSIFtPYnNlcnZhdGlvbiBSZXF1ZXN0XSAtIFJlcXVpcmVkIC0tPgoJCQk8IS0tIChTTikgT25s
eSBvbmUgT0JSIFtPYnNlcnZhdGlvbl0gcGVyIE9yZGVyIE9ic2VydmF0aW9uIGdyb3VwIChPUkMt
T0JSLU9CWCkgLS0+CgkJCTwhLS0gKFNOKSBPQlIuMiBbUGxhY2VyIE9yZGVyIE51bWJlcl0gLSBS
ZXF1cmllZCAtIHNlZSBEaWFnbm9zdGljUmVwb3J0L2lkZW50aWZpZXIgLS0+CgkJCTxEaWFnbm9z
dGljT3JkZXI+CgkJCQk8IS0tIChTTikgVGhlIHZhbHVlIE1VU1QgYmUgaWRlbnRpY2FsIHRvIERp
YWdub3N0aWNSZXBvcnQvcmVxdWVzdC9yZWZlcmVuY2UvQHZhbHVlIChha2EgT1JDKSB0aGlzIE9C
UiBiZWxvbmdzIHRvIC0tPgoJCQkJPGlkIHZhbHVlPSJPQlItb2JzZXJ2YXRpb24tcmVxdWVzdC0x
Ii8+CgkJCQk8IS0tIChTTikgSGFyZC1jb2RlZCwgcmVxdWlyZWQgYnkgRkhJUiAtLT4KCQkJCTxz
dWJqZWN0IGlkPSJQYXRpZW50Ii8+CgkJCQk8ZXZlbnQ+CgkJCQkJPCEtLSAoU04pIEhhcmQtY29k
ZWQsIHJlcXVpcmVkIGJ5IEZISVIgLS0+CgkJCQkJPHN0YXR1cyB2YWx1ZT0iY29tcGxldGVkIi8+
CgkJCQkJPCEtLSBPQlIuNyBbT2JzZXJ2YXRpb24gRGF0ZS9UaW1lXSAtIFJlcXVpcmVkIC0tPgoJ
CQkJCTwhLS0gKFNOKSBUaGUgc3BlY2ltZW4gY29sbGVjdGlvbiBkYXRlL3RpbWUgd2hlbiB0aGUg
dGVzdCBpbnZvbHZlcyBhIHNwZWNpbWVuIC0tPgoJCQkJCTxkYXRlVGltZSB2YWx1ZT0iMjAxNi0x
Mi0yMVQyMDo1MTo1NSswMDowMCIvPgoJCQkJCTxhY3Rvcj4KCQkJCQkJPHJlZmVyZW5jZSB2YWx1
ZT0iUHJhY3RpdGlvbmVyL29yZGVyaW5nLXByb3ZpZGVyLTEiLz4KCQkJCQk8L2FjdG9yPgoJCQkJ
PC9ldmVudD4KCQkJCTwhLS0gT0JSLjQgW1VuaXZlcnNhbCBTZXJ2aWNlIElkZW50aWZpZXJdIC0g
UmVxdWlyZWQgLS0+CgkJCQk8IS0tIChTTikgSWRlbnRpZmljYXRpb24gY29kZSBmb3IgdGhlIG9y
ZGVyZWQgdGVzdC4gT25lIG9yZGVyIGNvZGUgcGVyIE9CUiBzZWdtZW50IC0tPgoJCQkJPGl0ZW0+
CgkJCQkJPGNvZGU+CgkJCQkJCTxjb2Rpbmc+CgkJCQkJCQk8IS0tIE9CUi40LjQgW0FsdGVybmF0
ZSBJZGVudGlmaWVyXSAtIFJlcXVpcmVkIC0tPgoJCQkJCQkJPGNvZGUgdmFsdWU9Ijg2NiIvPgoJ
CQkJCQkJPCEtLSBPQlIuNC41IFtBbHRlcm5hdGUgVGV4dF0gLSBSZXF1aXJlZCAtLT4KCQkJCQkJ
CTxkaXNwbGF5IHZhbHVlPSJGcmVlIFQ0Ii8+CgkJCQkJCTwvY29kaW5nPgoJCQkJCTwvY29kZT4K
CQkJCTwvaXRlbT4KCQkJPC9EaWFnbm9zdGljT3JkZXI+CgkJPC9yZXNvdXJjZT4KCTwvZW50cnk+
Cgk8ZW50cnk+PCEtLSBEaWFnbm9zdGljT3JkZXIgKE9CUikgLS0+CgkJPHJlc291cmNlPgoJCQk8
IS0tIE9CUiBbT2JzZXJ2YXRpb24gUmVxdWVzdF0gLSBSZXF1aXJlZCAtLT4KCQkJPCEtLSAoU04p
IE9ubHkgb25lIE9CUiBbT2JzZXJ2YXRpb25dIHBlciBPcmRlciBPYnNlcnZhdGlvbiBncm91cCAo
T1JDLU9CUi1PQlgpIC0tPgoJCQk8IS0tIChTTikgT0JSLjIgW1BsYWNlciBPcmRlciBOdW1iZXJd
IC0gUmVxdXJpZWQgLSBzZWUgRGlhZ25vc3RpY1JlcG9ydC9pZGVudGlmaWVyIC0tPgoJCQk8RGlh
Z25vc3RpY09yZGVyPgoJCQkJPCEtLSAoU04pIFRoZSB2YWx1ZSBNVVNUIGJlIGlkZW50aWNhbCB0
byBEaWFnbm9zdGljUmVwb3J0L3JlcXVlc3QvcmVmZXJlbmNlL0B2YWx1ZSAoYWthIE9SQykgdGhp
cyBPQlIgYmVsb25ncyB0byAtLT4KCQkJCTxpZCB2YWx1ZT0iT0JSLW9ic2VydmF0aW9uLXJlcXVl
c3QtMiIvPgoJCQkJPCEtLSAoU04pIEhhcmQtY29kZWQsIHJlcXVpcmVkIGJ5IEZISVIgLS0+CgkJ
CQk8c3ViamVjdCBpZD0iUGF0aWVudCIvPgoJCQkJPGV2ZW50PgoJCQkJCTwhLS0gKFNOKSBIYXJk
LWNvZGVkLCByZXF1aXJlZCBieSBGSElSIC0tPgoJCQkJCTxzdGF0dXMgdmFsdWU9ImNvbXBsZXRl
ZCIvPgoJCQkJCTwhLS0gT0JSLjcgW09ic2VydmF0aW9uIERhdGUvVGltZV0gLSBSZXF1aXJlZCAt
LT4KCQkJCQk8IS0tIChTTikgVGhlIHNwZWNpbWVuIGNvbGxlY3Rpb24gZGF0ZS90aW1lIHdoZW4g
dGhlIHRlc3QgaW52b2x2ZXMgYSBzcGVjaW1lbiAtLT4KCQkJCQk8ZGF0ZVRpbWUgdmFsdWU9IjIw
MTYtMTItMjFUMjA6NDA6MDArMDA6MDAiLz4KCQkJCQk8YWN0b3I+CgkJCQkJCTxyZWZlcmVuY2Ug
dmFsdWU9IlByYWN0aXRpb25lci9vcmRlcmluZy1wcm92aWRlci0xIi8+CgkJCQkJPC9hY3Rvcj4K
CQkJCTwvZXZlbnQ+CgkJCQk8IS0tIE9CUi40IFtVbml2ZXJzYWwgU2VydmljZSBJZGVudGlmaWVy
XSAtIFJlcXVpcmVkIC0tPgoJCQkJPCEtLSAoU04pIElkZW50aWZpY2F0aW9uIGNvZGUgZm9yIHRo
ZSBvcmRlcmVkIHRlc3QuIE9uZSBvcmRlciBjb2RlIHBlciBPQlIgc2VnbWVudCAtLT4KCQkJCTxp
dGVtPgoJCQkJCTxjb2RlPgoJCQkJCQk8Y29kaW5nPgoJCQkJCQkJPCEtLSBPQlIuNC40IFtBbHRl
cm5hdGUgSWRlbnRpZmllcl0gLSBSZXF1aXJlZCAtLT4KCQkJCQkJCTxjb2RlIHZhbHVlPSI4OTki
Lz4KCQkJCQkJCTwhLS0gT0JSLjQuNSBbQWx0ZXJuYXRlIFRleHRdIC0gUmVxdWlyZWQgLS0+CgkJ
CQkJCQk8ZGlzcGxheSB2YWx1ZT0iVFNIIi8+CgkJCQkJCTwvY29kaW5nPgoJCQkJCTwvY29kZT4K
CQkJCTwvaXRlbT4KCQkJPC9EaWFnbm9zdGljT3JkZXI+CgkJPC9yZXNvdXJjZT4KCTwvZW50cnk+
CQoJPGVudHJ5PjwhLS0gQ292ZXJhZ2UgKElOMSkgLS0+CgkJPHJlc291cmNlPgoJCQk8IS0tIFRo
ZSBJbnN1cmFuY2UgKElOMSkgc2VnbWVudCBjb250YWlucyBpbnN1cmFuY2UgcG9saWN5IGNvdmVy
YWdlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBwcm9kdWNlIHByb3Blcmx5IHByby1yYXRlZCBh
bmQgcGF0aWVudCBhbmQgaW5zdXJhbmNlIGJpbGxzLiAgLS0+CgkJCTxDb3ZlcmFnZT4KCQkJCTxp
ZCB2YWx1ZT0iSU4xLWluc3VyYW5jZS0xIi8+CgkJCQk8Y29udGFpbmVkPgoJCQkJCTxPcmdhbml6
YXRpb24+CgkJCQkJCTxpZCB2YWx1ZT0iaW5zdXJhbmNlLWNvbXBhbnkiLz4KCQkJCQkJPCEtLSBJ
TjEuMyBbSW5zdXJhbmNlIENvbXBhbnkgSURdIC0gUmVxdWlyZWQgYnkgSEw3djIuNS4xIC0tPgoJ
CQkJCQk8IS0tIChTTikgVGhpcyBpcyB0aGUgUURJIEJpbGwgbW5lbW9uaWMgLS0+CgkJCQkJCTxp
ZGVudGlmaWVyPgoJCQkJCQkJPHZhbHVlIHZhbHVlPSJCVSIvPgoJCQkJCQk8L2lkZW50aWZpZXI+
CgkJCQkJPC9Pcmdhbml6YXRpb24+CgkJCQk8L2NvbnRhaW5lZD4KCQkJCTxpc3N1ZXJSZWZlcmVu
Y2U+CgkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iT3JnYW5pemF0aW9uL2luc3VyYW5jZS1jb21wYW55
Ii8+CgkJCQk8L2lzc3VlclJlZmVyZW5jZT4KCQkJCTwhLS0gSU4xLjQ3IFtDb3ZlcmFnZSBUeXBl
XSAtIFJlcXVpcmVkIC0tPgoJCQkJPHR5cGU+CgkJCQkJPCEtLSAoU04pIEZvbGxvd2luZyB2YWx1
ZXMgYXJlIHBvc3NpYmxlOiBUIChUaGlyZC1wYXJ0eSBiaWxsKSwgUCAoUGF0aWVudCBiaWxsKSwg
QyAoQ2xpZW50IGJpbGwpIC0tPgoJCQkJCTxjb2RlIHZhbHVlPSJQIi8+CgkJCQk8L3R5cGU+CgkJ
CQk8IS0tIElOMS4xNiBbTmFtZSBPZiBJbnN1cmVkXSAtIENvbmRpdGlvbmFsIC0tPgoJCQkJPCEt
LSAoU04pIFRoaXMgZmllbGQgaXMgcmVxdWlyZWQgaWYgSU4xLjQ3IChDb3ZlcmFnZSBUeXBlKSBp
cyAiVCItLT4KCQkJCTwhLS0gKFNOKSBPbmx5IG9uZSBvZiB0aGUgZm9sbG93aW5nIHR3byByZWZl
cmVuY2VzIGFyZSBhbGxvd2VkIC0tPgoJCQkJPHBsYW5ob2xkZXJSZWZlcmVuY2U+CgkJCQkJPCEt
LSAoU04pIFVzZSB0aGlzIGhhcmRjb2RlZCB2YWx1ZSBvbmx5IGlmIElOMS4xNyBbSW5zdXJlZCdz
IFJlbGF0aW9uc2hpcCBUbyBQYXRpZW50XSBpcyAiMSIgZm9yIFNlbGYgLS0+CgkJCQkJPHJlZmVy
ZW5jZSB2YWx1ZT0iUGF0aWVudC9QSUQtcGF0aWVudC1pZGVudGlmaWNhdGlvbiIvPgoJCQkJCTwh
LS0gKFNOKSBVc2UgdGhpcyBoYXJkY29kZWQgdmFsdWUgb25seSBpZiBJTjEuMTcgW0luc3VyZWQn
cyBSZWxhdGlvbnNoaXAgVG8gUGF0aWVudF0gaXMgIjIiIGZvciBTcG91c2Ugb3IgIjgiIGZvciBE
ZXBlbmRlbnQgLS0+CgkJCQkJPCEtLSA8cmVmZXJlbmNlIHZhbHVlPSJQZXJzb24vaW5zdXJlZC1w
ZXJzb24iLz4gLS0+CgkJCQk8L3BsYW5ob2xkZXJSZWZlcmVuY2U+CgkJCQk8YmVuZWZpY2lhcnlJ
ZGVudGlmaWVyLz4KCQkJCTwhLS0gSU4xLjE3IFtJbnN1cmVk77+9cyBSZWxhdGlvbnNoaXAgVG8g
UGF0aWVudF0gLSBDb25kaXRpb25hbCAtLT4KCQkJCTwhLS0gKFNOKSBUaGlzIGZpZWxkIGlzIHJl
cXVpcmVkIGlmIElOMS40NyAoQ292ZXJhZ2UgVHlwZSkgaXMgIlQiIC0tPgoJCQkJPHJlbGF0aW9u
c2hpcD4KCQkJCQk8IS0tIChTTikgQWxsb3dlZCB2YWx1ZXM6IDEgPSBTZWxmLCAyID0gU3BvdXNl
LCA4ID0gRGVwZW5kZW50IC0tPgoJCQkJCTwhLS0gKFNOKSBUaGUgdmFsdWUgc2V0IGlzIGludGVu
dGlvbmFsbHkgZGlmZmVyZW50IHRoYW4gLSBodHRwczovL3d3dy5obDcub3JnL2ZoaXIvMjAxNlNl
cC92YWx1ZXNldC1wb2xpY3lob2xkZXItcmVsYXRpb25zaGlwLmh0bWwgLS0+CgkJCQkJPGNvZGUg
dmFsdWU9IjEiLz4KCQkJCQk8ZGlzcGxheSB2YWx1ZT0iU2VsZiIvPgoJCQkJPC9yZWxhdGlvbnNo
aXA+CgkJCQk8IS0tIElOMS4yIFtJbnN1cmFuY2UgUGxhbiBJRF0gLSBOb3QgVXNlZCAtLT4KCQkJ
CTwhLS0gKFNOKSBUaGlzIGZpZWxkIGlzIHJlcXVpcmVkIGJ5IEhMN3YyLjUuMSBJTjEgc3BlY2lm
aWNhdGlvbiBidXQgbm90IHVzZWQgYnkgUXVlc3QgLS0+CgkJCQk8aWRlbnRpZmllcj4KCQkJCQk8
dmFsdWUgdmFsdWU9IlBsYW5JRDEyMzQiLz4KCQkJCTwvaWRlbnRpZmllcj4JCQkJCgkJCTwvQ292
ZXJhZ2U+CgkJPC9yZXNvdXJjZT4KCTwvZW50cnk+Cgk8ZW50cnk+PCEtLSBQcmFjdGl0aW9uZXIg
KE9CUi4xNi1PcmRlcmluZyBQcm92aWRlcikgLS0+CgkJPHJlc291cmNlPgoJCQk8IS0tIE9CUi4x
NiBbT3JkZXJpbmcgUHJvdmlkZXJdIC0gUmVxdWlyZWQgLSBJZGVudGlmaWVzIHRoZSBwcm92aWRl
ciB3aG8gb3JkZXJlZCB0aGUgdGVzdC0tPgoJCQk8UHJhY3RpdGlvbmVyPgoJCQkJPGlkIHZhbHVl
PSJvcmRlcmluZy1wcm92aWRlci0xIi8+CgkJCQk8aWRlbnRpZmllcj4KCQkJCQk8IS0tIE9CUjE2
LjEgW0lEIE51bWJlcl0gLSBSZXF1aXJlZCAtLT4KCQkJCQk8dmFsdWUgdmFsdWU9IjEzNjY0NzI1
NTciLz4KCQkJCQk8YXNzaWduZXI+CgkJCQkJCTwhLS0gMTYuOSBbQXNzaWduaW5nIEF1dGhvcml0
eV0gLSBSZXF1aXJlZCAtLT4KCQkJCQkJPCEtLSAoU04pIFRoaXMgcHJvYmFibHkgaGFyZC1jb2Rl
ZCB0byBOUEksIHRoZXJlZm9yZSBzaW1wbGlmaWVkIGZvciBub3csIG90aGVyd2lzZSBzaG91bGQg
YmUgcmVwbGFjZWQgd2l0aCBhIHJlZmVyZW5jZSB0byBhbiBvcmduaXphdGlvbiAtLT4KCQkJCQkJ
PGRpc3BsYXkgdmFsdWU9Ik5QSSIvPgoJCQkJCTwvYXNzaWduZXI+CgkJCQk8L2lkZW50aWZpZXI+
CgkJCQk8bmFtZT4KCQkJCQk8IS0tIE9CUi4xNi4yIFtGYW1pbHkgTmFtZV0gLSBSZXF1aXJlZCAt
LT4KCQkJCQk8ZmFtaWx5IHZhbHVlPSJKYXZpbGxvIi8+CgkJCQkJPCEtLSBPQlIuMTYuMyBbR2l2
ZW4gTmFtZV0gLSBSZXF1aXJlZCAtLT4KCQkJCQk8Z2l2ZW4gdmFsdWU9Ikphc29uIi8+CgkJCQk8
L25hbWU+CgkJCTwvUHJhY3RpdGlvbmVyPgoJCTwvcmVzb3VyY2U+Cgk8L2VudHJ5PgoJPGVudHJ5
PjwhLS0gUGVyc29uIChHVDEpIC0gT3B0aW9uYWwgYnV0IHJlcXVpcmVkIGZvciBSZXF1aXNpdGlv
biAjMSAtLT4KCQk8cmVzb3VyY2U+CgkJCTwhLS0gKFNOKSBUaGlzIHJlc291cmNlIGlzIHJlcXVp
cmVkIG9ubHkgaWYgSU4xLjQ3IChDb3ZlcmFnZSBUeXBlKSBpcyAiVCIsIG90aGVyd2lzZSBHdWFy
YW50b3IgaXMgT3B0aW9uYWwgLS0+CgkJCTwhLS0gKFNOKSBJZiBwcmVzZW50LCBvbmx5IG9uZSBH
VDEgc2VnbWVudCBpbiB0aGUgT01MIG1lc3NhZ2UgaXMgYWxsb3dlZCAtLT4KCQkJPFBlcnNvbj4K
CQkJCTxpZCB2YWx1ZT0iR1QxLWd1YXJhbnRvciIvPgoJCQkJPCEtLSBHVDEuMyBbR3VhcmFudG9y
IE5hbWVdIC0gUmVxdWlyZWQgLS0+CgkJCQk8IS0tIChTTikgR3VhcmFudG9yIE5hbWUgaXMgcmVx
dWlyZWQgaWYgSU4xLjQ3IFtDb3ZlcmFnZSBUeXBlXSBpcyAiUCIgb3IgIlQiLiAgLS0+CgkJCQk8
bmFtZT4KCQkJCQk8IS0tIChTTikgInVzZSIgZWxlbWVudCBpcyBoYXJkY29kZWQgZm9yIHByaW1h
cnkgcGF0aWVudCBuYW1lIC0tPgoJCQkJCTx1c2UgdmFsdWU9Im9mZmljaWFsIi8+CgkJCQkJPCEt
LSBHVDEuMy4xIFtGYW1pbHkgTmFtZV0gLS0+CgkJCQkJPCEtLSAoU04pIFRoZSBsYXN0IG5hbWUg
Y2FuIGJlIGEgbWF4aW11bSBvZiAyMCBjaGFyYWN0ZXJzLiBBbnkgbGFzdCBuYW1lIGxvbmdlciB0
aGFuIHRoZSBhbGxvd2VkIGxpbWl0IGlzIHRydW5jYXRlZCBpbiB0aGUgY29ycmVzcG9uZGluZyBy
ZXN1bHQgbWVzc2FnZS4gLS0+CgkJCQkJPGZhbWlseSB2YWx1ZT0iVEVTVCIvPgoJCQkJCTwhLS0g
R1QxLjMuMiBbR2l2ZW4gTmFtZV0gLS0+CgkJCQkJPCEtLSAoU04pIFRoZSBmaXJzdCBuYW1lIGlz
IGxpbWl0ZWQgdG8gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbnVtYmVyIG9mIGNoYXJhY3Rl
cnMgaW4gdGhlIGxhc3QgbmFtZSBhbmQgMjQuIC0tPgoJCQkJCTxnaXZlbiB2YWx1ZT0iVEMxIi8+
CgkJCQk8L25hbWU+CgkJCQk8IS0tIEdUMS42IFtHdWFyYW50b3IgUGhvbmUgTnVtYmVyIC0gSG9t
ZV0gLSBDb25kaXRpb25hbCAtLT4KCQkJCTwhLS0gKFNOKSBUaGlzIGZpZWxkIGlzIHJlcXVpcmVk
IGlmIElOMS40NyBbQ292ZXJhZ2UgVHlwZV0gaXMgIlAiIG9yICJUIiAtLT4KCQkJCTx0ZWxlY29t
PgoJCQkJCTxzeXN0ZW0gdmFsdWU9InBob25lIi8+CgkJCQkJPHZhbHVlIHZhbHVlPSI5NzItOTE2
LTMwMDAiLz4KCQkJCQk8dXNlIHZhbHVlPSJob21lIi8+CgkJCQk8L3RlbGVjb20+CgkJCQk8IS0t
IEdUMS41IFtHdWFyYW50b3IgQWRkcmVzc10gLSBDb25kaXRpb25hbCAtLT4KCQkJCTwhLS0gKFNO
KSBUaGlzIGZpZWxkIGlzIHJlcXVpcmVkIGlmIElOMS40NyBbQ292ZXJhZ2UgVHlwZV0gaXMgIlAi
IG9yICJUIiAtLT4KCQkJCTxhZGRyZXNzPgoJCQkJCTx1c2UgdmFsdWU9ImhvbWUiLz4KCQkJCQk8
bGluZSB2YWx1ZT0iNDc3MCBSZWdlbnQgQmx2ZC4iLz4KCQkJCQk8Y2l0eSB2YWx1ZT0iSXJ2aW5n
Ii8+CgkJCQkJPHN0YXRlIHZhbHVlPSJUWCIvPgoJCQkJCTxwb3N0YWxDb2RlIHZhbHVlPSI3NTA2
MyIvPgoJCQkJPC9hZGRyZXNzPgoJCQk8L1BlcnNvbj4KCQk8L3Jlc291cmNlPgoJPC9lbnRyeT4J
CQo8L0J1bmRsZT4K</inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>XML</inboundDataType>
          <outboundDataType>XML</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>true</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>true</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>FHIR Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>SubmitOrder Quest</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>4c7bc0bd-aede-4e90-9ce8-cde50750f1e8</channelId>
            <channelTemplate>${json}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Convert XML to JSON</name>
                <script>try {
	
	var jsonFeed = Packages.org.json.XML.toJSONObject(msg.toString());
	channelMap.put(&quot;json&quot;, jsonFeed.toString());
	
} catch(ex) {
	logger.error(&quot;Gateway: SubmitOrder destination - &quot; + ex);
	throw (&quot;Gateway: SubmitOrder destination - &quot; + ex);
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>try {
	
	var jsonFeed = Packages.org.json.XML.toJSONObject(msg.toString());
	channelMap.put(&quot;json&quot;, jsonFeed.toString());
	
} catch(ex) {
	logger.error(&quot;Gateway: SubmitOrder destination - &quot; + ex);
	throw (&quot;Gateway: SubmitOrder destination - &quot; + ex);
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Convert JSON to XML</name>
                <script>responseMap.put(&quot;OperationOutcome&quot;, msg.toString());</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>responseMap.put(&quot;OperationOutcome&quot;, msg.toString());</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>2</metaDataId>
          <name>SubmitOrder LabCorp</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Convert feed</name>
                <script>// TODO: Route incoming feed to LabCorp SubmitOrder</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// TODO: Route incoming feed to LabCorp SubmitOrder</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>false</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>e0f422e1-0550-40f1-8a37-e148e0b5f636</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>GetOrderDocuments</name>
      <description>Requests order documents and/or AOE questions for the accompanying order, as follows:&#xd;
• ABN - Determines whether or not an ABN is required.&#xd;
• AOE - Determines whether or not AOE questions are required for the submitted order codes. &#xd;
• REQ - Creates a requisition for the accompanying order, returns the requisition in a PDF file, and forwards the order to the lab for processing (unless submitted in combination with an AOE request that requires AOE questions to be answered).</description>
      <enabled>true</enabled>
      <lastModified>
        <time>1494273011522</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>14</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Set HL7v2.5 MSH segment</name>
              <script>// SENDING_APPLICATION designates the application that is sending the order message to Hub
//msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = &quot;SAFE&quot;;

// SENDING_FACILITY designates the account number provided to you by Quest for the businessunit you are ordering tests with
//msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = $(&quot;account&quot;);

// RECEIVING_FACILITY designates the business unit within Quest from which the labs are being ordered
//msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;STL&quot;;


// Time Zone is not used. If required, the pattern is &quot;yyyyMMddHHmmss.SSSZ&quot;
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = currentDate + UUIDGenerator.getUUID().toString().substring(0,6);
msg[&apos;MSH&apos;][&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = $(&quot;processingID&quot;);

channelMap.put( &quot;raw&quot;,  SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg));

//msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmm&quot;);

//logger.debug(&quot;getOrderDocuments-Source[0]: &quot; + SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg));</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// SENDING_APPLICATION designates the application that is sending the order message to Hub
//msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = &quot;SAFE&quot;;

// SENDING_FACILITY designates the account number provided to you by Quest for the businessunit you are ordering tests with
//msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = $(&quot;account&quot;);

// RECEIVING_FACILITY designates the business unit within Quest from which the labs are being ordered
//msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;STL&quot;;


// Time Zone is not used. If required, the pattern is &quot;yyyyMMddHHmmss.SSSZ&quot;
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = currentDate + UUIDGenerator.getUUID().toString().substring(0,6);
msg[&apos;MSH&apos;][&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = $(&quot;processingID&quot;);

channelMap.put( &quot;raw&quot;,  SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg));

//msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmm&quot;);

//logger.debug(&quot;getOrderDocuments-Source[0]: &quot; + SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg));</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>HL7V2</inboundDataType>
          <outboundDataType>HL7V2</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Submit Order REST</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>SOAP query</name>
                <script>var getOrderDocumentsSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
	&lt;soapenv:Header/&gt;
	&lt;soapenv:Body&gt;
		&lt;ord:getOrderDocuments&gt;
			&lt;ord:getOrderDocumentsRequest&gt;
				&lt;hl7Order&gt;???&lt;/hl7Order&gt;
				&lt;orderSupportRequests&gt;REQ&lt;/orderSupportRequests&gt;
			&lt;/ord:getOrderDocumentsRequest&gt;
		&lt;/ord:getOrderDocuments&gt;
	&lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;;

var bytes = new java.lang.String($(&apos;raw&apos;).toString()).getBytes();
getOrderDocumentsSoap.*::Body.*::getOrderDocuments.*::getOrderDocumentsRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

logger.debug(&quot;getOrderDocuments.Destiantion[0]: &quot; + getOrderDocumentsSoap.toString());</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var getOrderDocumentsSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
	&lt;soapenv:Header/&gt;
	&lt;soapenv:Body&gt;
		&lt;ord:getOrderDocuments&gt;
			&lt;ord:getOrderDocumentsRequest&gt;
				&lt;hl7Order&gt;???&lt;/hl7Order&gt;
				&lt;orderSupportRequests&gt;REQ&lt;/orderSupportRequests&gt;
			&lt;/ord:getOrderDocumentsRequest&gt;
		&lt;/ord:getOrderDocuments&gt;
	&lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;;

var bytes = new java.lang.String($(&apos;raw&apos;).toString()).getBytes();
getOrderDocumentsSoap.*::Body.*::getOrderDocuments.*::getOrderDocumentsRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

logger.debug(&quot;getOrderDocuments.Destiantion[0]: &quot; + getOrderDocumentsSoap.toString());</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>POST request</name>
                <script>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null) try {

	sslClient.setURL( &quot;https://cert.hub.Care360.com/orders/submission/service&quot; );
//	sslClient.setURL($(&quot;getOrderDocumentsURL&quot;));
	sslClient.setSOAPRequest(getOrderDocumentsSoap);

	channelMap.put( &quot;soapRequest&quot;, getOrderDocumentsSoap );
	var httpCode = sslClient.doPost();

	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));

	channelMap.put( &quot;soapResponse&quot;, soapResp );
	
	if (200 == httpCode) {

		var ack = soapResp.*::Body.*::getOrderDocumentsResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String( FileUtil.decode(ack));
		channelMap.put( &quot;responseHL7&quot;, ackHL7 )
		logger.info(&quot;HL7v2 respose: &quot; + ackHL7);
		 
	} else {
		logger.info(&quot;HTTP Code: &quot; + httpCode);
	}	
	
} catch(ex) {
	logger.error(&quot;getOrderDocuments Destination[0]: &quot; + ex);

}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null) try {

	sslClient.setURL( &quot;https://cert.hub.Care360.com/orders/submission/service&quot; );
//	sslClient.setURL($(&quot;getOrderDocumentsURL&quot;));
	sslClient.setSOAPRequest(getOrderDocumentsSoap);

	channelMap.put( &quot;soapRequest&quot;, getOrderDocumentsSoap );
	var httpCode = sslClient.doPost();

	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));

	channelMap.put( &quot;soapResponse&quot;, soapResp );
	
	if (200 == httpCode) {

		var ack = soapResp.*::Body.*::getOrderDocumentsResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String( FileUtil.decode(ack));
		channelMap.put( &quot;responseHL7&quot;, ackHL7 )
		logger.info(&quot;HL7v2 respose: &quot; + ackHL7);
		 
	} else {
		logger.info(&quot;HTTP Code: &quot; + httpCode);
	}	
	
} catch(ex) {
	logger.error(&quot;getOrderDocuments Destination[0]: &quot; + ex);

}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64">PFM6RW52ZWxvcGUgeG1sbnM6Uz0iaHR0cDovL3NjaGVtYXMueG1sc29hcC5vcmcvc29hcC9lbnZl
bG9wZS8iPgoJPFM6Qm9keT4KCQk8bnMyOmdldE9yZGVyRG9jdW1lbnRzUmVzcG9uc2UgeG1sbnM6
bnMyPSJodHRwOi8vbWVkcGx1cy5jb20vb3JkZXJzIj4KCQkJPG5zMjpSZXN1bHQ+CgkJCQk8c3Rh
dHVzPlNVQ0NFU1M8L3N0YXR1cz4KCQkJCTxobDdPcmRlckFjaz5UVk5JZkY1K1hDWjhmRWhQVlh4
SVZVSlhVM3d5TVRNMU9EQXdmREl3TVRNd05URTBNRGcwTVRFM2ZIeFBUMUplTURBeWZEWXpNamMz
TXpJek9EY3dPREV6Tnprek9IeFFmREl1TXcxTlUwRjhRVUY4TmpNeU56Y3pNak00TnpBNE1UTTNP
VE00ZkE9PTwvaGw3T3JkZXJBY2s+CgkJCQk8bWVzc2FnZUNvbnRyb2xJZD42MzI3NzMyMzg3MDgx
Mzc5Mzg8L21lc3NhZ2VDb250cm9sSWQ+CgkJCQk8b3JkZXJUcmFuc2FjdGlvblVpZD5hNGM2OGM1
OTBhODAxZTE1MTlkZTQ0YTYxYWEyNDIyMzwvb3JkZXJUcmFuc2FjdGlvblVpZD4KCQkJCTxvcmRl
clN1cHBvcnREb2N1bWVudHM+CgkJCQkJPGRvY3VtZW50RGF0YT5KVkJFUmkweExqUUtKZUxqejlN
S01TQXdJRzlpYWlBPC9kb2N1bWVudERhdGE+CgkJCQkJPGRvY3VtZW50VHlwZT5BQk4tUkVRPC9k
b2N1bWVudFR5cGU+CgkJCQkJPHJlcXVlc3RTdGF0dXM+MDAwMDogUHJvY2Vzc2luZyBDb21wbGV0
ZWQgU3VjY2Vzc2Z1bGx5PC9yZXF1ZXN0U3RhdHVzPgoJCQkJCTxyZXNwb25zZU1lc3NhZ2U+UkVR
IE9LOyBBQk4gaXMgbm90IHJlcXVpcmVkPC9yZXNwb25zZU1lc3NhZ2U+CgkJCQkJPHN1Y2Nlc3M+
dHJ1ZTwvc3VjY2Vzcz4KCQkJCTwvb3JkZXJTdXBwb3J0RG9jdW1lbnRzPgoJCQk8L25zMjpSZXN1
bHQ+CgkJPC9uczI6Z2V0T3JkZXJEb2N1bWVudHNSZXNwb25zZT4KCTwvUzpCb2R5Pgo8L1M6RW52
ZWxvcGU+</outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

// Prepare SSL Client to access submitOrder Conformance Environment
if (globalMap.containsKey(&quot;sslClient&quot;) &amp;&amp; globalMap.get(&quot;sslClient&quot;)) 
	try {

		var sslClient = new Packages.org.safemovement.DEXSSLClient();		
		sslClient.setAuthorizationType(org.safemovement.DEXSSLClient.Authorization.BASIC);
		sslClient.setContentType(&quot;text/xml;charset=UTF-8&quot;);
		sslClient.setUserName($(&quot;username&quot;));
		sslClient.setUserPassword($(&quot;userpsw&quot;));		
		sslClient.setConnectionType(&quot;Close&quot;);
		
		globalChannelMap.put(&quot;sslClientClass&quot;, sslClient);
		
	} catch(ex) {
		logger.error(&quot;submitOrder Deploy: &quot; + ex.toString());		
	}



return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data

if (globalChannelMap.containsKey(&quot;sslClientClass&quot;)){
	globalChannelMap.remove(&quot;sslClientClass&quot;);
}


return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>4f329e32-3a0a-44cd-8bf1-7dd309df7967</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>GetOrderDocuments - SAVED</name>
      <description>Requests order documents and/or AOE questions for the accompanying order, as follows:&#xd;
• ABN - Determines whether or not an ABN is required.&#xd;
• AOE - Determines whether or not AOE questions are required for the submitted order codes. &#xd;
• REQ - Creates a requisition for the accompanying order, returns the requisition in a PDF file, and forwards the order to the lab for processing (unless submitted in combination with an AOE request that requires AOE questions to be answered).</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1494000622910</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>2</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Set HL7v2.5 MSH segment</name>
              <script>// SENDING_APPLICATION designates the application that is sending the order message to Hub
msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = &quot;SAFE&quot;;

// SENDING_FACILITY designates the account number provided to you by Quest for the businessunit you are ordering tests with
msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = $(&quot;account&quot;);

// RECEIVING_FACILITY designates the business unit within Quest from which the labs are being ordered
msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;STL&quot;;


// Time Zone is not used. If required, the pattern is &quot;yyyyMMddHHmmss.SSSZ&quot;
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = currentDate + UUIDGenerator.getUUID().toString().substring(0,6);
msg[&apos;MSH&apos;][&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = $(&quot;processingID&quot;);

msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmm&quot;);



logger.debug(&quot;getOrderDocuments-Source[0]: &quot; + SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg));</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// SENDING_APPLICATION designates the application that is sending the order message to Hub
msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = &quot;SAFE&quot;;

// SENDING_FACILITY designates the account number provided to you by Quest for the businessunit you are ordering tests with
msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = $(&quot;account&quot;);

// RECEIVING_FACILITY designates the business unit within Quest from which the labs are being ordered
msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;STL&quot;;


// Time Zone is not used. If required, the pattern is &quot;yyyyMMddHHmmss.SSSZ&quot;
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = currentDate + UUIDGenerator.getUUID().toString().substring(0,6);
msg[&apos;MSH&apos;][&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = $(&quot;processingID&quot;);

msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmm&quot;);



logger.debug(&quot;getOrderDocuments-Source[0]: &quot; + SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg));</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>HL7V2</inboundDataType>
          <outboundDataType>HL7V2</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Submit Order REST</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>SOAP query</name>
                <script>var getOrderDocumentsSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
	&lt;soapenv:Header/&gt;
	&lt;soapenv:Body&gt;
		&lt;ord:getOrderDocuments&gt;
			&lt;ord:getOrderDocumentsRequest&gt;
				&lt;hl7Order&gt;???&lt;/hl7Order&gt;
				&lt;orderSupportRequests&gt;ABN&lt;/orderSupportRequests&gt;
			&lt;/ord:getOrderDocumentsRequest&gt;
		&lt;/ord:getOrderDocuments&gt;
	&lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;;

var bytes = new java.lang.String(msg.toString()).getBytes();
getOrderDocumentsSoap.*::Body.*::getOrderDocuments.*::getOrderDocumentsRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

logger.debug(&quot;getOrderDocuments.Destiantion[0]: &quot; + getOrderDocumentsSoap.toString());</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var getOrderDocumentsSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
	&lt;soapenv:Header/&gt;
	&lt;soapenv:Body&gt;
		&lt;ord:getOrderDocuments&gt;
			&lt;ord:getOrderDocumentsRequest&gt;
				&lt;hl7Order&gt;???&lt;/hl7Order&gt;
				&lt;orderSupportRequests&gt;ABN&lt;/orderSupportRequests&gt;
			&lt;/ord:getOrderDocumentsRequest&gt;
		&lt;/ord:getOrderDocuments&gt;
	&lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;;

var bytes = new java.lang.String(msg.toString()).getBytes();
getOrderDocumentsSoap.*::Body.*::getOrderDocuments.*::getOrderDocumentsRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

logger.debug(&quot;getOrderDocuments.Destiantion[0]: &quot; + getOrderDocumentsSoap.toString());</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>POST request</name>
                <script>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null) try {
	sslClient.setURL($(&quot;getOrderDocumentsURL&quot;));
	sslClient.setSOAPRequest(getOrderDocumentsSoap);

	var httpCode = sslClient.doPost();

	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));

	if (200 == httpCode) {

		var ack = soapResp.*::Body.*::getOrderDocumentsResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String( FileUtil.decode(ack));
		logger.info(&quot;HL7v2 respose: &quot; + ackHL7);
		 
	} else {
		logger.info(&quot;HTTP Code: &quot; + httpCode);
	}	
	
} catch(ex) {
	logger.error(&quot;getOrderDocuments Destination[0]: &quot; + ex);

}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null) try {
	sslClient.setURL($(&quot;getOrderDocumentsURL&quot;));
	sslClient.setSOAPRequest(getOrderDocumentsSoap);

	var httpCode = sslClient.doPost();

	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));

	if (200 == httpCode) {

		var ack = soapResp.*::Body.*::getOrderDocumentsResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String( FileUtil.decode(ack));
		logger.info(&quot;HL7v2 respose: &quot; + ackHL7);
		 
	} else {
		logger.info(&quot;HTTP Code: &quot; + httpCode);
	}	
	
} catch(ex) {
	logger.error(&quot;getOrderDocuments Destination[0]: &quot; + ex);

}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64">PFM6RW52ZWxvcGUgeG1sbnM6Uz0iaHR0cDovL3NjaGVtYXMueG1sc29hcC5vcmcvc29hcC9lbnZl
bG9wZS8iPgoJPFM6Qm9keT4KCQk8bnMyOmdldE9yZGVyRG9jdW1lbnRzUmVzcG9uc2UgeG1sbnM6
bnMyPSJodHRwOi8vbWVkcGx1cy5jb20vb3JkZXJzIj4KCQkJPG5zMjpSZXN1bHQ+CgkJCQk8c3Rh
dHVzPlNVQ0NFU1M8L3N0YXR1cz4KCQkJCTxobDdPcmRlckFjaz5UVk5JZkY1K1hDWjhmRWhQVlh4
SVZVSlhVM3d5TVRNMU9EQXdmREl3TVRNd05URTBNRGcwTVRFM2ZIeFBUMUplTURBeWZEWXpNamMz
TXpJek9EY3dPREV6Tnprek9IeFFmREl1TXcxTlUwRjhRVUY4TmpNeU56Y3pNak00TnpBNE1UTTNP
VE00ZkE9PTwvaGw3T3JkZXJBY2s+CgkJCQk8bWVzc2FnZUNvbnRyb2xJZD42MzI3NzMyMzg3MDgx
Mzc5Mzg8L21lc3NhZ2VDb250cm9sSWQ+CgkJCQk8b3JkZXJUcmFuc2FjdGlvblVpZD5hNGM2OGM1
OTBhODAxZTE1MTlkZTQ0YTYxYWEyNDIyMzwvb3JkZXJUcmFuc2FjdGlvblVpZD4KCQkJCTxvcmRl
clN1cHBvcnREb2N1bWVudHM+CgkJCQkJPGRvY3VtZW50RGF0YT5KVkJFUmkweExqUUtKZUxqejlN
S01TQXdJRzlpYWlBPC9kb2N1bWVudERhdGE+CgkJCQkJPGRvY3VtZW50VHlwZT5BQk4tUkVRPC9k
b2N1bWVudFR5cGU+CgkJCQkJPHJlcXVlc3RTdGF0dXM+MDAwMDogUHJvY2Vzc2luZyBDb21wbGV0
ZWQgU3VjY2Vzc2Z1bGx5PC9yZXF1ZXN0U3RhdHVzPgoJCQkJCTxyZXNwb25zZU1lc3NhZ2U+UkVR
IE9LOyBBQk4gaXMgbm90IHJlcXVpcmVkPC9yZXNwb25zZU1lc3NhZ2U+CgkJCQkJPHN1Y2Nlc3M+
dHJ1ZTwvc3VjY2Vzcz4KCQkJCTwvb3JkZXJTdXBwb3J0RG9jdW1lbnRzPgoJCQk8L25zMjpSZXN1
bHQ+CgkJPC9uczI6Z2V0T3JkZXJEb2N1bWVudHNSZXNwb25zZT4KCTwvUzpCb2R5Pgo8L1M6RW52
ZWxvcGU+</outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

// Prepare SSL Client to access submitOrder Conformance Environment
if (globalMap.containsKey(&quot;sslClient&quot;) &amp;&amp; globalMap.get(&quot;sslClient&quot;)) 
	try {

		var sslClient = new Packages.org.safemovement.DEXSSLClient();		
		sslClient.setAuthorizationType(org.safemovement.DEXSSLClient.Authorization.BASIC);
		sslClient.setContentType(&quot;text/xml;charset=UTF-8&quot;);
		sslClient.setUserName($(&quot;username&quot;));
		sslClient.setUserPassword($(&quot;userpsw&quot;));		
		sslClient.setConnectionType(&quot;Close&quot;);
		
		globalChannelMap.put(&quot;sslClientClass&quot;, sslClient);
		
	} catch(ex) {
		logger.error(&quot;submitOrder Deploy: &quot; + ex.toString());		
	}



return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data

if (globalChannelMap.containsKey(&quot;sslClientClass&quot;)){
	globalChannelMap.remove(&quot;sslClientClass&quot;);
}


return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>0e065234-bc37-4b39-8bef-64905497ec91</id>
      <nextMetaDataId>4</nextMetaDataId>
      <name>GetPatientResult</name>
      <description>Returns the patient&apos;s most recent test result, and whether that patient has outstanding results</description>
      <enabled>true</enabled>
      <lastModified>
        <time>1497379719285</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>133</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>8015</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>d3</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
              <entry>
                <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                <string>hapi-fhir</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>false</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>text/plain</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode></responseStatusCode>
          <responseHeaders class="linked-hash-map"/>
          <charset>UTF-8</charset>
          <contextPath>GetPatientResult</contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Establish Client Connection / Get Patient</name>
              <script>importPackage(Packages.java.util);
importPackage(Packages.java.text);
importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var PatientID = msg[&apos;PatientIdentifier&apos;][&apos;Value&apos;]

var Url = configurationMap.get(&apos;sparkRawURL&apos;)
var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();

var client = ctx.newRestfulGenericClient( Url );
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 

channelMap.put( &quot;client&quot;, client );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( PatientID ))
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;
var patientResourceID;

if( msSize )
{
	patientResource = ms.get(0).getResource();
	patientResourceID = patientResource.getId().getIdPart()
	channelMap.put(&quot;PatientResource&quot;, patientResource );

	patientResourceID = patientResource.getId().getIdPart()
	channelMap.put(&quot;PatientResourceID&quot;, patientResourceID );

	// Account for out-of-order Patient IDs
	if( patientResource.getIdentifierFirstRep().getUse() == &quot;official&quot; )
	{
		tmp[&apos;PatientIdentifier&apos;][0][&apos;Value&apos;] = patientResource.getIdentifierFirstRep().getValue();
		tmp[&apos;PatientIdentifier&apos;][1][&apos;Value&apos;] = patientResource.getIdentifier().get(1).getValue();
	}
	else
	{
		tmp[&apos;PatientIdentifier&apos;][1][&apos;Value&apos;] = patientResource.getIdentifierFirstRep().getValue();
		tmp[&apos;PatientIdentifier&apos;][0][&apos;Value&apos;] = patientResource.getIdentifier().get(1).getValue();
	}	
}
else
{
	throw &quot;GetPatientResult: Patient Not Found&quot;;
}</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>importPackage(Packages.java.util);
importPackage(Packages.java.text);
importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var PatientID = msg[&apos;PatientIdentifier&apos;][&apos;Value&apos;]

var Url = configurationMap.get(&apos;sparkRawURL&apos;)
var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();

var client = ctx.newRestfulGenericClient( Url );
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 

channelMap.put( &quot;client&quot;, client );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( PatientID ))
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;
var patientResourceID;

if( msSize )
{
	patientResource = ms.get(0).getResource();
	patientResourceID = patientResource.getId().getIdPart()
	channelMap.put(&quot;PatientResource&quot;, patientResource );

	patientResourceID = patientResource.getId().getIdPart()
	channelMap.put(&quot;PatientResourceID&quot;, patientResourceID );

	// Account for out-of-order Patient IDs
	if( patientResource.getIdentifierFirstRep().getUse() == &quot;official&quot; )
	{
		tmp[&apos;PatientIdentifier&apos;][0][&apos;Value&apos;] = patientResource.getIdentifierFirstRep().getValue();
		tmp[&apos;PatientIdentifier&apos;][1][&apos;Value&apos;] = patientResource.getIdentifier().get(1).getValue();
	}
	else
	{
		tmp[&apos;PatientIdentifier&apos;][1][&apos;Value&apos;] = patientResource.getIdentifierFirstRep().getValue();
		tmp[&apos;PatientIdentifier&apos;][0][&apos;Value&apos;] = patientResource.getIdentifier().get(1).getValue();
	}	
}
else
{
	throw &quot;GetPatientResult: Patient Not Found&quot;;
}</string>
                </entry>
              </data>
            </step>
            <step>
              <sequenceNumber>1</sequenceNumber>
              <name>Get Reports</name>
              <script>var reportSearchResults = client.search()
	.forResource(DiagnosticReport) 
	.where(DiagnosticReport.SUBJECT.hasId($(&apos;PatientResourceID&apos;)))
	.sort().ascending(DiagnosticReport.ISSUED)	
	.returnBundle(Bundle)	
	.execute();

	
var ms;
var firstTime = true; 
var reports = new HashMap();
var lastDate;

var JSONDate = new SimpleDateFormat( &quot;yyyy-MM-dd&quot;);

do
{

	if( !firstTime )
	{
		reportSearchResults = client.loadPage().next(reportSearchResults).execute();
	}
	
	ms = reportSearchResults.getEntry();
		
	for(var i=0; i&lt;ms.size() ; i++ )
	{
		var report = ms.get(i).getResource();
//		var reportString = ctx.newJsonParser().encodeResourceToString(report);

		reports.put( report.getCode().getCodingFirstRep().getCode().toString(), report  );
		lastDate = JSONDate.format( report.getIssued() );
		
	}
	
	firstTime = false;
}
while( reportSearchResults.getLink(Bundle.LINK_NEXT) != null );

tmp[&apos;MostRecentLabSet&apos;][&apos;DateOfService&apos;] = lastDate;

var reportArrayList = new ArrayList( reports.values() );
var size = reportArrayList.size();

var jp = ctx.newJsonParser();
		
for( var i=0; i&lt;size ; i++ )
{

	var theLab =  
{
	 &quot;Order&quot;: {
		 &quot;PlacerOrderNumber&quot;: &quot;&quot;,
		 &quot;FillerOrderNumber&quot;: &quot;&quot;
	},
	 &quot;Result&quot;: {
		 &quot;ParentCode&quot;: &quot;&quot;,
		 &quot;PerformedTestCode&quot;: {
			 &quot;Code&quot;: &quot;&quot;,
			 &quot;System&quot;: &quot;&quot;,
			 &quot;Display&quot;: &quot;&quot;
		},
		 &quot;ResultDate&quot;: &quot;&quot;,
		 &quot;Status&quot;: &quot;Final&quot;,
		 &quot;Observations&quot;: [
		],
		 &quot;TextResultLines&quot;: &quot;&quot;,
		 &quot;ReportPDFBase64&quot;: &quot;&quot;,
		 &quot;ReportHL7Base64&quot;: &quot;&quot;
	}
};
	
	var thisReport = reportArrayList.get(i);
		

	theLab.Result.PerformedTestCode.Code = thisReport.getCode().getCodingFirstRep().getCode();
	theLab.Result.PerformedTestCode.System = thisReport.getCode().getCodingFirstRep().getSystem();
	theLab.Result.PerformedTestCode.Display = thisReport.getCode().getCodingFirstRep().getDisplay();
	
	theLab.Result.ResultDate = JSONDate.format( thisReport.getIssued() );
	theLab.Result.Status = thisReport.getStatus();

	theLab.Order.PlacerOrderNumber = thisReport.getIdentifier().get(0).getValue();
	theLab.Order.FillerOrderNumber = thisReport.getIdentifier().get(1).getValue();
	theLab.Result.ParentCode = thisReport.getConclusion();	
	
	var Observations = thisReport.getContained().getContainedResources();
	var ObservationString = &quot;&quot;;
	var ObservationsCount = Observations.size();

//	logger.error( &quot;Observations: &quot; + ObservationsCount );
		
	for( var j=0 ; j&lt;ObservationsCount ; j++ )
	{
		theLab.Result.Observations.push( JSON.parse( jp.encodeResourceToString(Observations.get(j) ) ) );
	}	

	if( !thisReport.getText().isEmpty())
	{			
		theLab.Result.TextResultLines = thisReport.getText().getDiv().getValueAsString();
	}
		
	var presentedForms = thisReport.getPresentedForm();
		
	if(presentedForms.size()&gt;1)
	{
//		theLab.Result.ReportPDFBase64 = FileUtil.encode( presentedForms.get(0).getData() );
//		theLab.Result.ReportHL7Base64 = FileUtil.encode( presentedForms.get(1).getData() );
	}
	
	tmp[&apos;Labs&apos;].push( theLab );	
}</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>var reportSearchResults = client.search()
	.forResource(DiagnosticReport) 
	.where(DiagnosticReport.SUBJECT.hasId($(&apos;PatientResourceID&apos;)))
	.sort().ascending(DiagnosticReport.ISSUED)	
	.returnBundle(Bundle)	
	.execute();

	
var ms;
var firstTime = true; 
var reports = new HashMap();
var lastDate;

var JSONDate = new SimpleDateFormat( &quot;yyyy-MM-dd&quot;);

do
{

	if( !firstTime )
	{
		reportSearchResults = client.loadPage().next(reportSearchResults).execute();
	}
	
	ms = reportSearchResults.getEntry();
		
	for(var i=0; i&lt;ms.size() ; i++ )
	{
		var report = ms.get(i).getResource();
//		var reportString = ctx.newJsonParser().encodeResourceToString(report);

		reports.put( report.getCode().getCodingFirstRep().getCode().toString(), report  );
		lastDate = JSONDate.format( report.getIssued() );
		
	}
	
	firstTime = false;
}
while( reportSearchResults.getLink(Bundle.LINK_NEXT) != null );

tmp[&apos;MostRecentLabSet&apos;][&apos;DateOfService&apos;] = lastDate;

var reportArrayList = new ArrayList( reports.values() );
var size = reportArrayList.size();

var jp = ctx.newJsonParser();
		
for( var i=0; i&lt;size ; i++ )
{

	var theLab =  
{
	 &quot;Order&quot;: {
		 &quot;PlacerOrderNumber&quot;: &quot;&quot;,
		 &quot;FillerOrderNumber&quot;: &quot;&quot;
	},
	 &quot;Result&quot;: {
		 &quot;ParentCode&quot;: &quot;&quot;,
		 &quot;PerformedTestCode&quot;: {
			 &quot;Code&quot;: &quot;&quot;,
			 &quot;System&quot;: &quot;&quot;,
			 &quot;Display&quot;: &quot;&quot;
		},
		 &quot;ResultDate&quot;: &quot;&quot;,
		 &quot;Status&quot;: &quot;Final&quot;,
		 &quot;Observations&quot;: [
		],
		 &quot;TextResultLines&quot;: &quot;&quot;,
		 &quot;ReportPDFBase64&quot;: &quot;&quot;,
		 &quot;ReportHL7Base64&quot;: &quot;&quot;
	}
};
	
	var thisReport = reportArrayList.get(i);
		

	theLab.Result.PerformedTestCode.Code = thisReport.getCode().getCodingFirstRep().getCode();
	theLab.Result.PerformedTestCode.System = thisReport.getCode().getCodingFirstRep().getSystem();
	theLab.Result.PerformedTestCode.Display = thisReport.getCode().getCodingFirstRep().getDisplay();
	
	theLab.Result.ResultDate = JSONDate.format( thisReport.getIssued() );
	theLab.Result.Status = thisReport.getStatus();

	theLab.Order.PlacerOrderNumber = thisReport.getIdentifier().get(0).getValue();
	theLab.Order.FillerOrderNumber = thisReport.getIdentifier().get(1).getValue();
	theLab.Result.ParentCode = thisReport.getConclusion();	
	
	var Observations = thisReport.getContained().getContainedResources();
	var ObservationString = &quot;&quot;;
	var ObservationsCount = Observations.size();

//	logger.error( &quot;Observations: &quot; + ObservationsCount );
		
	for( var j=0 ; j&lt;ObservationsCount ; j++ )
	{
		theLab.Result.Observations.push( JSON.parse( jp.encodeResourceToString(Observations.get(j) ) ) );
	}	

	if( !thisReport.getText().isEmpty())
	{			
		theLab.Result.TextResultLines = thisReport.getText().getDiv().getValueAsString();
	}
		
	var presentedForms = thisReport.getPresentedForm();
		
	if(presentedForms.size()&gt;1)
	{
//		theLab.Result.ReportPDFBase64 = FileUtil.encode( presentedForms.get(0).getData() );
//		theLab.Result.ReportHL7Base64 = FileUtil.encode( presentedForms.get(1).getData() );
	}
	
	tmp[&apos;Labs&apos;].push( theLab );	
}</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">ewoJICJQYXRpZW50SWRlbnRpZmllciI6IAoJCXsKCQkJICJBc3NpZ25pbmdBdXRob3JpdHkiOiAi
U0FGRSIsCgkJCSAiVmFsdWUiOiAiU0FGRS4xMTExMTExMSIKCQl9Cn0=</inboundTemplate>
          <outboundTemplate encoding="base64">ew0KICAiUGF0aWVudElkZW50aWZpZXIiIDogWw0KICAgIHsNCiAgICAgICJBc3NpZ25pbmdBdXRo
b3JpdHkiIDogIlNBRkUiLA0KICAgICAgIlZhbHVlIiA6IDExMTExMTExMTENCiAgICB9LA0KICAg
IHsNCiAgICAgICJBc3NpZ25pbmdBdXRob3JpdHkiIDogIkVIUiIsDQogICAgICAiVmFsdWUiIDog
MjIyMjIyMjIyMjINCiAgICB9DQogIF0sDQogICJNb3N0UmVjZW50TGFiU2V0IiA6IHsNCiAgICAi
RGF0ZU9mU2VydmljZSIgOiAiMTk3Mi0xMS0zMCIKICB9LA0KICAiTGFicyIgOiBbDQogIF0NCn0=
</outboundTemplate>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>3</metaDataId>
          <name>Get Reports</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set">
          <string>RKW</string>
          <string>CURRENT</string>
        </tags>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
          <entry>
            <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
            <string>hapi-fhir</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>f24a2bfd-8f45-4170-b6d6-6410f426ec66</id>
      <nextMetaDataId>3</nextMetaDataId>
      <name>InitiateOrder</name>
      <description>Creates required bundle for ordering from minimal JSON:

{
	 &quot;PatientID&quot;: &quot;SAFE.11111111&quot;,
	 &quot;LabToken&quot;: &quot;Quest&quot;,
	 &quot;LabFacility&quot;:&quot;STL&quot;,
	 &quot;SafeOrderID&quot;: 1,
	 &quot;BillType&quot;:&quot;P&quot;,
	 &quot;OrderingProviderFirstName&quot;:&quot;John&quot;,
	 &quot;OrderingProviderMiddleName&quot;:&quot;Q.&quot;,
	 &quot;OrderingProviderLastName&quot;:&quot;Sawbones&quot;,
	 &quot;OrderingPrividerNPI&quot;:&quot;1111111111&quot;,
	 &quot;GuarantorFirstName&quot;:&quot;x&quot;,
	 &quot;GuarantorMiddleName&quot;:&quot;y&quot;,
	 &quot;GuarantorLastName&quot;:&quot;z&quot;,
	 &quot;GuarantorAddress&quot;:&quot;111 Lane Ln&quot;,
	 &quot;GuarantorCity&quot;:&quot;Nowhere&quot;,
	 &quot;GuarantorState&quot;:&quot;MT&quot;,
	 &quot;GuarantorZip&quot;:&quot;00000-0000&quot;,
	 &quot;GuarantorPhone&quot;:&quot;0000000000&quot;,
	 &quot;InsuranceCode&quot;:&quot;AUHSC&quot;,
	 &quot;PlanCode&quot;:&quot;111111&quot;,
	 &quot;PolicyNumber&quot;:&quot;11111111-11&quot;,
	 &quot;IncludedTests&quot;: [
		&quot;HEPC&quot;,
		&quot;AIDS1&quot;,
		&quot;AIDS2&quot;
	]
}</description>
      <enabled>true</enabled>
      <lastModified>
        <time>1495038226838</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>105</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>8013</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
              <entry>
                <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                <string>hapi-fhir</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>false</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>text/plain</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode></responseStatusCode>
          <responseHeaders class="linked-hash-map"/>
          <charset>UTF-8</charset>
          <contextPath>InitiateOrder</contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Setup</name>
              <script>channelMap.put(&apos;LabToken&apos;, msg[&apos;LabToken&apos;] );

logger.error( &quot;PlacerOrderNumber: &quot; + msg[&apos;PlacerOrderNumberOverride&apos;] );

if( msg[&apos;PlacerOrderNumberOverride&apos;] != &quot;&quot; )
{
	channelMap.put(&apos;PlacerOrderNumber&apos;, msg[&apos;PlacerOrderNumberOverride&apos;] );	
}
else
{
	channelMap.put(&apos;PlacerOrderNumber&apos;, connectorMessage.getMessageId() );
}</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>channelMap.put(&apos;LabToken&apos;, msg[&apos;LabToken&apos;] );

logger.error( &quot;PlacerOrderNumber: &quot; + msg[&apos;PlacerOrderNumberOverride&apos;] );

if( msg[&apos;PlacerOrderNumberOverride&apos;] != &quot;&quot; )
{
	channelMap.put(&apos;PlacerOrderNumber&apos;, msg[&apos;PlacerOrderNumberOverride&apos;] );	
}
else
{
	channelMap.put(&apos;PlacerOrderNumber&apos;, connectorMessage.getMessageId() );
}</string>
                </entry>
              </data>
            </step>
            <step>
              <sequenceNumber>1</sequenceNumber>
              <name>Define MessageHeader</name>
              <script>var MessageHeader =
{
	 &apos;resource&apos;: {
		 &apos;MessageHeader&apos;: {
			 &apos;destination&apos;: {
				 &apos;endpoint&apos;: {
					 &apos;value&apos;: &apos;MET&apos;
				},
				 &apos;name&apos;: {
					 &apos;value&apos;: &apos;PSC&apos;
				}
			},
			 &apos;id&apos;: {
				 &apos;value&apos;: &apos;MSH-message-header&apos;
			},
			 &apos;source&apos;: {
				 &apos;endpoint&apos;: {
					 &apos;value&apos;: &apos;90046003&apos;
				},
				 &apos;name&apos;: {
					 &apos;value&apos;: &apos;SAFE&apos;
				}
			},
			 &apos;event&apos;: {
				 &apos;code&apos;: {
					 &apos;value&apos;: &apos;submit-order&apos;
				}
			},
			 &apos;timestamp&apos;: {
				 &apos;value&apos;: &apos;2017-03-13T12:31:32.122-07:00&apos;
			}
		}
	}
};

MessageHeader.resource.MessageHeader.destination.endpoint.value = msg[&apos;LabFacility&apos;];

tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( MessageHeader );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>var MessageHeader =
{
	 &apos;resource&apos;: {
		 &apos;MessageHeader&apos;: {
			 &apos;destination&apos;: {
				 &apos;endpoint&apos;: {
					 &apos;value&apos;: &apos;MET&apos;
				},
				 &apos;name&apos;: {
					 &apos;value&apos;: &apos;PSC&apos;
				}
			},
			 &apos;id&apos;: {
				 &apos;value&apos;: &apos;MSH-message-header&apos;
			},
			 &apos;source&apos;: {
				 &apos;endpoint&apos;: {
					 &apos;value&apos;: &apos;90046003&apos;
				},
				 &apos;name&apos;: {
					 &apos;value&apos;: &apos;SAFE&apos;
				}
			},
			 &apos;event&apos;: {
				 &apos;code&apos;: {
					 &apos;value&apos;: &apos;submit-order&apos;
				}
			},
			 &apos;timestamp&apos;: {
				 &apos;value&apos;: &apos;2017-03-13T12:31:32.122-07:00&apos;
			}
		}
	}
};

MessageHeader.resource.MessageHeader.destination.endpoint.value = msg[&apos;LabFacility&apos;];

tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( MessageHeader );</string>
                </entry>
              </data>
            </step>
            <step>
              <sequenceNumber>2</sequenceNumber>
              <name>Query for Patient</name>
              <script>importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var Url = configurationMap.get(&apos;sparkRawURL&apos;);

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( msg[&apos;PatientID&apos;]) )
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;

if( msSize )
{
	var patientResource = ms.get(0).getResource();
	var patientString = ctx.newJsonParser().encodeResourceToString(patientResource);
	
//	logger.error( &quot;Patient: \n&quot; + patientResource.getIdentifier().get(0).getValue() );
//	logger.error( &quot;Patient: \n&quot; + patientString );	
}
else
{
	throw &quot;Initiate Order: Patient Not Found&quot;;
}

var PatientTarget =
       {
        &quot;resource&quot; : {
          &quot;Patient&quot; : {
            &quot;identifier&quot; : [
              {
                &quot;use&quot; : {
                  &quot;value&quot; : &quot;secondary&quot;
                },
                &quot;value&quot; : {
                  &quot;value&quot; : 20526619
                }
              },
              {
                &quot;use&quot; : {
                  &quot;value&quot; : &quot;official&quot;
                },
                &quot;value&quot; : {
                  &quot;value&quot; : 20526619
                }
              }
            ],
            &quot;address&quot; : {
              &quot;country&quot; : {
                &quot;value&quot; : &quot;USA&quot;
              },
              &quot;city&quot; : {
                &quot;value&quot; : &quot;scottsdale&quot;
              },
              &quot;line&quot; : {
                &quot;value&quot; : &quot;123 my street&quot;
              },
			&quot;postalCode&quot;: {
				 &quot;value&quot;: 85257
			},              
              &quot;state&quot; : {
                &quot;value&quot; : &quot;AZ&quot;
              }
            },
            &quot;gender&quot; : {
              &quot;value&quot; : &quot;male&quot;
            },
            
            &quot;name&quot; : {
              &quot;family&quot; : {
              	&quot;value&quot;: &quot;Mace&quot;
              },
              &quot;given&quot; : {
              	&quot;value&quot;:&quot;Andrew&quot;
              	}
              },
            &quot;telecom&quot; : {
              &quot;system&quot; : {
                &quot;value&quot; : &quot;phone&quot;
              },
              &quot;use&quot; : {
                &quot;value&quot; : &quot;home&quot;
              },
              &quot;value&quot; : {
                &quot;value&quot; : 1234567890
              }
            },
            &quot;id&quot; : {
              &quot;value&quot; : &quot;PID-patient-identification&quot;
            },
            &quot;birthDate&quot; : {
              &quot;value&quot; : &quot;1988-01-01&quot;
            }
          }
        }
      }      ;


var PatientSource = JSON.parse( patientString );

PatientTarget.resource.Patient.identifier[0].value.value = PatientSource.identifier[0].value;
PatientTarget.resource.Patient.identifier[0].use.value = &quot;secondary&quot;;

PatientTarget.resource.Patient.identifier[1].value.value = PatientSource.identifier[1].value;
PatientTarget.resource.Patient.identifier[1].use.value = &quot;official&quot;;

PatientTarget.resource.Patient.name.family.value = PatientSource.name[0].family[0];
PatientTarget.resource.Patient.name.given.value =  PatientSource.name[0].given[0];

PatientTarget.resource.Patient.telecom.value.value = PatientSource.telecom[0].value;
PatientTarget.resource.Patient.gender.value = PatientSource.gender;
PatientTarget.resource.Patient.birthDate.value = PatientSource.birthDate;

PatientTarget.resource.Patient.address.line.value = PatientSource.address[0].line[0];
PatientTarget.resource.Patient.address.city.value = PatientSource.address[0].city;
PatientTarget.resource.Patient.address.state.value = PatientSource.address[0].state;
PatientTarget.resource.Patient.address.postalCode.value = PatientSource.address[0].postalCode;
PatientTarget.resource.Patient.id = PatientSource.id;

tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( PatientTarget );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var Url = configurationMap.get(&apos;sparkRawURL&apos;);

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( msg[&apos;PatientID&apos;]) )
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;

if( msSize )
{
	var patientResource = ms.get(0).getResource();
	var patientString = ctx.newJsonParser().encodeResourceToString(patientResource);
	
//	logger.error( &quot;Patient: \n&quot; + patientResource.getIdentifier().get(0).getValue() );
//	logger.error( &quot;Patient: \n&quot; + patientString );	
}
else
{
	throw &quot;Initiate Order: Patient Not Found&quot;;
}

var PatientTarget =
       {
        &quot;resource&quot; : {
          &quot;Patient&quot; : {
            &quot;identifier&quot; : [
              {
                &quot;use&quot; : {
                  &quot;value&quot; : &quot;secondary&quot;
                },
                &quot;value&quot; : {
                  &quot;value&quot; : 20526619
                }
              },
              {
                &quot;use&quot; : {
                  &quot;value&quot; : &quot;official&quot;
                },
                &quot;value&quot; : {
                  &quot;value&quot; : 20526619
                }
              }
            ],
            &quot;address&quot; : {
              &quot;country&quot; : {
                &quot;value&quot; : &quot;USA&quot;
              },
              &quot;city&quot; : {
                &quot;value&quot; : &quot;scottsdale&quot;
              },
              &quot;line&quot; : {
                &quot;value&quot; : &quot;123 my street&quot;
              },
			&quot;postalCode&quot;: {
				 &quot;value&quot;: 85257
			},              
              &quot;state&quot; : {
                &quot;value&quot; : &quot;AZ&quot;
              }
            },
            &quot;gender&quot; : {
              &quot;value&quot; : &quot;male&quot;
            },
            
            &quot;name&quot; : {
              &quot;family&quot; : {
              	&quot;value&quot;: &quot;Mace&quot;
              },
              &quot;given&quot; : {
              	&quot;value&quot;:&quot;Andrew&quot;
              	}
              },
            &quot;telecom&quot; : {
              &quot;system&quot; : {
                &quot;value&quot; : &quot;phone&quot;
              },
              &quot;use&quot; : {
                &quot;value&quot; : &quot;home&quot;
              },
              &quot;value&quot; : {
                &quot;value&quot; : 1234567890
              }
            },
            &quot;id&quot; : {
              &quot;value&quot; : &quot;PID-patient-identification&quot;
            },
            &quot;birthDate&quot; : {
              &quot;value&quot; : &quot;1988-01-01&quot;
            }
          }
        }
      }      ;


var PatientSource = JSON.parse( patientString );

PatientTarget.resource.Patient.identifier[0].value.value = PatientSource.identifier[0].value;
PatientTarget.resource.Patient.identifier[0].use.value = &quot;secondary&quot;;

PatientTarget.resource.Patient.identifier[1].value.value = PatientSource.identifier[1].value;
PatientTarget.resource.Patient.identifier[1].use.value = &quot;official&quot;;

PatientTarget.resource.Patient.name.family.value = PatientSource.name[0].family[0];
PatientTarget.resource.Patient.name.given.value =  PatientSource.name[0].given[0];

PatientTarget.resource.Patient.telecom.value.value = PatientSource.telecom[0].value;
PatientTarget.resource.Patient.gender.value = PatientSource.gender;
PatientTarget.resource.Patient.birthDate.value = PatientSource.birthDate;

PatientTarget.resource.Patient.address.line.value = PatientSource.address[0].line[0];
PatientTarget.resource.Patient.address.city.value = PatientSource.address[0].city;
PatientTarget.resource.Patient.address.state.value = PatientSource.address[0].state;
PatientTarget.resource.Patient.address.postalCode.value = PatientSource.address[0].postalCode;
PatientTarget.resource.Patient.id = PatientSource.id;

tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( PatientTarget );</string>
                </entry>
              </data>
            </step>
            <step>
              <sequenceNumber>3</sequenceNumber>
              <name>Define Coverage</name>
              <script>var Coverage = 
{
	 &quot;resource&quot;: {
		 &quot;Coverage&quot;: {
			 &quot;identifier&quot;: {
				 &quot;value&quot;: {
					 &quot;value&quot;: &quot;PlanID1234&quot;
				}
			},
			 &quot;contained&quot;: {
				 &quot;Organization&quot;: {
					 &quot;identifier&quot;: {
						 &quot;value&quot;: {
							 &quot;value&quot;: &quot;N&quot;
						}
					},
					 &quot;id&quot;: {
						 &quot;value&quot;: &quot;IN1-insurance-1&quot;
					}
				}
			},
			 &quot;subscriber&quot;: {
				 &quot;reference&quot;: {
					 &quot;value&quot;: &quot;Patient/PID1&quot;
				}
			},
			 &quot;id&quot;: {
				 &quot;value&quot;: &quot;IN1-insurance-1&quot;
			},
			 &quot;type&quot;: {
				 &quot;code&quot;: {
					 &quot;value&quot;: &quot;C&quot;
				}
			},
			 &quot;plan&quot;: {
				 &quot;value&quot;: &quot;Patient/PID1&quot;
			}
		}
	}
};


Coverage.resource.Coverage.identifier.value.value = msg[&apos;InsuranceCode&apos;];
Coverage.resource.Coverage.plan.value = msg[&apos;PlanCode&apos;];

tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( Coverage );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>var Coverage = 
{
	 &quot;resource&quot;: {
		 &quot;Coverage&quot;: {
			 &quot;identifier&quot;: {
				 &quot;value&quot;: {
					 &quot;value&quot;: &quot;PlanID1234&quot;
				}
			},
			 &quot;contained&quot;: {
				 &quot;Organization&quot;: {
					 &quot;identifier&quot;: {
						 &quot;value&quot;: {
							 &quot;value&quot;: &quot;N&quot;
						}
					},
					 &quot;id&quot;: {
						 &quot;value&quot;: &quot;IN1-insurance-1&quot;
					}
				}
			},
			 &quot;subscriber&quot;: {
				 &quot;reference&quot;: {
					 &quot;value&quot;: &quot;Patient/PID1&quot;
				}
			},
			 &quot;id&quot;: {
				 &quot;value&quot;: &quot;IN1-insurance-1&quot;
			},
			 &quot;type&quot;: {
				 &quot;code&quot;: {
					 &quot;value&quot;: &quot;C&quot;
				}
			},
			 &quot;plan&quot;: {
				 &quot;value&quot;: &quot;Patient/PID1&quot;
			}
		}
	}
};


Coverage.resource.Coverage.identifier.value.value = msg[&apos;InsuranceCode&apos;];
Coverage.resource.Coverage.plan.value = msg[&apos;PlanCode&apos;];

tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( Coverage );</string>
                </entry>
              </data>
            </step>
            <step>
              <sequenceNumber>4</sequenceNumber>
              <name>Define Practitioner / Ordering Provider</name>
              <script>var Practitioner = 
{
	 &quot;resource&quot;: {
		 &quot;Practitioner&quot;: {
			 &quot;identifier&quot;: {
				 &quot;assigner&quot;: {
					 &quot;display&quot;: {
						 &quot;value&quot;: &quot;NPI&quot;
					}
				},
				 &quot;value&quot;: {
					 &quot;value&quot;: &quot;NPI_ID12345&quot;
				}
			},
			 &quot;name&quot;: {
				 &quot;given&quot;: {
					 &quot;value&quot;: &quot;Jason&quot;
				},
				 &quot;family&quot;: {
					 &quot;value&quot;: &quot;Javillo&quot;
				}
			},
			 &quot;id&quot;: {
				 &quot;value&quot;: &quot;ordering-provider-1&quot;
			}
		}
	}
};

Practitioner.resource.Practitioner.identifier.value.value = msg[&apos;OrderingProviderNPI&apos;];
Practitioner.resource.Practitioner.name.family.value = msg[&apos;OrderingProviderLastName&apos;];
Practitioner.resource.Practitioner.name.given.value  = msg[&apos;OrderingProviderFirstName&apos;];

tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( Practitioner );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>var Practitioner = 
{
	 &quot;resource&quot;: {
		 &quot;Practitioner&quot;: {
			 &quot;identifier&quot;: {
				 &quot;assigner&quot;: {
					 &quot;display&quot;: {
						 &quot;value&quot;: &quot;NPI&quot;
					}
				},
				 &quot;value&quot;: {
					 &quot;value&quot;: &quot;NPI_ID12345&quot;
				}
			},
			 &quot;name&quot;: {
				 &quot;given&quot;: {
					 &quot;value&quot;: &quot;Jason&quot;
				},
				 &quot;family&quot;: {
					 &quot;value&quot;: &quot;Javillo&quot;
				}
			},
			 &quot;id&quot;: {
				 &quot;value&quot;: &quot;ordering-provider-1&quot;
			}
		}
	}
};

Practitioner.resource.Practitioner.identifier.value.value = msg[&apos;OrderingProviderNPI&apos;];
Practitioner.resource.Practitioner.name.family.value = msg[&apos;OrderingProviderLastName&apos;];
Practitioner.resource.Practitioner.name.given.value  = msg[&apos;OrderingProviderFirstName&apos;];

tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( Practitioner );</string>
                </entry>
              </data>
            </step>
            <step>
              <sequenceNumber>5</sequenceNumber>
              <name>Add Static Test Set</name>
              <script>var Panel = 
[
	{ &apos;code&apos;: &apos;91431&apos;, &apos;display&apos;: &apos;HIV 1/2 ANTIGEN/ANTIBODY,FOURTH GENERATION W/RFL&apos; },
	{ &apos;code&apos;: &apos;8472&apos;, &apos;display&apos;: &apos;HEPATITIS C AB W/REFL TO HCV RNA, QN, PCR^SERUM&apos; },
	{ &apos;code&apos;: &apos;498&apos;, &apos;display&apos;: &apos;HEPATITIS B SURFACE ANTIGEN W/REFL CONFIRM&apos; },
	{ &apos;code&apos;: &apos;3640&apos;, &apos;display&apos;: &apos;HSV 2 IGG, TYPE SPECIFIC AB&apos; },
	{ &apos;code&apos;: &apos;799&apos;, &apos;display&apos;: &apos;RPR (MONITOR) W/REFL TITER&apos; }, /*Syphylis*/
	{ &apos;code&apos;: &apos;11362&apos;, &apos;display&apos;: &apos;NEISSERIA GONORRHOEAE RNA, TMA&apos; },
	{ &apos;code&apos;: &apos;11363&apos;, &apos;display&apos;: &apos;CHLAMYDIA/N. GONORRHOEAE RNA, TMA&apos; }		
]
;


var index = 1;

for each( item in Panel )
{

var order = 
{
	 &apos;resource&apos;: {
		 &apos;DiagnosticOrder&apos;: {
			 &apos;item&apos;: {
				 &apos;code&apos;: {
					 &apos;coding&apos;: {
						 &apos;code&apos;: {
							 &apos;value&apos;: 91431
						},
						 &apos;display&apos;: {
							 &apos;value&apos;: &apos;Chlamydia&apos;
						}
					}
				},
				 &apos;specimen&apos;: {
					 &apos;display&apos;: {
						 &apos;value&apos;: &apos;G&apos;
					}
				}
			},
			 &apos;subject&apos;: {
				 &apos;id&apos;: &apos;Patient&apos;
			},
			 &apos;id&apos;: {
				 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
			},
			 &apos;event&apos;: {
				 &apos;dateTime&apos;: {
					 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
				},
				 &apos;actor&apos;: {
					 &apos;reference&apos;: {
						 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
					}
				},
				 &apos;status&apos;: {
					 &apos;value&apos;: &apos;completed&apos;
				}
			}
		}
	}
};

var report =
{
	 &apos;resource&apos;: {
		 &apos;DiagnosticReport&apos;: {
			 &apos;result&apos;: {
				 &apos;reference&apos;: {
					 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
				}
			},
			 &apos;identifier&apos;: {
				 &apos;system&apos;: {
					 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
				},
				 &apos;type&apos;: {
					 &apos;id&apos;: &apos;99QDI&apos;
				},
				 &apos;value&apos;: {
					 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
				}
			},
			 &apos;request&apos;: {
				 &apos;reference&apos;: {
					 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
				}
			},
			 &apos;contained&apos;: {
				 &apos;Practitioner&apos;: {
					 &apos;identifier&apos;: {
						 &apos;value&apos;: {
							 &apos;value&apos;: &apos;NPP_ID&apos;
						}
					},
					 &apos;name&apos;: {
						 &apos;family&apos;: {
							 &apos;value&apos;: &apos;NPP_Name&apos;
						}
					},
					 &apos;id&apos;: {
						 &apos;value&apos;: &apos;ORC11-verified-by&apos;
					}
				}
			},
			 &apos;extension&apos;: {
				 &apos;valueTiming&apos;: &apos;&apos;
			},
			 &apos;code&apos;: {
				 &apos;id&apos;: 10124
			},
			 &apos;performer&apos;: {
				 &apos;reference&apos;: {
					 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
				}
			},
			 &apos;subject&apos;: {
				 &apos;reference&apos;: {
					 &apos;value&apos;: &apos;Patient&apos;
				}
			},
			 &apos;effectiveElementDefinition&apos;: {
				 &apos;extension&apos;: {
					 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
				}
			},
			 &apos;id&apos;: {
				 &apos;value&apos;: &apos;ORC-common-order-1&apos;
			},
			 &apos;status&apos;: {
				 &apos;value&apos;: &apos;final&apos;
			}
		}
	}
};	


	var code    = item.code;
	var display = item.display; 

	report.resource.DiagnosticReport.id.value = index + &apos;&apos;;
	report.resource.DiagnosticReport.request.reference.value = &quot;DiagnosticOrder/&quot; + index + &apos;&apos;;
	
	tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( report );	
//	logger.error( &quot;Test: &quot; + code + &quot; - &quot; + display );
	
	order.resource.DiagnosticOrder.item.code.coding.code.value = code;
	order.resource.DiagnosticOrder.item.code.coding.display.value = display						 
	order.resource.DiagnosticOrder.id.value = index;
	
	tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( order );		

	index++;
}

/*

var Entries = 
[
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86631
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Chlamydia&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-1&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 87591
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Gonorrhea&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-2&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86704
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Hepatitis A&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-3&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-3&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 87340
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Hepatitis B&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-4&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-4&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 81001
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Hepatitis C&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-5&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-5&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86695
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Herpes 1&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-6&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-6&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86696
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Herpes 2&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-7&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-7&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86701
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;HIV Type1&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-8&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-8&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86702
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;HIV Type 2&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-9&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-9&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86592
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Syphilis&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-10&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-10&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			}
]
;
*/
/*
for( var i=0 ; i&lt;Entries.length; i++ )
{
	tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( Entries[i] );	
}
*/</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>var Panel = 
[
	{ &apos;code&apos;: &apos;91431&apos;, &apos;display&apos;: &apos;HIV 1/2 ANTIGEN/ANTIBODY,FOURTH GENERATION W/RFL&apos; },
	{ &apos;code&apos;: &apos;8472&apos;, &apos;display&apos;: &apos;HEPATITIS C AB W/REFL TO HCV RNA, QN, PCR^SERUM&apos; },
	{ &apos;code&apos;: &apos;498&apos;, &apos;display&apos;: &apos;HEPATITIS B SURFACE ANTIGEN W/REFL CONFIRM&apos; },
	{ &apos;code&apos;: &apos;3640&apos;, &apos;display&apos;: &apos;HSV 2 IGG, TYPE SPECIFIC AB&apos; },
	{ &apos;code&apos;: &apos;799&apos;, &apos;display&apos;: &apos;RPR (MONITOR) W/REFL TITER&apos; }, /*Syphylis*/
	{ &apos;code&apos;: &apos;11362&apos;, &apos;display&apos;: &apos;NEISSERIA GONORRHOEAE RNA, TMA&apos; },
	{ &apos;code&apos;: &apos;11363&apos;, &apos;display&apos;: &apos;CHLAMYDIA/N. GONORRHOEAE RNA, TMA&apos; }		
]
;


var index = 1;

for each( item in Panel )
{

var order = 
{
	 &apos;resource&apos;: {
		 &apos;DiagnosticOrder&apos;: {
			 &apos;item&apos;: {
				 &apos;code&apos;: {
					 &apos;coding&apos;: {
						 &apos;code&apos;: {
							 &apos;value&apos;: 91431
						},
						 &apos;display&apos;: {
							 &apos;value&apos;: &apos;Chlamydia&apos;
						}
					}
				},
				 &apos;specimen&apos;: {
					 &apos;display&apos;: {
						 &apos;value&apos;: &apos;G&apos;
					}
				}
			},
			 &apos;subject&apos;: {
				 &apos;id&apos;: &apos;Patient&apos;
			},
			 &apos;id&apos;: {
				 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
			},
			 &apos;event&apos;: {
				 &apos;dateTime&apos;: {
					 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
				},
				 &apos;actor&apos;: {
					 &apos;reference&apos;: {
						 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
					}
				},
				 &apos;status&apos;: {
					 &apos;value&apos;: &apos;completed&apos;
				}
			}
		}
	}
};

var report =
{
	 &apos;resource&apos;: {
		 &apos;DiagnosticReport&apos;: {
			 &apos;result&apos;: {
				 &apos;reference&apos;: {
					 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
				}
			},
			 &apos;identifier&apos;: {
				 &apos;system&apos;: {
					 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
				},
				 &apos;type&apos;: {
					 &apos;id&apos;: &apos;99QDI&apos;
				},
				 &apos;value&apos;: {
					 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
				}
			},
			 &apos;request&apos;: {
				 &apos;reference&apos;: {
					 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
				}
			},
			 &apos;contained&apos;: {
				 &apos;Practitioner&apos;: {
					 &apos;identifier&apos;: {
						 &apos;value&apos;: {
							 &apos;value&apos;: &apos;NPP_ID&apos;
						}
					},
					 &apos;name&apos;: {
						 &apos;family&apos;: {
							 &apos;value&apos;: &apos;NPP_Name&apos;
						}
					},
					 &apos;id&apos;: {
						 &apos;value&apos;: &apos;ORC11-verified-by&apos;
					}
				}
			},
			 &apos;extension&apos;: {
				 &apos;valueTiming&apos;: &apos;&apos;
			},
			 &apos;code&apos;: {
				 &apos;id&apos;: 10124
			},
			 &apos;performer&apos;: {
				 &apos;reference&apos;: {
					 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
				}
			},
			 &apos;subject&apos;: {
				 &apos;reference&apos;: {
					 &apos;value&apos;: &apos;Patient&apos;
				}
			},
			 &apos;effectiveElementDefinition&apos;: {
				 &apos;extension&apos;: {
					 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
				}
			},
			 &apos;id&apos;: {
				 &apos;value&apos;: &apos;ORC-common-order-1&apos;
			},
			 &apos;status&apos;: {
				 &apos;value&apos;: &apos;final&apos;
			}
		}
	}
};	


	var code    = item.code;
	var display = item.display; 

	report.resource.DiagnosticReport.id.value = index + &apos;&apos;;
	report.resource.DiagnosticReport.request.reference.value = &quot;DiagnosticOrder/&quot; + index + &apos;&apos;;
	
	tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( report );	
//	logger.error( &quot;Test: &quot; + code + &quot; - &quot; + display );
	
	order.resource.DiagnosticOrder.item.code.coding.code.value = code;
	order.resource.DiagnosticOrder.item.code.coding.display.value = display						 
	order.resource.DiagnosticOrder.id.value = index;
	
	tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( order );		

	index++;
}

/*

var Entries = 
[
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86631
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Chlamydia&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-1&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 87591
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Gonorrhea&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-2&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86704
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Hepatitis A&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-3&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-3&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 87340
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Hepatitis B&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-4&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-4&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 81001
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Hepatitis C&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-5&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-5&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86695
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Herpes 1&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-6&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-6&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86696
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Herpes 2&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-7&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-7&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86701
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;HIV Type1&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-8&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-8&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86702
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;HIV Type 2&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-9&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-9&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticOrder&apos;: {
						 &apos;item&apos;: {
							 &apos;code&apos;: {
								 &apos;coding&apos;: {
									 &apos;code&apos;: {
										 &apos;value&apos;: 86592
									},
									 &apos;display&apos;: {
										 &apos;value&apos;: &apos;Syphilis&apos;
									}
								}
							},
							 &apos;specimen&apos;: {
								 &apos;display&apos;: {
									 &apos;value&apos;: &apos;G&apos;
								}
							}
						},
						 &apos;subject&apos;: {
							 &apos;id&apos;: &apos;Patient&apos;
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;OBR-observation-request-10&apos;
						},
						 &apos;event&apos;: {
							 &apos;dateTime&apos;: {
								 &apos;value&apos;: &apos;2016-11-18T20:51:55+00:00&apos;
							},
							 &apos;actor&apos;: {
								 &apos;reference&apos;: {
									 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
								}
							},
							 &apos;status&apos;: {
								 &apos;value&apos;: &apos;completed&apos;
							}
						}
					}
				}
			},
			{
				 &apos;resource&apos;: {
					 &apos;DiagnosticReport&apos;: {
						 &apos;result&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Observation/OBX-observation-1&apos;
							}
						},
						 &apos;identifier&apos;: {
							 &apos;system&apos;: {
								 &apos;value&apos;: &apos;QUEST_SKB_7186121&apos;
							},
							 &apos;type&apos;: {
								 &apos;id&apos;: &apos;99QDI&apos;
							},
							 &apos;value&apos;: {
								 &apos;value&apos;: $(&apos;PlacerOrderNumber&apos;)
							}
						},
						 &apos;request&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;DiagnosticOrder/obr-observation-request&apos;
							}
						},
						 &apos;contained&apos;: {
							 &apos;Practitioner&apos;: {
								 &apos;identifier&apos;: {
									 &apos;value&apos;: {
										 &apos;value&apos;: &apos;NPP_ID&apos;
									}
								},
								 &apos;name&apos;: {
									 &apos;family&apos;: {
										 &apos;value&apos;: &apos;NPP_Name&apos;
									}
								},
								 &apos;id&apos;: {
									 &apos;value&apos;: &apos;ORC11-verified-by&apos;
								}
							}
						},
						 &apos;extension&apos;: {
							 &apos;valueTiming&apos;: &apos;&apos;
						},
						 &apos;code&apos;: {
							 &apos;id&apos;: 10124
						},
						 &apos;performer&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Practitioner/ordering-provider-1&apos;
							}
						},
						 &apos;subject&apos;: {
							 &apos;reference&apos;: {
								 &apos;value&apos;: &apos;Patient&apos;
							}
						},
						 &apos;effectiveElementDefinition&apos;: {
							 &apos;extension&apos;: {
								 &apos;url&apos;: &apos;http://hl7.org/fhir/v3/NullFlavor/NI&apos;
							}
						},
						 &apos;id&apos;: {
							 &apos;value&apos;: &apos;ORC-common-order-10&apos;
						},
						 &apos;status&apos;: {
							 &apos;value&apos;: &apos;final&apos;
						}
					}
				}
			}
]
;
*/
/*
for( var i=0 ; i&lt;Entries.length; i++ )
{
	tmp[&apos;Bundle&apos;][&apos;entry&apos;].push( Entries[i] );	
}
*/</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">ewoJICJQYXRpZW50SUQiOiAiU0FGRS4xMTExMTExMSIsCgkgIkxhYlRva2VuIjogIlF1ZXN0IiwK
CSAiTGFiRmFjaWxpdHkiOiJTVEwiLAoJICJTYWZlT3JkZXJJRCI6IDEsCgkgIkJpbGxUeXBlIjoi
UCIsCgkgIk9yZGVyaW5nUHJvdmlkZXJGaXJzdE5hbWUiOiJKb2huIiwKCSAiT3JkZXJpbmdQcm92
aWRlck1pZGRsZU5hbWUiOiJRLiIsCgkgIk9yZGVyaW5nUHJvdmlkZXJMYXN0TmFtZSI6IlNhd2Jv
bmVzIiwKCSAiT3JkZXJpbmdQcm92aWRlck5QSSI6IjExMTExMTExMTEiLAoJICJHdWFyYW50b3JG
aXJzdE5hbWUiOiJ4IiwKCSAiR3VhcmFudG9yTWlkZGxlTmFtZSI6InkiLAoJICJHdWFyYW50b3JM
YXN0TmFtZSI6InoiLAoJICJHdWFyYW50b3JBZGRyZXNzIjoiMTExIExhbmUgTG4iLAoJICJHdWFy
YW50b3JDaXR5IjoiTm93aGVyZSIsCgkgIkd1YXJhbnRvclN0YXRlIjoiTVQiLAoJICJHdWFyYW50
b3JaaXAiOiIwMDAwMC0wMDAwIiwKCSAiR3VhcmFudG9yUGhvbmUiOiIwMDAwMDAwMDAwIiwKCSAi
SW5zdXJhbmNlQ29kZSI6IkFVSFNDIiwKCSAiUGxhbkNvZGUiOiIxMTExMTEiLAoJICJQb2xpY3lO
dW1iZXIiOiIxMTExMTExMS0xMSIsCgkgIkluY2x1ZGVkVGVzdHMiOiBbCgkJIkhFUEMiLAoJCSJB
SURTMSIsCgkJIkFJRFMyIgoJICBdLAoJICAiUGxhY2VyT3JkZXJOdW1iZXJPdmVycmlkZSI6Ijki
Cn0=</inboundTemplate>
          <outboundTemplate encoding="base64">eyJCdW5kbGUiOiB7CiAgImVudHJ5IjogWwogIF0sCiAgImlkIjogeyJ2YWx1ZSI6ICJPTUwtTzIx
LWIxYTE3Y2QyLTg2NWYtNDg2YS05NjBkLThlYTc3NjRlYzAwZCJ9LAogICJ0eXBlIjogeyJ2YWx1
ZSI6ICJzZWFyY2hzZXQifQp9fQ==</outboundTemplate>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>To Send Order</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
                <entry>
                  <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                  <string>hapi-fhir</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>4c7bc0bd-aede-4e90-9ce8-cde50750f1e8</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules>
              <rule>
                <sequenceNumber>0</sequenceNumber>
                <name>Quest?</name>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>return $(&apos;LabToken&apos;).toUpperCase() == &quot;QUEST&quot;;</string>
                  </entry>
                </data>
                <type>JavaScript</type>
                <script>return $(&apos;LabToken&apos;).toUpperCase() == &quot;QUEST&quot;;</script>
                <operator>NONE</operator>
              </rule>
            </rules>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>2</metaDataId>
          <name>Dummy</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>false</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set">
          <string>RKW</string>
        </tags>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
          <entry>
            <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
            <string>hapi-fhir</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>7e3d40fd-a84d-41df-9994-7a405c6a3bad</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>InsertInsuranceOrganization</name>
      <description></description>
      <enabled>false</enabled>
      <lastModified>
        <time>1497221995041</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>5</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>8013</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>d1</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
              <entry>
                <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                <string>hapi-fhir</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>false</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>text/plain</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode></responseStatusCode>
          <responseHeaders class="linked-hash-map"/>
          <charset>UTF-8</charset>
          <contextPath>InsertPractitioner</contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Insert Practitioner</name>
              <script>importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.model.dstu2.valueset);
importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);
	
var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

var resource = new Organization();

var theNPI = new ResourceReferenceDt();
theNPI.setDisplay(&quot;NPI&quot;);
		
resource.addIdentifier().setAssigner( theNPI ).setValue( msg[&apos;npi&apos;] );		
		
var theName = new HumanNameDt();
theName.addFamily( msg[&apos;lastName&apos;] ).addGiven( msg[&apos;firstName&apos;] ).addGiven( msg[&apos;middleName&apos;] );
		
resource.setName( theName );

var outcome = client.create()
	.resource(resource)
	.conditional()
	.where(Practitioner.IDENTIFIER.exactly().identifier( msg[&apos;npi&apos;] ))
	.execute();
		
practitioner = client.read(resource, outcome.getId().getIdPart() );

logger.error(&quot;New Organization: ID= &quot; + outcome.getId().getIdPart() );
		
channelMap.put( &quot;ResourceID&quot;, outcome.getId().getIdPart() );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.model.dstu2.valueset);
importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);
	
var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

var resource = new Organization();

var theNPI = new ResourceReferenceDt();
theNPI.setDisplay(&quot;NPI&quot;);
		
resource.addIdentifier().setAssigner( theNPI ).setValue( msg[&apos;npi&apos;] );		
		
var theName = new HumanNameDt();
theName.addFamily( msg[&apos;lastName&apos;] ).addGiven( msg[&apos;firstName&apos;] ).addGiven( msg[&apos;middleName&apos;] );
		
resource.setName( theName );

var outcome = client.create()
	.resource(resource)
	.conditional()
	.where(Practitioner.IDENTIFIER.exactly().identifier( msg[&apos;npi&apos;] ))
	.execute();
		
practitioner = client.read(resource, outcome.getId().getIdPart() );

logger.error(&quot;New Organization: ID= &quot; + outcome.getId().getIdPart() );
		
channelMap.put( &quot;ResourceID&quot;, outcome.getId().getIdPart() );</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">ewoJIm5waSI6IjIyMjIyMjIyMjIiLAoJImZpcnN0TmFtZSI6IkphY2siLAoJIm1pZGRsZU5hbWUi
OiJNIiwKCSJsYXN0TmFtZSI6IlNtaXRoIgp9</inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Return</name>
          <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
                <entry>
                  <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                  <string>hapi-fhir</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <script>return $(&apos;ResourceID&apos;);</script>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>New Step</name>
                <script>tmp[&apos;row&apos;][&apos;column1&apos;] = $(&apos;PatientResourceID&apos;);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>tmp[&apos;row&apos;][&apos;column1&apos;] = $(&apos;PatientResourceID&apos;);</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64">eHh4eHg=</outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>DELIMITED</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
                <numberedRows>false</numberedRows>
                <ignoreCR>true</ignoreCR>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
                <splitType>Record</splitType>
                <batchSkipRecords>0</batchSkipRecords>
                <batchMessageDelimiter></batchMessageDelimiter>
                <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
                <batchGroupingColumn></batchGroupingColumn>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>JavaScript Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set">
          <string>RKW</string>
        </tags>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
          <entry>
            <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
            <string>hapi-fhir</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>6dacfc8f-4e4a-4baa-8996-635d9fc36cc8</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>InsertPatient</name>
      <description></description>
      <enabled>true</enabled>
      <lastModified>
        <time>1500316666249</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>39</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>8012</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>d1</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                <string>hapi-fhir</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>false</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>text/plain</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode></responseStatusCode>
          <responseHeaders class="linked-hash-map"/>
          <charset>UTF-8</charset>
          <contextPath>InsertPatient</contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Insert Patient</name>
              <script>// Begin...

// rhw  Message Content
channelMap.put(&apos;safeId&apos;,msg[&apos;safeId&apos;]);  //rhw
channelMap.put(&apos;emrId&apos;,msg[&apos;emrId&apos;]);  //rhw
channelMap.put(&apos;firstName&apos;,msg[&apos;firstName&apos;]);  //rhw
channelMap.put(&apos;middleName&apos;,msg[&apos;middleName&apos;]);  //rhw
channelMap.put(&apos;lastName&apos;,msg[&apos;lastName&apos;]);  //rhw
channelMap.put(&apos;lineAddress&apos;,msg[&apos;lineAddress&apos;]);  //rhw
channelMap.put(&apos;cityAddress&apos;,msg[&apos;cityAddress&apos;]);  //rhw
channelMap.put(&apos;stateAddress&apos;,msg[&apos;stateAddress&apos;]);  //rhw
channelMap.put(&apos;zipAddress&apos;,msg[&apos;zipAddress&apos;]);  //rhw
channelMap.put(&apos;singleCharGender&apos;,msg[&apos;singleCharGender&apos;]);  //rhw
channelMap.put(&apos;YYYYMMDDBirthdate&apos;,msg[&apos;YYYYMMDDBirthdate&apos;]);  //rhw
channelMap.put(&apos;HomePhoneNoDelimiters&apos;,msg[&apos;HomePhoneNoDelimiters&apos;]);  //rhw


// rhw  FHIR Package Import
importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.model.dstu2.valueset);
importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);


// rhw  Variable Declarations
var HL7DateFormat = new java.text.SimpleDateFormat(&quot;YYYYMMdd&quot;);
var Url = configurationMap.get(&apos;sparkRawURL&apos;);
 logger.info(&apos;Url:  &apos; + Url);  //rhw
var ctx = new FhirContext(FhirVersionEnum.DSTU2);
var client = ctx.newRestfulGenericClient( Url );


// rhw  
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );
 logger.info(&apos;ctx:  &apos; + $(&apos;ctx&apos;));  //rhw


// Need to replace conditional insert with query + create strategy


// rhw  
var patient = new Patient();
 logger.info(&apos;patient:  &apos; + patient);  //rhw


// rhw  
patient.addIdentifier().setUse(IdentifierUseEnum.SECONDARY).setValue( msg[&apos;emrId&apos;] );	
patient.addIdentifier().setUse(IdentifierUseEnum.OFFICIAL).setValue( msg[&apos;safeId&apos;] );		


// rhw  
patient.addName().addFamily( msg[&apos;lastName&apos;] ).addGiven( msg[&apos;firstName&apos;] ).addGiven( msg[&apos;middleName&apos;] );
patient.addAddress().addLine( msg[&apos;lineAddress&apos;] ).setCity( msg[&apos;cityAddress&apos;] ).setState( msg[&apos;stateAddress&apos;] ).setPostalCode( msg[&apos;zipAddress&apos;] );
patient.setBirthDateWithDayPrecision( HL7DateFormat.parse( msg[&apos;YYYYMMDDBirthdate&apos;] ) );

// rhw  
if( msg[&apos;singleCharGender&apos;].toString() == &quot;M&quot; )
{
	patient.setGender(AdministrativeGenderEnum.MALE);
	//logger.error( msg[&apos;singleCharGender&apos;].toString() );
	logger.info( msg[&apos;singleCharGender&apos;].toString() );  //rhw
} else {
	patient.setGender(AdministrativeGenderEnum.FEMALE);
	logger.info( msg[&apos;singleCharGender&apos;].toString() );  //rhw
}


// rhw  
var contactPoint = new Packages.ca.uhn.fhir.model.dstu2.composite.ContactPointDt();
contactPoint.setUse(ContactPointUseEnum.HOME);
contactPoint.setValue( msg[&apos;HomePhoneNoDelimiters&apos;] );
patient.addTelecom(contactPoint );


// rhw  
var outcome = client.create()
	.resource(patient)
	.execute();

// rhw  
patient = client.read(Patient, outcome.getId().getIdPart() );

logger.error(&quot;New Patient: ID= &quot; + outcome.getId().getIdPart() );

channelMap.put( &quot;PatientResourceID&quot;, outcome.getId().getIdPart() );


// End...</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Begin...

// rhw  Message Content
channelMap.put(&apos;safeId&apos;,msg[&apos;safeId&apos;]);  //rhw
channelMap.put(&apos;emrId&apos;,msg[&apos;emrId&apos;]);  //rhw
channelMap.put(&apos;firstName&apos;,msg[&apos;firstName&apos;]);  //rhw
channelMap.put(&apos;middleName&apos;,msg[&apos;middleName&apos;]);  //rhw
channelMap.put(&apos;lastName&apos;,msg[&apos;lastName&apos;]);  //rhw
channelMap.put(&apos;lineAddress&apos;,msg[&apos;lineAddress&apos;]);  //rhw
channelMap.put(&apos;cityAddress&apos;,msg[&apos;cityAddress&apos;]);  //rhw
channelMap.put(&apos;stateAddress&apos;,msg[&apos;stateAddress&apos;]);  //rhw
channelMap.put(&apos;zipAddress&apos;,msg[&apos;zipAddress&apos;]);  //rhw
channelMap.put(&apos;singleCharGender&apos;,msg[&apos;singleCharGender&apos;]);  //rhw
channelMap.put(&apos;YYYYMMDDBirthdate&apos;,msg[&apos;YYYYMMDDBirthdate&apos;]);  //rhw
channelMap.put(&apos;HomePhoneNoDelimiters&apos;,msg[&apos;HomePhoneNoDelimiters&apos;]);  //rhw


// rhw  FHIR Package Import
importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.model.dstu2.valueset);
importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);


// rhw  Variable Declarations
var HL7DateFormat = new java.text.SimpleDateFormat(&quot;YYYYMMdd&quot;);
var Url = configurationMap.get(&apos;sparkRawURL&apos;);
 logger.info(&apos;Url:  &apos; + Url);  //rhw
var ctx = new FhirContext(FhirVersionEnum.DSTU2);
var client = ctx.newRestfulGenericClient( Url );


// rhw  
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );
 logger.info(&apos;ctx:  &apos; + $(&apos;ctx&apos;));  //rhw


// Need to replace conditional insert with query + create strategy


// rhw  
var patient = new Patient();
 logger.info(&apos;patient:  &apos; + patient);  //rhw


// rhw  
patient.addIdentifier().setUse(IdentifierUseEnum.SECONDARY).setValue( msg[&apos;emrId&apos;] );	
patient.addIdentifier().setUse(IdentifierUseEnum.OFFICIAL).setValue( msg[&apos;safeId&apos;] );		


// rhw  
patient.addName().addFamily( msg[&apos;lastName&apos;] ).addGiven( msg[&apos;firstName&apos;] ).addGiven( msg[&apos;middleName&apos;] );
patient.addAddress().addLine( msg[&apos;lineAddress&apos;] ).setCity( msg[&apos;cityAddress&apos;] ).setState( msg[&apos;stateAddress&apos;] ).setPostalCode( msg[&apos;zipAddress&apos;] );
patient.setBirthDateWithDayPrecision( HL7DateFormat.parse( msg[&apos;YYYYMMDDBirthdate&apos;] ) );

// rhw  
if( msg[&apos;singleCharGender&apos;].toString() == &quot;M&quot; )
{
	patient.setGender(AdministrativeGenderEnum.MALE);
	//logger.error( msg[&apos;singleCharGender&apos;].toString() );
	logger.info( msg[&apos;singleCharGender&apos;].toString() );  //rhw
} else {
	patient.setGender(AdministrativeGenderEnum.FEMALE);
	logger.info( msg[&apos;singleCharGender&apos;].toString() );  //rhw
}


// rhw  
var contactPoint = new Packages.ca.uhn.fhir.model.dstu2.composite.ContactPointDt();
contactPoint.setUse(ContactPointUseEnum.HOME);
contactPoint.setValue( msg[&apos;HomePhoneNoDelimiters&apos;] );
patient.addTelecom(contactPoint );


// rhw  
var outcome = client.create()
	.resource(patient)
	.execute();

// rhw  
patient = client.read(Patient, outcome.getId().getIdPart() );

logger.error(&quot;New Patient: ID= &quot; + outcome.getId().getIdPart() );

channelMap.put( &quot;PatientResourceID&quot;, outcome.getId().getIdPart() );


// End...</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">ewoJInNhZmVJZCI6IjExMTExMTExIiwKCSJlbXJJZCI6IjIyMjIyMjIyIiwKCSJmaXJzdE5hbWUi
OiJKaWxsIiwKCSJtaWRkbGVOYW1lIjoiTSIsCgkibGFzdE5hbWUiOiJTbWl0aCIsCgkibGluZUFk
ZHJlc3MiOiIxMTExIE1pbGwgU3QiLAoJImNpdHlBZGRyZXNzIjoiUm9zd2VsbCIsCgkic3RhdGVB
ZGRyZXNzIjoiR0EiLAoJInppcEFkZHJlc3MiOiIzMDA3NiIsCgkic2luZ2xlQ2hhckdlbmRlciI6
IkYiLAoJIllZWVlNTUREQmlydGhkYXRlIjoiMTk1OTA2MDEiLAoJIkhvbWVQaG9uZU5vRGVsaW1p
dGVycyI6IjQwNDM4ODMzMzMiCn0=</inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Return</name>
          <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                  <string>hapi-fhir</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <script>return $(&apos;PatientResourceID&apos;);</script>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>New Step</name>
                <script>tmp[&apos;row&apos;][&apos;column1&apos;] = $(&apos;PatientResourceID&apos;);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>tmp[&apos;row&apos;][&apos;column1&apos;] = $(&apos;PatientResourceID&apos;);</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64">eHh4eHg=</outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>DELIMITED</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
                <numberedRows>false</numberedRows>
                <ignoreCR>true</ignoreCR>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
                <splitType>Record</splitType>
                <batchSkipRecords>0</batchSkipRecords>
                <batchMessageDelimiter></batchMessageDelimiter>
                <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
                <batchGroupingColumn></batchGroupingColumn>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>JavaScript Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
            <string>hapi-fhir</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>4843495c-2d03-45d1-aaa2-9d8c0156b88d</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>InsertPatientV3</name>
      <description></description>
      <enabled>true</enabled>
      <lastModified>
        <time>1497290147132</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>1</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>8012</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>d1</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                <string>hapi-fhir</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>false</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>text/plain</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode></responseStatusCode>
          <responseHeaders class="linked-hash-map"/>
          <charset>UTF-8</charset>
          <contextPath>InsertPatient</contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Insert Patient</name>
              <script>importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.org.hl7.fhir.dstu3.model);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var HL7DateFormat = new java.text.SimpleDateFormat(&quot;YYYYMMdd&quot;);
	
var Url = configurationMap.get(&apos;sparkRawURL&apos;);

var ctx = new FhirContext(FhirVersionEnum.DSTU2);
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

// Need to replace conditional insert with query + create strategy

var patient = new Patient();

patient.addIdentifier().setUse(IdentifierUseEnum.SECONDARY).setValue( msg[&apos;emrId&apos;] );	
patient.addIdentifier().setUse(IdentifierUseEnum.OFFICIAL).setValue( msg[&apos;safeId&apos;] );		
		
patient.addName().addFamily( msg[&apos;lastName&apos;] ).addGiven( msg[&apos;firstName&apos;] ).addGiven( msg[&apos;middleName&apos;] );
patient.addAddress().addLine( msg[&apos;lineAddress&apos;] ).setCity( msg[&apos;cityAddress&apos;] ).setState( msg[&apos;stateAddress&apos;] ).setPostalCode( msg[&apos;zipAddress&apos;] );
patient.setBirthDateWithDayPrecision( HL7DateFormat.parse( msg[&apos;YYYYMMDDBirthdate&apos;] ) );


if( msg[&apos;singleCharGender&apos;].toString() == &quot;M&quot; )
{
	patient.setGender(AdministrativeGenderEnum.MALE);
	logger.error( msg[&apos;singleCharGender&apos;].toString() );
}
else
{
	patient.setGender(AdministrativeGenderEnum.FEMALE);
}

var contactPoint = new Packages.ca.uhn.fhir.model.dstu3.composite.ContactPointDt();
contactPoint.setUse(ContactPointUseEnum.HOME);
contactPoint.setValue( msg[&apos;HomePhoneNoDelimiters&apos;] );
patient.addTelecom(contactPoint );

var outcome = client.create()
	.resource(patient)
	.execute();
		
patient = client.read(Patient, outcome.getId().getIdPart() );
		
logger.error(&quot;New Patient: ID= &quot; + outcome.getId().getIdPart() );
		
channelMap.put( &quot;PatientResourceID&quot;, outcome.getId().getIdPart() );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.org.hl7.fhir.dstu3.model);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var HL7DateFormat = new java.text.SimpleDateFormat(&quot;YYYYMMdd&quot;);
	
var Url = configurationMap.get(&apos;sparkRawURL&apos;);

var ctx = new FhirContext(FhirVersionEnum.DSTU2);
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

// Need to replace conditional insert with query + create strategy

var patient = new Patient();

patient.addIdentifier().setUse(IdentifierUseEnum.SECONDARY).setValue( msg[&apos;emrId&apos;] );	
patient.addIdentifier().setUse(IdentifierUseEnum.OFFICIAL).setValue( msg[&apos;safeId&apos;] );		
		
patient.addName().addFamily( msg[&apos;lastName&apos;] ).addGiven( msg[&apos;firstName&apos;] ).addGiven( msg[&apos;middleName&apos;] );
patient.addAddress().addLine( msg[&apos;lineAddress&apos;] ).setCity( msg[&apos;cityAddress&apos;] ).setState( msg[&apos;stateAddress&apos;] ).setPostalCode( msg[&apos;zipAddress&apos;] );
patient.setBirthDateWithDayPrecision( HL7DateFormat.parse( msg[&apos;YYYYMMDDBirthdate&apos;] ) );


if( msg[&apos;singleCharGender&apos;].toString() == &quot;M&quot; )
{
	patient.setGender(AdministrativeGenderEnum.MALE);
	logger.error( msg[&apos;singleCharGender&apos;].toString() );
}
else
{
	patient.setGender(AdministrativeGenderEnum.FEMALE);
}

var contactPoint = new Packages.ca.uhn.fhir.model.dstu3.composite.ContactPointDt();
contactPoint.setUse(ContactPointUseEnum.HOME);
contactPoint.setValue( msg[&apos;HomePhoneNoDelimiters&apos;] );
patient.addTelecom(contactPoint );

var outcome = client.create()
	.resource(patient)
	.execute();
		
patient = client.read(Patient, outcome.getId().getIdPart() );
		
logger.error(&quot;New Patient: ID= &quot; + outcome.getId().getIdPart() );
		
channelMap.put( &quot;PatientResourceID&quot;, outcome.getId().getIdPart() );</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">ewoJInNhZmVJZCI6IjExMTExMTExIiwKCSJlbXJJZCI6IjIyMjIyMjIyIiwKCSJmaXJzdE5hbWUi
OiJKaWxsIiwKCSJtaWRkbGVOYW1lIjoiTSIsCgkibGFzdE5hbWUiOiJTbWl0aCIsCgkibGluZUFk
ZHJlc3MiOiIxMTExIE1pbGwgU3QiLAoJImNpdHlBZGRyZXNzIjoiUm9zd2VsbCIsCgkic3RhdGVB
ZGRyZXNzIjoiR0EiLAoJInppcEFkZHJlc3MiOiIzMDA3NiIsCgkic2luZ2xlQ2hhckdlbmRlciI6
IkYiLAoJIllZWVlNTUREQmlydGhkYXRlIjoiMTk1OTA2MDEiLAoJIkhvbWVQaG9uZU5vRGVsaW1p
dGVycyI6IjQwNDM4ODMzMzMiCn0=</inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Return</name>
          <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                  <string>hapi-fhir</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <script>return $(&apos;PatientResourceID&apos;);</script>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>New Step</name>
                <script>tmp[&apos;row&apos;][&apos;column1&apos;] = $(&apos;PatientResourceID&apos;);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>tmp[&apos;row&apos;][&apos;column1&apos;] = $(&apos;PatientResourceID&apos;);</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64">eHh4eHg=</outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>DELIMITED</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
                <numberedRows>false</numberedRows>
                <ignoreCR>true</ignoreCR>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
                <splitType>Record</splitType>
                <batchSkipRecords>0</batchSkipRecords>
                <batchMessageDelimiter></batchMessageDelimiter>
                <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
                <batchGroupingColumn></batchGroupingColumn>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>JavaScript Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
            <string>hapi-fhir</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>21a56174-3525-4cfe-bb7d-f6e5eb4bd236</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>InsertPractitioner</name>
      <description></description>
      <enabled>false</enabled>
      <lastModified>
        <time>1493601603365</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>6</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>8013</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>d1</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
              <entry>
                <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                <string>hapi-fhir</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>false</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>text/plain</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode></responseStatusCode>
          <responseHeaders class="linked-hash-map"/>
          <charset>UTF-8</charset>
          <contextPath>InsertPractitioner</contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Insert Practitioner</name>
              <script>importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.model.dstu2.valueset);
importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);
	
var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

var practitioner = new Practitioner();

var theNPI = new ResourceReferenceDt();
theNPI.setDisplay(&quot;NPI&quot;);
		
practitioner.addIdentifier().setAssigner( theNPI ).setValue( msg[&apos;npi&apos;] );		
		
var theName = new HumanNameDt();
theName.addFamily( msg[&apos;lastName&apos;] ).addGiven( msg[&apos;firstName&apos;] ).addGiven( msg[&apos;middleName&apos;] );
		
practitioner.setName( theName );

var outcome = client.create()
	.resource(practitioner)
	.conditional()
	.where(Practitioner.IDENTIFIER.exactly().identifier( msg[&apos;npi&apos;] ))
	.execute();
		
practitioner = client.read(Practitioner, outcome.getId().getIdPart() );

logger.error(&quot;New Practitioner: ID= &quot; + outcome.getId().getIdPart() );
		
channelMap.put( &quot;ResourceID&quot;, outcome.getId().getIdPart() );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.model.dstu2.valueset);
importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);
	
var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

var practitioner = new Practitioner();

var theNPI = new ResourceReferenceDt();
theNPI.setDisplay(&quot;NPI&quot;);
		
practitioner.addIdentifier().setAssigner( theNPI ).setValue( msg[&apos;npi&apos;] );		
		
var theName = new HumanNameDt();
theName.addFamily( msg[&apos;lastName&apos;] ).addGiven( msg[&apos;firstName&apos;] ).addGiven( msg[&apos;middleName&apos;] );
		
practitioner.setName( theName );

var outcome = client.create()
	.resource(practitioner)
	.conditional()
	.where(Practitioner.IDENTIFIER.exactly().identifier( msg[&apos;npi&apos;] ))
	.execute();
		
practitioner = client.read(Practitioner, outcome.getId().getIdPart() );

logger.error(&quot;New Practitioner: ID= &quot; + outcome.getId().getIdPart() );
		
channelMap.put( &quot;ResourceID&quot;, outcome.getId().getIdPart() );</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">ewoJIm5waSI6IjIyMjIyMjIyMjIiLAoJImZpcnN0TmFtZSI6IkphY2siLAoJIm1pZGRsZU5hbWUi
OiJNIiwKCSJsYXN0TmFtZSI6IlNtaXRoIgp9</inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Return</name>
          <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
                <entry>
                  <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
                  <string>hapi-fhir</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <script>return $(&apos;ResourceID&apos;);</script>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>New Step</name>
                <script>tmp[&apos;row&apos;][&apos;column1&apos;] = $(&apos;PatientResourceID&apos;);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>tmp[&apos;row&apos;][&apos;column1&apos;] = $(&apos;PatientResourceID&apos;);</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64">eHh4eHg=</outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>DELIMITED</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
                <numberedRows>false</numberedRows>
                <ignoreCR>true</ignoreCR>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
                <splitType>Record</splitType>
                <batchSkipRecords>0</batchSkipRecords>
                <batchMessageDelimiter></batchMessageDelimiter>
                <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
                <batchGroupingColumn></batchGroupingColumn>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>JavaScript Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set">
          <string>RKW</string>
        </tags>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
          <entry>
            <string>29f52768-5925-40e8-b62d-a265b40e6ab4</string>
            <string>hapi-fhir</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>10bbdc06-7736-4608-b057-4ba3e427bd5d</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>Interp Engine Listener</name>
      <description>Listener for the Interpretation engine  &#xd;
&#xd;
Source is HTTP listener  &#xd;
It will then call the FHIR server or other servers(?) as needed to get result data  &#xd;
It will then interpret the data (yes/no/needs interp) and for the yes/no condition send it back, for needs interp send to a physician work queue.&#xd;
</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1499977760169</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>12</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>9000</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>d1</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>false</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>application/xml</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode>200</responseStatusCode>
          <responseHeaders class="linked-hash-map"/>
          <charset>UTF-8</charset>
          <contextPath>Interp</contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps/>
          <inboundDataType>XML</inboundDataType>
          <outboundDataType>XML</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>true</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>true</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Destination 1</name>
          <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <script>connectorMessage.getEncodedData()</script>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>JavaScript Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>fe611e68-b10f-49b0-bbf9-3f64882fa904</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>JSONGetOrderDocuments</name>
      <description>Requests order documents and/or AOE questions for the accompanying order, as follows:&#xd;
• ABN - Determines whether or not an ABN is required.&#xd;
• AOE - Determines whether or not AOE questions are required for the submitted order codes. &#xd;
• REQ - Creates a requisition for the accompanying order, returns the requisition in a PDF file, and forwards the order to the lab for processing (unless submitted in combination with an AOE request that requires AOE questions to be answered).</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1494271741309</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>12</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Set HL7v2.5 MSH segment</name>
              <script>// SENDING_APPLICATION designates the application that is sending the order message to Hub
//msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = &quot;SAFE&quot;;

// SENDING_FACILITY designates the account number provided to you by Quest for the businessunit you are ordering tests with
//msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = $(&quot;account&quot;);

// RECEIVING_FACILITY designates the business unit within Quest from which the labs are being ordered
//msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;STL&quot;;


// Time Zone is not used. If required, the pattern is &quot;yyyyMMddHHmmss.SSSZ&quot;
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = currentDate + UUIDGenerator.getUUID().toString().substring(0,6);
msg[&apos;MSH&apos;][&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = $(&quot;processingID&quot;);

//msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmm&quot;);

channelMap.put( &quot;rawHL7&quot;, SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg));</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// SENDING_APPLICATION designates the application that is sending the order message to Hub
//msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = &quot;SAFE&quot;;

// SENDING_FACILITY designates the account number provided to you by Quest for the businessunit you are ordering tests with
//msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = $(&quot;account&quot;);

// RECEIVING_FACILITY designates the business unit within Quest from which the labs are being ordered
//msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;STL&quot;;


// Time Zone is not used. If required, the pattern is &quot;yyyyMMddHHmmss.SSSZ&quot;
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = currentDate + UUIDGenerator.getUUID().toString().substring(0,6);
msg[&apos;MSH&apos;][&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = $(&quot;processingID&quot;);

//msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmm&quot;);

channelMap.put( &quot;rawHL7&quot;, SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg));</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>HL7V2</inboundDataType>
          <outboundDataType>HL7V2</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Submit Order REST</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>SOAP query</name>
                <script>var bytes = new java.lang.String($(&apos;rawHL7&apos;)).getBytes();
channelMap.put(&quot;orderHL7&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var bytes = new java.lang.String($(&apos;rawHL7&apos;)).getBytes();
channelMap.put(&quot;orderHL7&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>POST request</name>
                <script>var theJSON = {
&quot;documentTypes&quot;: [
&quot;REQ&quot;
],
&quot;orderHl7&quot;: $(&apos;orderHL7&apos;)
};</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var theJSON = {
&quot;documentTypes&quot;: [
&quot;REQ&quot;
],
&quot;orderHl7&quot;: $(&apos;orderHL7&apos;)
};</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64">ewoiZG9jdW1lbnRUeXBlcyI6IFsKIlJFUSIKXSwKIm9yZGVySGw3IjogIiIKfTs=</outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

// Prepare SSL Client to access submitOrder Conformance Environment
if (globalMap.containsKey(&quot;sslClient&quot;) &amp;&amp; globalMap.get(&quot;sslClient&quot;)) 
	try {

		var sslClient = new Packages.org.safemovement.DEXSSLClient();		
		sslClient.setAuthorizationType(org.safemovement.DEXSSLClient.Authorization.BASIC);
		sslClient.setContentType(&quot;text/xml;charset=UTF-8&quot;);
		sslClient.setUserName($(&quot;username&quot;));
		sslClient.setUserPassword($(&quot;userpsw&quot;));		
		sslClient.setConnectionType(&quot;Close&quot;);
		
		globalChannelMap.put(&quot;sslClientClass&quot;, sslClient);
		
	} catch(ex) {
		logger.error(&quot;submitOrder Deploy: &quot; + ex.toString());		
	}



return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data

if (globalChannelMap.containsKey(&quot;sslClientClass&quot;)){
	globalChannelMap.remove(&quot;sslClientClass&quot;);
}


return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>9eeed45d-4613-4501-86f1-236e91808742</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>LRI GetResults</name>
      <description>The LRI getResults channel allows you to retrieve HL7 result messages from the Data Exchange LRI REST Server.

Last updated: March 28, 2017</description>
      <enabled>true</enabled>
      <lastModified>
        <time>1497221651121</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>12</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.js.JavaScriptReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <pollConnectorProperties version="3.4.2">
            <pollingType>INTERVAL</pollingType>
            <pollOnStart>true</pollOnStart>
            <pollingFrequency>18000000</pollingFrequency>
            <pollingHour>0</pollingHour>
            <pollingMinute>0</pollingMinute>
            <cronJobs/>
            <pollConnectorPropertiesAdvanced>
              <weekly>true</weekly>
              <inactiveDays>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
                <boolean>false</boolean>
              </inactiveDays>
              <dayOfMonth>1</dayOfMonth>
              <allDay>true</allDay>
              <startingHour>8</startingHour>
              <startingMinute>0</startingMinute>
              <endingHour>17</endingHour>
              <endingMinute>0</endingMinute>
            </pollConnectorPropertiesAdvanced>
          </pollConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <script>return true;</script>
        </properties>
        <transformer version="3.4.2">
          <steps/>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>XML</inboundDataType>
          <outboundDataType>XML</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>false</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>false</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>JavaScript Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Submit Order REST</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>SOAP query</name>
                <script>// Set initial getResults SOAP query
// This stays the same for all requests

var getResultsSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:res=&quot;http://medplus.com/results&quot;&gt;
   &lt;soapenv:Header/&gt;
   &lt;soapenv:Body&gt;
      &lt;res:getResults&gt;
         &lt;res:RetrieveResultsRequest&gt;
            &lt;requestParameters&gt;
               &lt;parameterName&gt;maxMessages&lt;/parameterName&gt;
               &lt;parameterValue&gt;900&lt;/parameterValue&gt;
            &lt;/requestParameters&gt;
            &lt;resultServiceType&gt;HL7&lt;/resultServiceType&gt;
         &lt;/res:RetrieveResultsRequest&gt;
      &lt;/res:getResults&gt;
   &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;;

getResultsSoap.*::Body.*::getResults.*::RetrieveResultsRequest.requestParameters.parameterValue = $cfg(&quot;maxLRIMessages&quot;);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Set initial getResults SOAP query
// This stays the same for all requests

var getResultsSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:res=&quot;http://medplus.com/results&quot;&gt;
   &lt;soapenv:Header/&gt;
   &lt;soapenv:Body&gt;
      &lt;res:getResults&gt;
         &lt;res:RetrieveResultsRequest&gt;
            &lt;requestParameters&gt;
               &lt;parameterName&gt;maxMessages&lt;/parameterName&gt;
               &lt;parameterValue&gt;900&lt;/parameterValue&gt;
            &lt;/requestParameters&gt;
            &lt;resultServiceType&gt;HL7&lt;/resultServiceType&gt;
         &lt;/res:RetrieveResultsRequest&gt;
      &lt;/res:getResults&gt;
   &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;;

getResultsSoap.*::Body.*::getResults.*::RetrieveResultsRequest.requestParameters.parameterValue = $cfg(&quot;maxLRIMessages&quot;);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Process LRI requests</name>
                <script>try {

	var ackORU = [];
	var isMore = false;
	var controlIdList = [];	
	var requestId;
	
	// Placeholder for doPost() response SOAP, namespaces are preserved
	var soapResp;	
	
	do {

		var httpCode = doPost(getResultsSoap, $cfg(&quot;getLRIResultsURL&quot;));
		
		if (httpCode == 200) {		

			// Mar 28 2017: To add to Custom Metadata
			channelMap.put(&quot;GetResultsResponse&quot;, soapResp.toString());

			// The HTML error response with &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Draft//EN&quot;&gt; is possible.
			// This causes E4X serialization problem
			if (soapResp.indexOf(&quot;!DOCTYPE&quot;) &gt; -1) {			
				var error = soapResp.substring(stringResponse.indexOf(&quot;&lt;TITLE&gt;&quot;), stringResponse.indexOf(&quot;&lt;/TITLE&gt;&quot;) + 8);
				throw (&quot;LRI GetResults: Destination - HTTP ERROR: &quot; + error);
				
			} else {

				soapResp = new XML(soapResp.toString());				
				if (soapResp.*::Body.*::getResultsResponse.*::Results) {
					// Extracts isMore indicator (whether or not more results are available from the DEX to be returned)
					isMore = (soapResp.*::Body.*::getResultsResponse.*::Results.isMore.toString().toLowerCase() == &quot;true&quot;);
					// Extracts the request ID to identify the results to be acknowledged
					requestId = soapResp.*::Body.*::getResultsResponse.*::Results.requestId.toString() || &quot;&quot;;
				}
			}

			// Mar 27 2017 - Quest getResultsResponse always has isMore = &quot;true&quot;, which cause an infinite loop, Issue #18
			// FIX: maxMessages set to 900, isMore set to false
			isMore = false;						

			processResults(soapResp);
	
		} else if (httpCode &gt;= 300 &amp;&amp; httpCode &lt; 400) {
			// 3xx Redirection
			throw (&quot;LRI GetResults: Destination - HTTP &quot; + getHttpCodeDescription(httpCode));			
			
		} else if (httpCode &gt;= 400 &amp;&amp; httpCode &lt; 500) {
			// 4xx Client Error
			// TODO: Attempt to resend the same message and then throw the exception
			throw (&quot;LRI GetResults: Destination - HTTP &quot; + getHttpCodeDescription(httpCode));
					
		} else if (httpCode &gt;= 500) {
			// 5xx Server Error
			throw (&quot;LRI GetResults: Destination - HTTP &quot; + getHttpCodeDescription(httpCode));			
		}

	} while (isMore);
	
	// Check if ackORU Array is not empty
	if (ackORU.length &gt; 0) {
	
		var httpCode = doPost(getAckSoap(), $cfg(&quot;getLRIResultsURL&quot;));
		
		if (httpCode == 200) {
			// Ignore DEX ACK on ACK response
			// TODO: May need to handle those as well to verify isMore parameter

			// Mar 28 2017: To add to Custom Metadata
			channelMap.put(&quot;AcknowledgeResultsResponse&quot;, soapResp.toString());
			
		} else {
			throw (&quot;LRI GetResults: Destination (ACK) - HTTP &quot; + getHttpCodeDescription(httpCode));
		}
	}	

} catch(ex) {
	// TODO: Better logging if failed
	if (soapResp) {
		logger.error(ex + &quot;  getResultsResponse: &quot; + soapResp);
		throw (ex + &quot;  getResultsResponse: &quot; + soapResp);
	} else {
		logger.error(ex);
		throw (ex);		
	}

} finally {
	controlIdList.length = 0;
	ackORU.length = 0;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>try {

	var ackORU = [];
	var isMore = false;
	var controlIdList = [];	
	var requestId;
	
	// Placeholder for doPost() response SOAP, namespaces are preserved
	var soapResp;	
	
	do {

		var httpCode = doPost(getResultsSoap, $cfg(&quot;getLRIResultsURL&quot;));
		
		if (httpCode == 200) {		

			// Mar 28 2017: To add to Custom Metadata
			channelMap.put(&quot;GetResultsResponse&quot;, soapResp.toString());

			// The HTML error response with &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Draft//EN&quot;&gt; is possible.
			// This causes E4X serialization problem
			if (soapResp.indexOf(&quot;!DOCTYPE&quot;) &gt; -1) {			
				var error = soapResp.substring(stringResponse.indexOf(&quot;&lt;TITLE&gt;&quot;), stringResponse.indexOf(&quot;&lt;/TITLE&gt;&quot;) + 8);
				throw (&quot;LRI GetResults: Destination - HTTP ERROR: &quot; + error);
				
			} else {

				soapResp = new XML(soapResp.toString());				
				if (soapResp.*::Body.*::getResultsResponse.*::Results) {
					// Extracts isMore indicator (whether or not more results are available from the DEX to be returned)
					isMore = (soapResp.*::Body.*::getResultsResponse.*::Results.isMore.toString().toLowerCase() == &quot;true&quot;);
					// Extracts the request ID to identify the results to be acknowledged
					requestId = soapResp.*::Body.*::getResultsResponse.*::Results.requestId.toString() || &quot;&quot;;
				}
			}

			// Mar 27 2017 - Quest getResultsResponse always has isMore = &quot;true&quot;, which cause an infinite loop, Issue #18
			// FIX: maxMessages set to 900, isMore set to false
			isMore = false;						

			processResults(soapResp);
	
		} else if (httpCode &gt;= 300 &amp;&amp; httpCode &lt; 400) {
			// 3xx Redirection
			throw (&quot;LRI GetResults: Destination - HTTP &quot; + getHttpCodeDescription(httpCode));			
			
		} else if (httpCode &gt;= 400 &amp;&amp; httpCode &lt; 500) {
			// 4xx Client Error
			// TODO: Attempt to resend the same message and then throw the exception
			throw (&quot;LRI GetResults: Destination - HTTP &quot; + getHttpCodeDescription(httpCode));
					
		} else if (httpCode &gt;= 500) {
			// 5xx Server Error
			throw (&quot;LRI GetResults: Destination - HTTP &quot; + getHttpCodeDescription(httpCode));			
		}

	} while (isMore);
	
	// Check if ackORU Array is not empty
	if (ackORU.length &gt; 0) {
	
		var httpCode = doPost(getAckSoap(), $cfg(&quot;getLRIResultsURL&quot;));
		
		if (httpCode == 200) {
			// Ignore DEX ACK on ACK response
			// TODO: May need to handle those as well to verify isMore parameter

			// Mar 28 2017: To add to Custom Metadata
			channelMap.put(&quot;AcknowledgeResultsResponse&quot;, soapResp.toString());
			
		} else {
			throw (&quot;LRI GetResults: Destination (ACK) - HTTP &quot; + getHttpCodeDescription(httpCode));
		}
	}	

} catch(ex) {
	// TODO: Better logging if failed
	if (soapResp) {
		logger.error(ex + &quot;  getResultsResponse: &quot; + soapResp);
		throw (ex + &quot;  getResultsResponse: &quot; + soapResp);
	} else {
		logger.error(ex);
		throw (ex);		
	}

} finally {
	controlIdList.length = 0;
	ackORU.length = 0;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>Functions pool</name>
                <script>/**
* Submits the HTTP POST request method 
* @param msgSoap - SOAP message to be submitted in the HTTP body
* @param url - the URL HTTP POST to be submitted to
*/
function doPost(msgSoap, url) {
	
	var httpClient = globalChannelMap.get(&quot;httpClientClass&quot;);
	
	if (httpClient == null) return 0;
	
	if (httpClient) {
		
		httpClient.setURL(url);
		httpClient.setSOAPRequest(msgSoap);
		httpCode = httpClient.doPost();

		// Preserve namespaces
		soapResp = httpClient.getSOAPResponse(true);

		return httpCode;
		
	} else {
		return 0;
	}
	
}





/**
* Extracts, decodes and routes ORU_R01 messages
* @param soapResp - getResultsResponse SOAP message from DEX
*/
function processResults(soapResp) {
	
	if (soapResp.*::Body.*::getResultsResponse.*::Results.toString().length &gt; 0) {
		for each (seg in soapResp.*::Body.*::getResultsResponse.*::Results.children()) {			
			if (seg.name().toString() == &quot;results&quot;) {
				
				// Route the HL7v2 message to ORU_R01 processing channel
				var hl7v251ORU = new java.lang.String(FileUtil.decode(seg.HL7Message[&apos;message&apos;].toString()));

				router.routeMessage(&quot;ORU Processing&quot;, hl7v251ORU );
				
				// Extract MSH.10 [Message Control ID] of the actual ORU_R01 message
				var xmlORU = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(hl7v251ORU));				
				var msgCtrlID = xmlORU[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString();
				controlIdList.push(msgCtrlID);

				// Create HL7v2 ACK message to acknowledge this ORU_R01
				var hl7v2Ack = &quot;MSH|^~\&amp;||||STL|||ACK|||2.5.1|||AL|NE|||||LRI_NG_RN_Profile^^2.16.840.1.113883.9.20^ISO&quot; + &apos;\n&apos; +
				&quot;MSA|CA|&quot;;
				var xmlAck = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(hl7v2Ack));
				
				xmlAck[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = $cfg(&quot;application&quot;);
				xmlAck[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = $cfg(&quot;account&quot;);
				xmlAck[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;STL&quot;;
								
				// Time Zone is not used (otherwise use &quot;yyyyMMddHHmmssZ&quot;)
				var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
				xmlAck[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;); // or &quot;yyyyMMddHHmmssZ&quot;
				xmlAck[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = currentDate + UUIDGenerator.getUUID().toString().substring(0,6);
				xmlAck[&apos;MSH&apos;][&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = $(&quot;processingID&quot;);

				// The message control ID returned in MSH.10 (Message Control ID) from the result message.
				xmlAck[&apos;MSA&apos;][&apos;MSA.2&apos;][&apos;MSA.2.1&apos;] = msgCtrlID;

				// Save ACK response for acknoledgement
				ackORU.push(SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(xmlAck));					
				
			}
		}
	} 	
}


/**
* Constructs ACK SOAP message using global variables
*/
function getAckSoap() {
	
	var ackSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:res=&quot;http://medplus.com/results&quot;&gt;
	   &lt;soapenv:Header/&gt;
	   &lt;soapenv:Body&gt;
	      &lt;res:acknowledgeResults&gt;
	         &lt;res:RetrieveResultsAcknowledge/&gt;
	      &lt;/res:acknowledgeResults&gt;
	   &lt;/soapenv:Body&gt;
	&lt;/soapenv:Envelope&gt;;

	for (var i =0; i &lt; controlIdList.length; i++) {
		var ackMessage = &lt;ackMessages&gt;&lt;controlId&gt;&lt;/controlId&gt;&lt;message&gt;&lt;/message&gt;&lt;/ackMessages&gt;;
		ackMessage.controlId = controlIdList[i];

		// Encode HL7v2 ACK message
		var bytes = new java.lang.String(ackORU[i].toString()).getBytes();
		ackMessage[&apos;message&apos;] = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);
		
		ackSoap.*::Body.*::acknowledgeResults.*::RetrieveResultsAcknowledge.appendChild(ackMessage);
	}

	ackSoap.*::Body.*::acknowledgeResults.*::RetrieveResultsAcknowledge.requestId = requestId;
	ackSoap.*::Body.*::acknowledgeResults.*::RetrieveResultsAcknowledge.resultServiceType = &quot;hl7&quot;;

	// Mar 28 2017: To add to Custom Metadata
	channelMap.put(&quot;AcknowledgeResults&quot;, ackSoap.toString());

	return ackSoap;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
* Submits the HTTP POST request method 
* @param msgSoap - SOAP message to be submitted in the HTTP body
* @param url - the URL HTTP POST to be submitted to
*/
function doPost(msgSoap, url) {
	
	var httpClient = globalChannelMap.get(&quot;httpClientClass&quot;);
	
	if (httpClient == null) return 0;
	
	if (httpClient) {
		
		httpClient.setURL(url);
		httpClient.setSOAPRequest(msgSoap);
		httpCode = httpClient.doPost();

		// Preserve namespaces
		soapResp = httpClient.getSOAPResponse(true);

		return httpCode;
		
	} else {
		return 0;
	}
	
}





/**
* Extracts, decodes and routes ORU_R01 messages
* @param soapResp - getResultsResponse SOAP message from DEX
*/
function processResults(soapResp) {
	
	if (soapResp.*::Body.*::getResultsResponse.*::Results.toString().length &gt; 0) {
		for each (seg in soapResp.*::Body.*::getResultsResponse.*::Results.children()) {			
			if (seg.name().toString() == &quot;results&quot;) {
				
				// Route the HL7v2 message to ORU_R01 processing channel
				var hl7v251ORU = new java.lang.String(FileUtil.decode(seg.HL7Message[&apos;message&apos;].toString()));

				router.routeMessage(&quot;ORU Processing&quot;, hl7v251ORU );
				
				// Extract MSH.10 [Message Control ID] of the actual ORU_R01 message
				var xmlORU = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(hl7v251ORU));				
				var msgCtrlID = xmlORU[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString();
				controlIdList.push(msgCtrlID);

				// Create HL7v2 ACK message to acknowledge this ORU_R01
				var hl7v2Ack = &quot;MSH|^~\&amp;||||STL|||ACK|||2.5.1|||AL|NE|||||LRI_NG_RN_Profile^^2.16.840.1.113883.9.20^ISO&quot; + &apos;\n&apos; +
				&quot;MSA|CA|&quot;;
				var xmlAck = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(hl7v2Ack));
				
				xmlAck[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = $cfg(&quot;application&quot;);
				xmlAck[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = $cfg(&quot;account&quot;);
				xmlAck[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;STL&quot;;
								
				// Time Zone is not used (otherwise use &quot;yyyyMMddHHmmssZ&quot;)
				var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;);
				xmlAck[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;] = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;); // or &quot;yyyyMMddHHmmssZ&quot;
				xmlAck[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = currentDate + UUIDGenerator.getUUID().toString().substring(0,6);
				xmlAck[&apos;MSH&apos;][&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = $(&quot;processingID&quot;);

				// The message control ID returned in MSH.10 (Message Control ID) from the result message.
				xmlAck[&apos;MSA&apos;][&apos;MSA.2&apos;][&apos;MSA.2.1&apos;] = msgCtrlID;

				// Save ACK response for acknoledgement
				ackORU.push(SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(xmlAck));					
				
			}
		}
	} 	
}


/**
* Constructs ACK SOAP message using global variables
*/
function getAckSoap() {
	
	var ackSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:res=&quot;http://medplus.com/results&quot;&gt;
	   &lt;soapenv:Header/&gt;
	   &lt;soapenv:Body&gt;
	      &lt;res:acknowledgeResults&gt;
	         &lt;res:RetrieveResultsAcknowledge/&gt;
	      &lt;/res:acknowledgeResults&gt;
	   &lt;/soapenv:Body&gt;
	&lt;/soapenv:Envelope&gt;;

	for (var i =0; i &lt; controlIdList.length; i++) {
		var ackMessage = &lt;ackMessages&gt;&lt;controlId&gt;&lt;/controlId&gt;&lt;message&gt;&lt;/message&gt;&lt;/ackMessages&gt;;
		ackMessage.controlId = controlIdList[i];

		// Encode HL7v2 ACK message
		var bytes = new java.lang.String(ackORU[i].toString()).getBytes();
		ackMessage[&apos;message&apos;] = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);
		
		ackSoap.*::Body.*::acknowledgeResults.*::RetrieveResultsAcknowledge.appendChild(ackMessage);
	}

	ackSoap.*::Body.*::acknowledgeResults.*::RetrieveResultsAcknowledge.requestId = requestId;
	ackSoap.*::Body.*::acknowledgeResults.*::RetrieveResultsAcknowledge.resultServiceType = &quot;hl7&quot;;

	// Mar 28 2017: To add to Custom Metadata
	channelMap.put(&quot;AcknowledgeResults&quot;, ackSoap.toString());

	return ackSoap;
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

// Prepare SSL Client to access submitOrder Conformance Environment
if (globalMap.containsKey(&quot;httpClient&quot;) &amp;&amp; globalMap.get(&quot;httpClient&quot;)) 

	try {

		var httpClient = new Packages.org.safemovement.DEXHTTPClient();		
		httpClient.setAuthorizationType(org.safemovement.DEXHTTPClient.Authorization.BASIC);
		httpClient.setContentType(&quot;text/xml;charset=UTF-8&quot;);
		httpClient.setUserName($cfg(&quot;username&quot;));
		httpClient.setUserPassword($cfg(&quot;userpsw&quot;));		
		httpClient.setConnectionType(&quot;Close&quot;);
		
		globalChannelMap.put(&quot;httpClientClass&quot;, httpClient);
		
	} catch(ex) {
		
		logger.error(&quot;LRI GetResults: Deploy - &quot; + ex.toString());
		throw (&quot;LRI GetResults: Deploy - &quot; + ex.toString());
		// Stop this channel to resolve the problem
		ChannelUtil.stopChannel(channelId);		
	}

return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data

if (globalChannelMap.containsKey(&quot;httpClientClass&quot;)){
	globalChannelMap.remove(&quot;httpClientClass&quot;);
}


return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>RESULTS_RESPONSE</name>
            <type>STRING</type>
            <mappingName>GetResultsResponse</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>ACK_RESULTS</name>
            <type>STRING</type>
            <mappingName>AcknowledgeResults</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>ACK_RESULTS_RESP</name>
            <type>STRING</type>
            <mappingName>AcknowledgeResultsResponse</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
      <dependencyIds/>
    </channel>
    <channel version="3.4.2">
      <id>829fe0c9-9229-4cb3-9cc3-1250213f284f</id>
      <nextMetaDataId>4</nextMetaDataId>
      <name>OLD ORU Processing</name>
      <description>LRI ORU_R01 processing downstream channel.
The channel receives ORU_R01 messages routed from the LRI getResults channel.

(SN) This channel should use Strict Parser for incoming HL7v2 ORU messages.

Last updated: March 25, 2017</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1497219245488</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>94</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Route ORU to Destination</name>
              <script>// Different HL7v2.x.x versions will be processed differently
var version = msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;VID.1&apos;].toString();

channelMap.put(&quot;MessageControlID&quot;, msg[&apos;MSH&apos;][&apos;MSH.10&apos;].toString());
 
if (&quot;2.5.1&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.5.1&quot;,&quot;FHIR_submit&quot;]);
	
} else if (&quot;2.3.1&quot; == version || &quot;2.3&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.3.x&quot;,&quot;FHIR_submit&quot;]);
	
} else {
	logger.error(&quot;ORU Processing: unknown ORU_R01 message version (MSH.12) - &quot; + version);
	destinationSet.removeAllExcept([&quot;FHIR_submit&quot;]);
}

var bytes = new java.lang.String(SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg) ).getBytes();
channelMap.put( &quot;HL7Base64&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Different HL7v2.x.x versions will be processed differently
var version = msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;VID.1&apos;].toString();

channelMap.put(&quot;MessageControlID&quot;, msg[&apos;MSH&apos;][&apos;MSH.10&apos;].toString());
 
if (&quot;2.5.1&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.5.1&quot;,&quot;FHIR_submit&quot;]);
	
} else if (&quot;2.3.1&quot; == version || &quot;2.3&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.3.x&quot;,&quot;FHIR_submit&quot;]);
	
} else {
	logger.error(&quot;ORU Processing: unknown ORU_R01 message version (MSH.12) - &quot; + version);
	destinationSet.removeAllExcept([&quot;FHIR_submit&quot;]);
}

var bytes = new java.lang.String(SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg) ).getBytes();
channelMap.put( &quot;HL7Base64&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>HL7V2</inboundDataType>
          <outboundDataType>HL7V2</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules>
            <rule>
              <sequenceNumber>0</sequenceNumber>
              <name>Check for ORU messages</name>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Continue processing only if the incoming message is ORU_R01
if(&quot;ORU&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.1&apos;].toString() &amp;&amp; &quot;R01&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.2&apos;].toString()) {
	return true;
} else {
	logger.error(&quot;ORU Processing: non-ORU message is rejected &quot; + msg.toString());
	return false;
}</string>
                </entry>
              </data>
              <type>JavaScript</type>
              <script>// Continue processing only if the incoming message is ORU_R01
if(&quot;ORU&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.1&apos;].toString() &amp;&amp; &quot;R01&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.2&apos;].toString()) {
	return true;
} else {
	logger.error(&quot;ORU Processing: non-ORU message is rejected &quot; + msg.toString());
	return false;
}</script>
              <operator>NONE</operator>
            </rule>
          </rules>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>ORU_R01_2.5.1</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Patient resource</name>
                <script>// Mar 16: &lt;value value=&quot;&quot;/&gt; removed from identifier


var resPatient = &lt;Patient&gt;
			&lt;id value=&quot;PID-patient-identification&quot;/&gt;
			&lt;text&gt;
				&lt;status value=&quot;generated&quot;/&gt;
				&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
			&lt;/text&gt;			
			&lt;identifier&gt;
				&lt;use value=&quot;official&quot;/&gt;				
			&lt;/identifier&gt;
			&lt;name&gt;
				&lt;use value=&quot;official&quot;/&gt;
				&lt;family value=&quot;&quot;/&gt;
			&lt;/name&gt;
				&lt;telecom&gt;
					&lt;system value=&quot;phone&quot;/&gt;
					&lt;value value=&quot;&quot;/&gt;
					&lt;use value=&quot;home&quot;/&gt;
				&lt;/telecom&gt;
			&lt;gender value=&quot;&quot;/&gt;
			&lt;birthDate value=&quot;&quot;/&gt;
			&lt;address&gt;
				&lt;use value=&quot;home&quot;/&gt;
			&lt;/address&gt;
		&lt;/Patient&gt;;


// Process NTE segments
// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot;  
resPatient.text.*::div.* = new XMLList();
var 	patientComment = false;
for each (var nte in msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;].children()) {
	if (&quot;NTE&quot; == nte.name().toString()) {

		patientComment = true;
		
		// Source of Comment - Optional
		var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
		var source = nte[&apos;NTE.2&apos;].toString();
		
		// Comments that are contained in the segment - Required
		var comment = nte[&apos;NTE.3&apos;].toString();

		if (commentSources.indexOf(source) &gt; -1) {	
			resPatient.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
		} else {
			resPatient.text.*::div.* += new XML(&apos;&lt;p&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
		}
	}
}

if (!patientComment) delete resPatient.text;

// Patient Quest360 identifier list (repeatable)
// (SN)  Only first PID.3.1 [ID Number] is mapped in this version
var identifierTypeCode = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.5&apos;].toString();
if (identifierTypeCode) {
	resPatient.identifier.type.coding.code.@value = identifierTypeCode;
}

//======================= ~~ RKW IMPORTANT: This is where the patient SAFE ID is found
// Quest identifier - Required

var patientID = msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString();
//var patientID = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.1&apos;].toString();
resPatient.identifier.(use.@value == &quot;official&quot;).value.@value = patientID;


// ============================ RKW ~~ New Stuff

importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

logger.error( &quot;Query for Patient: &quot; + msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][0][&apos;CX.1&apos;].toString() );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][0][&apos;CX.1&apos;].toString() ))
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;

if( msSize )
{
	var patientResource = ms.get(0).getResource();
//	var patientString = ctx.newJsonParser().encodeResourceToString(patientResource);
	
	logger.error( &quot;Patient: \n&quot; + patientResource.getId().getIdPart() );
//	logger.error( &quot;Patient: \n&quot; + patientString );	
}
else
{
	throw &quot;ORU Processing: Patient Not Found&quot;;
}

//var PatientSource = JSON.parse( patientString );
channelMap.put(&quot;PatientResourceID&quot;, patientResource.getId().getIdPart() );


 //=========================================================== ~~ RKW Leave - this is part of old code
// Store Patient resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Patient&quot;, resPatient);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Mar 16: &lt;value value=&quot;&quot;/&gt; removed from identifier


var resPatient = &lt;Patient&gt;
			&lt;id value=&quot;PID-patient-identification&quot;/&gt;
			&lt;text&gt;
				&lt;status value=&quot;generated&quot;/&gt;
				&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
			&lt;/text&gt;			
			&lt;identifier&gt;
				&lt;use value=&quot;official&quot;/&gt;				
			&lt;/identifier&gt;
			&lt;name&gt;
				&lt;use value=&quot;official&quot;/&gt;
				&lt;family value=&quot;&quot;/&gt;
			&lt;/name&gt;
				&lt;telecom&gt;
					&lt;system value=&quot;phone&quot;/&gt;
					&lt;value value=&quot;&quot;/&gt;
					&lt;use value=&quot;home&quot;/&gt;
				&lt;/telecom&gt;
			&lt;gender value=&quot;&quot;/&gt;
			&lt;birthDate value=&quot;&quot;/&gt;
			&lt;address&gt;
				&lt;use value=&quot;home&quot;/&gt;
			&lt;/address&gt;
		&lt;/Patient&gt;;


// Process NTE segments
// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot;  
resPatient.text.*::div.* = new XMLList();
var 	patientComment = false;
for each (var nte in msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;].children()) {
	if (&quot;NTE&quot; == nte.name().toString()) {

		patientComment = true;
		
		// Source of Comment - Optional
		var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
		var source = nte[&apos;NTE.2&apos;].toString();
		
		// Comments that are contained in the segment - Required
		var comment = nte[&apos;NTE.3&apos;].toString();

		if (commentSources.indexOf(source) &gt; -1) {	
			resPatient.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
		} else {
			resPatient.text.*::div.* += new XML(&apos;&lt;p&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
		}
	}
}

if (!patientComment) delete resPatient.text;

// Patient Quest360 identifier list (repeatable)
// (SN)  Only first PID.3.1 [ID Number] is mapped in this version
var identifierTypeCode = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.5&apos;].toString();
if (identifierTypeCode) {
	resPatient.identifier.type.coding.code.@value = identifierTypeCode;
}

//======================= ~~ RKW IMPORTANT: This is where the patient SAFE ID is found
// Quest identifier - Required

var patientID = msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString();
//var patientID = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.1&apos;].toString();
resPatient.identifier.(use.@value == &quot;official&quot;).value.@value = patientID;


// ============================ RKW ~~ New Stuff

importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

logger.error( &quot;Query for Patient: &quot; + msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][0][&apos;CX.1&apos;].toString() );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][0][&apos;CX.1&apos;].toString() ))
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;

if( msSize )
{
	var patientResource = ms.get(0).getResource();
//	var patientString = ctx.newJsonParser().encodeResourceToString(patientResource);
	
	logger.error( &quot;Patient: \n&quot; + patientResource.getId().getIdPart() );
//	logger.error( &quot;Patient: \n&quot; + patientString );	
}
else
{
	throw &quot;ORU Processing: Patient Not Found&quot;;
}

//var PatientSource = JSON.parse( patientString );
channelMap.put(&quot;PatientResourceID&quot;, patientResource.getId().getIdPart() );


 //=========================================================== ~~ RKW Leave - this is part of old code
// Store Patient resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Patient&quot;, resPatient);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Save PDF Report</name>
                <script>for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	// Find attachment
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp;  obs[&apos;OBX.2&apos;].toString() == &quot;ED&quot; ) {
			
			var bytes = new java.lang.String(obs[&apos;OBX.5&apos;][&apos;ED.5&apos;].toString()).getBytes();
			channelMap.put( &quot;PDFBase64&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );			
		}	
	}
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	// Find attachment
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp;  obs[&apos;OBX.2&apos;].toString() == &quot;ED&quot; ) {
			
			var bytes = new java.lang.String(obs[&apos;OBX.5&apos;][&apos;ED.5&apos;].toString()).getBytes();
			channelMap.put( &quot;PDFBase64&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );			
		}	
	}
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>Create Map of DiagnosticOrder Resources to create lookup</name>
                <script>/*
importPackage(Packages.java.util);
importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var ctx = channelMap.get( &quot;ctx&quot; );
var client = ctx.newRestfulGenericClient( configurationMap.get(&apos;sparkRawURL&apos;) );

var orderSearchResults = client
	.search()
	.forResource(DiagnosticOrder)
	.where(DiagnosticOrder.IDENTIFIER.exactly().systemAndIdentifier($(&apos;sparkRawURL&apos;) + &quot;/&quot; + &quot;90046003&quot;, msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString() ))	
	.returnBundle(Bundle)	
	.execute();
		
var ms;
var firstTime = true; 
var orders = new HashMap();

logger.error(&quot;About to iterate through DiagnosticOrders...&quot; );&#xd;
		
do
{
	if( !firstTime )
	{
		orderSearchResults = client.loadPage().next(orderSearchResults).execute();
	}
	
	ms = orderSearchResults.getEntry();
		
	for(var i=0; i&lt;ms.size() ; i++ )
	{
		var order = ms.get(i).getResource();
		var orderString = ctx.newJsonParser().encodeResourceToString(order);

		orders.put( order.getItemFirstRep().getCode().getCoding().get(0).getCode(), order.getId().getIdPart() );
		
//		logger.error( &quot;DiagnosticOrder Resource ID: \n&quot; + order.getId().getIdPart() );
//		logger.error( &quot;DiagnosticOrder: \n&quot; + orderString );
	}
	
	firstTime = false;
}
while( orderSearchResults.getLink(Bundle.LINK_NEXT) != null );

channelMap.put( &quot;theOrders&quot;, orders );

*/</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/*
importPackage(Packages.java.util);
importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var ctx = channelMap.get( &quot;ctx&quot; );
var client = ctx.newRestfulGenericClient( configurationMap.get(&apos;sparkRawURL&apos;) );

var orderSearchResults = client
	.search()
	.forResource(DiagnosticOrder)
	.where(DiagnosticOrder.IDENTIFIER.exactly().systemAndIdentifier($(&apos;sparkRawURL&apos;) + &quot;/&quot; + &quot;90046003&quot;, msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString() ))	
	.returnBundle(Bundle)	
	.execute();
		
var ms;
var firstTime = true; 
var orders = new HashMap();

logger.error(&quot;About to iterate through DiagnosticOrders...&quot; );&#xd;
		
do
{
	if( !firstTime )
	{
		orderSearchResults = client.loadPage().next(orderSearchResults).execute();
	}
	
	ms = orderSearchResults.getEntry();
		
	for(var i=0; i&lt;ms.size() ; i++ )
	{
		var order = ms.get(i).getResource();
		var orderString = ctx.newJsonParser().encodeResourceToString(order);

		orders.put( order.getItemFirstRep().getCode().getCoding().get(0).getCode(), order.getId().getIdPart() );
		
//		logger.error( &quot;DiagnosticOrder Resource ID: \n&quot; + order.getId().getIdPart() );
//		logger.error( &quot;DiagnosticOrder: \n&quot; + orderString );
	}
	
	firstTime = false;
}
while( orderSearchResults.getLink(Bundle.LINK_NEXT) != null );

channelMap.put( &quot;theOrders&quot;, orders );

*/</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>3</sequenceNumber>
                <name>DiagnosticReport resource</name>
                <script>var arrDiagnosticReport = [];
var arrOrderingProvider = [];
var arrProviderID = [];

/*
* (SN) Practitioner resource for Performing Organization or Medical Doctor is not mapped (see comments below)
*
*/ 

for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

logger.error( &quot;Processing Observation&quot; );

	// Ignore &quot;comment&quot; results
	if( observation[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;86006556&quot; )
	{
		continue; 
	}

	var resDiagnosticReport = &lt;DiagnosticReport&gt;
							&lt;text&gt;
								&lt;status value=&quot;generated&quot;/&gt;
								&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
							&lt;/text&gt;
						&lt;/DiagnosticReport&gt;;
	
	// Process only ORC-OBR-OBX group
	if (observation[&apos;ORC&apos;][&apos;ORC.1&apos;].toString() != &quot;RE&quot;) { continue; }

	// Reference to contained observations
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			logger.error( &quot;OBX Found: &quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString())
			var id = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			var resultReference = &lt;contained&gt;
									&lt;Observation&gt;
										&lt;id value=&quot;&quot;/&gt;
									&lt;/Observation&gt;
								&lt;/contained&gt;;
			resultReference.Observation.id.@value = id;
			resDiagnosticReport.appendChild(resultReference);	
		}
	}	

//	resDiagnosticReport.id.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();

	// Process Observation Request (OBR) level NTE segments
	// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot; 
	// March 14 2017: Issue #3 &quot;Comments appear twice&quot; fixed 
	resDiagnosticReport.text.*::div.* = new XMLList();
	var observationComment = false;	

	// Extract ORC-OBR-OBX group related comments only
	var orderObservationGroup = new XML(observation.toString());
	
	// March 14: This returns all children and grandchildren NTE segments of the this object
	for each (var nte in orderObservationGroup.descendants(&quot;NTE&quot;)) { 
		
		if (&quot;NTE&quot; == nte.name().toString()) {

			observationComment = true;

			// March 14, 2017: Comment source depends on the group and appended as a prefix 
			var prefix = &quot;&quot;;
			if (nte.parent().name().toString().indexOf(&quot;.ORDER_OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBR&quot;;
			} else if (nte.parent().name().toString().indexOf(&quot;.OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBX&quot;;
			}
			
			// Source of Comment - Optional
			var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
			var source = nte[&apos;NTE.2&apos;].toString();
			
			// Comments contained in the segment - Required
			var comment = nte[&apos;NTE.3&apos;].toString();

			if (commentSources.indexOf(source) &gt; -1) {	
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;-&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
			} else {
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
			}
		}
	}

	if (!observationComment) delete resDiagnosticReport.text;

	// Process single OBR segment
//	resDiagnosticReport.appendChild(new XML(&quot;&lt;contained&gt;&quot; + getDiagnosticOrder(observation) + &quot;&lt;/contained&gt;&quot;));

/*
	// Process Ordering Provider
	// (SN) Add only if such Ordering Provider is not in the list already
	var provID =  observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	if (arrProviderID.indexOf(provID) &lt; 0) {
		arrOrderingProvider.push(getOrderingProvider(observation));
		arrProviderID.push(provID);
	}

	// Process multiple OBX segments
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString()) {

			// OBX segments nested under DiagnosticReport as contained resources
			resDiagnosticReport.appendChild(new XML(&quot;&lt;contained&gt;&quot; + getObservationResource(obs) + &quot;&lt;/contained&gt;&quot;));
		}	
	}	
*/
	// Placer Order Number - If populated, this field contains the placer application’s order number.
	if (observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString()) {
		var identifier1 = &lt;identifier&gt;
						&lt;system value=&quot;&quot;/&gt;
						&lt;value value=&quot;&quot;/&gt;
					&lt;/identifier&gt;;
		identifier1.value.@value = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString();
//		identifier1.system.@value = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.2&apos;].toString();
		identifier1.system.@value = &quot;90046003&quot;
		resDiagnosticReport.appendChild(identifier1);
	}

	// Filler Order Number - The order number associated with the filler’s application. 
	if (observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString()) {
		var identifier2 = &lt;identifier&gt;
						&lt;system value=&quot;&quot;/&gt;
						&lt;value value=&quot;&quot;/&gt;
					&lt;/identifier&gt;;
		identifier2.value.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();
		identifier2.system.@value = &quot;Observation/&quot; +  observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.2&apos;].toString();
		resDiagnosticReport.appendChild(identifier2);		
	}

	var identifier3 = &lt;identifier&gt;
					&lt;system value=&quot;&quot;/&gt;
					&lt;value value=&quot;&quot;/&gt;
				&lt;/identifier&gt;;
		identifier3.value.@value = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
		identifier3.system.@value = &quot;QUEST&quot;;
		resDiagnosticReport.appendChild(identifier3);		
	

	// Order Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)
	var statusCode = observation[&apos;ORC&apos;][&apos;ORC.5&apos;].toString();
	if (statusCode) {
		var statusXML = &lt;status value=&quot;final&quot;&gt;
					&lt;/status&gt;;

		resDiagnosticReport.appendChild(statusXML);
	}

	resDiagnosticReport.code.@id = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();

	// Hard-coded, required by FHIR
	resDiagnosticReport.appendChild(new XML(&apos;&lt;subject&gt;&lt;reference value=&quot;Patient&quot;/&gt;&lt;/subject&gt;&apos;));

	// Observation Date/Time
	resDiagnosticReport.effectiveDateTime.@value = convertHL7DateTime(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());
	resDiagnosticReport.issued.@value = convertHL7DateTime(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());

	// Reference to observation this report is based on
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;) {
			var id = &quot;Observation/#&quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			var resultReference = &lt;result&gt;
									&lt;reference value=&quot;&quot;/&gt;
								&lt;/result&gt;;
			resultReference.reference.@value = id;
			resDiagnosticReport.appendChild(resultReference);	
		}	
	}


//	logger.error( &quot;Diagnostic Report\n:&quot; +  resDiagnosticReport.toString() );

	// ~~ STEPS: 
	// 1. Add test code to ID
	// 2. Pull array of Observations for each Order/Report
	// 3. Put Observations into Diagnostic Report
	// 5. Populate Conclusion

	importPackage(Packages.java.util);
	importPackage(Packages.ca.uhn.fhir.context);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);	
	importPackage(Packages.ca.uhn.fhir.rest.api);
	importPackage(Packages.ca.uhn.fhir.rest.client);

	var ctx = channelMap.get( &quot;ctx&quot; );
	var client = ctx.newRestfulGenericClient( configurationMap.get(&apos;sparkRawURL&apos;) );

	var originatingCode = observation[&apos;OBR&apos;][&apos;OBR.50&apos;][&apos;CWE.1&apos;].toString();

	// The parent test is itself, but a reflex has a different parent test
	if( originatingCode == null || originatingCode == &quot;&quot; ) 
	{
		originatingCode = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	}


	logger.error( &quot;String Report 1: &quot; + resDiagnosticReport.toString() );
	
	var report = ctx.newXmlParser().parseResource( resDiagnosticReport.toString() );	
	
	report.setSubject(new ResourceReferenceDt(  &quot;Patient/&quot; + $(&apos;PatientResourceID&apos;) ));	

	var theAttachments = new ArrayList();
	
	var attachment = new AttachmentDt();
	attachment.setContentType(&quot;application/pdf&quot;);
	attachment.setData( new java.lang.String( $(&apos;PDFBase64&apos;) ).getBytes() );
	theAttachments.add(attachment);

	var attachment2 = new AttachmentDt();
	attachment2.setContentType(&quot;text/hl7&quot;);
	attachment2.setData( new java.lang.String( $(&apos;HL7Base64&apos;) ).getBytes() );
	theAttachments.add(attachment2);
	
	report.setPresentedForm(theAttachments );	

	// Contained Observations

	var jp = ctx.newJsonParser();

     var resourceList = new ArrayList();

	var containedDt = new ContainedDt();

	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString()) 
		{
			// ~~ Make sure to exclude OBX observations containing PDF
//			var obxObservation = ctx.newXmlParser().parseResource( getObservationResource(obs).toString() );	
			var obxObservation = getObservationResourcePopulated( obs );

			logger.error( &quot;OBSERVATION: &quot; + jp.encodeResourceToString( obxObservation ) );			

			resourceList.add(obxObservation);
	    
		}	
	}

	containedDt.setContainedResources(resourceList);
	report.setContained(containedDt);		


	// Conclusion
	var abnormalFlags = observation[&apos;OBX.8&apos;].toString();
	if (abnormalFlags) {
		report.setConclusion(&quot;ABNORMAL&quot;);
	} else {
		report.setConclusion(&quot;NORMAL&quot;);
	}

	logger.error( &quot;String Report 2: &quot; + jp.encodeResourceToString( report) );
		
	var outcome = client.create()
		.resource(report)
		.execute();	

	logger.error( &quot;Outcome: &quot; + outcome.getResource().toString() );
	
//	arrDiagnosticReport.push(resDiagnosticReport.toString());
}

// Store DiagnosticReport resource to be processed by FHIR_Submit destination
channelMap.put(&quot;DiagnosticReport&quot;, arrDiagnosticReport);

// Store Practitioner resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Practitioner&quot;, arrOrderingProvider);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var arrDiagnosticReport = [];
var arrOrderingProvider = [];
var arrProviderID = [];

/*
* (SN) Practitioner resource for Performing Organization or Medical Doctor is not mapped (see comments below)
*
*/ 

for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

logger.error( &quot;Processing Observation&quot; );

	// Ignore &quot;comment&quot; results
	if( observation[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;86006556&quot; )
	{
		continue; 
	}

	var resDiagnosticReport = &lt;DiagnosticReport&gt;
							&lt;text&gt;
								&lt;status value=&quot;generated&quot;/&gt;
								&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
							&lt;/text&gt;
						&lt;/DiagnosticReport&gt;;
	
	// Process only ORC-OBR-OBX group
	if (observation[&apos;ORC&apos;][&apos;ORC.1&apos;].toString() != &quot;RE&quot;) { continue; }

	// Reference to contained observations
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			logger.error( &quot;OBX Found: &quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString())
			var id = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			var resultReference = &lt;contained&gt;
									&lt;Observation&gt;
										&lt;id value=&quot;&quot;/&gt;
									&lt;/Observation&gt;
								&lt;/contained&gt;;
			resultReference.Observation.id.@value = id;
			resDiagnosticReport.appendChild(resultReference);	
		}
	}	

//	resDiagnosticReport.id.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();

	// Process Observation Request (OBR) level NTE segments
	// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot; 
	// March 14 2017: Issue #3 &quot;Comments appear twice&quot; fixed 
	resDiagnosticReport.text.*::div.* = new XMLList();
	var observationComment = false;	

	// Extract ORC-OBR-OBX group related comments only
	var orderObservationGroup = new XML(observation.toString());
	
	// March 14: This returns all children and grandchildren NTE segments of the this object
	for each (var nte in orderObservationGroup.descendants(&quot;NTE&quot;)) { 
		
		if (&quot;NTE&quot; == nte.name().toString()) {

			observationComment = true;

			// March 14, 2017: Comment source depends on the group and appended as a prefix 
			var prefix = &quot;&quot;;
			if (nte.parent().name().toString().indexOf(&quot;.ORDER_OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBR&quot;;
			} else if (nte.parent().name().toString().indexOf(&quot;.OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBX&quot;;
			}
			
			// Source of Comment - Optional
			var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
			var source = nte[&apos;NTE.2&apos;].toString();
			
			// Comments contained in the segment - Required
			var comment = nte[&apos;NTE.3&apos;].toString();

			if (commentSources.indexOf(source) &gt; -1) {	
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;-&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
			} else {
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
			}
		}
	}

	if (!observationComment) delete resDiagnosticReport.text;

	// Process single OBR segment
//	resDiagnosticReport.appendChild(new XML(&quot;&lt;contained&gt;&quot; + getDiagnosticOrder(observation) + &quot;&lt;/contained&gt;&quot;));

/*
	// Process Ordering Provider
	// (SN) Add only if such Ordering Provider is not in the list already
	var provID =  observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	if (arrProviderID.indexOf(provID) &lt; 0) {
		arrOrderingProvider.push(getOrderingProvider(observation));
		arrProviderID.push(provID);
	}

	// Process multiple OBX segments
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString()) {

			// OBX segments nested under DiagnosticReport as contained resources
			resDiagnosticReport.appendChild(new XML(&quot;&lt;contained&gt;&quot; + getObservationResource(obs) + &quot;&lt;/contained&gt;&quot;));
		}	
	}	
*/
	// Placer Order Number - If populated, this field contains the placer application’s order number.
	if (observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString()) {
		var identifier1 = &lt;identifier&gt;
						&lt;system value=&quot;&quot;/&gt;
						&lt;value value=&quot;&quot;/&gt;
					&lt;/identifier&gt;;
		identifier1.value.@value = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString();
//		identifier1.system.@value = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.2&apos;].toString();
		identifier1.system.@value = &quot;90046003&quot;
		resDiagnosticReport.appendChild(identifier1);
	}

	// Filler Order Number - The order number associated with the filler’s application. 
	if (observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString()) {
		var identifier2 = &lt;identifier&gt;
						&lt;system value=&quot;&quot;/&gt;
						&lt;value value=&quot;&quot;/&gt;
					&lt;/identifier&gt;;
		identifier2.value.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();
		identifier2.system.@value = &quot;Observation/&quot; +  observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.2&apos;].toString();
		resDiagnosticReport.appendChild(identifier2);		
	}

	var identifier3 = &lt;identifier&gt;
					&lt;system value=&quot;&quot;/&gt;
					&lt;value value=&quot;&quot;/&gt;
				&lt;/identifier&gt;;
		identifier3.value.@value = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
		identifier3.system.@value = &quot;QUEST&quot;;
		resDiagnosticReport.appendChild(identifier3);		
	

	// Order Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)
	var statusCode = observation[&apos;ORC&apos;][&apos;ORC.5&apos;].toString();
	if (statusCode) {
		var statusXML = &lt;status value=&quot;final&quot;&gt;
					&lt;/status&gt;;

		resDiagnosticReport.appendChild(statusXML);
	}

	resDiagnosticReport.code.@id = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();

	// Hard-coded, required by FHIR
	resDiagnosticReport.appendChild(new XML(&apos;&lt;subject&gt;&lt;reference value=&quot;Patient&quot;/&gt;&lt;/subject&gt;&apos;));

	// Observation Date/Time
	resDiagnosticReport.effectiveDateTime.@value = convertHL7DateTime(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());
	resDiagnosticReport.issued.@value = convertHL7DateTime(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());

	// Reference to observation this report is based on
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;) {
			var id = &quot;Observation/#&quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			var resultReference = &lt;result&gt;
									&lt;reference value=&quot;&quot;/&gt;
								&lt;/result&gt;;
			resultReference.reference.@value = id;
			resDiagnosticReport.appendChild(resultReference);	
		}	
	}


//	logger.error( &quot;Diagnostic Report\n:&quot; +  resDiagnosticReport.toString() );

	// ~~ STEPS: 
	// 1. Add test code to ID
	// 2. Pull array of Observations for each Order/Report
	// 3. Put Observations into Diagnostic Report
	// 5. Populate Conclusion

	importPackage(Packages.java.util);
	importPackage(Packages.ca.uhn.fhir.context);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);	
	importPackage(Packages.ca.uhn.fhir.rest.api);
	importPackage(Packages.ca.uhn.fhir.rest.client);

	var ctx = channelMap.get( &quot;ctx&quot; );
	var client = ctx.newRestfulGenericClient( configurationMap.get(&apos;sparkRawURL&apos;) );

	var originatingCode = observation[&apos;OBR&apos;][&apos;OBR.50&apos;][&apos;CWE.1&apos;].toString();

	// The parent test is itself, but a reflex has a different parent test
	if( originatingCode == null || originatingCode == &quot;&quot; ) 
	{
		originatingCode = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	}


	logger.error( &quot;String Report 1: &quot; + resDiagnosticReport.toString() );
	
	var report = ctx.newXmlParser().parseResource( resDiagnosticReport.toString() );	
	
	report.setSubject(new ResourceReferenceDt(  &quot;Patient/&quot; + $(&apos;PatientResourceID&apos;) ));	

	var theAttachments = new ArrayList();
	
	var attachment = new AttachmentDt();
	attachment.setContentType(&quot;application/pdf&quot;);
	attachment.setData( new java.lang.String( $(&apos;PDFBase64&apos;) ).getBytes() );
	theAttachments.add(attachment);

	var attachment2 = new AttachmentDt();
	attachment2.setContentType(&quot;text/hl7&quot;);
	attachment2.setData( new java.lang.String( $(&apos;HL7Base64&apos;) ).getBytes() );
	theAttachments.add(attachment2);
	
	report.setPresentedForm(theAttachments );	

	// Contained Observations

	var jp = ctx.newJsonParser();

     var resourceList = new ArrayList();

	var containedDt = new ContainedDt();

	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString()) 
		{
			// ~~ Make sure to exclude OBX observations containing PDF
//			var obxObservation = ctx.newXmlParser().parseResource( getObservationResource(obs).toString() );	
			var obxObservation = getObservationResourcePopulated( obs );

			logger.error( &quot;OBSERVATION: &quot; + jp.encodeResourceToString( obxObservation ) );			

			resourceList.add(obxObservation);
	    
		}	
	}

	containedDt.setContainedResources(resourceList);
	report.setContained(containedDt);		


	// Conclusion
	var abnormalFlags = observation[&apos;OBX.8&apos;].toString();
	if (abnormalFlags) {
		report.setConclusion(&quot;ABNORMAL&quot;);
	} else {
		report.setConclusion(&quot;NORMAL&quot;);
	}

	logger.error( &quot;String Report 2: &quot; + jp.encodeResourceToString( report) );
		
	var outcome = client.create()
		.resource(report)
		.execute();	

	logger.error( &quot;Outcome: &quot; + outcome.getResource().toString() );
	
//	arrDiagnosticReport.push(resDiagnosticReport.toString());
}

// Store DiagnosticReport resource to be processed by FHIR_Submit destination
channelMap.put(&quot;DiagnosticReport&quot;, arrDiagnosticReport);

// Store Practitioner resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Practitioner&quot;, arrOrderingProvider);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>4</sequenceNumber>
                <name>Functions pool</name>
                <script>/**
	Creates the DiagnosticOrder resourse with OBR segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return DiagnosticOrder XML string
*/

function getObservationResourcePopulated(obs) {

	importPackage( Packages.java.util );
	importPackage( Packages.org.hl7.fhir.instance.model );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.resource );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.valueset );
	importPackage( Packages.ca.uhn.fhir.model.primitive );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.composite );
	importPackage( Packages.java.text );

	var HL7DateFormat = new SimpleDateFormat(&quot;YYYYMMdd&quot;);

	var obsResource = new Observation();

	obsResource.setId( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());				
		
	obsResource.addIdentifier().setValue(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());

	switch( obs[&apos;OBX.11&apos;].toString() + &apos;&apos; )
	{
		case &quot;F&quot;:
			obsResource.setStatus(ObservationStatusEnum.FINAL);				
		break;

		case &quot;P&quot;:
			obsResource.setStatus(ObservationStatusEnum.PRELIMINARY);			
		break;

		case &quot;S&quot;:
			obsResource.setStatus(ObservationStatusEnum.AMENDED);	
		break;

		case &quot;C&quot;:
			obsResource.setStatus(ObservationStatusEnum.CANCELLED);
		break;
			
		default:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
			logger.error( &quot;Unrecognized Status Code: &quot; + obs[&apos;OBX.11&apos;].toString() );	
	}

	var theCodeableConcept = new CodeableConceptDt();
	var theLoincCoding = new CodingDt();
	var theQuestCoding = new CodingDt();
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) 
	{
		// LOINC coding
		theLoincCoding.setSystem(&quot;http://loinc.org&quot;);
		theLoincCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString());
		theLoincCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString());
		theCodeableConcept.addCoding(theLoincCoding );		
	}

	theQuestCoding.setSystem(obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString());
	theQuestCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());
	theQuestCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString());
	theCodeableConcept.addCoding(theQuestCoding );				

	obsResource.setCode(theCodeableConcept );

	if( obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString() )
	{
		obsResource.setEffective(new DateTimeDt(HL7DateFormat.parse(obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString())));		
	}

	if( obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString() )
	{
		obsResource.setIssuedWithMillisPrecision(HL7DateFormat.parse(obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString()));
	}
	obsResource.setValue( new StringDt( obs[&apos;OBX.5&apos;].toString() ) );

	var theInterpretation = new CodeableConceptDt();
	theInterpretation.setText(obs[&apos;OBX.8&apos;].toString());	
	obsResource.setInterpretation(theInterpretation );	

	var theReferenceRange = new Observation.ReferenceRange();
	var theMeaningCoding = new CodeableConceptDt();
	var theReferenceRangeMeaningCoding = new CodingDt();	

	theReferenceRangeMeaningCoding.setCode(obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString());
	theReferenceRangeMeaningCoding.setSystem(obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString());
	theReferenceRangeMeaningCoding.setDisplay(obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString());
		
	theMeaningCoding.addCoding(theReferenceRangeMeaningCoding );
	theReferenceRange.setText(obs[&apos;OBX.7&apos;].toString());
		
	theReferenceRange.setMeaning(theMeaningCoding );
	obsResource.addReferenceRange(theReferenceRange);	

	logger.error( &quot;Contained Observation: \n&quot; + obsResource.toString() );
	return obsResource;
}

/*
function getDiagnosticOrder(obs) {

//
//(SN) Following fields are not mapped in this version:
// OBR.26 [Parent Result] - Optional - If OBR.11 (Specimen Action Code) is populated, then this field is populated with the data in the parent OBX.03 (Observation Identifier) subfield.
// OBR.29 [Parent] - Optional - This field is populated if OBR.11 (Specimen Action Code) is populated.
// OBR.50 [Parent Universal Service Identifier] - Optional - The universal service identifier of the parent order. This field is populated if OBR.11 (Specimen Action Code) is populated.
//
	var diagnosticOrder = &lt;DiagnosticOrder&gt;
					&lt;id value=&quot;obr-observation-request&quot;/&gt;
					&lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/diagnosticorder-precondition&quot;&gt;
						&lt;valueDateTime value=&quot;&quot;/&gt;
					&lt;/extension&gt;
					&lt;subject id=&quot;Patient&quot;/&gt;
					&lt;event&gt;
						&lt;status value=&quot;completed&quot;&gt;
							&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
								&lt;valueCodeableConcept&gt;
									&lt;coding&gt;
										&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0123&quot;/&gt;
										&lt;code value=&quot;&quot;/&gt;
										&lt;display value=&quot;&quot;/&gt;
									&lt;/coding&gt;
								&lt;/valueCodeableConcept&gt;
							&lt;/extension&gt;
						&lt;/status&gt;
						&lt;dateTime value=&quot;&quot;/&gt;
						&lt;actor&gt;
							&lt;reference value=&quot;Practitioner/ordering-provider&quot;/&gt;
						&lt;/actor&gt;
					&lt;/event&gt;
					&lt;item&gt;
						&lt;code&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/code&gt;
						&lt;specimen&gt;
							&lt;display value=&quot;G&quot;/&gt;
						&lt;/specimen&gt;
					&lt;/item&gt;
				&lt;/DiagnosticOrder&gt;;

	diagnosticOrder.extension.valueDateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());

	var resultHandling = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	if (resultHandling) {
		diagnosticOrder.supportingInformation.display.@value = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	} else {
		delete diagnosticOrder.supportingInformation;
	}

	// Result Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBR&apos;][&apos;OBR.25&apos;].toString();
	if (statusCode) {
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0123&quot;, statusCode);
	}

	//  The date/time the results were reported or status changed
	diagnosticOrder.event.dateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;TS.1&apos;].toString());

	// Quest samples contain local and LOINC codes
	diagnosticOrder.item.code.coding.system.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.3&apos;].toString();
	diagnosticOrder.item.code.coding.code.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	diagnosticOrder.item.code.coding.display.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.2&apos;].toString();

	// Specimen Action Code
	var specimenActionCode = obs[&apos;OBR&apos;][&apos;OBR.11&apos;].toString();
	if (specimenActionCode) {
		diagnosticOrder.item.specimen.display.@value = specimenActionCode;
	} else {
		delete diagnosticOrder.item.specimen;
	}

	return diagnosticOrder.toString();
}
*/
/**
	Creates the Observation resourse with a single OBX segment mappings

	@param {String} obs - original ORU_R01.OBSERVATION XML string
	@return {String} return Observation XML string
*/
function getObservationResource(obs) {

	var obsResource = &lt;Observation xmlns=&quot;http://hl7.org/fhir&quot;&gt;			
					&lt;identifier id=&quot;&quot;/&gt;
					&lt;status value=&quot;final&quot;&gt;
						&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
							&lt;valueCodeableConcept&gt;
								&lt;coding&gt;
									&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0085&quot;/&gt;
									&lt;code value=&quot;F&quot;/&gt;
									&lt;display value=&quot;Final results; can only be changed with a corrected result&quot;/&gt;
								&lt;/coding&gt;
							&lt;/valueCodeableConcept&gt;
						&lt;/extension&gt;
					&lt;/status&gt;
					&lt;code&gt;
						&lt;extension url=&quot;http://www.questdiagnostics.com&quot;&gt;
							&lt;valueCoding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/valueCoding&gt;
						&lt;/extension&gt;
						&lt;coding&gt;
							&lt;system value=&quot;http://loinc.org&quot;/&gt;
							&lt;code value=&quot;&quot;/&gt;
							&lt;display value=&quot;&quot;/&gt;
						&lt;/coding&gt;
					&lt;/code&gt;
					&lt;effectiveDateTime value=&quot;&quot;/&gt;
					&lt;issued value=&quot;&quot;/&gt;
					&lt;valueString value=&quot;&quot;/&gt;
					&lt;interpretation&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/interpretation&gt;
					&lt;referenceRange&gt;
						&lt;meaning&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/meaning&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/referenceRange&gt;
				&lt;/Observation&gt;;

	obsResource.identifier.@id =  obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();

	// Result Status - the status of the result value
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBX.11&apos;].toString();
	if (statusCode) {
		 obsResource.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 obsResource.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0085&quot;, statusCode);
	}
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) {
		// Care360 own coding
		obsResource.code.extension.valueCoding.system.@value =  obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.extension.valueCoding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.extension.valueCoding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();

		// LOINC coding
		obsResource.code.coding.system.@value = &quot;http://loinc.org&quot;;
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString();		
	} else {
		delete obsResource.code.extension;
		obsResource.code.coding.system.@value =  obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();			
	}

	var dateTimeOfObservation = obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfObservation) {
		obsResource.effectiveDateTime.@value = convertHL7DateTime(dateTimeOfObservation);
	} else {
		delete obsResource.effectiveDateTime;
	}

	var dateTimeOfAnalysis = obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfAnalysis) {
		obsResource.issued.@value = convertHL7DateTime(dateTimeOfAnalysis);
	} else {
		delete obsResource.issued;
	}

	// March 15: Issues #13: OBX.5 [Observation Value] using SN (Structured Numeric) data type
	var observationValue = &quot;&quot;;
	if (obs[&apos;OBX.5&apos;][&apos;SN.3&apos;]) {
		for each (var sn in obs[&apos;OBX.5&apos;].children()) {
			if (sn.toString()) observationValue += sn.toString(); 
		}
	} else {
		observationValue = obs[&apos;OBX.5&apos;].toString();
	}
	
	if (observationValue) {
		obsResource.valueString.@value = observationValue;
	} else {
		delete obsResource.valueString;
	}

	var abnormalFlags = obs[&apos;OBX.8&apos;].toString();
	if (abnormalFlags) {
		obsResource.interpretation.text.@value = abnormalFlags;
	} else {
		delete obsResource.interpretation;
	}

	var unitsOfMeasure = obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString();
	var meaningPresent = true;
	if (unitsOfMeasure) {
		obsResource.referenceRange.meaning.coding.code.@value = unitsOfMeasure;
		if (obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.system.@value = obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.system;
		}
		if (obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.display.@value = obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.display;
		}
	} else {
		delete obsResource.referenceRange.meaning;
		meaningPresent = false;
	}
	
	var referencesRange = obs[&apos;OBX.7&apos;].toString();
	var rangePresent = true;
	if (referencesRange) {
		obsResource.referenceRange.text.@value = referencesRange;
	} else {
		delete obsResource.referenceRange.text;
		rangePresent = false;
	}

	if (!meaningPresent &amp;&amp; !rangePresent) delete obsResource.referenceRange;

	// Reference to performing organization
//	obsResource.performer.reference.@value=&quot;Practitioner/obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	logger.error( &quot;Contained Observation: \n&quot; + obsResource.toString() );
	return obsResource.toString();
	
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates the DiagnosticOrder resourse with OBR segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return DiagnosticOrder XML string
*/

function getObservationResourcePopulated(obs) {

	importPackage( Packages.java.util );
	importPackage( Packages.org.hl7.fhir.instance.model );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.resource );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.valueset );
	importPackage( Packages.ca.uhn.fhir.model.primitive );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.composite );
	importPackage( Packages.java.text );

	var HL7DateFormat = new SimpleDateFormat(&quot;YYYYMMdd&quot;);

	var obsResource = new Observation();

	obsResource.setId( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());				
		
	obsResource.addIdentifier().setValue(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());

	switch( obs[&apos;OBX.11&apos;].toString() + &apos;&apos; )
	{
		case &quot;F&quot;:
			obsResource.setStatus(ObservationStatusEnum.FINAL);				
		break;

		case &quot;P&quot;:
			obsResource.setStatus(ObservationStatusEnum.PRELIMINARY);			
		break;

		case &quot;S&quot;:
			obsResource.setStatus(ObservationStatusEnum.AMENDED);	
		break;

		case &quot;C&quot;:
			obsResource.setStatus(ObservationStatusEnum.CANCELLED);
		break;
			
		default:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
			logger.error( &quot;Unrecognized Status Code: &quot; + obs[&apos;OBX.11&apos;].toString() );	
	}

	var theCodeableConcept = new CodeableConceptDt();
	var theLoincCoding = new CodingDt();
	var theQuestCoding = new CodingDt();
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) 
	{
		// LOINC coding
		theLoincCoding.setSystem(&quot;http://loinc.org&quot;);
		theLoincCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString());
		theLoincCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString());
		theCodeableConcept.addCoding(theLoincCoding );		
	}

	theQuestCoding.setSystem(obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString());
	theQuestCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());
	theQuestCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString());
	theCodeableConcept.addCoding(theQuestCoding );				

	obsResource.setCode(theCodeableConcept );

	if( obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString() )
	{
		obsResource.setEffective(new DateTimeDt(HL7DateFormat.parse(obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString())));		
	}

	if( obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString() )
	{
		obsResource.setIssuedWithMillisPrecision(HL7DateFormat.parse(obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString()));
	}
	obsResource.setValue( new StringDt( obs[&apos;OBX.5&apos;].toString() ) );

	var theInterpretation = new CodeableConceptDt();
	theInterpretation.setText(obs[&apos;OBX.8&apos;].toString());	
	obsResource.setInterpretation(theInterpretation );	

	var theReferenceRange = new Observation.ReferenceRange();
	var theMeaningCoding = new CodeableConceptDt();
	var theReferenceRangeMeaningCoding = new CodingDt();	

	theReferenceRangeMeaningCoding.setCode(obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString());
	theReferenceRangeMeaningCoding.setSystem(obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString());
	theReferenceRangeMeaningCoding.setDisplay(obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString());
		
	theMeaningCoding.addCoding(theReferenceRangeMeaningCoding );
	theReferenceRange.setText(obs[&apos;OBX.7&apos;].toString());
		
	theReferenceRange.setMeaning(theMeaningCoding );
	obsResource.addReferenceRange(theReferenceRange);	

	logger.error( &quot;Contained Observation: \n&quot; + obsResource.toString() );
	return obsResource;
}

/*
function getDiagnosticOrder(obs) {

//
//(SN) Following fields are not mapped in this version:
// OBR.26 [Parent Result] - Optional - If OBR.11 (Specimen Action Code) is populated, then this field is populated with the data in the parent OBX.03 (Observation Identifier) subfield.
// OBR.29 [Parent] - Optional - This field is populated if OBR.11 (Specimen Action Code) is populated.
// OBR.50 [Parent Universal Service Identifier] - Optional - The universal service identifier of the parent order. This field is populated if OBR.11 (Specimen Action Code) is populated.
//
	var diagnosticOrder = &lt;DiagnosticOrder&gt;
					&lt;id value=&quot;obr-observation-request&quot;/&gt;
					&lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/diagnosticorder-precondition&quot;&gt;
						&lt;valueDateTime value=&quot;&quot;/&gt;
					&lt;/extension&gt;
					&lt;subject id=&quot;Patient&quot;/&gt;
					&lt;event&gt;
						&lt;status value=&quot;completed&quot;&gt;
							&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
								&lt;valueCodeableConcept&gt;
									&lt;coding&gt;
										&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0123&quot;/&gt;
										&lt;code value=&quot;&quot;/&gt;
										&lt;display value=&quot;&quot;/&gt;
									&lt;/coding&gt;
								&lt;/valueCodeableConcept&gt;
							&lt;/extension&gt;
						&lt;/status&gt;
						&lt;dateTime value=&quot;&quot;/&gt;
						&lt;actor&gt;
							&lt;reference value=&quot;Practitioner/ordering-provider&quot;/&gt;
						&lt;/actor&gt;
					&lt;/event&gt;
					&lt;item&gt;
						&lt;code&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/code&gt;
						&lt;specimen&gt;
							&lt;display value=&quot;G&quot;/&gt;
						&lt;/specimen&gt;
					&lt;/item&gt;
				&lt;/DiagnosticOrder&gt;;

	diagnosticOrder.extension.valueDateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());

	var resultHandling = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	if (resultHandling) {
		diagnosticOrder.supportingInformation.display.@value = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	} else {
		delete diagnosticOrder.supportingInformation;
	}

	// Result Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBR&apos;][&apos;OBR.25&apos;].toString();
	if (statusCode) {
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0123&quot;, statusCode);
	}

	//  The date/time the results were reported or status changed
	diagnosticOrder.event.dateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;TS.1&apos;].toString());

	// Quest samples contain local and LOINC codes
	diagnosticOrder.item.code.coding.system.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.3&apos;].toString();
	diagnosticOrder.item.code.coding.code.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	diagnosticOrder.item.code.coding.display.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.2&apos;].toString();

	// Specimen Action Code
	var specimenActionCode = obs[&apos;OBR&apos;][&apos;OBR.11&apos;].toString();
	if (specimenActionCode) {
		diagnosticOrder.item.specimen.display.@value = specimenActionCode;
	} else {
		delete diagnosticOrder.item.specimen;
	}

	return diagnosticOrder.toString();
}
*/
/**
	Creates the Observation resourse with a single OBX segment mappings

	@param {String} obs - original ORU_R01.OBSERVATION XML string
	@return {String} return Observation XML string
*/
function getObservationResource(obs) {

	var obsResource = &lt;Observation xmlns=&quot;http://hl7.org/fhir&quot;&gt;			
					&lt;identifier id=&quot;&quot;/&gt;
					&lt;status value=&quot;final&quot;&gt;
						&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
							&lt;valueCodeableConcept&gt;
								&lt;coding&gt;
									&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0085&quot;/&gt;
									&lt;code value=&quot;F&quot;/&gt;
									&lt;display value=&quot;Final results; can only be changed with a corrected result&quot;/&gt;
								&lt;/coding&gt;
							&lt;/valueCodeableConcept&gt;
						&lt;/extension&gt;
					&lt;/status&gt;
					&lt;code&gt;
						&lt;extension url=&quot;http://www.questdiagnostics.com&quot;&gt;
							&lt;valueCoding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/valueCoding&gt;
						&lt;/extension&gt;
						&lt;coding&gt;
							&lt;system value=&quot;http://loinc.org&quot;/&gt;
							&lt;code value=&quot;&quot;/&gt;
							&lt;display value=&quot;&quot;/&gt;
						&lt;/coding&gt;
					&lt;/code&gt;
					&lt;effectiveDateTime value=&quot;&quot;/&gt;
					&lt;issued value=&quot;&quot;/&gt;
					&lt;valueString value=&quot;&quot;/&gt;
					&lt;interpretation&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/interpretation&gt;
					&lt;referenceRange&gt;
						&lt;meaning&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/meaning&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/referenceRange&gt;
				&lt;/Observation&gt;;

	obsResource.identifier.@id =  obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();

	// Result Status - the status of the result value
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBX.11&apos;].toString();
	if (statusCode) {
		 obsResource.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 obsResource.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0085&quot;, statusCode);
	}
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) {
		// Care360 own coding
		obsResource.code.extension.valueCoding.system.@value =  obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.extension.valueCoding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.extension.valueCoding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();

		// LOINC coding
		obsResource.code.coding.system.@value = &quot;http://loinc.org&quot;;
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString();		
	} else {
		delete obsResource.code.extension;
		obsResource.code.coding.system.@value =  obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();			
	}

	var dateTimeOfObservation = obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfObservation) {
		obsResource.effectiveDateTime.@value = convertHL7DateTime(dateTimeOfObservation);
	} else {
		delete obsResource.effectiveDateTime;
	}

	var dateTimeOfAnalysis = obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfAnalysis) {
		obsResource.issued.@value = convertHL7DateTime(dateTimeOfAnalysis);
	} else {
		delete obsResource.issued;
	}

	// March 15: Issues #13: OBX.5 [Observation Value] using SN (Structured Numeric) data type
	var observationValue = &quot;&quot;;
	if (obs[&apos;OBX.5&apos;][&apos;SN.3&apos;]) {
		for each (var sn in obs[&apos;OBX.5&apos;].children()) {
			if (sn.toString()) observationValue += sn.toString(); 
		}
	} else {
		observationValue = obs[&apos;OBX.5&apos;].toString();
	}
	
	if (observationValue) {
		obsResource.valueString.@value = observationValue;
	} else {
		delete obsResource.valueString;
	}

	var abnormalFlags = obs[&apos;OBX.8&apos;].toString();
	if (abnormalFlags) {
		obsResource.interpretation.text.@value = abnormalFlags;
	} else {
		delete obsResource.interpretation;
	}

	var unitsOfMeasure = obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString();
	var meaningPresent = true;
	if (unitsOfMeasure) {
		obsResource.referenceRange.meaning.coding.code.@value = unitsOfMeasure;
		if (obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.system.@value = obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.system;
		}
		if (obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.display.@value = obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.display;
		}
	} else {
		delete obsResource.referenceRange.meaning;
		meaningPresent = false;
	}
	
	var referencesRange = obs[&apos;OBX.7&apos;].toString();
	var rangePresent = true;
	if (referencesRange) {
		obsResource.referenceRange.text.@value = referencesRange;
	} else {
		delete obsResource.referenceRange.text;
		rangePresent = false;
	}

	if (!meaningPresent &amp;&amp; !rangePresent) delete obsResource.referenceRange;

	// Reference to performing organization
//	obsResource.performer.reference.@value=&quot;Practitioner/obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	logger.error( &quot;Contained Observation: \n&quot; + obsResource.toString() );
	return obsResource.toString();
	
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>5</sequenceNumber>
                <name>Practitioner (Ordering Provider) resource</name>
                <script>/**
	Creates the Practitioner resourse for Ordering Provider with ORC segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getOrderingProvider(obs) {

	// Mar 16 update: /Practitioner/practitionerRole/organization is changed to 
	// /Practitioner/practitionerRole/managingOrganization - tooling issue on the &quot;left side&quot;
	// Note: this breaks STU3 1.4.0 XML Schema validation

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;ordering-provider&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;id value=&quot;orc21-ordering-facility-1&quot;/&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
								&lt;/identifier&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;telecom&gt;
									&lt;system value=&quot;phone&quot;/&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;use value=&quot;work&quot;/&gt;
								&lt;/telecom&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;system value=&quot;NPI&quot;/&gt;
							&lt;value value=&quot;&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
						&lt;practitionerRole&gt;
							&lt;managingOrganization&gt;
								&lt;reference value=&quot;Organization/orc21-ordering-facility-1&quot;/&gt;
							&lt;/managingOrganization&gt;
						&lt;/practitionerRole&gt;
					&lt;/Practitioner&gt;;

	// Practitioner&apos;s own ID
	resPractitioner.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.system.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.13&apos;].toString();

	// Organization this Practitioner belongs to
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.1&apos;].toString();

	// Organization telecom
	var telecom = &quot;(&quot; + obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.6&apos;].toString() + &quot;) &quot; + convertPhone(obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.7&apos;].toString());
	if (telecom.length &gt; 4) {
		resPractitioner.contained.Organization.telecom.value.@value = telecom;
	} else delete resPractitioner.contained.Organization.telecom;

	// Organization address
	var addressInUse = false;
	var line = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;

	// Practitioner name
	var familyName = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);	
	} else {
		delete resPractitioner.name;
	}

	return resPractitioner.toString();	
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates the Practitioner resourse for Ordering Provider with ORC segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getOrderingProvider(obs) {

	// Mar 16 update: /Practitioner/practitionerRole/organization is changed to 
	// /Practitioner/practitionerRole/managingOrganization - tooling issue on the &quot;left side&quot;
	// Note: this breaks STU3 1.4.0 XML Schema validation

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;ordering-provider&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;id value=&quot;orc21-ordering-facility-1&quot;/&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
								&lt;/identifier&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;telecom&gt;
									&lt;system value=&quot;phone&quot;/&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;use value=&quot;work&quot;/&gt;
								&lt;/telecom&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;system value=&quot;NPI&quot;/&gt;
							&lt;value value=&quot;&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
						&lt;practitionerRole&gt;
							&lt;managingOrganization&gt;
								&lt;reference value=&quot;Organization/orc21-ordering-facility-1&quot;/&gt;
							&lt;/managingOrganization&gt;
						&lt;/practitionerRole&gt;
					&lt;/Practitioner&gt;;

	// Practitioner&apos;s own ID
	resPractitioner.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.system.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.13&apos;].toString();

	// Organization this Practitioner belongs to
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.1&apos;].toString();

	// Organization telecom
	var telecom = &quot;(&quot; + obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.6&apos;].toString() + &quot;) &quot; + convertPhone(obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.7&apos;].toString());
	if (telecom.length &gt; 4) {
		resPractitioner.contained.Organization.telecom.value.@value = telecom;
	} else delete resPractitioner.contained.Organization.telecom;

	// Organization address
	var addressInUse = false;
	var line = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;

	// Practitioner name
	var familyName = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);	
	} else {
		delete resPractitioner.name;
	}

	return resPractitioner.toString();	
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>6</sequenceNumber>
                <name>Practitioner (Performing Organization) resource</name>
                <script>/**
	Creates the Practitioner resourse for OBX.23 [Performing Organization Name],
	OBX.24 [Performing Organization Address] and OBX.25[Performing Organization Medical Director] for each OBX segment

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getPerformingProvider(obs) {

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;obx-performing-organization&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;assigner id=&quot;CLIA&quot;/&gt;
								&lt;/identifier&gt;
								&lt;type&gt;
									&lt;text value=&quot;FI&quot;/&gt;
								&lt;/type&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;type&gt;
								&lt;text value=&quot;NPI&quot;/&gt;
							&lt;/type&gt;
							&lt;value value=&quot;&quot;/&gt;
							&lt;assigner id=&quot;EN&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
					&lt;/Practitioner&gt;;

	// Performing Organization Name
	resPractitioner.id.@value = &quot;obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;OBX.23&apos;][&apos;XON.1&apos;].toString();
	

	// Performing Organization Address
	var addressInUse = false;
	var line = obs[&apos;OBX.24&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;OBX.24&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;OBX.24&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;OBX.24&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;


	// Medical Director
	resPractitioner.identifier.value.@value = obs[&apos;OBX.25&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.assigner.@id = obs[&apos;OBX.25&apos;][&apos;XCN.14&apos;][&apos;HD.1&apos;].toString()

	// Medical Director Name
	var familyName = obs[&apos;OBX.25&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;suffix value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString() +&apos;&quot;/&gt;&apos;);				
	} else {
		delete resPractitioner.name;
	}

	
	return resPractitioner.toString();		
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates the Practitioner resourse for OBX.23 [Performing Organization Name],
	OBX.24 [Performing Organization Address] and OBX.25[Performing Organization Medical Director] for each OBX segment

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getPerformingProvider(obs) {

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;obx-performing-organization&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;assigner id=&quot;CLIA&quot;/&gt;
								&lt;/identifier&gt;
								&lt;type&gt;
									&lt;text value=&quot;FI&quot;/&gt;
								&lt;/type&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;type&gt;
								&lt;text value=&quot;NPI&quot;/&gt;
							&lt;/type&gt;
							&lt;value value=&quot;&quot;/&gt;
							&lt;assigner id=&quot;EN&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
					&lt;/Practitioner&gt;;

	// Performing Organization Name
	resPractitioner.id.@value = &quot;obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;OBX.23&apos;][&apos;XON.1&apos;].toString();
	

	// Performing Organization Address
	var addressInUse = false;
	var line = obs[&apos;OBX.24&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;OBX.24&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;OBX.24&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;OBX.24&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;


	// Medical Director
	resPractitioner.identifier.value.@value = obs[&apos;OBX.25&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.assigner.@id = obs[&apos;OBX.25&apos;][&apos;XCN.14&apos;][&apos;HD.1&apos;].toString()

	// Medical Director Name
	var familyName = obs[&apos;OBX.25&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;suffix value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString() +&apos;&quot;/&gt;&apos;);				
	} else {
		delete resPractitioner.name;
	}

	
	return resPractitioner.toString();		
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64">TVNIfF5+XCZ8UUxTfFRNRV4wNUQwNjQyODI3XkNMSUF8fDkwMDQ2MDAzfDIwMTcwNTExMTEyODM3
LjAwMC0wNzAwfHxPUlVeUjAxXk9SVV9SMDF8ODAwMDAwMDAwMDAwMDEwMzMyMDF8UHwyLjUuMXwx
fHxBTHxORXx8fHx8TFJJX05HX1JOX1Byb2ZpbGVeXjIuMTYuODQwLjEuMTEzODgzLjkuMjBeSVNP
DVBJRHwxfHxTQUZFLjExMTExMTExXl5eXlBUfjg1NjcxMDA5NjAyODQ0NjdeXl5eQU58fFNNSVRI
XkpJTExeXl5eXkx8fDE5NTgxMjI4fE18fHwxMTExIE1JTEwgU1ReXlJPU1dFTExeR0FeMzAwNzZe
VVNBDU5URXwxfEx8RkFTVElORzpOTw1PUkN8UkV8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5
ODZUXlFVRVNUX1RNRXx8Q018fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5e
TlBJfHx8fHx8fHx8U0FGRSBJUEMsQSBQUk9GRVNTSU9OQUwgQ09SUC5eXl5eXl5eXl45MDA0NjAw
M3w3OTA0IFNBTlRBIE1PTklDQSBCTFZEIFNURSAzMDBeTUFJTDAwMF5XRVNUIEhPTExZV09PRF5D
QV45MDA0Ni01MTcwXl5PXl5VU0F8Xl5eXl4zMTBeNTc5Mjc3OHx8fHx8fHx8MTEzNjNeQ0hMQU1Z
RElBL0dDIFJOQSxUTUFeOTlRREleNzAwMDAxMTM2M15eVU5JVENPREUNT0JSfDF8OV5RVUVTVF9U
TUVfOTAwNDYwMDN8V0gzNTA5ODZUXlFVRVNUX1RNRXwxNzEzNF5TUEVDIElEIE5PVElGSUNBVElP
Tl45OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfHx8fEd8fHx8fDE0OTc4NzUwMjVeS0FX
RVNDSF5HQVJZXl5eXl5eXl5eXk5QSXx8fHx8fDIwMTcwNTExMTEyODM3LjAwMC0wNzAwfHx8Rnx8
fHw5JlFVRVNUX1RNRV85MDA0NjAwM15XSDM1MDk4NlQmUVVFU1RfVE1FfHx8fHx8fHx8fHx8fHx8
fHx8fHx8MTEzNjNeQ0hMQU1ZRElBL0dDIFJOQSxUTUFeOTlRREleNzAwMDAxMTM2M15eVU5JVENP
REUNT0JYfDF8fDg2MDA2NTU2XkNPTU1FTlQ6Xjk5UURJXjgyNTEtMV5TZXJ2aWNlIENtbnQgWFhY
LUltcF5MTnwxfHx8fHx8fEZ8fHwyMDE3MDUxMTExMjgzNy4wMDAtMDcwMHx8fHx8MjAxNzA1MTEw
ODE3NDYuMDAwLTA3MDB8fHx8UVVFU1QgRElBR05PU1RJQ1MtV0VTVCBISUxMU15eXl5eXkZJXkNM
SUFeXjA1RDA2NDI4Mjd8ODQwMSBGQUxMQlJPT0sgQVZFTlVFXl5XRVNUIEhJTExTXkNBXjkxMzA0
LTMyMjZ8MTM2NjQ3OTA5OV5URVJSQVpBU15FTlJJUVVFXl5NRF5eXl5eXl5eTlBJXkVODU5URXwx
fEx8U3BlY2ltZW4gbGFiZWxzIG11c3QgaW5jbHVkZSB0d28gZm9ybXMgb2YgcGF0aWVudCANU1BN
fDF8fHxVU1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8MjAxNzA1
MTAxMzM2MDAuMDAwLTA3MDB8MjAxNzA1MTEwODE3NDcuMDAwLTA3MDANT1JDfFJFfDleUVVFU1Rf
VE1FXzkwMDQ2MDAzfFdIMzUwOTg2VF5RVUVTVF9UTUV8fENNfHx8fHx8fDE0OTc4NzUwMjVeS0FX
RVNDSF5HQVJZXl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEgUFJPRkVTU0lPTkFMIENP
UlAuXl5eXl5eXl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxWRCBTVEUgMzAwXk1BSUww
MDBeV0VTVCBIT0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5eXl5eMzEwXjU3OTI3NzgN
T0JSfDJ8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5ODZUXlFVRVNUX1RNRXwxMTM2M15DSExB
TVlESUEvR0MgUk5BLFRNQV45OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfHx8fHx8fHx8
MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTExMTI4Mzcu
MDAwLTA3MDB8fHxGDU5URXwxfEx8VGhpcyB0ZXN0IHdhcyBwZXJmb3JtZWQgdXNpbmcgdGhlIEFQ
VElNQSBDT01CTzIgQXNzYXkNT0JYfDF8U1R8NzAwNDM4MDBeQ0hMQU1ZRElBIFRSQUNIT01BVElT
IFJOQSwgVE1BXjk5UURJXjQzMzA0LTVeQyB0cmFjaCByUk5BIFhYWCBRbCBQQ1JeTE58MXxERVRF
Q1RFRHx8Tk9UIERFVEVDVEVEfEF8fHxGfHx8MjAxNzA1MTExMTI4MzcuMDAwLTA3MDB8fHx8fDIw
MTcwNTExMDgyOTAzLjAwMC0wNzAwfHx8fFFVRVNUIERJQUdOT1NUSUNTLVdFU1QgSElMTFNeXl5e
Xl5GSV5DTElBXl4wNUQwNjQyODI3fDg0MDEgRkFMTEJST09LIEFWRU5VRV5eV0VTVCBISUxMU15D
QV45MTMwNC0zMjI2fDEzNjY0NzkwOTleVEVSUkFaQVNeRU5SSVFVRV5eTUReXl5eXl5eXk5QSV5F
Tg1OVEV8MXxMfCANTlRFfDEwfEx8IA1PQlh8MnxTVHw3MDA0MzkwMF5ORUlTU0VSSUEgR09OT1JS
SE9FQUUgUk5BLCBUTUFeOTlRREleNDMzMDUtMl5OIGdvbm9ycmhvZWEgclJOQSBYWFggUWwgUENS
XkxOfDF8REVURUNURUR8fE5PVCBERVRFQ1RFRHxBfHx8Rnx8fDIwMTcwNTExMTEyODM3LjAwMC0w
NzAwfHx8fHwyMDE3MDUxMTA4MjkwMy4wMDAtMDcwMHx8fHxRVUVTVCBESUFHTk9TVElDUy1XRVNU
IEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9PSyBBVkVOVUVeXldF
U1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVOUklRVUVeXk1EXl5e
Xl5eXl5OUEleRU4NTlRFfDF8THwgDU5URXwxMHxMfCANU1BNfDF8MDFeMDF8fFVTUEVDXlNvdXJj
ZSwgVW5zcGVjaWZpZWReSEw3MDQ4N3x8fHx8fHx8fHx8fHwyMDE3MDUxMDEzMzYwMC4wMDAtMDcw
MHwyMDE3MDUxMTA4MTc0Ny4wMDAtMDcwMA1PUkN8UkV8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gz
NTA5ODZUXlFVRVNUX1RNRXx8Q018fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5e
Xl5eTlBJfHx8fHx8fHx8U0FGRSBJUEMsQSBQUk9GRVNTSU9OQUwgQ09SUC5eXl5eXl5eXl45MDA0
NjAwM3w3OTA0IFNBTlRBIE1PTklDQSBCTFZEIFNURSAzMDBeTUFJTDAwMF5XRVNUIEhPTExZV09P
RF5DQV45MDA0Ni01MTcwXl5PXl5VU0F8Xl5eXl4zMTBeNTc5Mjc3OHx8fHx8fHx8MTEzNjNeQ0hM
QU1ZRElBL0dDIFJOQSxUTUFeOTlRREleNzAwMDAxMTM2M15eVU5JVENPREUNT0JSfDN8OV5RVUVT
VF9UTUVfOTAwNDYwMDN8V0gzNTA5ODZUXlFVRVNUX1RNRXxDbGluaWNhbFBERlJlcG9ydDFeQ2xp
bmljYWwgUERGIFJlcG9ydCBXSDM1MDk4NlQtMV45OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAwMC0w
NzAwfHx8fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAx
NzA1MTExMTI4MzcuMDAwLTA3MDB8fHxGDU9CWHwxfEVEfENsaW5pY2FsUERGUmVwb3J0MV5DbGlu
aWNhbCBQREYgUmVwb3J0IFdIMzUwOTg2VC0xXjk5UURJfHxUTUVeSU1eXkJhc2U2NF5KVkJFUmkw
eExqVUtKZUxqejlNS015QXdJRzlpYWdvOFBDOU1aVzVuZEdnZ01UQXZSbWxzZEdWeUwwWnNZWFJs
UkdWamIyUmxQajV6ZEhKbFlXMEtlSndyNUFJQUFPNEFmQXBsYm1SemRISmxZVzBLWlc1a2IySnFD
alFnTUNCdlltb0tQRHd2VEdWdVozUm9JRFl5TDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlQ0K2Mz
UnlaV0Z0Q25pY1V3amtLdVJ5Q3VIU2o4ZzBVTEJVQ0Vuak1sUXdBRUpEQlZOakl3VmpBNFdRWEM2
TkFFZDNWNkNJdjV1Q2tXWklGcGRyQ0ZjZ0Z3QlZOd3ZLQ21WdVpITjBjbVZoYlFwbGJtUnZZbW9L
TlNBd0lHOWlhZ284UEM5TVpXNW5kR2dnTVRBdlJtbHNkR1Z5TDBac1lYUmxSR1ZqYjJSbFBqNXpk
SEpsWVcwS2VKd3I1QUlBQU80QWZBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqWWdNQ0J2WW1vS1BE
d3ZUR1Z1WjNSb0lEWXpMMFpwYkhSbGNpOUdiR0YwWlVSbFkyOWtaVDQrYzNSeVpXRnRDbmljVXdq
a0t1UnlDdUhTajhnMFZMQlVDRW5qTWxRd0FFSkRCVk5qSXdWakE0V1FYQzZOQUVkM1Z3VWpCWDgz
QlNQTmtDd3UxeEN1UUM0QVZYUUx6QXBsYm1SemRISmxZVzBLWlc1a2IySnFDamtnTUNCdlltb0tQ
RHd2VEdWdVozUm9JREkzT1RBdlJtbHNkR1Z5TDBac1lYUmxSR1ZqYjJSbFBqNXpkSEpsWVcwS2VK
ekZXdDEzbTdnU2Y4OWZ3VG43c2oybklaSVFJUEpHYlpLd2E1dlU5bTVQNzNZZnFFTVM3clZOaXUz
MjlML2ZFVVpDaUEvVEpMZmI5dXlDbU5IOFprYWFEOG5ZUVBEM0hNTi9YSThZcTgzWmx6TmNqR0VE
TS82dkdIS1p5WmgzcExXd2FjUC9MY3ZFTmtLb1lMb0lOOWdZWjJmdno5NHR6eTZ1YklNYXkvdHlJ
cGdjVzlTZzFDVFlNWlliNDY5ZmpUZkczOGJ5TjZDRWI2Uk82bmltWlJHRTRCR1p4R2x3dUFiR05R
N0trSWxzaGpBMVBCTjdSL3A1OHBUbCt6Y0daL3gxc1kvM2g5MWwrWGFWYnVPMW5FNkhhcnMyWURC
dGk1d1ViQ09BNmhLUE9RWnhRVExpb0F1bXhUUmMzcnd0NWYwV1RpYmxKTUVTYklrTWFwc09vOXgw
RytNY21aYkRSeXhDT2YvYUlNZzFFWi9MN2hrdStmbXdZenIwT095WWlNS2pCY1BIV1pXQlIrUEQy
ZllNTElwY1JpMzRUbDFxZ3lvbWRxaUxIR04rZmZiWDM2RFhIUXk1cEZEbDI1a0VKK0Yyb0ZpQTU3
K2N0WDZzOGRpdXlaQlVTQ0tIWVVwcHR6YlBBdjlqYUJvYVZCODNNTE5LV2hpbERiSWNleFplVkJQ
WkM3Tk9laTRBU2FybW9rSTFkelZXUjEybEg0TmZRSzlrNmRaYWlLRGd3dmEwYXh2SU1nazFiTXYw
R1BLOGN1UGV4dnMwMllxZEcyN3ZzM3dEUTlsVzNVSUFUUGRwVFZ1SzdMWjNxVDlGMUhRc3oyTzBa
Z1Z1YzhzcDNQRWFxNjhHVVlkd2RHUjk5RWlsR2s4QktyM1RBZjVaS0UvSnIxQnFhMVBieWRKdWJT
aGZ0aTNxd3JvZzZsUjE4M2U2dGczNXE3aGJOMUhQTGlBOHp3RVoxNnUrRnhaUHlTcmRKTnYremNB
dERTeWU0Mm11VklmbFZyQmR4N1JzOEl1dEQ5ZnNCV213TFJDRDhTWDN5OWRlSys0NlFHMi8xR0hx
eEcxS3FrN2czUFYzdXhHNk94VC9JUTJ4NTdsY3d4S3RESXk2L0VxbitnS1hkcW1IQWx2UnFRSDJa
Y3UzVldZWDRBN2lWbjkyTHBrMmRmNXZJYXhqNTFIRVRHTHg3YVp0dk5INmRBNXFwT3RtY2NPbmhy
a1p4NitXRHNyQTYxUUtBd01pZHFDd0pXcmhlRVRJeHlXaUR1U3ZFcnNiSUNxc3luQkZ4MWk1V280
RlRXMEkxV2VTQkcySzFNWmZVQW0zZ3RTVVFYV3FGdVROZXEydHZ0Ulh6UXQwYUN3WlZBZFVlZ0ZB
RzQ0TjlNV1d3QjZEMUdUQ0Z1VThlVkpJRksxaFJVdDUrMWZ1TDYwL0trUlhMVmxQVXlSM0tFYk5B
dEdEM2dxN0VGZU8wNHlqZDZLVHcrU0NzQXZzMmF5Y1NqSjZ3R2t4aUM0NnQzOGRDRzdKeFp2QU5z
RVkranVHTFlUb2tmYzYyZDRsK2FVdXk0YjJrNkpqdzFwbm1CNGxkVUhUeVJ1a1J4U0U4RzRVVWtw
WklEOW0yNlFQaEVZL3UyNURjWnphc2sxaUF3Q250ZlllOTBuUldCZitWUUNHUHY3cEZraGQwM09C
cThSMms4VHIvZU1nZVJvbnN4MFhJK1E1aURCS0hWY1JLVHVFdnFwUkxVK1pHak9xZXZDMWc5K3cy
cHEvMTZLS2dyUVdBam8wZUhZTzdRVlJZYTBGTnpFZ0kwa2pjTGVrSFduaExuVmVIcTBiQ2FWRG9k
YkUwOVhadEMrVDF3RjdNa21XeDJwYW1GSmFCOGN6WFl0V0oxQmw2OURZVXNTaFpjMmpjWHk0c1d6
a01XZlo0S2lFTUdKU3UwQlZIcko5T2FTN2xGZEdQWEkwSmxUOGNYcWtlTGFKWFNyRDRpVCtYRWFJ
ZVhKZlB2M1NJMDlqOXpxUCtoU1JHQkdUUVREUlEzRy96VEcyVElvckU0Nnk5VHBaN1pPN0huUTZE
N0l2TUxvZ0NMdU5pSW1wS081MXBndVJBSzFMeXltZmI4ZDluc01FbHFsVmJNclNkYXNrL2RxUFZH
UGhTUEZKcEJxVFFJcllKWGFISWJXWXllektmOGVUM0g2a0dzc3dwQnFUdENtK0pLeUJWTyswKzdv
a3RTdGphb1NyT3A2WEIrd2Y2TmYwQnJPN094YkR0UkRPMld2eFNOR3ZGdjA2OUg1MjY2eHIxbEt6
YXRnMm5Vb29CdXNiVjdLdXJjN1RwdVBMSTMrNzhJWVNqU3pjempYZzNLQjlOYjZHSWdQcWgvWVVW
dlhnV2o2cTllQy9pS0lkbWhFS1lkcHFWb3Jlc1ZTRWVXQkN6NUs5L05RUEp6Q3VNMVJ5dGZ6MHUv
OGhXSXhrbzNMdHp6OTI4MnE1aGxmQm9wcTlIYjMxUlJpWlIxZkJZaEZHTTM5U0RvMmkrYTNaUFMr
R0FvTnhKY3B5MS9VUUZaZFovbXdwSnA1R3MzQWtYdDVOL2h3TG1xV0FZZlZwamdreUhjeUxycklF
Q0JiTGt1OG1ta3crZm9paXNiQ0RGRk40NE56R0xxcEM0L3Y2cmFFTGRUczBYS0l4YlBnY3lMRHBs
UmxpTkFtRG1SQzdDT1ovaHFOZ0lkek5ZQkU1ME1JeHkyMzBlTVNDK0crclV5MXVnMUU0RFdhQ1d5
OXBlSWZKT0pMdTVaMC9xRENKZll3VTVaSjhmMGgyZTJHUTRxVjhIcWZ4d3piYjdkUFZUbnplUHli
bFU3emJaYXMwaGhSV0RxeXpoMHg4MjRyQmVMM3VvdStRVkk1czR2eC80am5PazRiNGZSN2ZKU3BS
ZHQ4L3I5bnBWOHc4dGR2WG5jb2dvTmlsVTZNcCtHRzV1RlRxS0s5RzdpSEROWkZZMzFmK1lobk9y
aTluVWYySURSTVIrNG5JUklTZktoVEhQK1ZUR2JHTTVwRUhVSlJWdXBoRXZDc1JxWEVERFh5dWFi
UG1WVFhXVllhaWhZRW9ZcGx1R1FDV2xVVm44U1pwTEZtQ3hmR0t3aFNLQS81NXZIMFFQRWVqcTh1
UjhIMUFHTTliQ25OMEVBS2orOVpwbEJrc1JpRkdXOFdGZFRVRFZOVkpubXhYU1F0N0ZWOXRIaVVo
WDFDVnRTak5TL040SGRheGdOekcxZEhxemNTZmZoeUgvc1hNRkNFMm1rWHorVTBVK0VHUFdHMmVZ
S2JUSW9QV1NScG5FTno2dExDK1JqbWYrV0xmTHFkK0Q0aFRFaEEvU1c2alVKWlBpMmV4NlVEVkE2
d01FODFNQXRiY0g5MUVVMzhaTGhvV3IvbFlBZnNjS0JhQmpPRHdMZUlvYVBydG95eE1sV2tjTElQ
Uk1oajM0MVhXcEZQSE80dEVWcWhtYWxwYzBkYzU2UnozQkFXNGw3akY5MU9VRU8wR3o2VlJDcGMr
WmJ4MS9pcTIzVWhvbStVaWdseUxoOE5xbmFTcjhzMWZwU0l6K0p1bmRYcWZyc3JMaWFPRGloQ2tv
L1VHbzlVb1AvMDY4LzNscHpmbDdIbXlPNnhGeE5rOVpvZTF3UEpaS0pKdTkwbitsQ2RWQWtzRnRs
VzIvZTlodTFLdVV0U29pd1pqMUVtL3BmSVVNWVBNSnd5NGpqOW5lYnpQOHUrTmRMdGFwMXV3bThp
NWQvRStGalJmNHhRWTF6Si9aaTFROFhDb0dtbVZtSThRMG5ncjRtQjRyNEZiZjVjR3ZPTk9UdTdF
THJ3LzVKV2VEWFJrT0RxTmRBK0xKOTArQ0J5eGNKeDA3bE9TODlzdzZWcTU3Q3E5ZGtYaUU0OVAw
cENIWFRGekE2MDFISzFHS3VIRmExaHlXekNRcUlteWRiSTZyR094RVBaeC9wRHNoWjJYb3ZySzhq
dTVWcFFwR2doUFJYMEZvVVo2RkN4UVZNWEJZU2VnWWh0WjVZRTU3TFdSd0FoVjIrb3g0N2VPTzdu
M3NpNS9kd1Q2Tm53YUtaZHVTZWt5SXo5azJ5elBIN01rVGo2OWFiUXAvUFpvdU1UVFVSbDNCTnNo
T1pQek1vemwvYzRzQ0JmUVJNaTgyYXd0VHVmTlorR3BFaWRtZFVpRGs2Zk8rTU1KRkxNWFpsQjln
alpuRGM4a0owbWh3Um9lODNYU2Z5V05rdUdCWHlmOWVZbVVESS8vT3VuUFRxUmtlUERYU1g5Q0lp
WERBNzlPK2k4a1VqSThEZWlrUHltUmtpSVhFUDVMN1pNSU5kS2Zra2lKT3h5ZlJ2ck1SRXJZY0lt
blNHRTI3d1FKSkNuS3I4MXhnM1Q1bU82YTF2MFdpMEY5dVpaclVGdXgvdTB5bklyQVBJcW03eUlp
dnV4MjhmY21ZZ3NOUnF5VGZ1Sy94emkvelRPNXBjTHR5bXkxc29XSFN6bEZDck9SNGJNUjNjcnlV
SEFicjcvdmxjQlpHaml1em1GV2p6R3NYZGhNcVhyY0owL3Y5dEpqRFlEV2NJQWFhY3pkSkdManQw
ZjUwMVBZWnNMemU3SHBsWFd5T09USmJTeFR4NjY4ZkJhWUgrT3ZMZEhBb3NOaGFxU2ZFNG5zRHRK
anZrbTNFdDluRWV0UEhHK3FTT3poU0pxa3JTN29pSFN0NTZhV1MwMlh1dnp1NHZnem5HQitGYzJu
b1N4Y0Z1RXlVRTlTSGUxM2pEQUZMeDNGYjNHYVIyT0VtRkQ1MTZuZS8xR2Q5bzlELzNvV0xaYmhh
SEd1WGdLRWs4bENyQVpHa1FpdlYvNWs4bTRlUmIrTHpmMW5NUHNqRUlSZEUxUTNDTmhDOU53aVJG
eGRUL1R5WXB6bXlRcmV4VUYrTUp1SGdGZWtuV0ErOS8vakw5NU9xOXVKU2VnTFltU1BrVU1KSStM
MnR6akkvZ2NZMkQyckNtVnVaSE4wY21WaGJRcGxibVJ2WW1vS01UQWdNQ0J2WW1vS1BEd3ZWSGx3
WlM5WVQySnFaV04wTDBOdmJHOXlVM0JoWTJWYkwwbERRMEpoYzJWa0lERTRJREFnVWwwdlUzVmlk
SGx3WlM5SmJXRm5aUzlPWVcxbEwwbHRNUzlDYVhSelVHVnlRMjl0Y0c5dVpXNTBJRGd2VjJsa2RH
Z2dNamd6TDB4bGJtZDBhQ0F6TkRFNEwwaGxhV2RvZENBeE1UTXZSbWxzZEdWeUwwWnNZWFJsUkdW
amIyUmxQajV6ZEhKbFlXMEtlSnp0bmIrdTY3Z1J4dDhuMVNhQWtjY3cwdTFEM0dMYmJWT2t1RWlW
S25tQlZFR2FBRnU3U0pjcVZmcThpRmU0Z3pQZ25YK2NvVWhKOXZrK0VJYVBqMFJSTW4rYTRYQW9Q
NThRQkVFUUJFRVFCRUVRQkVFUUJFRVFCRUVRQkVFUUJFRVFCRUVRQkVFUUJFRVFCRUVRQkVFUUJF
Rkg2SC8vLzg4Ly8vMVhLbi84KzA5dDRjKzNzbTEyZGtzaDZITGF1Q0NDTmw3dWYvcmg5dk52OG1Y
YmZpdkVHdmlDUHJuR0lJb0xXYkd6end5Q2p0Tm1Tclp1LytWdnYvT016b0NSNHNKWXdXWkJieTlD
aWJzOXZkR3ZIbGJrM1hVSFVPeERZcHdGdmF0aWxNdy9CVVJBQTRKSUFpVmRUS3pnczBHUTBFWUVq
NVU4Zk1UbnNFY1FaR3BESTdCS3VzQWtRWkFwTmt4QUNZSjJhblBZdERzSGxDQm9RQnROU1pRMkU0
WVpXQWdLRk5PMEVjU3ZNRXltSHYvOVpTdGYvL0dISC8vOGV5cmI5ZVQzMitmYmY4OXVJM1NRS0FR
Um9NUnZZSmkwaUtOa2Nnakl5dWlsTHhHTm03cUdhWHVGWVJMYXZuZXlSTlVDcklTMnE2RXYwZG1O
R3BFWGhSQW9iU2JzN0paZVRubXI1QlV3eGRKQWJYZXFzeHRWMW1aeFRFK1BPYUt5aUNheWQ1Uzh4
MysraXZiVEJLWmF2UUZROFh3VE16VjMwRVJwZ1pUT2RQOCtwWlpiY3YyZ1Iwd1RoeURhTUFXWWl2
VUdRSm1CQ0xaS2Mya2FXRHhGQVpBTGtxVy8rc3pJS0I1dGdhbFhCNm9iSko5Q0U5bWpuVTdScGVL
S0hrM0pFYlMzKzJ0MW5oVjZhYUMyZnE0REVlMjRhWDk0WEt6NDJGbXVFeEl4clV3cEh1V1pLcThT
ZGgyNVpBNVIzZVg1RWZ3WFpjeDBzcS9iMWhOWFpRSlZhditKTW9kT0xWQjdhREt0MHIyM0xGR1Bw
elJUcDd0L3BuMFppTzU2ZHNyc09kWDc5a0Q4dVR2S3k1UFZuVWNnVFBMWDVQcldLbkQyOXR1bS9T
Z0ZaSjF1cDh5dU1sWlZuczJsUUpYbTBicE14VkRFV0hYM3ZleTBWR3llaGp0dHUzZ3FUNUI0N2Rx
c0U4ZFRzOHdUUy9ka0U1WjFRT1g3ZitaOHEvTUk0a1F5amJtZ25Zck4wekJOVkczQWtSaXlpVFow
V1d2TFdZNmYrWTN2Y2UrVEZTNENhb0NtNEpRSGFxdGFxQzdScDBqMzgvdSt6Q0k5WWhwQVNSZXZu
bHZGOFpzYmRkZDM0UDFmN29sQWVZRVJia0F3ZzZZYmFWNmN0cW8yM2RFY1JwbEFjV3B4VzY0VG80
ak4wNEEzcGRmSUIyKzZSWlB1RGErU3padjdsRC9kdGZaL3N4bElWd0JsdW1mZTZlZ1QxeFdLYlFJ
bjA0dHZ2R0xZWEQ4Z2dzc1lUYnFybHdqSzhHWENsV3p0dHRsMnl2WHJaR2k2ditkVnEzdlJDcUJL
TndmejNPTUtCNjdNeXdIVnB1Mkp2anJRNjZpMm0rV1l6UzM2RUxlSzE3ZHRQOFhyeTNTcUtkVWVB
TlJBWEYzdklwQVJRQTJ3OEhKQWNkeGd2N1BIQ2VvYXBVVlk2ZnFUVGIxL3l3eXNYeTJwZHdKSysz
c1pneExYYVVZc1MzYnF0WUJxVXlORW42LzJONUZsNFZrOXI0amxpdUxQZkVuYW5SSjlnZDdKNVJ1
ekpocVo5cjllekR5L1ZQbTFnQkpoN2JaN2x6eWlOa0c5Wkl6RTZpb1RKZkY1WUtGdTZlQTVSU0Qz
aHlZV0FYVktVRUlEMVM3Yk40c1o3bXRQdnh2MDdwTDFXa0MxaWVVdENOV2Uxb1kxdWtCNUVJbFhr
Nit1d1VxMm5FNThpdGVYQ1hhdHFITTZVSEhQejVleGlhUjg2dEdWZ2ZKQUtKa25QUXJ6bURMcEVJ
c1dXNVQwSjEyeVNrQk5pZlZwYTdMekd6OWxZbmQ0UGpmVDFId2lVMlllNnJKQWVmSHRrbmtTTkhr
b21hWkhGL0c1WjdDQ0VWWUpxTnVhQUlMWk1mSXl4eDE2czdsQTZRb25Bc1VOeUtRaGRXT1BWd2Fx
YlNmM3lWSU45MFI0WEZNUVk5VXRMV0tpNUlNU2ROWlRndWU2VjJTKzlIYjl3cU5aeHR2dFkrWkJG
NDJoQmtvbVZ6YS9WUG1GZ0dxTkM3K1d6RlB3a0RGdnhMU3pCTmFxQkJSYnFDa3BFNlVFZzNpdi9E
MWZieFlmYmxHVWI0OHlONUFYQXFyTnRXT204bmRzVGxqS1c2anBSUU5idFZEclpxTXlUTzFKcGE0
ZXJoczVISnVIMnE4WW1SY0M2b3Y2K2M1ODd5Sm5yOHZSVHRkdXdGb2wyejhYcUtkdmJuYjZQOEUw
YUNtNm1GbGpNdHgxcDA4VHZDaFErODFUWUp0YVR5em00aS8vK3ExKzFSOTI0Y3BISk5yQlk1N0Jy
and1dXJrQmdaMEtPazh5M3p2WU9KUExsOHcraWxuT0xBMStkYUJFUktMYXRhYjRlRXlLaVkvZ3lN
T3F0VlBKRzRLWXpoNjloRkt4LzZhZm4wQi9kdVBKWG0vMGJLSUlDd1NIMERWN2hzeWJJV3JiRUsr
dUNpWndkUXU3OFh5OUJ1VDB0UnNhcU5KNm9zQTJaUUlScGxVeUxSU1hBQ3MrU2pVaU1SZW81OVRa
bk80OU9aT0VNSUJxTjFrb1dBL1Y5U0ZGUFY1UUlzNndOVS93Z2tEbDQxMWZ3cDlkNjVvbnp6QzE3
QWl2VDZCa1lwVy9JWHo1ZnZBNGVnbHQ1U2N4cTB6cFBsTmFYWjUzNTRiYjM4Mk1UYlp6NERTdkJs
VCtScDBjUFpsWUJTaDU1c2w4WXhxcC9BMWg3TVJMcWo1SW9lMU93YjY2MnlRN0xSbUZKRkJqN2Qr
VElORkY0NDJCaXVlZWt1WkpXNlc0ZU9Pc3RpVDlQVzJhZDF6RlNBUGRpWWNHZ1R1bjNhcWthMWRk
N3BSbktvNjZkSjlGbHFtbjY5OWVEYWpTMHJ5Ylk1N2lvWk9KVWdtcklQcFhIUUFPM0VuR0ZJdzR1
QmVabzNVaUpmbndCQStyZG1OZFlYTDFSRENFS1QyWHo3c095Y1o0TlZRWFdDMlNBS29VY1BiTVUy
Q2J0TE0zVUFJN2xRLzQ2eWNFN3JpS05UMktEMDNkYzRoMU5lK3YvMUYvZXEyMyszQWJwa3NBbGR5
TC9iMnFlWW9qZUR2SnFzNUhIMm1ob0UraUZxaDhweHFMNzQyTm0vSXUzOEI4TklDQ3BxdWFmaFBu
bGg5am0weXNCazU1WVBBSVFiRjROSkhzVk42UGhBcWFCRlpUUms4QlUzbnpKSjd2QktDZ3VSb0F5
ak5QZVFzMUY2anFZcFBXd3BhaU1SRFVGUThvcWtBdEdqMXQ5WXMzWGZPVVA5azJQWDRndkFsQlhY
RmNvclJzZk1CQ2pSbXBMbGJWQjErSUJ0K0tDZllRMU5VWVVBTVdLdVlpWCtnNS85V24vWXZWVyt0
Q2ZIc1docmMxekczVmU0dW1uaTh5SjNXdkxIc2ZzMUFacjIvMWFmS1B5d3VtcGtja3ZIU0kvTFEr
WlFMTWJkVkxxOHNMcFVpdHZndnhYWkh2amVaTmtvWkZwNCtobGc1azZDR2MydGxiTVlDNitjdmZI
dC8vYm90WHc5VVNBRTRYWmZFRjErU1lyQW5tbWhLbG50Kys2MWxBTFlyeXpiOEszNlRORTF1bzZR
T29HQllTWVhYTlphY1hWQmVvdzVwQlgxazNHZktlZm95NU53K1ZRU2taNVp2ZXczVXNZcDIvOTh3
Qjlmem9KR0FxbzZzQlJiNWZrQmk4ZGJsU3BvUm5vV1pOUmMyOURqelhySmxhNFdmbU1SbjIvQWM4
bklNelVhdTd4QnQzbjFreHZVazdmVWo2N2M3UzR2RzVVYjUxNDZuVzJSUG1hWHA4ajFTeU8yYjhn
ZTUrNHNQaGxRdm00Z3ZleXp3Vzk5NTJ4SmM4WFA0cG5kNzJkT2NYcDZDMzBSdDREY3MzeVZ5UFB4
WS96QU9WekQ3YW4zcFVQUVd6cWR3R3pkU2lqS01TVVBUMWllL0w3T1E4N0RLZnhoQS94YVYxVHRx
OStMMCtCVjdlSzU2RlFtVEZEMk14ZHpHdkNkdm90bTM2RU93ZWUzTVFIbER0MGMwbWlWMzQwT2Ex
TXErd0o1cmlTVzRaTzN2N1hiNHA0eW1LN0huTzNycjUzT3JJU1BkUEU2aW4vK3c3NmdiNnY3Rkwr
ZlhqZDJwTW9JSmVaQjZPYVRKM01RZU1nVmt4SzQramZPWUczcFY1V201a3ZqM1R4Um1BaTBJVFUr
elUxc2lXOFdQTTA3TU9GTWRnV1I1UW5zd2hSaWJvNFFVYjQzdXllYmlnNjNwNzBTZEI4OFNXVmFB
eVRXci9heHJyWTZTbmRhcEJpU1JXZTR3SXVhWmVPOWVsR3cwQWRWTS8rVmVOL3VsZFRHZFM2MmF0
TGUyZWdyZ0pKSU1HNGt6enNic0JvQWJpR01rcnRrakJRbmpORkkraDhrWnFTb2ZuZ0htTDFWTHo5
RndQRkkrZTJoWDBlaGR0K0pKSGYxcGVxSkM0bVNlN290NnNHN0lnRFFBMVFFZnN0UjRnblRVUm1D
ZnQ5WGxZeloyS01pZWhsbWJEcm5QNWdpZWM2SU1tbXhFRUpmSjdKWE9sVEsrUEd4ODhZV01ZcUc2
VGREMmlQZFVhZHNyc3JsMnlBcUJXZEhYUnlOV0xOVXBBbVo2SkNaUUlRUEh1ajQrSE9aOExWSDR1
Vzljc2d0VTYrRFlBMUo1OFNESFJjSENpTW9XbXgwSVQvT0VpbE5wR0h1RHNrVmFFemJzT2pPbnla
WHJVRkpkdjJFTHBEY3d3OVRFdW42NHpDTEF2RlMybTBFekZSb3BRV3BGclpJcG1lQTg0Vmg0b0x4
Q242Y2pFNjBwem5YRUREaHRESlZ0MUNsQkJlNDRSWWRVR3EwMVR0VUcwYlVNY0hieXk3NWpENVM5
K01IK2tnWXA3dU9sMHhYSGoxckhScDFBQ2FpektWNjEvZFpRdjBPa0xhdlJLd0ZNSU9rVVpvT0tB
VXRWQ2ViZlFoNS9Zd0hPK1U4WlF6NkY1cUh6OUdWL1I5SnhMODFDQlRnZnFNNnZiK2J2WkxLVXgx
Q1BNN1hrMlB5VkFrU3YrczgzVzA2ZFFCZW9aVGdlYnlILzFGeVpYWXl6RG1SSnRuVHFIc04zeTRO
REU4U29sOUI0cDdxNmljSjVQcHJ0Ni9odU5qdHZnM3UwakphOUw4WThmUzNqYVVLSHBLNDRCMVJy
RVI1TnQ2UEhPTjViMnBMeTdEZmQvM2l3VHRUREQ4bDZUK05CZlZiYms4UU9vZzhWNWVxdkRnd015
cDRwdUg4L0R6OXpvZ25rb1hhYzNzWnR2N1N5Z3VvM1VlbFN5dThXVytUQ2dQa1RYM0l2MkJKZmkx
VVhEc1RhSC9KcDJhcDBleGFWR2NWV0xuSmxxSS9QYkQ1OTRxVW16cnZERlJXNmVDQnQrUXFhUzZu
YUpiaVFCZWxlMUtPbWxJbURLbEJoMnRmK0t3NHpRZXl0R3FaMU5CbE5DWWxBZzNvT21UeVVlTHBr
TEdNMWxnOXZuWjdmNmlucDgvME5wcDZSOVFpZUtIVHk5K0NJbzhQb2dxQldsVXJRbzZlVEFnS2F6
bXc5QlZ4RWxBYkxubHJGSE1FelFlNnVVcmNmR2FJd2oycGlTYkZlZkZ3U2RvdGJLRUNtNnNPY21K
cVB2emNQR3hhdUFpRkdDVllJK2c4anVtTGszbWFKcGF2OTF3SHBiQ0xxbWlDeHRqQUtPdkgveCtx
bXp6d21DTGlFUmM0aHRFOFgweUVVRVJCRFVWZnRiaEZRKzFRcEVDSUlnQ0lJZ0NJSWdDSUlnQ0lJ
Z0NJS2c5OWF2YnBmZGVBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqRTRJREFnYjJKcUNqdzhMMHhs
Ym1kMGFDQXlOVGsyTDA0Z015OUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVStQbk4wY21WaGJRcDRu
SjJXZDFSVDJSYUh6NzAzdlZDU0VJcVUwR3RvVWdKSURiMUlrUzRxTVFrUVNzQ1FBQ0kyUkZSd1JG
R1JwZ2d5S09DQW8wT1JzU0tLaFFGUnNlc0VHVVRVY1hBVUc1WkpaSzBaMzd4NTc4MmIzeC8zZm11
ZnZjL2RaKzk5MXJvQWtQeURCY0pNV0FtQURLRllGT0hueFlpTmkyZGdCd0VNOEFBRGJBRGdjTE96
UWhiNFJnS1pBbnpZakd5WkUvZ1h2Ym9PSVBuN0t0TS9qTUVBLzUrVXVWa2lNUUJRbUl6bjh2alpY
QmtYeVRnOVY1d2x0MC9KbUxZMFRjNHdTczRpV1lJeVZwTno4aXhiZlBhWlpRODU4ektFUEJuTGM4
N2laZkRrM0NmampUa1N2b3lSWUJrWDV3ajR1VEsrSm1PRGRFbUdRTVp2NUxFWmZFNDJBQ2lTM0M3
bWMxTmtiQzFqa2lneWdpM2plUURnU01sZjhOSXZXTXpQRThzUHhjN01XaTRTSktlSUdTWmNVNGFO
a3hPTDRjL1BUZWVMeGN3d0RqZU5JK0l4MkprWldSemhjZ0Jtei94WkZIbHRHYklpTzlnNE9UZ3di
UzF0dmlqVWYxMzhtNUwzZHBaZWhIL3VHVVFmK01QMlYzNlpEUUN3cG1XMTJmcUhiV2tWQUYzckFW
QzcvWWZOWUM4QWlySytkUTU5Y1I2NmZGNVN4T0lzWnl1cjNOeGNTd0dmYXlrdjZPLzZudzUvUTE5
OHoxSyszZS9sWVhqemt6aVNkREZEWGpkdVpucW1STVRJenVKdytRem1uNGY0SHdmK2RSNFdFZndr
dm9ndmxFVkV5NlpNSUV5V3RWdklFNGdGbVVLR1FQaWZtdmdQdy82azJibVdpZHI0RWRDV1dBS2xJ
UnBBZmg0QUtDb1JJQWw3WkN2UTczMEx4a2NEK2MyTDBabVluZnZQZ3Y1OVY3aE0vc2dXSkgrT1kw
ZEVNcmdTVWM3c212eGFBalFnQUVWQUErcEFHK2dERThBRXRzQVJ1QUFQNEFNQ1FTaUlCSEZnTWVD
Q0ZKQUJSQ0FYRklDMW9CaVVncTFnSjZnR2RhQVJOSU0yY0JoMGdXUGdORGdITG9ITFlBVGNBVkl3
RHA2QUtmQUt6RUFRaElYSUVCVlNoM1FnUThnY3NvVllrQnZrQXdWREVWQWNsQWdsUTBKSUFoVkE2
NkJTcUJ5cWh1cWhadWhiNkNoMEdyb0FEVU8zb0ZGb0V2b1ZlZ2NqTUFtbXdWcXdFV3dGczJCUE9B
aU9oQmZCeWZBeU9COHVncmZBbFhBRGZCRHVoRS9EbCtBUldBby9nYWNSZ0JBUk9xS0xNQkVXd2ta
Q2tYZ2tDUkVocTVBU3BBSnBRTnFRSHFRZnVZcElrYWZJV3hRR1JVVXhVRXlVQzhvZkZZWGlvcGFo
VnFFMm82cFJCMUNkcUQ3VVZkUW9hZ3IxRVUxR2E2TE4wYzdvQUhRc09obWRpeTVHVjZDYjBCM29z
K2dSOURqNkZRYURvV09NTVk0WWYwd2NKaFd6QXJNWnN4dlRqam1GR2NhTVlhYXhXS3c2MWh6cmln
M0ZjckJpYkRHMkNuc1FleEo3QlR1T2ZZTWo0blJ3dGpoZlhEeE9pQ3ZFVmVCYWNDZHdWM0FUdUJt
OEV0NFE3NHdQeGZQd3kvRmwrRVo4RDM0SVA0NmZJU2dUakFtdWhFaENLbUV0b1pMUVJqaEx1RXQ0
UVNRUzlZaE94SENpZ0xpR1dFazhSRHhQSENXK0pWRklaaVEyS1lFa0lXMGg3U2VkSXQwaXZTQ1R5
VVprRDNJOFdVemVRbTRtbnlIZko3OVJvQ3BZS2dRbzhCUldLOVFvZENwY1VYaW1pRmMwVlBSVVhL
eVlyMWloZUVSeFNQR3BFbDdKU0ltdHhGRmFwVlNqZEZUcGh0SzBNbFhaUmpsVU9VTjVzM0tMOGdY
bFJ4UXN4WWppUStGUmlpajdLR2NvWTFTRXFrOWxVN25VZGRSRzZsbnFPQTFETTZZRjBGSnBwYlJ2
YUlPMEtSV0tpcDFLdEVxZVNvM0tjUlVwSGFFYjBRUG82ZlF5K21INmRmbzdWUzFWVDFXKzZpYlZO
dFVycXEvVjVxaDVxUEhWU3RUYTFVYlUzcWt6MUgzVTA5UzNxWGVwMzlOQWFaaHBoR3ZrYXV6Uk9L
dnhkQTV0anNzYzdweVNPWWZuM05hRU5jMDBJelJYYU83VEhOQ2MxdExXOHRQSzBxclNPcVAxVkp1
dTdhR2RxcjFEKzRUMnBBNVZ4MDFIb0xORDU2VE9ZNFlLdzVPUnpxaGs5REdtZERWMS9YVWx1dlc2
ZzdvemVzWjZVWHFGZXUxNjkvUUoraXo5SlAwZCtyMzZVd1k2QmlFR0JRYXRCcmNOOFlZc3d4VERY
WWI5aHErTmpJMWlqRFlZZFJrOU1sWXpEakRPTjI0MXZtdENObkUzV1diU1lITE5GR1BLTWswejNX
MTYyUXcyc3pkTE1hc3hHektIelIzTUJlYTd6WWN0MEJaT0ZrS0xCb3NiVEJMVGs1bkRiR1dPV3RJ
dGd5MExMYnNzbjFrWldNVmJiYlBxdC9wb2JXK2RidDFvZmNlR1loTm9VMmpUWS9PcnJaa3QxN2JH
OXRwYzhsemZ1YXZuZHM5OWJtZHV4N2ZiWTNmVG5tb2ZZci9CdnRmK2c0T2pnOGloeldIUzBjQXgw
YkhXOFFhTHhncGpiV2FkZDBJN2VUbXRkanJtOU5iWndWbnNmTmo1RnhlbVM1cExpOHVqZWNieitQ
TWE1NDI1NnJseVhPdGRwVzRNdDBTM3ZXNVNkMTEzam51RCt3TVBmUStlUjVQSGhLZXBaNnJuUWM5
blh0WmVJcThPcjlkc1ovWks5aWx2eE52UHU4UjcwSWZpRStWVDdYUGZWODgzMmJmVmQ4clAzbStG
M3lsL3RIK1EvemIvR3dGYUFkeUE1b0NwUU1mQWxZRjlRYVNnQlVIVlFRK0N6WUpGd1QwaGNFaGd5
UGFRdS9NTjV3dm5kNFdDMElEUTdhSDN3b3pEbG9WOUg0NEpEd3V2Q1g4WVlSTlJFTkcvZ0xwZ3lZ
S1dCYThpdlNMTEl1OUVtVVJKb25xakZhTVRvcHVqWDhkNHg1VEhTR090WWxmR1hvclRpQlBFZGNk
ajQ2UGptK0tuRi9vczNMbHdQTUUrb1RqaCtpTGpSWG1MTGl6V1dKeSsrUGdTeFNXY0pVY1MwWWt4
aVMySjd6bWhuQWJPOU5LQXBiVkxwN2hzN2k3dUU1NEhid2R2a3UvS0wrZFBKTGttbFNjOVNuWk4z
cDQ4bWVLZVVwSHlWTUFXVkF1ZXAvcW4xcVcrVGd0TjI1LzJLVDBtdlQwRGw1R1ljVlJJRWFZSit6
SzFNL015aDdQTXM0cXpwTXVjbCsxY05pVUtFalZsUTltTHNydkZOTm5QMUlERVJMSmVNcHJqbGxP
VDh5WTNPdmRJbm5LZU1HOWd1ZG55VGNzbjhuM3p2MTZCV3NGZDBWdWdXN0MyWUhTbDU4cjZWZENx
cGF0NlYrdXZMbG85dnNadnpZRzFoTFZwYTM4b3RDNHNMM3k1TG1aZFQ1RlcwWnFpc2ZWKzYxdUxG
WXBGeFRjMnVHeW8yNGphS05nNHVHbnVwcXBOSDB0NEpSZExyVXNyU3Q5djVtNisrSlhOVjVWZmZk
cVN0R1d3ektGc3oxYk1WdUhXNjl2Y3R4MG9WeTdQTHgvYkhySzljd2RqUjhtT2x6dVg3THhRWVZk
UnQ0dXdTN0pMV2hsYzJWMWxVTFcxNm4xMVN2VklqVmROZTYxbTdhYmExN3Q1dTYvczhkalRWcWRW
VjFyM2JxOWc3ODE2di9yT0JxT0dpbjJZZlRuN0hqWkdOL1ovemZxNnVVbWpxYlRwdzM3aGZ1bUJp
QU45elk3TnpTMmFMV1d0Y0t1a2RmSmd3c0hMMzNoLzA5M0diS3R2cDdlWEhnS0hKSWNlZjV2NDdm
WERRWWQ3ajdDT3RIMW4rRjF0QjdXanBCUHFYTjQ1MVpYU0plMk82eDQrR25pMHQ4ZWxwK043eSsv
M0g5TTlWbk5jNVhqWkNjS0pvaE9mVHVhZm5ENlZkZXJwNmVUVFk3MUxldStjaVQxenJTKzhiL0Jz
ME5uejUzelBuZW4zN0Q5NTN2WDhzUXZPRjQ1ZVpGM3N1dVJ3cVhQQWZxRGpCL3NmT2dZZEJqdUhI
SWU2THp0ZDdobWVOM3ppaXZ1VjAxZTlyNTY3Rm5EdDBzajhrZUhyVWRkdjNraTRJYjNKdS9ub1Z2
cXQ1N2R6YnMvY1dYTVhmYmZrbnRLOWl2dWE5eHQrTlAyeFhlb2dQVDdxUFRyd1lNR0RPMlBjc1Nj
L1pmLzBmcnpvSWZsaHhZVE9SUE1qMjBmSEpuMG5MejllK0hqOFNkYVRtYWZGUHl2L1hQdk01Tmwz
djNqOE1qQVZPelgrWFBUODA2K2JYNmkvMlAvUzdtWHZkTmowL1ZjWnIyWmVsN3hSZjNQZ0xldHQv
N3VZZHhNenVlK3g3eXMvbUg3bytSajA4ZTZuakUrZmZnUDNoUFA3Q21WdVpITjBjbVZoYlFwbGJt
UnZZbW9LTWpBZ01DQnZZbW9LUER3dlRHVnVaM1JvSURFNU9UWXZSbWxzZEdWeUwwWnNZWFJsUkdW
amIyUmxQajV6ZEhKbFlXMEtlSnkxV2QxejJ6WVNmOWRmd1psN2NXWnFHcDhrNkh0U0pOcGhLMHVP
cERaejEvU0JrV21iYzVMb1NISTgvZSs3RUFrUUFFbkpzWHhwSmlXWCsvSGJCWGF4QzJFUHdYL25H
UDRKSStJdFZyM3ZQYnluWVE4TCtYZFBDb1V2UkZUeVV1eHorRCtsUHVZSW9iM1FSYkxDM3JEb2Zl
NTluUGN1cnJqSHZQbDlwUWlVWThvOHhueUNBMisrOHY0ODh6NTRmM256WDRFVHZoR2JOWWg4U2ds
QzhJaDhFalFrUWc5alM0SUo1Q011RUdaZTVPT281SjltVDhWbTk4R1RnbWV6WGJwNzNsNVdiMWY1
T2wxcWRTNVVIbkxBNEhOS2pocm1DS0NHSkJLQlIwS3dqQ1RvdmREc0pwbC8rcVd5OTJzeUdsVks0
am5FRW5tTSs0RmdNblFyN3h6NU5KQVVTcGlVWDNvRWhUNlN1dmdCY2lVdnlZRWZzSkljK0lqQkl3
VnlxZFVnUEhwZmV1c2VSQlNGZ2xINHprTEd3UlVmQnl4RWdUZTk3djM1Ri9oMUI2U1E3RjE1Nlds
d0dtNEhpaG1zL1BkZTYwZExob2UrUU5vaGpSeklqTEZ1Yjk0RS91ZlFORHlvUDY1QXM4bTZEMG9i
WkUxN0UxNWttVHdJMDJZOVY0QTBWM05USVd1NUdydkRkdW5uNE8raDE3YmNhTTFVVVFnaFBibVZR
TlFuek9QVWp3U0tvaXB4YjlOZG5xMVY1aWJyKzJLekFsS3hObE1JZ0xscmFubkxFRzk3MS80enhQ
eUFScEZnVmhSa3pHbXdYNDczMkgwV1JCZEN1WkEydGVReWcyY0ExYXZUQWY1TktJL1pyMUU2ZTlQ
SlpCMjNOcFNucFlWdHJBdWl5MldIdjNOcDI1Qy95M0s3SVRxUUJVU2VjOEFtL2JKellmYVVMZkpW
dGo2Y0RETFNJQklGa2JPVUpsbW5BZzhEbjNKWUYrNlNyWGpCTWRoV2lDSDRXdnIwdmRlSzJ3Ym81
SXNOMDJWdWM5SmNCQ2x0di9ORzZlNXcvS2M4eEZFVVNnOHJ0TG93dXZacm4rd05ydU5pbHdKdStO
UUFlOXIyYmJYWkJiaUR1WFU5TzdkTW16di90eExXa1hrTUNaOVFtVzVPNGcyV3g4K2d4bkhkYkc2
a2F0QXRKSDZ6ZFRBSTc5TXB2TElnWW9ZaDBpU0txSTFRMHBGbzBrOEdlaFJFamRVZzEzd0NBWUhw
aHNZaUlWdVRabWh6eEtLZjBBbTNnblNjUVRaWEMvSm12OWJXWDdxNzVnUWZHbHNHMllDcVZmQTU4
UUlPL1B1VXdKR0FvOG1IRkpVeW0yeHZVWTJHTlMrVDQxK1ZYODU4dERkZGoyUUhoaUtkb1JnMUc4
UUlaaXNjUWwwcDFRd25IOVVraDhrRkVSYzQ0cUpTcFFVamtLUUNxb3NyM2IrT2xiU1dra05nbTJF
TTg1M0FGQ0ZXeWw1bjY3dHNjK25hNGpCK01sUU9yTGJBVFdtcEM1ckwzbUF0VVJBaXAxRTRVbG9i
NU9FaFBJN29ySDhWUXpUS1AyM1lTb09VKzRRRHJDcGtuN0owdVh0OGxUMUhVdkFneEFoRkFTS0Nz
U0EwVE9vMi9sQnJaL2FRUmpxWVRkdDdWNmpYTmNEeTNVcDlBNm1WcHgwZXZQbWdPd2lpeG1wVklF
WFE2ZDZvcmkxbmc0NXdsenVubDlSRzFlOXdxUFYwNkJvLzJyZkorNEE5ZXBKVmQxOU9MVEg2K3lE
eVE4cnFhNktxdjIra0ZBbFkxWmc0RWw4K1VZNGlFY3diRXJVUlFYekc5ODFRMmNzVXkyVzIyR1Yz
QjZ3NElvaGZZSFJCRUE0YkJRSXoxWEE2TWhlcUp0TkxHbFRQdDhORE9DUHU0NURwNmpmTkZsbis0
eUJNUjBMQ3hNZGdPaklLSmhLWE9Id1ZUQXpiU0VSVUY5SHladkVnVGxma1ZVQmRJUjFRZkVsRUE2
azcrUjNxMnMwcHdjZ1Bzd00vdlRiOXhQemdEanpkMDVvaVc5VktpbHVwWi9obkpYcUgzMjhlNVZ6
UFdub29COXVxMHdrallJZm94Z0hEVFQxdFBwNWU1TnFOTjV4b0hEanRVcStZWTl0MzQzczQ4b3Fq
c3IxYTF6T2hVM3F0bWZCZnFvbUU1cGpCR1VQZHhLN1ZPSFh5dC82WGVEYlFmZkIxZi9vZnN3KzJm
bjBKb2JXQ3hsVTEyQTJzd0laOThLZkVOMHJpOFZ6OTRoRlAvMGdHOFV6QkZBSE1RdEFLQ3hvMmVt
VkNvVzV4VTlYc05oNGtOL0ZZU2J1bmp1elVoVVRTdlN5YkJ4TW00YjRRZFNnL1AyZmJuWXJBL3FW
Nkh1YnB3N3JZN3ZMRlZuM2VQV2JWVTdyZEZvczhoZEpiRVpiRlE2RytyUlV4WFM2NytEc3NWWlJW
dXZtZmVrNDNXY1A4YnBQZVpTWlRjWDlZcjkrNXJqZ2dlbEdqNXFMS3RxWHhPeGwyK2VDRUVqQmZo
VDZyZHRhOFJqRk9WMWxqbVdHWXEwYTdXaVpSZDR2VGRQMmdSRXFjNWdvU3VYV0lrRGMzdGV6a1da
bWIzTGRxTVJSUXdTQWJxZnlwckZZd3plNnpUYlplWkMzUzlYVEJaZjV3V1IxcnlWSDZUVWNtOHFp
YkZEQ1hJdUZHc0NYUVJEZUk3Zk5YRldLSFRXV0hub2hVMENmejVDb1o5T2ZKWkh6QUMwZGIzT0JG
SG4wZExvZnRKcG5Oa3ZHMXJnQ0R5WGhvWU93RWRNd2E4dGdSRGdxNjVLQ0hYVTduQW51WmZzdVdP
dCtlOVhiTjE0dmw4NTFPdEJlVjFmTGVyWkZ0VCtiODI0V0QyemlTb2ErMjZucjV0OUs0VmhhZjEv
bjNaL1dTMzRIMi9EN1BOaFhoSlZVWW5qYlp0ajREQ3VXV3JoRmRhQUlielRaZFBTMnpyMmZicng4
VXJIbGRaaUNMOC9WRDlmWjM4Vnc5YmJMdnNzem9ZdmFTNjBMMzdZajUwRGIvdENrVzJYYWIzZjI3
a244c1hySWYyVVpWM0llaXRnOHI4Skp1bEUxQW5XNHpIWXppUjM1M3hMU3dUZGRMVzBkWjE5eXQ0
V20rMFk1K1UrdFZsK0w5U1BPZzN0VE82TUlRMlJqNnEyeVRMMUsxZUxmcDdyR0FreVRmN2hTQXIy
ZUQvdTErYmVwZi9wc0hid1E1eUtzcm1YaDZOWm5lR01tWHpPTkxMUTV6bjNQeERQSkV3SEhMOUZW
SnN3d1E0bU5PRzR5ZmY0OW42cFFmSnYzcjhXUTJUd2F6OHk4MStWTXlHczJxWnpoMXE1dWVzNnYr
YVBSeE9wbjhWcjMzLzRqSHY4ZlZTNGY0b0Y4OVJKZ2lkazRKVWJQZFRUeUVXamZTU0tieFlENlpx
bzRoSGsrVHoxcjVQSjVPKy8vdHozNjVVUVVKbWhXbGVUeFJRb2dQVWNDSUlLRjVjdjREcVZKQXB3
cGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqSXhJREFnYjJKcUNqdzhMMVI1Y0dVdldFOWlhbVZqZEM5
RGIyeHZjbE53WVdObFd5OUpRME5DWVhObFpDQXlPU0F3SUZKZEwxTjFZblI1Y0dVdlNXMWhaMlV2
VG1GdFpTOUpiVEV2UW1sMGMxQmxja052YlhCdmJtVnVkQ0E0TDFkcFpIUm9JREk0TXk5TVpXNW5k
R2dnTXpReE9DOUlaV2xuYUhRZ01URXpMMFpwYkhSbGNpOUdiR0YwWlVSbFkyOWtaVDQrYzNSeVpX
RnRDbmljN1oyL3J1dTRFY2JmSjlVbWdKSEhNTkx0UTl4aTIyMVRwTGhJbFNwNWdWUkJtZ0JidTBp
WEtsWDZ2SWhYdUlNejRKMS9uS0ZJU2ZiNVBoQ0dqNDlFVVRKL211RndLRCtmRUFSQkVBUkJFQVJC
RUFSQkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFSQkVBUkJSK2gvLy8vUFAvLzlW
eXAvL1B0UGJlSFB0N0p0ZG5aTEllaHkycmdnZ2paZTduLzY0ZmJ6Yi9KbDIzNHJ4QnI0Z2o2NXhp
Q0tDMW14czg4TWdvN1Raa3EyYnYvbGI3L3pqTTZBa2VMQ1dNRm1RVzh2UW9tN1BiM1JyeDVXNU4x
MUIxRHNRMktjQmIycllwVE1Qd1ZFUUFPQ1NBSWxYVXlzNExOQmtOQkdCSStWUEh6RTU3QkhFR1Jx
UXlPd1NyckFKRUdRS1RaTVFBbUNkbXB6MkxRN0I1UWdhRUFiVFVtVU5oT0dHVmdJQ2hUVHRCSEVy
ekJNcGg3Ly9XVXJYLy94aHgvLy9Ic3EyL1hrOTl2bjIzL1BiaU4wa0NnRUVhREViMkNZdElpalpI
SUl5TXJvcFM4UmpadTZobWw3aFdFUzJyNTNza1RWQXF5RXRxdWhMOUhaalJxUkY0VVFLRzBtN095
V1hrNTVxK1FWTU1YU1FHMTNxck1iVmRabWNVeFBqem1pc29nbXNuZVV2TWQvdm9yMjB3U21XcjBC
VVBGOEV6TTFkOUJFYVlHVXpuVC9QcVdXVzNMOW9FZE1FNGNnMmpBRm1JcjFCa0NaZ1FpMlNuTnBH
bGc4UlFHUUM1S2x2L3JNeUNnZWJZR3BWd2VxR3lTZlFoUFpvNTFPMGFYaWloNU55UkcwdC90cmRa
NFZlbW1ndG42dUF4SHR1R2wvZUZ5cytOaFpyaE1TTWExTUtSN2xtU3F2RW5ZZHVXUU9VZDNsK1JI
OEYyWE1kTEt2MjlZVFYyVUNWV3IvaVRLSFRpMVFlMmd5cmRLOXR5eFJqNmMwVTZlN2Y2WjlHWWp1
ZW5iSzdEblYrL1pBL0xrN3lzdVQxWjFISUV6eTErVDYxaXB3OXZiYnB2MG9CV1NkYnFmTXJqSldW
WjdOcFVDVjV0RzZUTVZReEZoMTk3M3N0RlJzbm9ZN2JidDRLaytRZU8zYXJCUEhVN1BNRTB2M1pC
T1dkVURsKzMvbWZLdnpDT0pFTW8yNW9KMkt6ZE13VFZSdHdKRVlzb2syZEZscnkxbU9uL21ONzNI
dmt4VXVBbXFBcHVDVUIycXJXcWd1MGFkSTkvUDd2c3dpUFdJYVFFa1hyNTVieGZHYkczWFhkK0Q5
WCs2SlFIbUJFVzVBTUlPbUcybGVuTGFxTnQzUkhFYVpRSEZxY1Z1dUU2T0l6ZE9BTjZYWHlBZHZ1
a1dUN2cydmtzMmIrNVEvM2JYMmY3TVpTRmNBWmJwbjN1bm9FOWNWaW0wQ0o5T0xiN3hpMkZ3L0lJ
TExHRTI2cTVjSXl2Qmx3cFZzN2JiWmRzcjE2MlJvdXIvblZhdDcwUXFnU2pjSDg5empDZ2V1ek1z
QjFhYnRpYjQ2ME91b3RwdmxtTTB0K2hDM2l0ZTNiVC9GNjh0MHFpblZIZ0RVUUZ4ZDd5S1FFVUFO
c1BCeVFISGNZTCt6eHducUdxVkZXT242azAyOWY4c01yRjh0cVhjQ1N2dDdHWU1TMTJsR0xFdDI2
cldBYWxNalJKK3Y5amVSWmVGWlBhK0k1WXJpejN4SjJwMFNmWUhleWVVYnN5WWFtZmEvWHN3OHYx
VDV0WUFTWWUyMmU1YzhvalpCdldTTXhPb3FFeVh4ZVdDaGJ1bmdPVVVnOTRjbUZnRjFTbEJDQTlV
dTJ6ZUxHZTVyVDc4YjlPNlM5VnBBdFlubExRalZudGFHTmJwQWVSQ0pWNU92cnNGS3RweE9mSXJY
bHdsMnJhaHpPbEJ4ejgrWHNZbWtmT3JSbFlIeVFDaVpKejBLODVneTZSQ0xGbHVVOUNkZHNrcEFU
WW4xYVd1eTh4cy9aV0ozZUQ0MzA5UjhJbE5tSHVxeVFIbng3Wko1RWpSNUtKbW1SeGZ4dVdld2do
RldDYWpibWdDQzJUSHlNc2NkZXJPNVFPa0tKd0xGRGNpa0lYVmpqMWNHcW0wbjk4bFNEZmRFZUZ4
VEVHUFZMUzFpb3VTREVuVFdVNExudWxka3Z2UjIvY0tqV2NiYjdXUG1RUmVOb1FaS0psYzJ2MVQ1
aFlCcWpRdS9sc3hUOEpBeGI4UzBzd1RXcWdRVVc2Z3BLUk9sQklONHIvdzlYMjhXSDI1UmxHK1BN
amVRRndLcXpiVmpwdkozYkU1WXlsdW82VVVEVzdWUTYyYWpNa3p0U2FXdUhxNGJPUnliaDlxdkdK
a1hBdXFMK3ZuT2ZPOGlaNi9MMFU3WGJzQmFKZHMvRjZpbmIyNTIrai9CTkdncHVwaFpZekxjZGFk
UEU3d29VUHZOVTJDYldrOHM1dUl2Ly9xdGZ0VWZkdUhLUnlUYXdXT2V3YTQ4THJxNUFZR2RDanBQ
TXQ4NzJEaVR5NWZNUG9wWnppd05mbldnUkVTaTJyV20rSGhNaW9tUDRNakRxclZUeVJ1Q21NNGV2
WVJTc2YrbW41OUFmM2JqeVY1djlHeWlDQXNFaDlBMWU0Yk1teUZxMnhDdnJnb21jSFVMdS9GOHZR
Yms5TFViR3FqU2VxTEFObVVDRWFaVk1pMFVsd0FyUGtvMUlqRVhxT2ZVMlp6dVBUbVRoRENBYWpk
WktGZ1AxZlVoUlQxZVVDTE9zRFZQOElKQTVlTmRYOEtmWGV1YUo4OHd0ZXdJcjArZ1pHS1Z2eUY4
K1g3d09Ib0piZVVuTWF0TTZUNVRXbDJlZCtlRzI5L05qRTIyYytBMHJ3WlUva2FkSEQyWldBVW9l
ZWJKZkdNYXFmd05ZZXpFUzZvK1NLSHRUc0crdXRza095MFpoU1JRWSszZmt5RFJSZU9OZ1lybm5w
TG1TVnVsdUhqanJMWWsvVDF0bW5kY3hVZ0QzWW1IQm9FN3A5MnFwR3RYWGU2VVp5cU91blNmUlph
cHArdmZYZzJvMHRLOG0yT2U0cUdUaVZJSnF5RDZWeDBBRHR4SnhoU01PTGdYbWFOMUlpWDU4QVFQ
cTNaalhXRnk5VVF3aENrOWw4KzdEc25HZURWVUYxZ3RrZ0NxRkhEMnpGTmdtN1N6TjFBQ081VVAr
T3NuQk82NGlqVTlpZzlOM1hPSWRUWHZyLzlSZjNxdHQvdHdHNlpMQUpYY2kvMjlxbm1LSTNnN3lh
ck9SeDlwb2FCUG9oYW9mS2NhaSsrTmpadnlMdC9BZkRTQWdxYXJtbjRUNTVZZlk1dE1yQVpPZVdE
d0NFR3hlRFNSN0ZUZWo0UUttZ1JXVTBaUEFWTjU4eVNlN3dTZ29Ma2FBTW96VDNrTE5SZW82bUtU
MXNLV29qRVExQlVQS0twQUxSbzliZldMTjEzemxEL1pOajErSUx3SlFWMXhYS0swYkh6QVFvMFpx
UzVXMVFkZmlBYmZpZ24yRU5UVkdGQURGaXJtSWwvb09mL1ZwLzJMMVZ2clFueDdGb2EzTmN4dDFY
dUxwcDR2TWlkMXJ5eDdIN05RR2E5djlXbnlqOHNMcHFaSEpMeDBpUHkwUG1VQ3pHM1ZTNnZMQzZW
SXJiNEw4VjJSNzQzbVRaS0dSYWVQb1pZT1pPZ2huTnJaV3pHQXV2bkwzeDdmLzI2TFY4UFZFZ0JP
RjJYeEJkZmttS3dKNXBvU3BaN2Z2dXRaUUMySzhzMi9DdCtrelJOYnFPa0RxQmdXRW1GMXpXV25G
MVFYcU1PYVFWOVpOeG55bm42TXVUY1BsVUVwR2VXYjNzTjFMR0tkdi9mTUFmWDg2Q1JnS3FPckFV
VytYNUFZdkhXNVVxYUVaNkZtVFVYTnZRNDgxNnlaV3VGbjVqRVo5dndIUEp5RE0xR3J1OFFiZDU5
Wk1iMUpPMzFJK3UzTzB1THh1VkcrZGVPcDF0a1Q1bWw2Zkk5VXNqdG0vSUh1ZnVMRDRaVUw1dUlM
M3NzOEZ2ZmVkc1NYUEZ6K0taM2U5blRuRjZlZ3Q5RWJlQTNMTjhsY2p6OFdQOHdEbGN3KzJwOTZW
RDBGczZuY0JzM1Vvb3lqRWxEMDlZbnZ5K3prUE93eW44WVFQOFdsZFU3YXZmaTlQZ1ZlM2l1ZWhV
Smt4UTlqTVhjeHJ3bmI2TFp0K2hEc0hudHpFQjVRN2RITkpvbGQrTkRtdFRLdnNDZWE0a2x1R1R0
NysxMitLZU1waXV4NXp0NjYrZHpxeUVqM1R4T29wLy9zTytvRytyK3hTL24xNDNkcVRLQ0NYbVFl
am1reWR6RUhqSUZaTVN1UG8zem1CdDZWZVZwdVpMNDkwOFVaZ0l0Q0UxUHMxTmJJbHZGanpOT3pE
aFRIWUZrZVVKN01JVVltNk9FRkcrTjdzbm00b090NmU5RW5RZlBFbGxXZ01rMXEvMnNhNjJPa3Az
V3FRWWtrVm51TUNMbW1YanZYcFJzTkFIVlRQL2xYamY3cFhVeG5VdXRtclMzdG5vSzRDU1NEQnVK
TTg3RzdBYUFHNGhqSks3Wkl3VUo0elJTUG9mSkdha3FINTRCNWk5VlM4L1JjRHhTUG50b1Y5SG9Y
YmZpU1IzOWFYcWlRdUprbnU2TGVyQnV5SUEwQU5VQkg3TFVlSUowMUVaZ243ZlY1V00yZGlqSW5v
WlptdzY1eitZSW5uT2lESnBzUkJDWHlleVZ6cFV5dmp4c2ZQR0ZqR0todWszUTlvajNWR25iSzdL
NWRzZ0tnVm5SMTBjalZpelZLUUptZWlRbVVDRUR4N28rUGh6bWZDMVIrTGx2WExJTFZPdmcyQU5T
ZWZFZ3gwWEJ3b2pLRnBzZENFL3poSXBUYVJoN2c3SkZXaE0yN0RvenA4bVY2MUJTWGI5aEM2UTNN
TVBVeExwK3VNd2l3THhVdHB0Qk14VWFLVUZxUmEyU0tabmdQT0ZZZUtDOFFwK25JeE90S2M1MXhB
dzRiUXlWYmRRcFFRWHVPRVdIVkJxdE5VN1ZCdEcxREhCMjhzdStZdytVdmZqQi9wSUdLZTdqcGRN
Vng0OWF4MGFkUUFtb3N5bGV0ZjNXVUw5RHBDMnIwU3NCVENEcEZHYURpZ0ZMVlFubTMwSWVmMk1C
enZsUEdVTStoZWFoOC9SbGYwZlNjUy9OUWdVNEg2ak9yMi9tNzJTeWxNZFFqek8xNU5qOGxRSkVy
L3JQTjF0T25VQVhxR1U0SG04aC85UmNtVjJNc3c1a1NiWjA2aDdEZDh1RFF4UEVxSmZRZUtlNnVv
bkNlVDZhN2V2NGJqWTdiNE43dEl5V3ZTL0dQSDB0NDJsQ2g2U3VPQWRVYXhFZVRiZWp4emplVzlx
Uzh1dzMzZjk0c0U3VXd3L0play9qUVgxVzI1UEVEcUlQRmVYcXJ3NE1ETXFlS2JoL1B3OC9jNklK
NUtGMm5ON0diYiswc29McU4xSHBVc3J2Rmx2a3dvRDVFMTl5TDlnU1g0dFZGdzdFMmgveWFkbXFk
SHNXbFJuRlZpNXlaYWlQejJ3K2ZlS2xKczY3d3hVVnVuZ2diZmtLbWt1cDJpVzRrQVhwWHRTanBw
U0pneXBRWWRyWC9pc09NMEhzclJxbWRUUVpUUW1KUUlONkRwazhsSGk2WkN4ak5aWVBiNTJlMytv
cDZmUDlEYWFla2ZVSW5paDA4dmZnaUtQRDZJS2dWcFZLMEtPbmt3SUNtczVzUFFWY1JKUUd5NTVh
eFJ6Qk0wSHVybEszSHhtaU1JOXFZa214WG54Y0VuYUxXeWhBcHVyRG5KaWFqNzgzRHhzV3JnSWhS
Z2xXQ1BvUEk3cGk1TjVtaWFXci9kY0I2V3dpNnBvZ3NiWXdDanJ4LzhmcXBzODhKZ2k0aEVYT0li
UlBGOU1oRkJFUVExRlg3VzRSVVB0VUtSQWlDSUFpQ0lBaUNJQWlDSUFpQ0lBaUNvUGZXcjI2WDNY
Z0taVzVrYzNSeVpXRnRDbVZ1Wkc5aWFnb3lPU0F3SUc5aWFnbzhQQzlNWlc1bmRHZ2dNalU1Tmk5
T0lETXZSbWxzZEdWeUwwWnNZWFJsUkdWamIyUmxQajV6ZEhKbFlXMEtlSnlkbG5kVVU5a1doOCs5
TjcxUWtoQ0tsTkJyYUZJQ1NBMjlTSkV1S2pFSkVFckFrQUFpTmtSVWNFUlJrYVlJTWlqZ2dLTkRr
YkVpaW9VQlViSHJCQmxFMUhGd0ZCdVdTV1N0R2QrOGVlL05tOThmOTM1cm43M1AzV2Z2ZmRhNkFK
RDhnd1hDVEZnSmdBeWhXQlRoNThXSWpZdG5ZQWNCRFBBQUEyd0E0SEN6czBJVytFWUNtUUo4Mkl4
c21SUDRGNzI2RGlENSt5clRQNHpCQVArZmxMbFpJakVBVUppTTUvTDQyVndaRjhrNFBWZWNKYmRQ
eVppMk5FM09NRXJPSWxtQ01sYVRjL0lzVzN6Mm1XVVBPZk15aER3WnkzUE80bVh3NU53bjQ0MDVF
cjZNa1dBWkYrY0krTGt5dmlaamczUkpoa0RHYitTeEdYeE9OZ0Fva3R3dTVuTlRaR3d0WTVJb01v
SXQ0M2tBNEVqSlgvRFNMMWpNenhQTEQ4WE96Rm91RWlTbmlCa21YRk9HalpNVGkrSFB6MDNuaThY
TU1BNDNqU1BpTWRpWkdWa2M0WElBWnMvOFdSUjViUm15SWp2WU9EazRNRzB0YmI0bzFIOWQvSnVT
OTNhV1hvUi83aGxFSC9qRDlsZCttUTBBc0tabHRkbjZoMjFwRlFCZDZ3RlF1LzJIeldBdkFJcXl2
blVPZlhFZXVueGVVc1RpTEdjcnE5emNYRXNCbjJzcEwranYrcDhPZjBOZmZNOVN2dDN2NVdGNDg1
TTRrblF4UTE0M2JtWjZwa1RFeU03aWNQa001cCtIK0I4SC9uVWVGaEg4Skw2SUw1UkZSTXVtVENC
TWxyVmJ5Qk9JQlpsQ2hrRDRuNXI0RDhQK3BObTVsb25hK0JIUWxsZ0NwU0VhUUg0ZUFDZ3FFU0FK
ZTJRcjBPOTlDOFpIQS9uTmk5R1ptSjM3ejRMK2ZWZTRUUDdJRmlSL2ptTkhSREs0RWxITzdKcjhX
Z0kwSUFCRlFBUHFRQnZvQXhQQUJMYkFFYmdBRCtBREFrRW9pQVJ4WURIZ2doU1FBVVFnRnhTQXRh
QVlsSUt0WUNlb0JuV2dFVFNETm5BWWRJRmo0RFE0Qnk2QnkyQUUzQUZTTUE2ZWdDbndDc3hBRUlT
RnlCQVZVb2QwSUVQSUhMS0ZXSkFiNUFNRlF4RlFISlFJSlVOQ1NBSVZRT3VnVXFnY3FvYnFvV2Jv
Vytnb2RCcTZBQTFEdDZCUmFCTDZGWG9ISXpBSnBzRmFzQkZzQmJOZ1R6Z0lqb1FYd2Nud01qZ2ZM
b0szd0pWd0Ezd1E3b1JQdzVmZ0VWZ0tQNEduRVlBUUVUcWlpekFSRnNKR1FwRjRKQWtSSWF1UUVx
UUNhVURha0I2a0g3bUtTSkdueUZzVUJrVkZNVkJNbEF2S0h4V0Y0cUtXb1ZhaE5xT3FVUWRRbmFn
KzFGWFVLR29LOVJGTlJtdWl6ZEhPNkFCMExEb1puWXN1UmxlZ205QWQ2TFBvRWZRNCtoVUdnNkZq
akRHT0dIOU1IQ1lWc3dLekdiTWIwNDQ1aFJuR2pHR21zVmlzT3RZYzY0b054WEt3WW13eHRncDdF
SHNTZXdVN2puMkRJK0owY0xZNFgxdzhUb2dyeEZYZ1duQW5jRmR3RTdnWnZCTGVFTytNRDhYejhN
dnhaZmhHZkE5K0NEK09ueUVvRTR3SnJvUklRaXBoTGFHUzBFWTRTN2hMZUVFa0V2V0lUc1J3b29D
NGhsaEpQRVE4VHh3bHZpVlJTR1lrTmltQkpDRnRJZTBublNMZElyMGdrOGxHWkE5eVBGbE0za0p1
SnA4aDN5ZS9VYUFxV0NvRUtQQVVWaXZVS0hRcVhGRjRwb2hYTkZUMFZGeXNtSzlZb1hoRWNVanhx
UkpleVVpSnJjUlJXcVZVbzNSVTZZYlN0REpWMlVZNVZEbERlYk55aS9JRjVVY1VMTVdJNGtQaFVZ
b28reWhuS0dOVWhLcFBaVk81MUhYVVJ1cFo2amdOUXpPbUJkQlNhYVcwYjJpRHRDa1Zpb3FkU3JS
S25rcU55bkVWS1IyaEc5RUQ2T24wTXZwaCtuWDZPMVV0VlU5VnZ1b20xVGJWSzZxdjFlYW9lYWp4
MVVyVTJ0VkcxTjZwTTlSOTFOUFV0NmwzcWQvVFFHbVlhWVJyNUdyczBUaXI4WFFPYlk3TEhPNmNr
am1INTl6V2hEWE5OQ00wVjJqdTB4elFuTmJTMXZMVHl0S3EwanFqOVZTYnJ1MmhuYXE5US91RTlx
UU9WY2ROUjZDelErZWt6bU9HQ3NPVGtjNm9aUFF4cG5RMWRmMTFKYnIxdW9PNk0zckdlbEY2aFhy
dGV2ZjBDZm9zL1NUOUhmcTkrbE1HT2dZaEJnVUdyUWEzRGZHR0xNTVV3MTJHL1lhdmpZeU5Zb3cy
R0hVWlBUSldNdzR3empkdU5iNXJRalp4TjFsbTBtQnl6UlJqeWpKTk05MXRldGtNTnJNM1N6R3JN
UnN5aDgwZHpBWG11ODJITGRBV1RoWkNpd2FMRzB3UzA1T1p3MnhsamxyU0xZTXRDeTI3TEo5WkdW
akZXMjJ6NnJmNmFHMXZuVzdkYUgzSGhtSVRhRk5vMDJQenE2MlpMZGUyeHZiYVhQSmMzN21yNTNi
UGZXNW5ic2UzMjJOMzA1NXFIMksvd2I3WC9vT0RvNFBJb2MxaDB0SEFNZEd4MXZFR2k4WUtZMjFt
blhkQ08zazVyWFk2NXZUVzJjRlo3SHpZK1JjWHBrdWFTNHZMbzNuRzgvanpHdWVOdWVxNWNsenJY
YVZ1RExkRXQ3MXVVbmRkZDQ1N2cvc0REMzBQbmtlVHg0U25xV2VxNTBIUFoxN1dYaUt2RHEvWGJH
ZjJTdllwYjhUYno3dkVlOUNINGhQbFUrMXozMWZQTjltMzFYZkt6OTV2aGQ4cGY3Ui9rUDgyL3hz
QldnSGNnT2FBcVVESHdKV0JmVUdrb0FWQjFVRVBnczJDUmNFOUlYQklZTWoya0x2ekRlY0w1M2VG
Z3RDQTBPMmg5OEtNdzVhRmZSK09DUThMcndsL0dHRVRVUkRSdjRDNllNbUNsZ1d2SXIwaXl5THZS
SmxFU2FKNm94V2pFNktibzEvSGVNZVV4MGhqcldKWHhsNkswNGdUeEhYSFkrT2o0NXZpcHhmNkxO
eTVjRHpCUHFFNDRmb2k0MFY1aXk0czFsaWN2dmo0RXNVbG5DVkhFdEdKTVlrdGllODVvWndHenZU
U2dLVzFTNmU0Yk80dTdoT2VCMjhIYjVMdnlpL25UeVM1SnBVblBVcDJUZDZlUEpuaW5sS1I4bFRB
RmxRTG5xZjZwOWFsdms0TFRkdWY5aWs5SnIwOUE1ZVJtSEZVU0JHbUNmc3l0VFB6TW9lenpMT0tz
NlRMbkpmdFhEWWxDaEkxWlVQWmk3Szd4VFRaejlTQXhFU3lYakthNDVaVGsvTW1OenIzU0o1eW5q
QnZZTG5aOGszTEovSjk4NzllZ1ZyQlhkRmJvRnV3dG1CMHBlZksrbFhRcXFXcmVsZnJyeTVhUGI3
R2I4MkJ0WVMxYVd0L0tMUXVMQzk4dVM1bVhVK1JWdEdhb3JIMWZ1dGJpeFdLUmNVM05yaHNxTnVJ
MmlqWU9MaHA3cWFxVFI5TGVDVVhTNjFMSzByZmIrWnV2dmlWelZlVlgzM2FrclJsc015aGJNOVd6
RmJoMXV2YjNMY2RLRmN1enk4ZjJ4Nnl2WE1IWTBmSmpwYzdsK3k4VUdGWFViZUxzRXV5UzFvWlhO
bGRaVkMxdGVwOWRVcjFTSTFYVFh1dFp1Mm0ydGU3ZWJ1djdQSFkwMWFuVlZkYTkyNnZZTy9OZXIv
NnpnYWpob3A5bUgwNSt4NDJSamYyZjgzNnVybEpvNm0wNmNOKzRYN3BnWWdEZmMyT3pjMHRtaTFs
clhDcnBIWHlZTUxCeTk5NGY5UGR4bXlyYjZlM2x4NENoeVNISG4rYitPMzF3MEdIZTQrd2pyUjla
L2hkYlFlMW82UVQ2bHplT2RXVjBpWHRqdXNlUGhwNHRMZkhwYWZqZTh2djl4L1RQVlp6WE9WNDJR
bkNpYUlUbjA3bW41dytsWFhxNmVuazAyTzlTM3J2bklrOWM2MHZ2Ry93Yk5EWjgrZDh6NTNwOSt3
L2VkNzEvTEVMemhlT1htUmQ3THJrY0tsendINmc0d2Y3SHpvR0hRWTdoeHlIdWk4N1hlNFpuamQ4
NG9yN2xkTlh2YStldXhadzdkTEkvSkhoNjFIWGI5NUl1Q0c5eWJ2NTZGYjZyZWUzYzI3UDNGbHpG
MzIzNUo3U3ZZcjdtdmNiZmpUOXNWM3FJRDArNmowNjhHREJnenRqM0xFblAyWC85SDY4NkNINVlj
V0V6a1R6STl0SHh5WjlKeTgvWHZoNC9FbldrNW1ueFQ4ci8xejd6T1RaZDc5NC9ESXdGVHMxL2x6
MC9OT3ZtMStvdjlqLzB1NWw3M1RZOVAxWEdhOW1YcGU4VVg5ejRDM3JiZis3bUhjVE03bnZzZThy
UDVoKzZQa1k5UEh1cDR4UG4zNEQ5NFR6K3dwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pNd0lEQWdi
MkpxQ2p3OEwxUjVjR1V2UTJGMFlXeHZaeTlRWVdkbGN5QTRJREFnVWo0K0NtVnVaRzlpYWdvek1T
QXdJRzlpYWdvOFBDOURjbVZoZEc5eUtGRjFaWE4wSUVScFlXZHViM04wYVdOeklGSmxjRzl5ZEds
dVp5QlRaWEoyYVdObGN5a3ZVSEp2WkhWalpYSW9hVlJsZUhRZ01pNHhMalFnWENoaWVTQnNiM2Ro
WjJsbExtTnZiVndwS1M5VGRXSnFaV04wS0ZCaGRHbGxiblFnVW1Wd2IzSjBjeWt2VFc5a1JHRjBa
U2hFT2pJd01UY3dOVEV4TVRReU9UUXdMVEEwSnpBd0p5a3ZRWFYwYUc5eUtGRjFaWE4wSUVScFlX
ZHViM04wYVdOeklFbHVZMjl5Y0c5eVlYUmxaQ2t2UTNKbFlYUnBiMjVFWVhSbEtFUTZNakF4TnpB
MU1URXhOREk1TkRBdE1EUW5NREFuS1Q0K0NtVnVaRzlpYWdveUlEQWdiMkpxQ2p3OEwxUjVjR1V2
VDJKcVUzUnRMMDRnTVRndlRHVnVaM1JvSURRNU5pOUdhWEp6ZENBeE1qZ3ZSbWxzZEdWeUwwWnNZ
WFJsUkdWamIyUmxQajV6ZEhKbFlXMEtlSnp0VTExcjIwQVEvQ3Y3QjhMcFZybzdDWUtoVXVyV2xM
YkdOalJnL0tCSTEzQkZIMEdTUy9ydnUzdVNEWEZDYU9JRyt0QVg2ZlkwTjdlem1wRVFnQUdqUUJv
SVl3bFNnZ3FwUWxBcUFobUM1aW9DZ3dGSUJYRVFndFFReHdneEpKb1FDY2dnTUlBeGdRbUhTR2dk
QXhJdWltbWZJSXByWXRFcUJOUjBVNmdCRGNpWUNDOHZSWnIzZHQ0Mmc5aTQydllYcTdiT0c3SDVk
V2VGMzMzZkZHM3BtbHZ4elRYdm10NGQ2L1grWm1BVVErVnN4bFRMdkxQTlFLMEZzQklabmFhcTM0
WmNRdUtmRVQ5M0kvMHl2N1ZpWmZ0MjN4VzJwK1BYWDI5KzJHS2cxYUttVVFTTW5jM0VzbXVMdFIx
Z0s1WlhjeEFiZXo4QUllaDBPcjJ6NmIzWTBhMVYyNjN2OHNJU3paWDludStyWWZVaDVjR09iQ3lL
UHMwbEQ1bjduTk1uR1k1TFAydS9TbmpjZm1WNDRyeTZkdlFQUmhiaTJYU3VUdHY3TFhlcGljb2t1
Qk9mYmVueVI3dHBaVzE1dWp0TzdIbkpYdkVrZFZMcTViK2xUQlpIbzE1a0dSdWpKSnY0WC9iQUtS
OXQ5ZE1PcnNoZjdCUHhKYS9wd09TWEkyRkdIbkMydTBqYnFudzE1eW5wT1g2ZU9OWFRmYjZXTG5t
eXczTkVtNUh4bUtlZVc2UUlvdmpreW41cmZPaWt6OTd1dVl4NkV3QjYvNEgrODVDaS9Kc2hSWHpr
WGd5UDdzWG80RjVVQi9laVByZ1h6UlJTK2NZaFBaWDg4cENlTC9NMHBKajhEK20vSGRMZnAxUmhE
Z3BsYm1SemRISmxZVzBLWlc1a2IySnFDak15SURBZ2IySnFDanc4TDFSNWNHVXZXRkpsWmk5WFd6
RWdNaUF5WFM5U2IyOTBJRE13SURBZ1VpOUpibVJsZUZzd0lETXpYUzlKUkNCYlBHRTJZekpsWlRV
NVlUQXpNamhsTkRWbE4yRTBNbUkyWlRRME56VmpOak5tUGp3d05qTXdNVGcwWm1Zek1XVXhNelU1
Tm1RM1pUazNOMkZrTnpNME1XTmlNRDVkTDB4bGJtZDBhQ0F4TURrdlNXNW1ieUF6TVNBd0lGSXZV
Mmw2WlNBek15OUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVStQbk4wY21WaGJRcDRuQ1hMT3hLQ1FC
Q0U0WjRWNUtrcktibEZ4QW1JMFN0UVplTHh2SXdKb2Q2QkN4amcvTFVUZkZYVDB5TnAzNE9DWkxm
TlVZUUhmQjBiSks0R2xkbkxzM1pOMlFFeXlPRUlCWlFRclAra1htM1h1NytOUzFwYk9NRVpJbHln
ZzhhbXA1Zm5OL3lVNWc5UGx3dm5DbVZ1WkhOMGNtVmhiUXBsYm1Sdlltb0tjM1JoY25SNGNtVm1D
akU0TnpRNENpVWxSVTlHQ2c9PXx8fHx8fEZ8fHx8fHx8fHx8fHxRVUVTVCBESUFHTk9TVElDUy1X
RVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9PSyBBVkVOVUVe
XldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVOUklRVUVeXk1E
Xl5eXl5eXl5OUEleRU4N</inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>true</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>2</metaDataId>
          <name>ORU_R01_2.3.x</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>false</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>3</metaDataId>
          <name>FHIR_submit</name>
          <properties class="com.mirth.connect.connectors.http.HttpDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <host>${SparkURL}</host>
            <useProxyServer>false</useProxyServer>
            <proxyAddress></proxyAddress>
            <proxyPort></proxyPort>
            <method>post</method>
            <headers class="linked-hash-map"/>
            <parameters class="linked-hash-map"/>
            <responseXmlBody>true</responseXmlBody>
            <responseParseMultipart>true</responseParseMultipart>
            <responseIncludeMetadata>false</responseIncludeMetadata>
            <responseBinaryMimeTypes>application/xml</responseBinaryMimeTypes>
            <responseBinaryMimeTypesRegex>true</responseBinaryMimeTypesRegex>
            <multipart>false</multipart>
            <useAuthentication>false</useAuthentication>
            <authenticationType>Basic</authenticationType>
            <usePreemptiveAuthentication>false</usePreemptiveAuthentication>
            <username></username>
            <password></password>
            <content>${ORUBundle}</content>
            <contentType>application/xml</contentType>
            <dataTypeBinary>false</dataTypeBinary>
            <charset>UTF-8</charset>
            <socketTimeout>30000</socketTimeout>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Construct Bundle</name>
                <script>var resBundle = &lt;Bundle xmlns=&quot;http://hl7.org/fhir&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
		&lt;type value=&quot;message&quot;/&gt;
	&lt;/Bundle&gt;;

// Patient resource
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resPatient = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + channelMap.get(&quot;Patient&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBundle.appendChild(resPatient);

// DiagnosticReport resource
addEntry(&quot;DiagnosticReport&quot;);

// Practitioner resource for Ordering Provider
addEntry(&quot;Practitioner&quot;);

// Specimen resource
addEntry(&quot;Specimen&quot;);

// Binary resourse with original HL7v2 ORU_R01 message
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resBinary = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + globalChannelMap.get(&quot;Binary&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBinary.resource.Binary.id.@value = &quot;oru-r01-&quot; + channelMap.get(&quot;MessageControlID&quot;);
resBundle.appendChild(resBinary);

// Bundle settings
//resBundle.id.@value = channelMap.get(&quot;MessageControlID&quot;);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var resBundle = &lt;Bundle xmlns=&quot;http://hl7.org/fhir&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
		&lt;type value=&quot;message&quot;/&gt;
	&lt;/Bundle&gt;;

// Patient resource
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resPatient = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + channelMap.get(&quot;Patient&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBundle.appendChild(resPatient);

// DiagnosticReport resource
addEntry(&quot;DiagnosticReport&quot;);

// Practitioner resource for Ordering Provider
addEntry(&quot;Practitioner&quot;);

// Specimen resource
addEntry(&quot;Specimen&quot;);

// Binary resourse with original HL7v2 ORU_R01 message
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resBinary = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + globalChannelMap.get(&quot;Binary&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBinary.resource.Binary.id.@value = &quot;oru-r01-&quot; + channelMap.get(&quot;MessageControlID&quot;);
resBundle.appendChild(resBinary);

// Bundle settings
//resBundle.id.@value = channelMap.get(&quot;MessageControlID&quot;);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Send to Left Side</name>
                <script>//logger.debug(&quot;Bundle: &quot; + resBundle.toString());

channelMap.put(&quot;ORUBundle&quot;, resBundle.toString());</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>//logger.debug(&quot;Bundle: &quot; + resBundle.toString());

channelMap.put(&quot;ORUBundle&quot;, resBundle.toString());</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>Add Entry function</name>
                <script>/**
	Constructs multiple resource entries from the storred array.
	This function uses the global resBundle variable.

	@param {String} arrName - array name to extract from the channel map
*/
function addEntry(arrName) {
	var arrResource = channelMap.get(arrName);
	for (var i = 0; i &lt; arrResource.length; i++) {
		default xml namespace = &quot;http://hl7.org/fhir&quot;;
		var resource = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + arrResource[i] + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
		resBundle.appendChild(resource);	
	}
	channelMap.remove(arrName);
	arrResource.length = 0;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Constructs multiple resource entries from the storred array.
	This function uses the global resBundle variable.

	@param {String} arrName - array name to extract from the channel map
*/
function addEntry(arrName) {
	var arrResource = channelMap.get(arrName);
	for (var i = 0; i &lt; arrResource.length; i++) {
		default xml namespace = &quot;http://hl7.org/fhir&quot;;
		var resource = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + arrResource[i] + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
		resBundle.appendChild(resource);	
	}
	channelMap.remove(arrName);
	arrResource.length = 0;
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>true</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Validate Spark Server response</name>
                <script>var resp =  $(&apos;responseStatusLine&apos;);

//logger.info(&quot;ORU Processing: Destination - Response - &quot; + msg.toString());
//logger.info(&quot;ORU Processing: Destination - Response - &quot; + resp);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var resp =  $(&apos;responseStatusLine&apos;);

//logger.info(&quot;ORU Processing: Destination - Response - &quot; + msg.toString());
//logger.info(&quot;ORU Processing: Destination - Response - &quot; + resp);</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>HTTP Sender</transportName>
          <mode>DESTINATION</mode>
          <enabled>false</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data

message = stripNonValidXMLChars(message);

return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

globalMap.put(&quot;ORUProcessingChannelId&quot;, channelId);

return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set">
          <string>CURRENT</string>
        </tags>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <className>com.mirth.connect.server.attachments.javascript.JavaScriptAttachmentHandlerProvider</className>
          <type>JavaScript</type>
          <properties>
            <entry>
              <string>javascript.script</string>
              <string>// Modify the message variable below to create attachments

// Create Binary resourse with the original HL7v2 message
var resBinary = &lt;Binary&gt;				
				&lt;id value=&quot;&quot;/&gt;				
				&lt;contentType value=&quot;application/hl7-v2&quot;/&gt;
				&lt;content value=&quot;&quot;/&gt;
			&lt;/Binary&gt;;

// Encode original ORU message
var bytes = new java.lang.String(message.toString()).getBytes();
resBinary.content.@value = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

// Store to be processed by the FHIR_submit destination
globalChannelMap.put(&quot;Binary&quot;, resBinary.toString());


return message;</string>
            </entry>
          </properties>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
      <dependentIds/>
    </channel>
    <channel version="3.4.2">
      <id>b21b42cb-5080-4b45-ad37-e761ff386050</id>
      <nextMetaDataId>4</nextMetaDataId>
      <name>ORU Processing</name>
      <description>LRI ORU_R01 processing downstream channel.
The channel receives ORU_R01 messages routed from the LRI getResults channel.

(SN) This channel should use Strict Parser for incoming HL7v2 ORU messages.

Last updated: March 25, 2017</description>
      <enabled>true</enabled>
      <lastModified>
        <time>1497379998822</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>83</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Route ORU to Destination</name>
              <script>// Different HL7v2.x.x versions will be processed differently
var version = msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;VID.1&apos;].toString();

channelMap.put(&quot;MessageControlID&quot;, msg[&apos;MSH&apos;][&apos;MSH.10&apos;].toString());
 
if (&quot;2.5.1&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.5.1&quot;,&quot;FHIR_submit&quot;]);
	
} else if (&quot;2.3.1&quot; == version || &quot;2.3&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.3.x&quot;,&quot;FHIR_submit&quot;]);
	
} else {
	logger.error(&quot;ORU Processing: unknown ORU_R01 message version (MSH.12) - &quot; + version);
	destinationSet.removeAllExcept([&quot;FHIR_submit&quot;]);
}

var bytes = new java.lang.String(SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg) ).getBytes();
channelMap.put( &quot;HL7Base64&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Different HL7v2.x.x versions will be processed differently
var version = msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;VID.1&apos;].toString();

channelMap.put(&quot;MessageControlID&quot;, msg[&apos;MSH&apos;][&apos;MSH.10&apos;].toString());
 
if (&quot;2.5.1&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.5.1&quot;,&quot;FHIR_submit&quot;]);
	
} else if (&quot;2.3.1&quot; == version || &quot;2.3&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.3.x&quot;,&quot;FHIR_submit&quot;]);
	
} else {
	logger.error(&quot;ORU Processing: unknown ORU_R01 message version (MSH.12) - &quot; + version);
	destinationSet.removeAllExcept([&quot;FHIR_submit&quot;]);
}

var bytes = new java.lang.String(SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(msg) ).getBytes();
channelMap.put( &quot;HL7Base64&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>HL7V2</inboundDataType>
          <outboundDataType>HL7V2</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules>
            <rule>
              <sequenceNumber>0</sequenceNumber>
              <name>Check for ORU messages</name>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Continue processing only if the incoming message is ORU_R01
if(&quot;ORU&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.1&apos;].toString() &amp;&amp; &quot;R01&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.2&apos;].toString()) {
	return true;
} else {
	logger.error(&quot;ORU Processing: non-ORU message is rejected &quot; + msg.toString());
	return false;
}</string>
                </entry>
              </data>
              <type>JavaScript</type>
              <script>// Continue processing only if the incoming message is ORU_R01
if(&quot;ORU&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.1&apos;].toString() &amp;&amp; &quot;R01&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.2&apos;].toString()) {
	return true;
} else {
	logger.error(&quot;ORU Processing: non-ORU message is rejected &quot; + msg.toString());
	return false;
}</script>
              <operator>NONE</operator>
            </rule>
          </rules>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>ORU_R01_2.5.1</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${DR}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Patient resource</name>
                <script>// Mar 16: &lt;value value=&quot;&quot;/&gt; removed from identifier


var resPatient = &lt;Patient&gt;
			&lt;id value=&quot;PID-patient-identification&quot;/&gt;
			&lt;text&gt;
				&lt;status value=&quot;generated&quot;/&gt;
				&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
			&lt;/text&gt;			
			&lt;identifier&gt;
				&lt;use value=&quot;official&quot;/&gt;				
			&lt;/identifier&gt;
			&lt;name&gt;
				&lt;use value=&quot;official&quot;/&gt;
				&lt;family value=&quot;&quot;/&gt;
			&lt;/name&gt;
				&lt;telecom&gt;
					&lt;system value=&quot;phone&quot;/&gt;
					&lt;value value=&quot;&quot;/&gt;
					&lt;use value=&quot;home&quot;/&gt;
				&lt;/telecom&gt;
			&lt;gender value=&quot;&quot;/&gt;
			&lt;birthDate value=&quot;&quot;/&gt;
			&lt;address&gt;
				&lt;use value=&quot;home&quot;/&gt;
			&lt;/address&gt;
		&lt;/Patient&gt;;


// Process NTE segments
// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot;  
resPatient.text.*::div.* = new XMLList();
var 	patientComment = false;
for each (var nte in msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;].children()) {
	if (&quot;NTE&quot; == nte.name().toString()) {

		patientComment = true;
		
		// Source of Comment - Optional
		var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
		var source = nte[&apos;NTE.2&apos;].toString();
		
		// Comments that are contained in the segment - Required
		var comment = nte[&apos;NTE.3&apos;].toString();

		if (commentSources.indexOf(source) &gt; -1) {	
			resPatient.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
		} else {
			resPatient.text.*::div.* += new XML(&apos;&lt;p&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
		}
	}
}

if (!patientComment) delete resPatient.text;

// Patient Quest360 identifier list (repeatable)
// (SN)  Only first PID.3.1 [ID Number] is mapped in this version
var identifierTypeCode = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.5&apos;].toString();
if (identifierTypeCode) {
	resPatient.identifier.type.coding.code.@value = identifierTypeCode;
}

//======================= ~~ RKW IMPORTANT: This is where the patient SAFE ID is found
// Quest identifier - Required

var patientID = msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString();
//var patientID = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.1&apos;].toString();
resPatient.identifier.(use.@value == &quot;official&quot;).value.@value = patientID;


// ============================ RKW ~~ New Stuff

importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

//logger.error( &quot;Query for Patient: &quot; + msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][0][&apos;CX.1&apos;].toString() );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][0][&apos;CX.1&apos;].toString() ))
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;

if( msSize )
{
	var patientResource = ms.get(0).getResource();
}
else
{
	throw &quot;ORU Processing: Patient Not Found&quot;;
}

//var PatientSource = JSON.parse( patientString );
channelMap.put(&quot;PatientResourceID&quot;, patientResource.getId().getIdPart() );


 //=========================================================== ~~ RKW Leave - this is part of old code
// Store Patient resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Patient&quot;, resPatient);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Mar 16: &lt;value value=&quot;&quot;/&gt; removed from identifier


var resPatient = &lt;Patient&gt;
			&lt;id value=&quot;PID-patient-identification&quot;/&gt;
			&lt;text&gt;
				&lt;status value=&quot;generated&quot;/&gt;
				&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
			&lt;/text&gt;			
			&lt;identifier&gt;
				&lt;use value=&quot;official&quot;/&gt;				
			&lt;/identifier&gt;
			&lt;name&gt;
				&lt;use value=&quot;official&quot;/&gt;
				&lt;family value=&quot;&quot;/&gt;
			&lt;/name&gt;
				&lt;telecom&gt;
					&lt;system value=&quot;phone&quot;/&gt;
					&lt;value value=&quot;&quot;/&gt;
					&lt;use value=&quot;home&quot;/&gt;
				&lt;/telecom&gt;
			&lt;gender value=&quot;&quot;/&gt;
			&lt;birthDate value=&quot;&quot;/&gt;
			&lt;address&gt;
				&lt;use value=&quot;home&quot;/&gt;
			&lt;/address&gt;
		&lt;/Patient&gt;;


// Process NTE segments
// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot;  
resPatient.text.*::div.* = new XMLList();
var 	patientComment = false;
for each (var nte in msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;].children()) {
	if (&quot;NTE&quot; == nte.name().toString()) {

		patientComment = true;
		
		// Source of Comment - Optional
		var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
		var source = nte[&apos;NTE.2&apos;].toString();
		
		// Comments that are contained in the segment - Required
		var comment = nte[&apos;NTE.3&apos;].toString();

		if (commentSources.indexOf(source) &gt; -1) {	
			resPatient.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
		} else {
			resPatient.text.*::div.* += new XML(&apos;&lt;p&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
		}
	}
}

if (!patientComment) delete resPatient.text;

// Patient Quest360 identifier list (repeatable)
// (SN)  Only first PID.3.1 [ID Number] is mapped in this version
var identifierTypeCode = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.5&apos;].toString();
if (identifierTypeCode) {
	resPatient.identifier.type.coding.code.@value = identifierTypeCode;
}

//======================= ~~ RKW IMPORTANT: This is where the patient SAFE ID is found
// Quest identifier - Required

var patientID = msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString();
//var patientID = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.1&apos;].toString();
resPatient.identifier.(use.@value == &quot;official&quot;).value.@value = patientID;


// ============================ RKW ~~ New Stuff

importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

//logger.error( &quot;Query for Patient: &quot; + msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][0][&apos;CX.1&apos;].toString() );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][0][&apos;CX.1&apos;].toString() ))
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;

if( msSize )
{
	var patientResource = ms.get(0).getResource();
}
else
{
	throw &quot;ORU Processing: Patient Not Found&quot;;
}

//var PatientSource = JSON.parse( patientString );
channelMap.put(&quot;PatientResourceID&quot;, patientResource.getId().getIdPart() );


 //=========================================================== ~~ RKW Leave - this is part of old code
// Store Patient resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Patient&quot;, resPatient);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Save PDF Report</name>
                <script>for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	// Find attachment
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp;  obs[&apos;OBX.2&apos;].toString() == &quot;ED&quot; ) {
			
			var bytes = new java.lang.String(obs[&apos;OBX.5&apos;][&apos;ED.5&apos;].toString()).getBytes();
			channelMap.put( &quot;PDFBase64&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );			
		}	
	}
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	// Find attachment
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp;  obs[&apos;OBX.2&apos;].toString() == &quot;ED&quot; ) {
			
			var bytes = new java.lang.String(obs[&apos;OBX.5&apos;][&apos;ED.5&apos;].toString()).getBytes();
			channelMap.put( &quot;PDFBase64&quot;, FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;) );			
		}	
	}
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>DiagnosticReport resource</name>
                <script>var arrDiagnosticReport = [];
var arrOrderingProvider = [];
var arrProviderID = [];

/*
* (SN) Practitioner resource for Performing Organization or Medical Doctor is not mapped (see comments below)
*
*/ 

for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	// Process only ORC-OBR-OBX group
	if (observation[&apos;ORC&apos;][&apos;ORC.1&apos;].toString() != &quot;RE&quot;) { continue; }

	// Ignore &quot;comment&quot; or PDF results
	var invokeContinue = false;
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; ( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;ClinicalPDFReport1&quot; || obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;EnhancedPDFReport1&quot; ))
		{
			invokeContinue = true;
		}
	}	
	
	if( invokeContinue ){ continue; }; 
	
// logger.error( &quot;Processing Observation&quot; );

	var PlacerOrderNumber = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString();
	var PlacerNamespace   = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.2&apos;].toString();
	var FillerOrderNumber = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();
	var FillerNamespace   = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.2&apos;].toString();

	var StatusCode = observation[&apos;ORC&apos;][&apos;ORC.5&apos;].toString();
	
	var TestCode    = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	var TestHasParent     = false;

	// Does result have a parent?
	if( TestCode.indexOf( &quot;%&quot; ) &gt; -1 )
	{
		TestCode = TestCode.replace( &apos;%&apos;, &apos;&apos; );
		TestHasParent = true;	
	}
	
	var resDiagnosticReport = &lt;DiagnosticReport&gt;&lt;text&gt;&lt;status value=&quot;generated&quot;/&gt;&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;&lt;/text&gt;&lt;/DiagnosticReport&gt;;

	var contained = 0;
	
//msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0][&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;CE.1&apos;].toString()

	// Reference to contained observations
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		var containedObservation = &lt;contained&gt;&lt;/contained&gt;;		
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			containedObservation.appendChild( getObservationResourcePopulated( obs ) );
			resDiagnosticReport.appendChild(containedObservation);	
		}
	}	
	

//	logger.error( &quot;Report: &quot; +resDiagnosticReport );

	resDiagnosticReport.text.*::div.* = new XMLList();
	var observationComment = false;	

	// Extract ORC-OBR-OBX group related comments only
	var orderObservationGroup = new XML(observation.toString());
	
	// March 14: This returns all children and grandchildren NTE segments of the this object
	for each (var nte in orderObservationGroup.descendants(&quot;NTE&quot;)) { 
		
		if (&quot;NTE&quot; == nte.name().toString()) {

			observationComment = true;

			// March 14, 2017: Comment source depends on the group and appended as a prefix 
			var prefix = &quot;&quot;;
			if (nte.parent().name().toString().indexOf(&quot;.ORDER_OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBR&quot;;
			} else if (nte.parent().name().toString().indexOf(&quot;.OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBX&quot;;
			}
			
			// Source of Comment - Optional
			var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
			var source = nte[&apos;NTE.2&apos;].toString();
			
			// Comments contained in the segment - Required
			var comment = nte[&apos;NTE.3&apos;].toString();

			if (commentSources.indexOf(source) &gt; -1) {	
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;-&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
			} else {
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
			}
		}
	}

	if (!observationComment) delete resDiagnosticReport.text;

	// Process Ordering Provider
	// (SN) Add only if such Ordering Provider is not in the list already
	var provID =  observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	if (arrProviderID.indexOf(provID) &lt; 0) {
		arrOrderingProvider.push(getOrderingProvider(observation));
		arrProviderID.push(provID);
	}

	// Placer Order Number - If populated, this field contains the placer application’s order number.
	if (PlacerOrderNumber) {
		var identifier1 = &lt;identifier&gt;&lt;system value=&quot;&quot;/&gt;&lt;value value=&quot;&quot;/&gt;&lt;/identifier&gt;;
		identifier1.value.@value = PlacerOrderNumber;
		identifier1.system.@value = PlacerNamespace;
		resDiagnosticReport.appendChild(identifier1);
	}

	// Filler Order Number - The order number associated with the filler’s application. 
	if (FillerOrderNumber) {
		var identifier2 = &lt;identifier&gt;&lt;system value=&quot;&quot;/&gt;&lt;value value=&quot;&quot;/&gt;&lt;/identifier&gt;;
		identifier2.value.@value = FillerOrderNumber;
		identifier2.system.@value = FillerNamespace;
		resDiagnosticReport.appendChild(identifier2);		
	}

	if(TestCode){
		var identifier3 = &lt;identifier&gt;&lt;system value=&quot;&quot;/&gt;&lt;value value=&quot;&quot;/&gt;&lt;/identifier&gt;;
		identifier3.value.@value = TestCode;
		identifier3.system.@value = &quot;QUEST&quot;;
		resDiagnosticReport.appendChild(identifier3);		
	}
		
	// Order Status - Indicates whether the result is partial or final.
	if (StatusCode){
		var statusXML = &lt;status value=&quot;final&quot;&gt;&lt;/status&gt;;
		resDiagnosticReport.appendChild(statusXML);
	}

	resDiagnosticReport.code.@id = TestCode;

	// Hard-coded, required by FHIR
	var subXML = &lt;subject&gt;&lt;reference value=&quot;Patient&quot;/&gt;&lt;/subject&gt;;
	subXML.reference.@value = &quot;Patient/&quot; + $(&apos;PatientResourceID&apos;);
	resDiagnosticReport.appendChild(subXML);
	

	// Reference to observation this report is based on
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot; &amp;&amp; obs[&apos;OBX.2&apos;] !=&quot;ED&quot;) 
		{
			var resultReference = &lt;result&gt;&lt;reference value=&quot;&quot;/&gt;&lt;/result&gt;;
			resultReference.reference.@value =  &quot;#&quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			resDiagnosticReport.appendChild( resultReference );
		}	
	}

	resDiagnosticReport.appendChild(resultReference);	

//	logger.error( &quot;Report: &quot; + resDiagnosticReport.toString() );

	importPackage(Packages.java.util);
	importPackage(Packages.java.text);
	importPackage(Packages.ca.uhn.fhir.model.primitive);
	importPackage(Packages.ca.uhn.fhir.context);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);	
	importPackage(Packages.ca.uhn.fhir.rest.api);
	importPackage(Packages.ca.uhn.fhir.rest.client);

	var ctx = channelMap.get( &quot;ctx&quot; );
	var client = ctx.newRestfulGenericClient( configurationMap.get(&apos;sparkRawURL&apos;) );

	var originatingCode = observation[&apos;OBR&apos;][&apos;OBR.50&apos;][&apos;CWE.1&apos;].toString();

	// The parent test is itself, but a reflex has a different parent test
	if( originatingCode == null || originatingCode == &quot;&quot; ) 
	{
		originatingCode = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	}

	channelMap.put( &quot;RawReport1&quot;, resDiagnosticReport.toString() );

	var report = ctx.newXmlParser().parseResource( resDiagnosticReport.toString() );	

	var theCodeableConcept = new CodeableConceptDt();
	var theCoding = new CodingDt();
	theCoding.setSystem(observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.3&apos;].toString());
	theCoding.setCode(observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString());
	theCoding.setDisplay(observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.2&apos;].toString());
	theCodeableConcept.addCoding(theCoding );

	report.setCode(theCodeableConcept);	

	// Observation Date/Time
	var HL7TimestampFormatWithTZ = new SimpleDateFormat( &quot;yyyyMMddHHmmss.SSSZ&quot;);

	var theIssuedInstant = new InstantDt();
	var theTS = HL7TimestampFormatWithTZ.parse(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());	
	theIssuedInstant.setValue(theTS);
		
//	report.setEffective(theIssuedInstant);
	report.setIssued( theIssuedInstant );	
	
	var theAttachments = new ArrayList();
	
	var attachment = new AttachmentDt();
	attachment.setContentType(&quot;application/pdf&quot;);
	attachment.setData( new java.lang.String( $(&apos;PDFBase64&apos;) ).getBytes() );
	theAttachments.add(attachment);

	var attachment2 = new AttachmentDt();
	attachment2.setContentType(&quot;text/hl7&quot;);
	attachment2.setData( new java.lang.String( $(&apos;HL7Base64&apos;) ).getBytes() );
	theAttachments.add(attachment2);
	
	report.setPresentedForm(theAttachments );	

	if( TestHasParent )
	{
		parent = observation[&apos;OBR&apos;][&apos;OBR.50&apos;][&apos;CWE.1&apos;].toString().replace(&apos;%&apos;,&apos;&apos;);

		switch( parent + &apos;&apos; )
		{
			case &apos;SBHIV23&apos;:
				parent = &apos;91431&apos;
			break;

			default:
			break;
		}		

	}
	else
	{
		parent = SELF;
	}

	report.setConclusion( parent );		

		
	var outcome = client.create()
		.resource(report)
		.execute();	

//	logger.error( &quot;Outcome: &quot; + outcome.getResource().toString() );
	
//	arrDiagnosticReport.push(resDiagnosticReport.toString());


}

// Store DiagnosticReport resource to be processed by FHIR_Submit destination
channelMap.put(&quot;DiagnosticReport&quot;, arrDiagnosticReport);

// Store Practitioner resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Practitioner&quot;, arrOrderingProvider);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var arrDiagnosticReport = [];
var arrOrderingProvider = [];
var arrProviderID = [];

/*
* (SN) Practitioner resource for Performing Organization or Medical Doctor is not mapped (see comments below)
*
*/ 

for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	// Process only ORC-OBR-OBX group
	if (observation[&apos;ORC&apos;][&apos;ORC.1&apos;].toString() != &quot;RE&quot;) { continue; }

	// Ignore &quot;comment&quot; or PDF results
	var invokeContinue = false;
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; ( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;ClinicalPDFReport1&quot; || obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;EnhancedPDFReport1&quot; ))
		{
			invokeContinue = true;
		}
	}	
	
	if( invokeContinue ){ continue; }; 
	
// logger.error( &quot;Processing Observation&quot; );

	var PlacerOrderNumber = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString();
	var PlacerNamespace   = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.2&apos;].toString();
	var FillerOrderNumber = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();
	var FillerNamespace   = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.2&apos;].toString();

	var StatusCode = observation[&apos;ORC&apos;][&apos;ORC.5&apos;].toString();
	
	var TestCode    = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	var TestHasParent     = false;

	// Does result have a parent?
	if( TestCode.indexOf( &quot;%&quot; ) &gt; -1 )
	{
		TestCode = TestCode.replace( &apos;%&apos;, &apos;&apos; );
		TestHasParent = true;	
	}
	
	var resDiagnosticReport = &lt;DiagnosticReport&gt;&lt;text&gt;&lt;status value=&quot;generated&quot;/&gt;&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;&lt;/text&gt;&lt;/DiagnosticReport&gt;;

	var contained = 0;
	
//msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0][&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;CE.1&apos;].toString()

	// Reference to contained observations
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		var containedObservation = &lt;contained&gt;&lt;/contained&gt;;		
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			containedObservation.appendChild( getObservationResourcePopulated( obs ) );
			resDiagnosticReport.appendChild(containedObservation);	
		}
	}	
	

//	logger.error( &quot;Report: &quot; +resDiagnosticReport );

	resDiagnosticReport.text.*::div.* = new XMLList();
	var observationComment = false;	

	// Extract ORC-OBR-OBX group related comments only
	var orderObservationGroup = new XML(observation.toString());
	
	// March 14: This returns all children and grandchildren NTE segments of the this object
	for each (var nte in orderObservationGroup.descendants(&quot;NTE&quot;)) { 
		
		if (&quot;NTE&quot; == nte.name().toString()) {

			observationComment = true;

			// March 14, 2017: Comment source depends on the group and appended as a prefix 
			var prefix = &quot;&quot;;
			if (nte.parent().name().toString().indexOf(&quot;.ORDER_OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBR&quot;;
			} else if (nte.parent().name().toString().indexOf(&quot;.OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBX&quot;;
			}
			
			// Source of Comment - Optional
			var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
			var source = nte[&apos;NTE.2&apos;].toString();
			
			// Comments contained in the segment - Required
			var comment = nte[&apos;NTE.3&apos;].toString();

			if (commentSources.indexOf(source) &gt; -1) {	
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;-&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
			} else {
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
			}
		}
	}

	if (!observationComment) delete resDiagnosticReport.text;

	// Process Ordering Provider
	// (SN) Add only if such Ordering Provider is not in the list already
	var provID =  observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	if (arrProviderID.indexOf(provID) &lt; 0) {
		arrOrderingProvider.push(getOrderingProvider(observation));
		arrProviderID.push(provID);
	}

	// Placer Order Number - If populated, this field contains the placer application’s order number.
	if (PlacerOrderNumber) {
		var identifier1 = &lt;identifier&gt;&lt;system value=&quot;&quot;/&gt;&lt;value value=&quot;&quot;/&gt;&lt;/identifier&gt;;
		identifier1.value.@value = PlacerOrderNumber;
		identifier1.system.@value = PlacerNamespace;
		resDiagnosticReport.appendChild(identifier1);
	}

	// Filler Order Number - The order number associated with the filler’s application. 
	if (FillerOrderNumber) {
		var identifier2 = &lt;identifier&gt;&lt;system value=&quot;&quot;/&gt;&lt;value value=&quot;&quot;/&gt;&lt;/identifier&gt;;
		identifier2.value.@value = FillerOrderNumber;
		identifier2.system.@value = FillerNamespace;
		resDiagnosticReport.appendChild(identifier2);		
	}

	if(TestCode){
		var identifier3 = &lt;identifier&gt;&lt;system value=&quot;&quot;/&gt;&lt;value value=&quot;&quot;/&gt;&lt;/identifier&gt;;
		identifier3.value.@value = TestCode;
		identifier3.system.@value = &quot;QUEST&quot;;
		resDiagnosticReport.appendChild(identifier3);		
	}
		
	// Order Status - Indicates whether the result is partial or final.
	if (StatusCode){
		var statusXML = &lt;status value=&quot;final&quot;&gt;&lt;/status&gt;;
		resDiagnosticReport.appendChild(statusXML);
	}

	resDiagnosticReport.code.@id = TestCode;

	// Hard-coded, required by FHIR
	var subXML = &lt;subject&gt;&lt;reference value=&quot;Patient&quot;/&gt;&lt;/subject&gt;;
	subXML.reference.@value = &quot;Patient/&quot; + $(&apos;PatientResourceID&apos;);
	resDiagnosticReport.appendChild(subXML);
	

	// Reference to observation this report is based on
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot; &amp;&amp; obs[&apos;OBX.2&apos;] !=&quot;ED&quot;) 
		{
			var resultReference = &lt;result&gt;&lt;reference value=&quot;&quot;/&gt;&lt;/result&gt;;
			resultReference.reference.@value =  &quot;#&quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			resDiagnosticReport.appendChild( resultReference );
		}	
	}

	resDiagnosticReport.appendChild(resultReference);	

//	logger.error( &quot;Report: &quot; + resDiagnosticReport.toString() );

	importPackage(Packages.java.util);
	importPackage(Packages.java.text);
	importPackage(Packages.ca.uhn.fhir.model.primitive);
	importPackage(Packages.ca.uhn.fhir.context);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);	
	importPackage(Packages.ca.uhn.fhir.rest.api);
	importPackage(Packages.ca.uhn.fhir.rest.client);

	var ctx = channelMap.get( &quot;ctx&quot; );
	var client = ctx.newRestfulGenericClient( configurationMap.get(&apos;sparkRawURL&apos;) );

	var originatingCode = observation[&apos;OBR&apos;][&apos;OBR.50&apos;][&apos;CWE.1&apos;].toString();

	// The parent test is itself, but a reflex has a different parent test
	if( originatingCode == null || originatingCode == &quot;&quot; ) 
	{
		originatingCode = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	}

	channelMap.put( &quot;RawReport1&quot;, resDiagnosticReport.toString() );

	var report = ctx.newXmlParser().parseResource( resDiagnosticReport.toString() );	

	var theCodeableConcept = new CodeableConceptDt();
	var theCoding = new CodingDt();
	theCoding.setSystem(observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.3&apos;].toString());
	theCoding.setCode(observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString());
	theCoding.setDisplay(observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.2&apos;].toString());
	theCodeableConcept.addCoding(theCoding );

	report.setCode(theCodeableConcept);	

	// Observation Date/Time
	var HL7TimestampFormatWithTZ = new SimpleDateFormat( &quot;yyyyMMddHHmmss.SSSZ&quot;);

	var theIssuedInstant = new InstantDt();
	var theTS = HL7TimestampFormatWithTZ.parse(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());	
	theIssuedInstant.setValue(theTS);
		
//	report.setEffective(theIssuedInstant);
	report.setIssued( theIssuedInstant );	
	
	var theAttachments = new ArrayList();
	
	var attachment = new AttachmentDt();
	attachment.setContentType(&quot;application/pdf&quot;);
	attachment.setData( new java.lang.String( $(&apos;PDFBase64&apos;) ).getBytes() );
	theAttachments.add(attachment);

	var attachment2 = new AttachmentDt();
	attachment2.setContentType(&quot;text/hl7&quot;);
	attachment2.setData( new java.lang.String( $(&apos;HL7Base64&apos;) ).getBytes() );
	theAttachments.add(attachment2);
	
	report.setPresentedForm(theAttachments );	

	if( TestHasParent )
	{
		parent = observation[&apos;OBR&apos;][&apos;OBR.50&apos;][&apos;CWE.1&apos;].toString().replace(&apos;%&apos;,&apos;&apos;);

		switch( parent + &apos;&apos; )
		{
			case &apos;SBHIV23&apos;:
				parent = &apos;91431&apos;
			break;

			default:
			break;
		}		

	}
	else
	{
		parent = SELF;
	}

	report.setConclusion( parent );		

		
	var outcome = client.create()
		.resource(report)
		.execute();	

//	logger.error( &quot;Outcome: &quot; + outcome.getResource().toString() );
	
//	arrDiagnosticReport.push(resDiagnosticReport.toString());


}

// Store DiagnosticReport resource to be processed by FHIR_Submit destination
channelMap.put(&quot;DiagnosticReport&quot;, arrDiagnosticReport);

// Store Practitioner resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Practitioner&quot;, arrOrderingProvider);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>3</sequenceNumber>
                <name>Functions pool</name>
                <script>/**
	Creates the DiagnosticOrder resourse with OBR segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return DiagnosticOrder XML string
*/

function getObservationResourcePopulated(obs) {

	importPackage( Packages.java.util );
	importPackage( Packages.org.hl7.fhir.instance.model );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.resource );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.valueset );
	importPackage( Packages.ca.uhn.fhir.model.primitive );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.composite );
	importPackage( Packages.java.text );

	var HL7DateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);

	var obsResource = new Observation();

	obsResource.setId( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());				
		
	obsResource.addIdentifier().setValue(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());

	switch( obs[&apos;OBX.11&apos;].toString() + &apos;&apos; )
	{
		case &quot;F&quot;:
			obsResource.setStatus(ObservationStatusEnum.FINAL);				
		break;

		case &quot;P&quot;:
			obsResource.setStatus(ObservationStatusEnum.PRELIMINARY);			
		break;

		case &quot;S&quot;:
			obsResource.setStatus(ObservationStatusEnum.AMENDED);	
		break;

		case &quot;C&quot;:
			obsResource.setStatus(ObservationStatusEnum.CANCELLED);
		break;

		case &quot;X&quot;:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
		break;
					
		default:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
			logger.error( &quot;Unrecognized Status Code: &quot; + obs[&apos;OBX.11&apos;].toString() );	
	}

	var theCodeableConcept = new CodeableConceptDt();
	var theLoincCoding = new CodingDt();
	var theQuestCoding = new CodingDt();
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) 
	{
		// LOINC coding
		theLoincCoding.setSystem(&quot;http://loinc.org&quot;);
		theLoincCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString());
		theLoincCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString());
		theCodeableConcept.addCoding(theLoincCoding );		
	}

	theQuestCoding.setSystem(obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString());
	theQuestCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());
	theQuestCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString());
	theCodeableConcept.addCoding(theQuestCoding );				

	obsResource.setCode(theCodeableConcept );

	var HL7TimestampFormatWithTZ = new SimpleDateFormat( &quot;yyyyMMddHHmmss.SSSZ&quot;);

	if( obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString() )
	{
		obsResource.setIssuedWithMillisPrecision(HL7TimestampFormatWithTZ.parse(obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString()));
	}
	
	var theInterpretation = new CodeableConceptDt();
	theInterpretation.setText(obs[&apos;OBX.8&apos;].toString());	
	obsResource.setInterpretation(theInterpretation );	

	var theReferenceRange = new Observation.ReferenceRange();
	var theMeaningCoding = new CodeableConceptDt();
	var theReferenceRangeMeaningCoding = new CodingDt();	

//	theReferenceRangeMeaningCoding.setCode(obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString());
//	theReferenceRangeMeaningCoding.setSystem(obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString());
//	theReferenceRangeMeaningCoding.setDisplay(obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString());

	theMeaningCoding.addCoding(theReferenceRangeMeaningCoding );
	theReferenceRange.setText(obs[&apos;OBX.7&apos;].toString());
		
	theReferenceRange.setMeaning(theMeaningCoding );
	obsResource.addReferenceRange(theReferenceRange);	

	var theValue = obs[&apos;OBX.5&apos;][&apos;SN.1&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.2&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.3&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.4&apos;].toString();
	theValue = theValue.trim();

	if( theValue == &quot;&quot; )
	{
		theValue = obs[&apos;OBX.5&apos;].toString();
	}

	if( obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString() != &quot;&quot; )
	{
		theValue += &quot; &quot; + obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString();
	}

	obsResource.setValue( new StringDt( theValue ) );

//	logger.error( &quot;Value: &quot; + theValue );

//	logger.error( new XML( $(&apos;ctx&apos;).newXmlParser().encodeResourceToString(obsResource) ).toString() );
	return new XML( $(&apos;ctx&apos;).newXmlParser().encodeResourceToString(obsResource) );
}

/*
function getDiagnosticOrder(obs) {

//
//(SN) Following fields are not mapped in this version:
// OBR.26 [Parent Result] - Optional - If OBR.11 (Specimen Action Code) is populated, then this field is populated with the data in the parent OBX.03 (Observation Identifier) subfield.
// OBR.29 [Parent] - Optional - This field is populated if OBR.11 (Specimen Action Code) is populated.
// OBR.50 [Parent Universal Service Identifier] - Optional - The universal service identifier of the parent order. This field is populated if OBR.11 (Specimen Action Code) is populated.
//
	var diagnosticOrder = &lt;DiagnosticOrder&gt;
					&lt;id value=&quot;obr-observation-request&quot;/&gt;
					&lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/diagnosticorder-precondition&quot;&gt;
						&lt;valueDateTime value=&quot;&quot;/&gt;
					&lt;/extension&gt;
					&lt;subject id=&quot;Patient&quot;/&gt;
					&lt;event&gt;
						&lt;status value=&quot;completed&quot;&gt;
							&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
								&lt;valueCodeableConcept&gt;
									&lt;coding&gt;
										&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0123&quot;/&gt;
										&lt;code value=&quot;&quot;/&gt;
										&lt;display value=&quot;&quot;/&gt;
									&lt;/coding&gt;
								&lt;/valueCodeableConcept&gt;
							&lt;/extension&gt;
						&lt;/status&gt;
						&lt;dateTime value=&quot;&quot;/&gt;
						&lt;actor&gt;
							&lt;reference value=&quot;Practitioner/ordering-provider&quot;/&gt;
						&lt;/actor&gt;
					&lt;/event&gt;
					&lt;item&gt;
						&lt;code&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/code&gt;
						&lt;specimen&gt;
							&lt;display value=&quot;G&quot;/&gt;
						&lt;/specimen&gt;
					&lt;/item&gt;
				&lt;/DiagnosticOrder&gt;;

	diagnosticOrder.extension.valueDateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());

	var resultHandling = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	if (resultHandling) {
		diagnosticOrder.supportingInformation.display.@value = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	} else {
		delete diagnosticOrder.supportingInformation;
	}

	// Result Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBR&apos;][&apos;OBR.25&apos;].toString();
	if (statusCode) {
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0123&quot;, statusCode);
	}

	//  The date/time the results were reported or status changed
	diagnosticOrder.event.dateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;TS.1&apos;].toString());

	// Quest samples contain local and LOINC codes
	diagnosticOrder.item.code.coding.system.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.3&apos;].toString();
	diagnosticOrder.item.code.coding.code.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	diagnosticOrder.item.code.coding.display.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.2&apos;].toString();

	// Specimen Action Code
	var specimenActionCode = obs[&apos;OBR&apos;][&apos;OBR.11&apos;].toString();
	if (specimenActionCode) {
		diagnosticOrder.item.specimen.display.@value = specimenActionCode;
	} else {
		delete diagnosticOrder.item.specimen;
	}

	return diagnosticOrder.toString();
}
*/
/**
	Creates the Observation resourse with a single OBX segment mappings

	@param {String} obs - original ORU_R01.OBSERVATION XML string
	@return {String} return Observation XML string
*/
function getObservationResource(obs) {

	var obsResource = &lt;Observation xmlns=&quot;http://hl7.org/fhir&quot;&gt;			
					&lt;identifier id=&quot;&quot;/&gt;
					&lt;status value=&quot;final&quot;&gt;
						&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
							&lt;valueCodeableConcept&gt;
								&lt;coding&gt;
									&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0085&quot;/&gt;
									&lt;code value=&quot;F&quot;/&gt;
									&lt;display value=&quot;Final results; can only be changed with a corrected result&quot;/&gt;
								&lt;/coding&gt;
							&lt;/valueCodeableConcept&gt;
						&lt;/extension&gt;
					&lt;/status&gt;
					&lt;code&gt;
						&lt;extension url=&quot;http://www.questdiagnostics.com&quot;&gt;
							&lt;valueCoding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/valueCoding&gt;
						&lt;/extension&gt;
						&lt;coding&gt;
							&lt;system value=&quot;http://loinc.org&quot;/&gt;
							&lt;code value=&quot;&quot;/&gt;
							&lt;display value=&quot;&quot;/&gt;
						&lt;/coding&gt;
					&lt;/code&gt;
					&lt;effectiveDateTime value=&quot;&quot;/&gt;
					&lt;issued value=&quot;&quot;/&gt;
					&lt;valueString value=&quot;&quot;/&gt;
					&lt;interpretation&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/interpretation&gt;
					&lt;referenceRange&gt;
						&lt;meaning&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/meaning&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/referenceRange&gt;
				&lt;/Observation&gt;;

	obsResource.identifier.@id =  obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();

	// Result Status - the status of the result value
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBX.11&apos;].toString();
	if (statusCode) {
		 obsResource.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 obsResource.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0085&quot;, statusCode);
	}
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) {
		// Care360 own coding
		obsResource.code.extension.valueCoding.system.@value =  obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.extension.valueCoding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.extension.valueCoding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();

		// LOINC coding
		obsResource.code.coding.system.@value = &quot;http://loinc.org&quot;;
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString();		
	} else {
		delete obsResource.code.extension;
		obsResource.code.coding.system.@value =  obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();			
	}

	var dateTimeOfObservation = obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfObservation) {
		obsResource.effectiveDateTime.@value = convertHL7DateTime(dateTimeOfObservation);
	} else {
		delete obsResource.effectiveDateTime;
	}

	var dateTimeOfAnalysis = obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfAnalysis) {
		obsResource.issued.@value = convertHL7DateTime(dateTimeOfAnalysis);
	} else {
		delete obsResource.issued;
	}

	// March 15: Issues #13: OBX.5 [Observation Value] using SN (Structured Numeric) data type
	var observationValue = &quot;&quot;;
	if (obs[&apos;OBX.5&apos;][&apos;SN.3&apos;]) {
		for each (var sn in obs[&apos;OBX.5&apos;].children()) {
			if (sn.toString()) observationValue += sn.toString(); 
		}
	} else {
		observationValue = obs[&apos;OBX.5&apos;].toString();
	}
	
	if (observationValue) {
		obsResource.valueString.@value = observationValue + &quot; &quot; + obs[&apos;OBX.6&apos;].toString();
	} else {
		delete obsResource.valueString;
	}

	var abnormalFlags = obs[&apos;OBX.8&apos;].toString();
	if (abnormalFlags) {
		obsResource.interpretation.text.@value = abnormalFlags;
	} else {
		delete obsResource.interpretation;
	}

	var unitsOfMeasure = obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString();
	var meaningPresent = true;
	if (unitsOfMeasure) {
		obsResource.referenceRange.meaning.coding.code.@value = unitsOfMeasure;
		if (obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.system.@value = obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.system;
		}
		if (obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.display.@value = obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.display;
		}
	} else {
		meaningPresent = false;
	}
	
	var referencesRange = obs[&apos;OBX.7&apos;].toString();
	var rangePresent = true;
	if (referencesRange) {
		obsResource.referenceRange.text.@value = referencesRange;
	} else {
		delete obsResource.referenceRange.text;
		rangePresent = false;
	}

	if (!meaningPresent &amp;&amp; !rangePresent) delete obsResource.referenceRange;

	// Reference to performing organization
//	obsResource.performer.reference.@value=&quot;Practitioner/obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	logger.error( &quot;Contained Observation: \n&quot; + obsResource.toString() );
	return obsResource.toString();
	
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates the DiagnosticOrder resourse with OBR segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return DiagnosticOrder XML string
*/

function getObservationResourcePopulated(obs) {

	importPackage( Packages.java.util );
	importPackage( Packages.org.hl7.fhir.instance.model );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.resource );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.valueset );
	importPackage( Packages.ca.uhn.fhir.model.primitive );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.composite );
	importPackage( Packages.java.text );

	var HL7DateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);

	var obsResource = new Observation();

	obsResource.setId( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());				
		
	obsResource.addIdentifier().setValue(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());

	switch( obs[&apos;OBX.11&apos;].toString() + &apos;&apos; )
	{
		case &quot;F&quot;:
			obsResource.setStatus(ObservationStatusEnum.FINAL);				
		break;

		case &quot;P&quot;:
			obsResource.setStatus(ObservationStatusEnum.PRELIMINARY);			
		break;

		case &quot;S&quot;:
			obsResource.setStatus(ObservationStatusEnum.AMENDED);	
		break;

		case &quot;C&quot;:
			obsResource.setStatus(ObservationStatusEnum.CANCELLED);
		break;

		case &quot;X&quot;:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
		break;
					
		default:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
			logger.error( &quot;Unrecognized Status Code: &quot; + obs[&apos;OBX.11&apos;].toString() );	
	}

	var theCodeableConcept = new CodeableConceptDt();
	var theLoincCoding = new CodingDt();
	var theQuestCoding = new CodingDt();
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) 
	{
		// LOINC coding
		theLoincCoding.setSystem(&quot;http://loinc.org&quot;);
		theLoincCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString());
		theLoincCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString());
		theCodeableConcept.addCoding(theLoincCoding );		
	}

	theQuestCoding.setSystem(obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString());
	theQuestCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());
	theQuestCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString());
	theCodeableConcept.addCoding(theQuestCoding );				

	obsResource.setCode(theCodeableConcept );

	var HL7TimestampFormatWithTZ = new SimpleDateFormat( &quot;yyyyMMddHHmmss.SSSZ&quot;);

	if( obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString() )
	{
		obsResource.setIssuedWithMillisPrecision(HL7TimestampFormatWithTZ.parse(obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString()));
	}
	
	var theInterpretation = new CodeableConceptDt();
	theInterpretation.setText(obs[&apos;OBX.8&apos;].toString());	
	obsResource.setInterpretation(theInterpretation );	

	var theReferenceRange = new Observation.ReferenceRange();
	var theMeaningCoding = new CodeableConceptDt();
	var theReferenceRangeMeaningCoding = new CodingDt();	

//	theReferenceRangeMeaningCoding.setCode(obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString());
//	theReferenceRangeMeaningCoding.setSystem(obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString());
//	theReferenceRangeMeaningCoding.setDisplay(obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString());

	theMeaningCoding.addCoding(theReferenceRangeMeaningCoding );
	theReferenceRange.setText(obs[&apos;OBX.7&apos;].toString());
		
	theReferenceRange.setMeaning(theMeaningCoding );
	obsResource.addReferenceRange(theReferenceRange);	

	var theValue = obs[&apos;OBX.5&apos;][&apos;SN.1&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.2&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.3&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.4&apos;].toString();
	theValue = theValue.trim();

	if( theValue == &quot;&quot; )
	{
		theValue = obs[&apos;OBX.5&apos;].toString();
	}

	if( obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString() != &quot;&quot; )
	{
		theValue += &quot; &quot; + obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString();
	}

	obsResource.setValue( new StringDt( theValue ) );

//	logger.error( &quot;Value: &quot; + theValue );

//	logger.error( new XML( $(&apos;ctx&apos;).newXmlParser().encodeResourceToString(obsResource) ).toString() );
	return new XML( $(&apos;ctx&apos;).newXmlParser().encodeResourceToString(obsResource) );
}

/*
function getDiagnosticOrder(obs) {

//
//(SN) Following fields are not mapped in this version:
// OBR.26 [Parent Result] - Optional - If OBR.11 (Specimen Action Code) is populated, then this field is populated with the data in the parent OBX.03 (Observation Identifier) subfield.
// OBR.29 [Parent] - Optional - This field is populated if OBR.11 (Specimen Action Code) is populated.
// OBR.50 [Parent Universal Service Identifier] - Optional - The universal service identifier of the parent order. This field is populated if OBR.11 (Specimen Action Code) is populated.
//
	var diagnosticOrder = &lt;DiagnosticOrder&gt;
					&lt;id value=&quot;obr-observation-request&quot;/&gt;
					&lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/diagnosticorder-precondition&quot;&gt;
						&lt;valueDateTime value=&quot;&quot;/&gt;
					&lt;/extension&gt;
					&lt;subject id=&quot;Patient&quot;/&gt;
					&lt;event&gt;
						&lt;status value=&quot;completed&quot;&gt;
							&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
								&lt;valueCodeableConcept&gt;
									&lt;coding&gt;
										&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0123&quot;/&gt;
										&lt;code value=&quot;&quot;/&gt;
										&lt;display value=&quot;&quot;/&gt;
									&lt;/coding&gt;
								&lt;/valueCodeableConcept&gt;
							&lt;/extension&gt;
						&lt;/status&gt;
						&lt;dateTime value=&quot;&quot;/&gt;
						&lt;actor&gt;
							&lt;reference value=&quot;Practitioner/ordering-provider&quot;/&gt;
						&lt;/actor&gt;
					&lt;/event&gt;
					&lt;item&gt;
						&lt;code&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/code&gt;
						&lt;specimen&gt;
							&lt;display value=&quot;G&quot;/&gt;
						&lt;/specimen&gt;
					&lt;/item&gt;
				&lt;/DiagnosticOrder&gt;;

	diagnosticOrder.extension.valueDateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());

	var resultHandling = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	if (resultHandling) {
		diagnosticOrder.supportingInformation.display.@value = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	} else {
		delete diagnosticOrder.supportingInformation;
	}

	// Result Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBR&apos;][&apos;OBR.25&apos;].toString();
	if (statusCode) {
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0123&quot;, statusCode);
	}

	//  The date/time the results were reported or status changed
	diagnosticOrder.event.dateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;TS.1&apos;].toString());

	// Quest samples contain local and LOINC codes
	diagnosticOrder.item.code.coding.system.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.3&apos;].toString();
	diagnosticOrder.item.code.coding.code.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	diagnosticOrder.item.code.coding.display.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.2&apos;].toString();

	// Specimen Action Code
	var specimenActionCode = obs[&apos;OBR&apos;][&apos;OBR.11&apos;].toString();
	if (specimenActionCode) {
		diagnosticOrder.item.specimen.display.@value = specimenActionCode;
	} else {
		delete diagnosticOrder.item.specimen;
	}

	return diagnosticOrder.toString();
}
*/
/**
	Creates the Observation resourse with a single OBX segment mappings

	@param {String} obs - original ORU_R01.OBSERVATION XML string
	@return {String} return Observation XML string
*/
function getObservationResource(obs) {

	var obsResource = &lt;Observation xmlns=&quot;http://hl7.org/fhir&quot;&gt;			
					&lt;identifier id=&quot;&quot;/&gt;
					&lt;status value=&quot;final&quot;&gt;
						&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
							&lt;valueCodeableConcept&gt;
								&lt;coding&gt;
									&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0085&quot;/&gt;
									&lt;code value=&quot;F&quot;/&gt;
									&lt;display value=&quot;Final results; can only be changed with a corrected result&quot;/&gt;
								&lt;/coding&gt;
							&lt;/valueCodeableConcept&gt;
						&lt;/extension&gt;
					&lt;/status&gt;
					&lt;code&gt;
						&lt;extension url=&quot;http://www.questdiagnostics.com&quot;&gt;
							&lt;valueCoding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/valueCoding&gt;
						&lt;/extension&gt;
						&lt;coding&gt;
							&lt;system value=&quot;http://loinc.org&quot;/&gt;
							&lt;code value=&quot;&quot;/&gt;
							&lt;display value=&quot;&quot;/&gt;
						&lt;/coding&gt;
					&lt;/code&gt;
					&lt;effectiveDateTime value=&quot;&quot;/&gt;
					&lt;issued value=&quot;&quot;/&gt;
					&lt;valueString value=&quot;&quot;/&gt;
					&lt;interpretation&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/interpretation&gt;
					&lt;referenceRange&gt;
						&lt;meaning&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/meaning&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/referenceRange&gt;
				&lt;/Observation&gt;;

	obsResource.identifier.@id =  obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();

	// Result Status - the status of the result value
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBX.11&apos;].toString();
	if (statusCode) {
		 obsResource.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 obsResource.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0085&quot;, statusCode);
	}
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) {
		// Care360 own coding
		obsResource.code.extension.valueCoding.system.@value =  obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.extension.valueCoding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.extension.valueCoding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();

		// LOINC coding
		obsResource.code.coding.system.@value = &quot;http://loinc.org&quot;;
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString();		
	} else {
		delete obsResource.code.extension;
		obsResource.code.coding.system.@value =  obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();			
	}

	var dateTimeOfObservation = obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfObservation) {
		obsResource.effectiveDateTime.@value = convertHL7DateTime(dateTimeOfObservation);
	} else {
		delete obsResource.effectiveDateTime;
	}

	var dateTimeOfAnalysis = obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfAnalysis) {
		obsResource.issued.@value = convertHL7DateTime(dateTimeOfAnalysis);
	} else {
		delete obsResource.issued;
	}

	// March 15: Issues #13: OBX.5 [Observation Value] using SN (Structured Numeric) data type
	var observationValue = &quot;&quot;;
	if (obs[&apos;OBX.5&apos;][&apos;SN.3&apos;]) {
		for each (var sn in obs[&apos;OBX.5&apos;].children()) {
			if (sn.toString()) observationValue += sn.toString(); 
		}
	} else {
		observationValue = obs[&apos;OBX.5&apos;].toString();
	}
	
	if (observationValue) {
		obsResource.valueString.@value = observationValue + &quot; &quot; + obs[&apos;OBX.6&apos;].toString();
	} else {
		delete obsResource.valueString;
	}

	var abnormalFlags = obs[&apos;OBX.8&apos;].toString();
	if (abnormalFlags) {
		obsResource.interpretation.text.@value = abnormalFlags;
	} else {
		delete obsResource.interpretation;
	}

	var unitsOfMeasure = obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString();
	var meaningPresent = true;
	if (unitsOfMeasure) {
		obsResource.referenceRange.meaning.coding.code.@value = unitsOfMeasure;
		if (obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.system.@value = obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.system;
		}
		if (obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.display.@value = obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.display;
		}
	} else {
		meaningPresent = false;
	}
	
	var referencesRange = obs[&apos;OBX.7&apos;].toString();
	var rangePresent = true;
	if (referencesRange) {
		obsResource.referenceRange.text.@value = referencesRange;
	} else {
		delete obsResource.referenceRange.text;
		rangePresent = false;
	}

	if (!meaningPresent &amp;&amp; !rangePresent) delete obsResource.referenceRange;

	// Reference to performing organization
//	obsResource.performer.reference.@value=&quot;Practitioner/obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	logger.error( &quot;Contained Observation: \n&quot; + obsResource.toString() );
	return obsResource.toString();
	
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>4</sequenceNumber>
                <name>Practitioner (Ordering Provider) resource</name>
                <script>/**
	Creates the Practitioner resourse for Ordering Provider with ORC segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getOrderingProvider(obs) {

	// Mar 16 update: /Practitioner/practitionerRole/organization is changed to 
	// /Practitioner/practitionerRole/managingOrganization - tooling issue on the &quot;left side&quot;
	// Note: this breaks STU3 1.4.0 XML Schema validation

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;ordering-provider&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;id value=&quot;orc21-ordering-facility-1&quot;/&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
								&lt;/identifier&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;telecom&gt;
									&lt;system value=&quot;phone&quot;/&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;use value=&quot;work&quot;/&gt;
								&lt;/telecom&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;system value=&quot;NPI&quot;/&gt;
							&lt;value value=&quot;&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
						&lt;practitionerRole&gt;
							&lt;managingOrganization&gt;
								&lt;reference value=&quot;Organization/orc21-ordering-facility-1&quot;/&gt;
							&lt;/managingOrganization&gt;
						&lt;/practitionerRole&gt;
					&lt;/Practitioner&gt;;

	// Practitioner&apos;s own ID
	resPractitioner.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.system.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.13&apos;].toString();

	// Organization this Practitioner belongs to
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.1&apos;].toString();

	// Organization telecom
	var telecom = &quot;(&quot; + obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.6&apos;].toString() + &quot;) &quot; + convertPhone(obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.7&apos;].toString());
	if (telecom.length &gt; 4) {
		resPractitioner.contained.Organization.telecom.value.@value = telecom;
	} else delete resPractitioner.contained.Organization.telecom;

	// Organization address
	var addressInUse = false;
	var line = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;

	// Practitioner name
	var familyName = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);	
	} else {
		delete resPractitioner.name;
	}

	return resPractitioner.toString();	
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates the Practitioner resourse for Ordering Provider with ORC segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getOrderingProvider(obs) {

	// Mar 16 update: /Practitioner/practitionerRole/organization is changed to 
	// /Practitioner/practitionerRole/managingOrganization - tooling issue on the &quot;left side&quot;
	// Note: this breaks STU3 1.4.0 XML Schema validation

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;ordering-provider&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;id value=&quot;orc21-ordering-facility-1&quot;/&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
								&lt;/identifier&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;telecom&gt;
									&lt;system value=&quot;phone&quot;/&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;use value=&quot;work&quot;/&gt;
								&lt;/telecom&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;system value=&quot;NPI&quot;/&gt;
							&lt;value value=&quot;&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
						&lt;practitionerRole&gt;
							&lt;managingOrganization&gt;
								&lt;reference value=&quot;Organization/orc21-ordering-facility-1&quot;/&gt;
							&lt;/managingOrganization&gt;
						&lt;/practitionerRole&gt;
					&lt;/Practitioner&gt;;

	// Practitioner&apos;s own ID
	resPractitioner.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.system.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.13&apos;].toString();

	// Organization this Practitioner belongs to
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.1&apos;].toString();

	// Organization telecom
	var telecom = &quot;(&quot; + obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.6&apos;].toString() + &quot;) &quot; + convertPhone(obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.7&apos;].toString());
	if (telecom.length &gt; 4) {
		resPractitioner.contained.Organization.telecom.value.@value = telecom;
	} else delete resPractitioner.contained.Organization.telecom;

	// Organization address
	var addressInUse = false;
	var line = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;

	// Practitioner name
	var familyName = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);	
	} else {
		delete resPractitioner.name;
	}

	return resPractitioner.toString();	
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>5</sequenceNumber>
                <name>Practitioner (Performing Organization) resource</name>
                <script>/**
	Creates the Practitioner resourse for OBX.23 [Performing Organization Name],
	OBX.24 [Performing Organization Address] and OBX.25[Performing Organization Medical Director] for each OBX segment

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getPerformingProvider(obs) {

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;obx-performing-organization&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;assigner id=&quot;CLIA&quot;/&gt;
								&lt;/identifier&gt;
								&lt;type&gt;
									&lt;text value=&quot;FI&quot;/&gt;
								&lt;/type&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;type&gt;
								&lt;text value=&quot;NPI&quot;/&gt;
							&lt;/type&gt;
							&lt;value value=&quot;&quot;/&gt;
							&lt;assigner id=&quot;EN&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
					&lt;/Practitioner&gt;;

	// Performing Organization Name
	resPractitioner.id.@value = &quot;obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;OBX.23&apos;][&apos;XON.1&apos;].toString();
	

	// Performing Organization Address
	var addressInUse = false;
	var line = obs[&apos;OBX.24&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;OBX.24&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;OBX.24&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;OBX.24&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;


	// Medical Director
	resPractitioner.identifier.value.@value = obs[&apos;OBX.25&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.assigner.@id = obs[&apos;OBX.25&apos;][&apos;XCN.14&apos;][&apos;HD.1&apos;].toString()

	// Medical Director Name
	var familyName = obs[&apos;OBX.25&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;suffix value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString() +&apos;&quot;/&gt;&apos;);				
	} else {
		delete resPractitioner.name;
	}

	
	return resPractitioner.toString();		
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates the Practitioner resourse for OBX.23 [Performing Organization Name],
	OBX.24 [Performing Organization Address] and OBX.25[Performing Organization Medical Director] for each OBX segment

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getPerformingProvider(obs) {

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;obx-performing-organization&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;assigner id=&quot;CLIA&quot;/&gt;
								&lt;/identifier&gt;
								&lt;type&gt;
									&lt;text value=&quot;FI&quot;/&gt;
								&lt;/type&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;type&gt;
								&lt;text value=&quot;NPI&quot;/&gt;
							&lt;/type&gt;
							&lt;value value=&quot;&quot;/&gt;
							&lt;assigner id=&quot;EN&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
					&lt;/Practitioner&gt;;

	// Performing Organization Name
	resPractitioner.id.@value = &quot;obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;OBX.23&apos;][&apos;XON.1&apos;].toString();
	

	// Performing Organization Address
	var addressInUse = false;
	var line = obs[&apos;OBX.24&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;OBX.24&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;OBX.24&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;OBX.24&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;


	// Medical Director
	resPractitioner.identifier.value.@value = obs[&apos;OBX.25&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.assigner.@id = obs[&apos;OBX.25&apos;][&apos;XCN.14&apos;][&apos;HD.1&apos;].toString()

	// Medical Director Name
	var familyName = obs[&apos;OBX.25&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;suffix value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString() +&apos;&quot;/&gt;&apos;);				
	} else {
		delete resPractitioner.name;
	}

	
	return resPractitioner.toString();		
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64">TVNIfF5+XCZ8UUxTfFRNRV4wNUQwNjQyODI3XkNMSUF8fDkwMDQ2MDAzfDIwMTcwNTExMTEyODM1
LjAwMC0wNzAwfHxPUlVeUjAxXk9SVV9SMDF8ODAwMDAwMDAwMDAwMDEwMzMyMDB8UHwyLjUuMXwx
fHxBTHxORXx8fHx8TFJJX05HX1JOX1Byb2ZpbGVeXjIuMTYuODQwLjEuMTEzODgzLjkuMjBeSVNP
ClBJRHwxfHxTQUZFLjExMTExMTExXl5eXlBUfjg1NjcxMDA5NjAyODQ0NjdeXl5eQU58fFNNSVRI
XkpJTExeXl5eXkx8fDE5NTgxMjI4fE18fHwxMTExIE1JTEwgU1ReXlJPU1dFTExeR0FeMzAwNzZe
VVNBCk5URXwxfEx8RkFTVElORzpOTwpPUkN8UkV8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5
NTFUXlFVRVNUX1RNRXx8Q018fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5e
TlBJfHx8fHx8fHx8U0FGRSBJUEMsQSBQUk9GRVNTSU9OQUwgQ09SUC5eXl5eXl5eXl45MDA0NjAw
M3w3OTA0IFNBTlRBIE1PTklDQSBCTFZEIFNURSAzMDBeTUFJTDAwMF5XRVNUIEhPTExZV09PRF5D
QV45MDA0Ni01MTcwXl5PXl5VU0F8Xl5eXl4zMTBeNTc5Mjc3OApPQlJ8MXw5XlFVRVNUX1RNRV85
MDA0NjAwM3xXSDM1MDk1MVReUVVFU1RfVE1FfDQ5OF5IQlNBRyBXL1JGTCBDT05GXjk5UURJfHx8
MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8fHx8fHx8fHwxNDk3ODc1MDI1XktBV0VTQ0heR0FSWV5e
Xl5eXl5eXl5OUEl8fHx8fHwyMDE3MDUxMTExMjgzNS4wMDAtMDcwMHx8fEYKT0JYfDF8U1R8NTUw
MTkzMDBeSEVQQVRJVElTIEIgU1VSRkFDRSBBTlRJR0VOXjk5UURJXjUxOTYtMV5IQlYgc3VyZmFj
ZSBBZyBTZXJQbCBRbCBJQV5MTnwxfFJFQUNUSVZFfHxOT04tUkVBQ1RJVkV8QXx8fEZ8fHwyMDE3
MDUxMTExMjgzNS4wMDAtMDcwMHx8fHx8MjAxNzA1MTEwODMzMTQuMDAwLTA3MDB8fHx8UVVFU1Qg
RElBR05PU1RJQ1MtV0VTVCBISUxMU15eXl5eXkZJXkNMSUFeXjA1RDA2NDI4Mjd8ODQwMSBGQUxM
QlJPT0sgQVZFTlVFXl5XRVNUIEhJTExTXkNBXjkxMzA0LTMyMjZ8MTM2NjQ3OTA5OV5URVJSQVpB
U15FTlJJUVVFXl5NRF5eXl5eXl5eTlBJXkVOCk9CWHwyfFNUfDU1MDE5NjAwXkNPTkZJUk1BVElP
Tl45OVFESV43OTA1LTNeSEJWIHN1cmZhY2UgQWcgU2VyUGwgUWwgTnReTE58MXxETlJ8fHxOfHx8
WHx8fDIwMTcwNTExMTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4MzMxNC4wMDAtMDcwMHx8
fHxRVUVTVCBESUFHTk9TVElDUy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4
NDAxIEZBTExCUk9PSyBBVkVOVUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5
XlRFUlJBWkFTXkVOUklRVUVeXk1EXl5eXl5eXl5OUEleRU4KU1BNfDF8MDNeMDN8fFVTUEVDXlNv
dXJjZSwgVW5zcGVjaWZpZWReSEw3MDQ4N3x8fHx8fHx8fHx8fHwyMDE3MDUxMDEzMzYwMC4wMDAt
MDcwMHwyMDE3MDUxMTA4MDExOC4wMDAtMDcwMApPUkN8UkV8OV5RVUVTVF9UTUVfOTAwNDYwMDN8
V0gzNTA5NTFUXlFVRVNUX1RNRXx8Q018fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5e
Xl5eXl5eTlBJfHx8fHx8fHx8U0FGRSBJUEMsQSBQUk9GRVNTSU9OQUwgQ09SUC5eXl5eXl5eXl45
MDA0NjAwM3w3OTA0IFNBTlRBIE1PTklDQSBCTFZEIFNURSAzMDBeTUFJTDAwMF5XRVNUIEhPTExZ
V09PRF5DQV45MDA0Ni01MTcwXl5PXl5VU0F8Xl5eXl4zMTBeNTc5Mjc3OApPQlJ8Mnw5XlFVRVNU
X1RNRV85MDA0NjAwM3xXSDM1MDk1MVReUVVFU1RfVE1FfDg0NzJeSEVQIEMgQUIgVy9SRUZMIEhD
Vl45OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfHx8fHx8fHx8MTQ5Nzg3NTAyNV5LQVdF
U0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHxGCk9C
WHwxfFNUfDU1MDcxNjAwXkhFUEFUSVRJUyBDIEFOVElCT0RZXjk5UURJXjEzOTU1LTBeSENWIEFi
IFNlclBsIFFsIElBXkxOfDF8UkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxBfHx8Rnx8fDIwMTcwNTEx
MTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4MzM0NC4wMDAtMDcwMHx8fHxRVUVTVCBESUFH
Tk9TVElDUy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9P
SyBBVkVOVUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVO
UklRVUVeXk1EXl5eXl5eXl5OUEleRU4KT0JYfDJ8Tk18NTUwNzE3MDVeU0lHTkFMIFRPIENVVC1P
RkZeOTlRREleNDgxNTktOF5IQ1YgQWIgcy9jbyBTZXJQbCBJQV5MTnwxfDEwLjAwfHw8MS4wMHxI
fHx8Rnx8fDIwMTcwNTExMTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4MzM0NC4wMDAtMDcw
MHx8fHxRVUVTVCBESUFHTk9TVElDUy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0Mjgy
N3w4NDAxIEZBTExCUk9PSyBBVkVOVUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5
MDk5XlRFUlJBWkFTXkVOUklRVUVeXk1EXl5eXl5eXl5OUEleRU4KTlRFfDF8THwgCk5URXwyfEx8
Rm9sbG93aW5nIENEQyByZWNvbW1lbmRhdGlvbnMgKE1NV1IgTm8uIDYyLCAyMDEzKSwgdGhpcwpO
VEV8M3xMfHBhdGllbnQncyBIQ1YgQW50aWJvZHkgUmVhY3RpdmUgc2FtcGxlIHdpbGwgYmUgdGVz
dGVkIGZvcgpOVEV8NHxMfHRoZSBwcmVzZW5jZSBvZiBIQ1YgUk5BIGJ5IGEgTnVjbGVpYyBBY2lk
IEFtcGxpZmljYXRpb24KTlRFfDV8THxUZXN0IChOQUFUKSB0byBkZXRlcm1pbmUgaWYgdGhlIHBh
dGllbnQgaGFzIGFuIGFjdGl2ZSBIQ1YKTlRFfDZ8THxpbmZlY3Rpb24uCk5URXw3fEx8IApTUE18
MXwwM14wM3x8VVNQRUNeU291cmNlLCBVbnNwZWNpZmllZF5ITDcwNDg3fHx8fHx8fHx8fHx8fDIw
MTcwNTEwMTMzNjAwLjAwMC0wNzAwfDIwMTcwNTExMDgwMTE4LjAwMC0wNzAwCk9SQ3xSRXw5XlFV
RVNUX1RNRV85MDA0NjAwM3xXSDM1MDk1MVReUVVFU1RfVE1FfHxDTXx8fHx8fHwxNDk3ODc1MDI1
XktBV0VTQ0heR0FSWV5eXl5eXl5eXl5OUEl8fHx8fHx8fHxTQUZFIElQQyxBIFBST0ZFU1NJT05B
TCBDT1JQLl5eXl5eXl5eXjkwMDQ2MDAzfDc5MDQgU0FOVEEgTU9OSUNBIEJMVkQgU1RFIDMwMF5N
QUlMMDAwXldFU1QgSE9MTFlXT09EXkNBXjkwMDQ2LTUxNzBeXk9eXlVTQXxeXl5eXjMxMF41Nzky
Nzc4fHx8fHx8fHw4NDcyXkhFUCBDIEFCIFcvUkVGTCBIQ1ZeOTlRREleNTYwMDAwODQ3Ml5eVU5J
VENPREUKT0JSfDN8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXwlMzU2
NDVeSENWIFJOQSwgUU4gUENSXjk5UURJfHx8MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8fHx8R3x8
fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTExMTI4
MzUuMDAwLTA3MDB8fHxGfDU1MDcxNjAwJkhFUEFUSVRJUyBDIEFOVElCT0RZJjk5UURJJjEzOTU1
LTAmSENWIEFiIFNlclBsIFFsIElBJkxOfHx8OSZRVUVTVF9UTUVfOTAwNDYwMDNeV0gzNTA5NTFU
JlFVRVNUX1RNRXx8fHx8fHx8fHx8fHx8fHx8fHx8fDg0NzJeSEVQIEMgQUIgVy9SRUZMIEhDVl45
OVFESV41NjAwMDA4NDcyXl5VTklUQ09ERQpOVEV8MXxMfFRoZSBhbmFseXRpY2FsIHBlcmZvcm1h
bmNlIGNoYXJhY3RlcmlzdGljcyBvZiB0aGlzCk5URXwyfEx8YXNzYXkgaGF2ZSBiZWVuIGRldGVy
bWluZWQgYnkgUXVlc3QgRGlhZ25vc3RpY3MuIApOVEV8M3xMfFRoZSBtb2RpZmljYXRpb25zIGhh
dmUgbm90IGJlZW4gY2xlYXJlZCBvciBhcHByb3ZlZCBieQpOVEV8NHxMfHRoZSBGREEuIFRoaXMg
YXNzYXkgaGFzIGJlZW4gdmFsaWRhdGVkIHB1cnN1YW50IHRvIHRoZSAKTlRFfDV8THxDTElBIHJl
Z3VsYXRpb25zIGFuZCBpcyB1c2VkIGZvciBjbGluaWNhbCBwdXJwb3Nlcy4gIApOVEV8NnxMfCAK
TlRFfDd8THxUaGlzIHRlc3Qgd2FzIHBlcmZvcm1lZCB1c2luZyB0aGUgQ09CQVMoUilBbXBsaVBy
ZXAvCk5URXw4fEx8Q09CQVMoUilUYXFNYW4oUilIQ1YgVGVzdCx2Mi4wLgpOVEV8OXxMfCAKTlRF
fDEwfEx8Rm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhpcyB0ZXN0LCBnbyB0bzoKTlRFfDExfEx8
aHR0cDovL2VkdWNhdGlvbi5xdWVzdGRpYWdub3N0aWNzLmNvbS9mYXEvRkFRMjJ2MQpOVEV8MTJ8
THwoVGhpcyBsaW5rIGlzIGJlaW5nIHByb3ZpZGVkIGZvciBpbmZvcm1hdGlvbmFsLwpOVEV8MTN8
THxlZHVjYXRpb25hbCBwdXJwb3NlcyBvbmx5LikKTlRFfDE0fEx8IApPQlh8MXxOTXw1NTE5NDI1
NV5IQ1YgUk5BLCBRVUFOVElUQVRJVkUgUkVBTCBUSU1FIFBDUl45OVFESV4xMTAxMS00XkhDViBS
TkEgU2VyUGwgUENSLWFDbmNeTE58MXwxNXxJVS9tTF5eOTlRREl8PDE1fEh8fHxGfHx8MjAxNzA1
MTExMTI4MzUuMDAwLTA3MDB8fHx8fDIwMTcwNTExMDgzNDE1LjAwMC0wNzAwfHx8fFFVRVNUIERJ
QUdOT1NUSUNTLVdFU1QgSElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3fDg0MDEgRkFMTEJS
T09LIEFWRU5VRV5eV0VTVCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0NzkwOTleVEVSUkFaQVNe
RU5SSVFVRV5eTUReXl5eXl5eXk5QSV5FTgpPQlh8MnxOTXw1NTE5NDI2NV5IQ1YgUk5BLCBRVUFO
VElUQVRJVkUgUkVBTCBUSU1FIFBDUl45OVFESV4zODE4MC02XkhDViBSTkEgU2VyUGwgUENSLUxv
ZyBJVV5MTnwxfDEuMTh8TG9nIElVL21MXkxvZyBJVS9tTF45OVFESXw8MS4xOHxIfHx8Rnx8fDIw
MTcwNTExMTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4MzQxNS4wMDAtMDcwMHx8fHxRVUVT
VCBESUFHTk9TVElDUy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZB
TExCUk9PSyBBVkVOVUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJB
WkFTXkVOUklRVUVeXk1EXl5eXl5eXl5OUEleRU4KTlRFfDF8THwgCk5URXwyfEx8UGxlYXNlIG5v
dGU6IFBhdGllbnRzIHdpdGggY2lyY3VsYXRpbmcgYW50aS1IQ1YKTlRFfDN8THxhbnRpYm9kaWVz
IHRoYXQgaGF2ZSBkZXRlY3RhYmxlIEhDViBSTkEgYXMgZGV0ZXJtaW5lZApOVEV8NHxMfGJ5IE5B
VCwgc2hvdWxkIGJlIGNvbnNpZGVyZWQgdG8gaGF2ZSBhbiBhY3RpdmUgSENWCk5URXw1fEx8aW5m
ZWN0aW9uLiBQbGVhc2UgY29ycmVsYXRlIHRoZXNlIGZpbmRpbmdzIHdpdGggdGhlCk5URXw2fEx8
cGF0aWVudCdzIGNsaW5pY2FsIGhpc3RvcnkgYW5kIGFueSBvdGhlciBkaWFnbm9zdGljcwpOVEV8
N3xMfGZpbmRpbmdzLCBpbmNsdWRpbmcgYW55IGV2aWRlbmNlIG9mIGxpdmVyIGR5c2Z1bmN0aW9u
LgpOVEV8OHxMfFBsZWFzZSBjb25zaWRlciB0aGUgY3VycmVudCBUcmVhdG1lbnQgR3VpZGVsaW5l
cyBmb3IKTlRFfDl8THx0aGUgbWFuYWdlbWVudCBvZiB0aGVzZSBwYXRpZW50cyAoSiBIZXBhdG9s
LCAxNDMzLTE0NDQsCk5URXwxMHxMfE9jdDIwMTEpLgpOVEV8MTF8THwgClNQTXwxfDAzXjAzfHxV
U1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8MjAxNzA1MTAxMzM2
MDAuMDAwLTA3MDB8MjAxNzA1MTEwODAxMDAuMDAwLTA3MDAKT1JDfFJFfDleUVVFU1RfVE1FXzkw
MDQ2MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8fDE0OTc4NzUwMjVeS0FXRVNDSF5H
QVJZXl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEgUFJPRkVTU0lPTkFMIENPUlAuXl5e
Xl5eXl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxWRCBTVEUgMzAwXk1BSUwwMDBeV0VT
VCBIT0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5eXl5eMzEwXjU3OTI3NzgKT0JSfDR8
OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXwzNjQwXkhTViAyIElHR145
OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfHx8fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NI
XkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHxGCk9CWHwx
fE5NfDcwMDIwNjAwXkhTViAyIElHRywgVFlQRSBTUEVDSUZJQyBBQl45OVFESV41MjA5LTJeSFNW
MiBJZ0cgU2VyIElBLWFDbmNeTE58MXwxMi4wMHxpbmRleF5eOTlRREl8fEh8fHxGfHx8MjAxNzA1
MTExMTI4MzUuMDAwLTA3MDB8fHx8fDIwMTcwNTExMDg0MDAyLjAwMC0wNzAwfHx8fFFVRVNUIERJ
QUdOT1NUSUNTLVdFU1QgSElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3fDg0MDEgRkFMTEJS
T09LIEFWRU5VRV5eV0VTVCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0NzkwOTleVEVSUkFaQVNe
RU5SSVFVRV5eTUReXl5eXl5eXk5QSV5FTgpOVEV8MXxMfCAgICAgICAgICAgICAgICAgICAgICAg
ICAgSW5kZXggICAgICAgICAgSW50ZXJwcmV0YXRpb24KTlRFfDJ8THwgICAgICAgICAgICAgICAg
ICAgICAgICAgIC0tLS0tICAgICAgICAgIC0tLS0tLS0tLS0tLS0tCk5URXwzfEx8ICAgICAgICAg
ICAgICAgICAgICAgICAgICA8MC45MCAgICAgICAgICBOZWdhdGl2ZQpOVEV8NHxMfCAgICAgICAg
ICAgICAgICAgICAgICAgICAgMC45MC0xLjA5ICAgICAgRXF1aXZvY2FsCk5URXw1fEx8ICAgICAg
ICAgICAgICAgICAgICAgICAgICA+MS4wOSAgICAgICAgICBQb3NpdGl2ZQpOVEV8NnxMfCAKTlRF
fDd8THxUaGlzIGFzc2F5IHV0aWxpemVzIHJlY29tYmluYW50IHR5cGUtc3BlY2lmaWMgYW50aWdl
bnMKTlRFfDh8THx0byBkaWZmZXJlbnRpYXRlIEhTVi0xIGZyb20gSFNWLTIgaW5mZWN0aW9ucy4g
QQpOVEV8OXxMfHBvc2l0aXZlIHJlc3VsdCBjYW5ub3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiByZWNl
bnQgYW5kCk5URXwxMHxMfHBhc3QgaW5mZWN0aW9uLiBJZiByZWNlbnQgSFNWIGluZmVjdGlvbiBp
cyBzdXNwZWN0ZWQKTlRFfDExfEx8YnV0IHRoZSByZXN1bHRzIGFyZSBuZWdhdGl2ZSBvciBlcXVp
dm9jYWwsIHRoZSBhc3NheQpOVEV8MTJ8THxzaG91bGQgYmUgcmVwZWF0ZWQgaW4gNC02IHdlZWtz
LiBUaGUgcGVyZm9ybWFuY2UKTlRFfDEzfEx8Y2hhcmFjdGVyaXN0aWNzIG9mIHRoZSBhc3NheSBo
YXZlIG5vdCBiZWVuIGVzdGFibGlzaGVkCk5URXwxNHxMfGZvciBwZWRpYXRyaWMgcG9wdWxhdGlv
bnMsIGltbXVub2NvbXByb21pc2VkIHBhdGllbnRzLApOVEV8MTV8THxvciBuZW9uYXRhbCBzY3Jl
ZW5pbmcuClNQTXwxfDAyXjAyfHxVU1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8
fHx8fHx8fHx8MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8MjAxNzA1MTEwODAxMTguMDAwLTA3MDAK
T1JDfFJFfDleUVVFU1RfVE1FXzkwMDQ2MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8
fDE0OTc4NzUwMjVeS0FXRVNDSF5HQVJZXl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEg
UFJPRkVTU0lPTkFMIENPUlAuXl5eXl5eXl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxW
RCBTVEUgMzAwXk1BSUwwMDBeV0VTVCBIT0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5e
Xl5eMzEwXjU3OTI3NzgKT0JSfDV8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNU
X1RNRXw5MTQzMV5ISVYxLzIgQUcvQUIsNCBXL1JGTF45OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAw
MC0wNzAwfHx8fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8
MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHxGCk9CWHwxfFNUfDg2MDA5MDUyXkhJViBBRy9BQiwg
NFRIIEdFTl45OVFESV41Njg4OC0xXkhJViAxKzIgQWIrSElWMSBwMjQgQWcgU2VyUGwgUWwgSUFe
TE58MXxOT04tUkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxOfHx8Rnx8fDIwMTcwNTExMTEyODM1LjAw
MC0wNzAwfHx8fHwyMDE3MDUxMTA4NDEzOC4wMDAtMDcwMHx8fHxRVUVTVCBESUFHTk9TVElDUy1X
RVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9PSyBBVkVOVUVe
XldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVOUklRVUVeXk1E
Xl5eXl5eXl5OUEleRU4KTlRFfDF8THxUaGUgcmVwZWF0ZWRseSByZWFjdGl2ZSBzY3JlZW5pbmcg
YXNzYXkgcmVzdWx0IGlzCk5URXwyfEx8Y29uZmlybWVkIGJ5IGR1cGxpY2F0ZSByZXBlYXQgdGVz
dGluZywgYW5kIGluZGljYXRlcwpOVEV8M3xMfGEgUE9TU0lCTEUgcHJlc2VuY2Ugb2YgSElWLTEg
YW50aWJvZGllcyBvciBISVYtMiAKTlRFfDR8THxhbnRpYm9kaWVzLCBhbmQvb3IgSElWLTEgcDI0
IGFudGlnZW4uIEFkZGl0aW9uYWwKTlRFfDV8THx0ZXN0aW5nIGlzIHJlcXVpcmVkIGZvciBkaWFn
bm9zaXMuIApOVEV8NnxMfCAKTlRFfDd8THxUaGVyZWZvcmUsIHRoZXNlIHNjcmVlbmluZyByZXN1
bHRzIG11c3QgYmUgY29ycmVsYXRlZCAKTlRFfDh8THx3aXRoIHJlc3VsdHMgb2YgcmVmbGV4IGNv
bmZpcm1hdG9yeSB0ZXN0cywgaW5jbHVkaW5nCk5URXw5fEx8dGhlIEhJVi0xL0hJVi0yIGFudGli
b2R5IGRpZmZlcmVudGlhdGlvbiBhc3NheSBhbmQsIGlmIApOVEV8MTB8THxuZWNlc3NhcnksIHRo
ZSBISVYtMSBSTkEgcXVhbGl0YXRpdmUgVE1BLgpOVEV8MTF8THwgCk5URXwxMnxMfFRoZSA0dGgg
Z2VuZXJhdGlvbiBISVYtMS8yIEFudGlnZW4vQW50aWJvZHkKTlRFfDEzfEx8Y29tYmluYXRpb24g
aW1tdW5vYXNzYXkgaXMgYSBzY3JlZW5pbmcgdGVzdCBhbmQKTlRFfDE0fEx8c2hvdWxkIG5vdCBi
ZSB1c2VkIGFsb25lIGZvciBkaWFnbm9zaXMuICBSZXBlYXRlZGx5Ck5URXwxNXxMfHJlYWN0aXZl
IHJlc3VsdHMgZnJvbSB0aGUgNHRoIGdlbmVyYXRpb24gc2NyZWVuaW5nCk5URXwxNnxMfHRlc3Qg
YXJlIG9ubHkgaW5kaWNhdGl2ZSBvZiBISVYgaW5mZWN0aW9uIHdoZW4gdGhvc2UKTlRFfDE3fEx8
c2NyZWVuaW5nIHJlc3VsdHMgYXJlIGNvbmZpcm1lZCB0byBiZSBwb3NpdGl2ZSBieQpOVEV8MTh8
THxlaXRoZXIgdGhlIEhJVi0xLzIgQW50aWJvZHkgRGlmZmVyZW50aWF0aW9uIEFzc2F5IG9yCk5U
RXwxOXxMfHRoZSBISVYtMSBSTkEgdGVzdCBieSBUTUEuCk5URXwyMHxMfCAKTlRFfDIxfEx8UExF
QVNFIE5PVEU6IFRoaXMgaW5mb3JtYXRpb24gaGFzIGJlZW4gZGlzY2xvc2VkIHRvCk5URXwyMnxM
fHlvdSBmcm9tIHJlY29yZHMgd2hvc2UgY29uZmlkZW50aWFsaXR5IG1heSBiZQpOVEV8MjN8THxw
cm90ZWN0ZWQgYnkgc3RhdGUgbGF3LiAgSWYgeW91ciBzdGF0ZSByZXF1aXJlcyBzdWNoCk5URXwy
NHxMfHByb3RlY3Rpb24sIHRoZW4gdGhlIHN0YXRlIGxhdyBwcm9oaWJpdHMgeW91IGZyb20KTlRF
fDI1fEx8bWFraW5nIGFueSBmdXJ0aGVyIGRpc2Nsb3N1cmUgb2YgdGhlIGluZm9ybWF0aW9uCk5U
RXwyNnxMfHdpdGhvdXQgdGhlIHNwZWNpZmljIHdyaXR0ZW4gY29uc2VudCBvZiB0aGUgcGVyc29u
Ck5URXwyN3xMfHRvIHdob20gaXQgcGVydGFpbnMsIG9yIGFzIG90aGVyd2lzZSBwZXJtaXR0ZWQg
YnkgbGF3LgpOVEV8Mjh8THxBIGdlbmVyYWwgYXV0aG9yaXphdGlvbiBmb3IgdGhlIHJlbGVhc2Ug
b2YgbWVkaWNhbCBvcgpOVEV8Mjl8THxvdGhlciBpbmZvcm1hdGlvbiBpcyBOT1Qgc3VmZmljaWVu
dCBmb3IgdGhpcyBwdXJwb3NlLgpOVEV8MzB8THwgCk5URXwzMXxMfFRoZSBwZXJmb3JtYW5jZSBv
ZiB0aGlzIGFzc2F5IGhhcyBub3QgYmVlbiBjbGluaWNhbGx5Ck5URXwzMnxMfHZhbGlkYXRlZCBp
biBwYXRpZW50cyBsZXNzIHRoYW4gMiB5ZWFycyBvbGQuCk5URXwzM3xMfCAKU1BNfDF8fHxVU1BF
Q15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8MjAxNzA1MTAxMzM2MDAu
MDAwLTA3MDB8MjAxNzA1MTEwODAxMTguMDAwLTA3MDAKT1JDfFJFfDleUVVFU1RfVE1FXzkwMDQ2
MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8fDE0OTc4NzUwMjVeS0FXRVNDSF5HQVJZ
Xl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEgUFJPRkVTU0lPTkFMIENPUlAuXl5eXl5e
Xl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxWRCBTVEUgMzAwXk1BSUwwMDBeV0VTVCBI
T0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5eXl5eMzEwXjU3OTI3Nzh8fHx8fHx8fCVT
QkhJVjIzXkhJViA0VEggR0VOIFNDUiAyLDNeOTlRREleNzAwOTk5MTQzMV5eVU5JVENPREUKT0JS
fDZ8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXwlOTE0MzJeSElWIDEv
MiBBQiBESUZGXjk5UURJfHx8MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8fHx8R3x8fHx8MTQ5Nzg3
NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3
MDB8fHxGfDg2MDExNjEyJkhJViBSRVBFQVQgQSY5OVFESXx8fDkmUVVFU1RfVE1FXzkwMDQ2MDAz
XldIMzUwOTUxVCZRVUVTVF9UTUV8fHx8fHx8fHx8fHx8fHx8fHx8fHwlU0JISVYyM15ISVYgNFRI
IEdFTiBTQ1IgMiwzXjk5UURJXjcwMDk5OTE0MzFeXlVOSVRDT0RFCk9CWHwxfFNUfDg2MDA5MDU2
XkhJViAxIEFOVElCT0RZXjk5UURJXjI5ODkzLTVeSElWMSBBYiBTZXJQbCBRbCBJQV5MTnwxfFBP
U0lUSVZFfHxORUdBVElWRXxBfHx8Rnx8fDIwMTcwNTExMTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3
MDUxMTA4NDEzNy4wMDAtMDcwMHx8fHxRVUVTVCBESUFHTk9TVElDUy1XRVNUIEhJTExTXl5eXl5e
RkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9PSyBBVkVOVUVeXldFU1QgSElMTFNeQ0Fe
OTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVOUklRVUVeXk1EXl5eXl5eXl5OUEleRU4K
T0JYfDJ8U1R8ODYwMDkwNTdeSElWIDIgQU5USUJPRFleOTlRREleMzAzNjEtMF5ISVYgMiBBYiBT
ZXJQbCBRbCBJQV5MTnwxfE5FR0FUSVZFfHxORUdBVElWRXxOfHx8Rnx8fDIwMTcwNTExMTEyODM1
LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4NDEzNy4wMDAtMDcwMHx8fHxRVUVTVCBESUFHTk9TVElD
Uy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9PSyBBVkVO
VUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVOUklRVUVe
Xk1EXl5eXl5eXl5OUEleRU4KTlRFfDF8THwgCk5URXwyfEx8UG9zaXRpdmUgZm9yIEhJVi0xIGFu
dGlib2RpZXMuCk5URXwzfEx8IApOVEV8NHxMfExhYm9yYXRvcnkgZXZpZGVuY2Ugb2YgSElWLTEg
aW5mZWN0aW9uIGlzIHByZXNlbnQgaW4gCk5URXw1fEx8cGF0aWVudHMgZ3JlYXRlciB0aGFuIDI0
IG1vbnRocyBvZiBhZ2UuIApOVEV8NnxMfCAKTlRFfDd8THxJbiBwYXRpZW50cyBsZXNzIHRoYW4g
MjQgbW9udGhzIG9mIGFnZSwgYSBwb3NpdGl2ZSBISVYtMQpOVEV8OHxMfEFudGlib2R5IERpZmZl
cmVudGlhdGlvbiBhc3NheSByZXN1bHQgbWF5IHJlcHJlc2VudCAKTlRFfDl8THxwYXNzaXZlIHRy
YW5zZmVyIG9mIG1hdGVybmFsIGFudGlib2R5LiBJbiBwYXRpZW50cyBsZXNzCk5URXwxMHxMfHRo
YW4gMjQgbW9udGhzIG9mIGFnZSwgdGVzdGluZyB0aGUgcGF0aWVudCdzIHNwZWNpbWVuCk5URXwx
MXxMfHdpdGggdGhlIEhJVi0xIFJOQSBRdWFsaXRhdGl2ZSBUTUEgYXNzYXkgKHRlc3QgY29kZSAK
TlRFfDEyfEx8MTYxODUpIG9yIHRoZSBISVYtMSBETkEsIFF1YWxpdGF0aXZlLCBQQ1IgYXNzYXkg
KHRlc3QgCk5URXwxM3xMfGNvZGUgODQwMSkgaXMgcmVjb21tZW5kZWQgdG8gY29uZmlybSBISVYt
MSBpbmZlY3Rpb24uCk5URXwxNHxMfCAKTlRFfDE1fEx8UExFQVNFIE5PVEU6IFRoaXMgaW5mb3Jt
YXRpb24gaGFzIGJlZW4gZGlzY2xvc2VkIHRvCk5URXwxNnxMfHlvdSBmcm9tIHJlY29yZHMgd2hv
c2UgY29uZmlkZW50aWFsaXR5IG1heSBiZQpOVEV8MTd8THxwcm90ZWN0ZWQgYnkgc3RhdGUgbGF3
LiAgSWYgeW91ciBzdGF0ZSByZXF1aXJlcyBzdWNoCk5URXwxOHxMfHByb3RlY3Rpb24sIHRoZW4g
dGhlIHN0YXRlIGxhdyBwcm9oaWJpdHMgeW91IGZyb20gCk5URXwxOXxMfG1ha2luZyBhbnkgZnVy
dGhlciBkaXNjbG9zdXJlIG9mIHRoZSBpbmZvcm1hdGlvbgpOVEV8MjB8THx3aXRob3V0IHRoZSBz
cGVjaWZpYyB3cml0dGVuIGNvbnNlbnQgb2YgdGhlIHBlcnNvbgpOVEV8MjF8THx0byB3aG9tIGl0
IHBlcnRhaW5zLCBvciBhcyBvdGhlcndpc2UgcGVybWl0dGVkIGJ5IGxhdy4KTlRFfDIyfEx8QSBn
ZW5lcmFsIGF1dGhvcml6YXRpb24gZm9yIHRoZSByZWxlYXNlIG9mIG1lZGljYWwgb3IKTlRFfDIz
fEx8b3RoZXIgaW5mb3JtYXRpb24gaXMgTk9UIHN1ZmZpY2llbnQgZm9yIHRoaXMgcHVycG9zZS4K
TlRFfDI0fEx8IApOVEV8MjV8THxGb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBwbGVhc2UgcmVm
ZXIgdG8KTlRFfDI2fEx8aHR0cDovL2VkdWNhdGlvbi5xdWVzdGRpYWdub3N0aWNzLmNvbS9mYXEv
RkFRMTA2Ck5URXwyN3xMfChUaGlzIGxpbmsgaXMgYmVpbmcgcHJvdmlkZWQgZm9yIGluZm9ybWF0
aW9uYWwvCk5URXwyOHxMfGVkdWNhdGlvbmFsIHB1cnBvc2VzIG9ubHkuKQpOVEV8Mjl8THwgClNQ
TXwxfDA0XjA0fHxVU1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8
MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8MjAxNzA1MTEwODAxMDAuMDAwLTA3MDAKT1JDfFJFfDle
UVVFU1RfVE1FXzkwMDQ2MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8fDE0OTc4NzUw
MjVeS0FXRVNDSF5HQVJZXl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEgUFJPRkVTU0lP
TkFMIENPUlAuXl5eXl5eXl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxWRCBTVEUgMzAw
Xk1BSUwwMDBeV0VTVCBIT0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5eXl5eMzEwXjU3
OTI3NzgKT0JSfDd8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXwxNzEz
NF5TUEVDIElEIE5PVElGSUNBVElPTl45OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfHx8
fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTEx
MTI4MzUuMDAwLTA3MDB8fHxGCk9CWHwxfHw4NjAwNjU1Nl5DT01NRU5UOl45OVFESV44MjUxLTFe
U2VydmljZSBDbW50IFhYWC1JbXBeTE58MXx8fHx8fHxGfHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3
MDB8fHx8fDIwMTcwNTExMDgwMTE4LjAwMC0wNzAwfHx8fFFVRVNUIERJQUdOT1NUSUNTLVdFU1Qg
SElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3fDg0MDEgRkFMTEJST09LIEFWRU5VRV5eV0VT
VCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0NzkwOTleVEVSUkFaQVNeRU5SSVFVRV5eTUReXl5e
Xl5eXk5QSV5FTgpOVEV8MXxMfFNwZWNpbWVuIGxhYmVscyBtdXN0IGluY2x1ZGUgdHdvIGZvcm1z
IG9mIHBhdGllbnQgCk5URXwyfEx8SUQuIE9ubHkgb25lIHVuaXF1ZSBpZGVudGlmaWVyIHdhcyBw
cmVzZW50IG9uIHRoZSAKTlRFfDN8THxzYW1wbGUocykuIFRoZSB0ZXN0aW5nIHlvdSByZXF1ZXN0
ZWQgd2lsbCBiZSAKTlRFfDR8THxwcm9jZXNzZWQ7IGhvd2V2ZXIsIGdvaW5nIGZvcndhcmQgcGxl
YXNlIHByb3ZpZGUgCk5URXw1fEx8dHdvIGlkZW50aWZpZXJzIGFzIHJlcXVpcmVkIGJ5IHRoZSBD
b2xsZWdlIG9mIApOVEV8NnxMfEFtZXJpY2FuIFBhdGhvbG9naXN0cyAoQ0FQKS4KU1BNfDF8fHxV
U1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8MjAxNzA1MTAxMzM2
MDAuMDAwLTA3MDB8MjAxNzA1MTEwODAxMTguMDAwLTA3MDAKT1JDfFJFfDleUVVFU1RfVE1FXzkw
MDQ2MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8fDE0OTc4NzUwMjVeS0FXRVNDSF5H
QVJZXl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEgUFJPRkVTU0lPTkFMIENPUlAuXl5e
Xl5eXl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxWRCBTVEUgMzAwXk1BSUwwMDBeV0VT
VCBIT0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5eXl5eMzEwXjU3OTI3NzgKT0JSfDh8
OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXw3OTleUlBSIChNT05JVE9S
KSBXL1JFRkxeOTlRREl8fHwyMDE3MDUxMDEzMzYwMC4wMDAtMDcwMHx8fHx8fHx8fDE0OTc4NzUw
MjVeS0FXRVNDSF5HQVJZXl5eXl5eXl5eXk5QSXx8fHx8fDIwMTcwNTExMTEyODM1LjAwMC0wNzAw
fHx8RgpPQlh8MXxTVHw0MDAxMDEwMF5SUFIgKE1PTklUT1IpIFcvUkVGTCBUSVRFUl45OVFESV4y
MDUwNy0wXlJQUiBTZXIgUWxeTE58MXxSRUFDVElWRXx8Tk9OLVJFQUNUSVZFfEF8fHxGfHx8MjAx
NzA1MTExMTI4MzUuMDAwLTA3MDB8fHx8fDIwMTcwNTExMDg0MDE1LjAwMC0wNzAwfHx8fFFVRVNU
IERJQUdOT1NUSUNTLVdFU1QgSElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3fDg0MDEgRkFM
TEJST09LIEFWRU5VRV5eV0VTVCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0NzkwOTleVEVSUkFa
QVNeRU5SSVFVRV5eTUReXl5eXl5eXk5QSV5FTgpOVEV8MXxMfFRoZSBSUFIgaXMgYSBub24tdHJl
cG9uZW1hbC1zcGVjaWZpYyB0ZXN0OyB0aGVyZWZvcmUsIApOVEV8MnxMfGEgdHJlcG9uZW1hbC1z
cGVjaWZpYyBjb25maXJtYXRvcnkgdGVzdCBzaG91bGQgYmUgCk5URXwzfEx8cGVyZm9ybWVkIHVu
bGVzcyBwcmlvciBzeXBoaWxpcyBpbmZlY3Rpb24gaGFzIGJlZW4gCk5URXw0fEx8ZG9jdW1lbnRl
ZCBmb3IgdGhpcyBwYXRpZW50LgpTUE18MXwwMV4wMXx8VVNQRUNeU291cmNlLCBVbnNwZWNpZmll
ZF5ITDcwNDg3fHx8fHx8fHx8fHx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfDIwMTcwNTExMDgw
MTE4LjAwMC0wNzAwCk9SQ3xSRXw5XlFVRVNUX1RNRV85MDA0NjAwM3xXSDM1MDk1MVReUVVFU1Rf
VE1FfHxDTXx8fHx8fHwxNDk3ODc1MDI1XktBV0VTQ0heR0FSWV5eXl5eXl5eXl5OUEl8fHx8fHx8
fHxTQUZFIElQQyxBIFBST0ZFU1NJT05BTCBDT1JQLl5eXl5eXl5eXjkwMDQ2MDAzfDc5MDQgU0FO
VEEgTU9OSUNBIEJMVkQgU1RFIDMwMF5NQUlMMDAwXldFU1QgSE9MTFlXT09EXkNBXjkwMDQ2LTUx
NzBeXk9eXlVTQXxeXl5eXjMxMF41NzkyNzc4fHx8fHx8fHw3OTleUlBSIChNT05JVE9SKSBXL1JF
RkxeOTlRREleNDEwMDAwMDc5OV5eVU5JVENPREUKT0JSfDl8OV5RVUVTVF9UTUVfOTAwNDYwMDN8
V0gzNTA5NTFUXlFVRVNUX1RNRXwlMzYyMDNeUlBSIFRJVEVSXjk5UURJfHx8MjAxNzA1MTAxMzM2
MDAuMDAwLTA3MDB8fHx8R3x8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJ
fHx8fHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHxGfDQwMDEwMTAwJlJQUiAoTU9OSVRPUikg
Vy9SRUZMIFRJVEVSJjk5UURJJjIwNTA3LTAmUlBSIFNlciBRbCZMTnx8fDkmUVVFU1RfVE1FXzkw
MDQ2MDAzXldIMzUwOTUxVCZRVUVTVF9UTUV8fHx8fHx8fHx8fHx8fHx8fHx8fHw3OTleUlBSIChN
T05JVE9SKSBXL1JFRkxeOTlRREleNDEwMDAwMDc5OV5eVU5JVENPREUKT0JYfDF8U058ODYwMDc0
MDheUlBSIFRJVEVSXjk5UURJXjMxMTQ3LTJeUlBSIFNlci1UaXRyXkxOfDF8XjFeOl4xNnx8fEh8
fHxGfHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHx8fDIwMTcwNTExMDg0MDM0LjAwMC0wNzAw
fHx8fFFVRVNUIERJQUdOT1NUSUNTLVdFU1QgSElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3
fDg0MDEgRkFMTEJST09LIEFWRU5VRV5eV0VTVCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0Nzkw
OTleVEVSUkFaQVNeRU5SSVFVRV5eTUReXl5eXl5eXk5QSV5FTgpTUE18MXwwMV4wMXx8VVNQRUNe
U291cmNlLCBVbnNwZWNpZmllZF5ITDcwNDg3fHx8fHx8fHx8fHx8fDIwMTcwNTEwMTMzNjAwLjAw
MC0wNzAwfDIwMTcwNTExMDgwMTAwLjAwMC0wNzAwCk9SQ3xSRXw5XlFVRVNUX1RNRV85MDA0NjAw
M3xXSDM1MDk1MVReUVVFU1RfVE1FfHxDTXx8fHx8fHwxNDk3ODc1MDI1XktBV0VTQ0heR0FSWV5e
Xl5eXl5eXl5OUEl8fHx8fHx8fHxTQUZFIElQQyxBIFBST0ZFU1NJT05BTCBDT1JQLl5eXl5eXl5e
XjkwMDQ2MDAzfDc5MDQgU0FOVEEgTU9OSUNBIEJMVkQgU1RFIDMwMF5NQUlMMDAwXldFU1QgSE9M
TFlXT09EXkNBXjkwMDQ2LTUxNzBeXk9eXlVTQXxeXl5eXjMxMF41NzkyNzc4Ck9CUnwxMHw5XlFV
RVNUX1RNRV85MDA0NjAwM3xXSDM1MDk1MVReUVVFU1RfVE1FfEVuaGFuY2VkUERGUmVwb3J0MV5F
bmhhbmNlZCBQREYgUmVwb3J0IFdIMzUwOTUxVC0xXjk5UURJfHx8MjAxNzA1MTAxMzM2MDAuMDAw
LTA3MDB8fHx8fHx8fHwxNDk3ODc1MDI1XktBV0VTQ0heR0FSWV5eXl5eXl5eXl5OUEl8fHx8fHwy
MDE3MDUxMTExMjgzNS4wMDAtMDcwMHx8fEYKT0JYfDF8RUR8RW5oYW5jZWRQREZSZXBvcnQxXkVu
aGFuY2VkIFBERiBSZXBvcnQgV0gzNTA5NTFULTFeOTlRREl8fFRNRV5JTV5eQmFzZTY0XkpWQkVS
aTB4TGpVS0plTGp6OU1LTXlBd0lHOWlhZ284UEM5TVpXNW5kR2dnTVRBdlJtbHNkR1Z5TDBac1lY
UmxSR1ZqYjJSbFBqNXpkSEpsWVcwS2VKd3I1QUlBQU80QWZBcGxibVJ6ZEhKbFlXMEtaVzVrYjJK
cUNqUWdNQ0J2WW1vS1BEd3ZUR1Z1WjNSb0lEWXpMMFpwYkhSbGNpOUdiR0YwWlVSbFkyOWtaVDQr
YzNSeVpXRnRDbmljVXdqa0t1UnlDdUhTajhnMFViQlVDRW5qTWxRd0FFSkRCVk5qSXdWakE0V1FY
QzZOQUVkM1Z3VlRCWDgzQlZQTmtDd3UxeEN1UUM0QVZra0wxUXBsYm1SemRISmxZVzBLWlc1a2Iy
SnFDalVnTUNCdlltb0tQRHd2VEdWdVozUm9JREV3TDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlQ0
K2MzUnlaV0Z0Q25pY0srUUNBQUR1QUh3S1pXNWtjM1J5WldGdENtVnVaRzlpYWdvMklEQWdiMkpx
Q2p3OEwweGxibWQwYUNBMk15OUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVStQbk4wY21WaGJRcDRu
Rk1JNUNya2Nncmgwby9JTkZLd1ZBaEo0ekpVTUFCQ1F3VlRZeU1GWXdPRmtGd3VqUUJIZDFjRll3
Vi9Od1ZUelpBc0x0Y1Fya0F1QUZYUEM5RUtaVzVrYzNSeVpXRnRDbVZ1Wkc5aWFnbzNJREFnYjJK
cUNqdzhMMHhsYm1kMGFDQXhNQzlHYVd4MFpYSXZSbXhoZEdWRVpXTnZaR1UrUG5OMGNtVmhiUXA0
bkN2a0FnQUE3Z0I4Q21WdVpITjBjbVZoYlFwbGJtUnZZbW9LT0NBd0lHOWlhZ284UEM5TVpXNW5k
R2dnTmpNdlJtbHNkR1Z5TDBac1lYUmxSR1ZqYjJSbFBqNXpkSEpsWVcwS2VKeFRDT1FxNUhJSzRk
S1B5RFJVc0ZRSVNlTXlWREFBUWtNRlUyTWpCV01EaFpCY0xvMEFSM2RYQlNNRmZ6Y0ZVODJRTEM3
WEVLNUFMZ0JWa2d2UENtVnVaSE4wY21WaGJRcGxibVJ2WW1vS09TQXdJRzlpYWdvOFBDOU1aVzVu
ZEdnZ01UQXZSbWxzZEdWeUwwWnNZWFJsUkdWamIyUmxQajV6ZEhKbFlXMEtlSndyNUFJQUFPNEFm
QXBsYm1SemRISmxZVzBLWlc1a2IySnFDakV3SURBZ2IySnFDanc4TDB4bGJtZDBhQ0EyTXk5R2FX
eDBaWEl2Um14aGRHVkVaV052WkdVK1BuTjBjbVZoYlFwNG5GTUk1Q3JrY2dyaDBvL0lORmF3VkFo
SjR6SlVNQUJDUXdWVFl5TUZZd09Ga0Z3dWpRQkhkMWNGRXdWL053VlR6WkFzTHRjUXJrQXVBRllN
QzlNS1pXNWtjM1J5WldGdENtVnVaRzlpYWdveE1TQXdJRzlpYWdvOFBDOU1aVzVuZEdnZ01UQXZS
bWxzZEdWeUwwWnNZWFJsUkdWamIyUmxQajV6ZEhKbFlXMEtlSndyNUFJQUFPNEFmQXBsYm1SemRI
SmxZVzBLWlc1a2IySnFDakV5SURBZ2IySnFDanc4TDB4bGJtZDBhQ0EyTWk5R2FXeDBaWEl2Um14
aGRHVkVaV052WkdVK1BuTjBjbVZoYlFwNG5GTUk1Q3JrY2dyaDBvL0lORkN3VkFoSjR6SlVNQUJD
UXdWVFl5TUZZd09Ga0Z3dWpRQkhkMWVnaUwrYmdxbG1TQmFYYXdoWElCY0FWVlVMelFwbGJtUnpk
SEpsWVcwS1pXNWtiMkpxQ2pFMUlEQWdiMkpxQ2p3OEwweGxibWQwYUNBeU5qUTJMMFpwYkhSbGNp
OUdiR0YwWlVSbFkyOWtaVDQrYzNSeVpXRnRDbmljdlZwdGI5czRFdjZlWHlGZ3YyeUJXaUVwNmkx
M09NQjFuTlI3aVozYVJvTmlkejhvanB3SWEwdXVMWGV2OSt0dktKRVVSVXF5MHVUcTFxMUV6WkRQ
ekhEZUtHTUx3WjhCaG4vOGtGaXI3ZG5YTTF5TVlRc0g3Rzh4NUFkMkVJUWxyWU50Ri81M0hCdTdD
S0dDNlh5eXhkWmxkdmJwN01QeTdQekt0YWkxWFBPSllITHNVSXRTbTJEUFdtNnQzMysxM2xsL1dz
dmZnQktla1RxcEY5cU9ReENDUzJRVHorRHdMWXhySERSQU5uSURoS2tWMmpnczZlZnhMdHZuN3l6
RytPc2lqL0xqNFlMZlhTVnB0SkhUNlZCZDN3VU10dXVRa3d1N0NLRDZKQXc4aS9pd01tS2dDNmJG
N1dUNThUMWY3N2ZKelEyZlpMd0VYU0tMdXJZWFVLYTZyVFZBdHVPeEVZZFF4cit4Q1BKdHhPWnlP
NFk1UHh2MmJJK1d3NTZOS0Z3Nk1Gek9xZ3c4Vy9kbjZSbG9GUGtCZGVBNTlha0xvdGpZb3o3eXJQ
bjEyZTkvZ2x5UE1PU1RRcFMvenlRNENiY0Z4UUlzLy9XczhXR054L1h0QUVtQkpISVlwcFMyUy9O
RDRGK0d4cENnZXJpRm1WWFNRaWxOa09YWUQrRkZ0U1U3WWRaSkJ3S1FwREkzRmFxWnk5Z2RkWkZl
QnIrQVhxMmxhMnNoZ29JUDd1bldITWl4Q2JWY3h3NERGSWJjY2UraVBJbFQ0Ym1UZEozdHR6Q1Vw
YW9MQVREZHBqVnBLWEtiN3FYOEZGSGJjOEl3b0RVdE1KMDdYbUdPdDloOU5ZZzZoTktROWRHU1Ns
V2VBbFJhcHdYOEQ2RTh0WDZGVXR1Ym1pZEx2VFdoZkoxYjFCZHJnNmhUMWRYZmF0b201RzlpYmwx
RkhWNUFXSjRETWlaWDNSY1d1M2lWYk9PMDJ4bVlwb0VsOUVMTmxPcXdkQVhYOTJ6SEJidTQrbkJO
WDVBR213SXhLRjl5djM3dk5lS3VBOVQ4cFE1VEoyNFNValVDNDY3ZnUwYm9iaEg4UlJMaU1QU1po
Qnl0REl6NitwVk05UTB1OVZJUEJhNGlrd0gyZGR1M2NjMDJ3QzNFamZaczNUSk40dnpmUWxpTDUx
RVUyTVJoN3FZNTNtaHpPZ2NaNmRvc2J0alVNSGZBOEt1bGd6THdOcFZDejRDSVBTaHNpVm80bGdq
WnVFVFVndnhOWXJjQm9zS3FERmQwUWNCM1MxblExSVpRZlNaSjBDUkliZndWbFhBalNFMFlWS2Rx
UUc3V2EwMzFwYjVyWGlHRHNXVlFIUkMzQW9DMlBCZm9DNWZBWVFDcHlRWVhaVHo3dUZoUnRJWVZM
V1h0SC9jdnJUOHFscTVhc282bVNIb29SbWFCR0VKdmhYMklLK1UwbDdNUG9wUEQ1SndFNXpoMEF6
NlZaQXlCMHdrZ3V1amN3K3V4NEpaY3JBbHNXaGhEZnhkZ0J5RmE4bDdINldPOHY5RFhjcUg5cEto
c1dPc010K1ZLYmRCMGNvTzBSRUVJNjBZaHBmQUMrVGxMNHk0UUd2MzB1Z2xGT2JYajJzUUZBRjVq
N1gzWnRZckd1aGhlalVIUjVhZDlRZXJib1E5Y0hOdkhPTnJrejczVzB6Z0QxL014UXFHSFNFQ3A1
eXRMeWc2aHEycFV5OU5BalJsVlBmald3YTlmYmMzdWExRkZRVm9MQVMwUy9IQU83UVJSWWEwRk56
RWdJNGtSdUJ2U2p0Undteml2ajlaR1Fta1JxREh4dEhVMnpkdmtiY0NlVEpMOFdFMExVMHJyNElX
Mjc5RHFCSXEzRG9aTEVZL3lta2ZqdVAvb3VDaDA4ZExncUJZSmlFM2RBaFUvWlB0NlRBNEpxNHc2
MXRHWVVQRnhPMVlKWFJ2N1ZJYkZtK2lCUjRoNXZPWlh2M1NzcDdHSHJVZDl5cElZRVR1QVlLS0g0
bTZkWSt6WUZGY3FIR1diVGJ6SzQ4Y09kRG9QY3M4eE9pY0krMGJFeEZRVTl6clR1VWlBem9Yajhl
dTd5eTdMWVFMYjFDbWNrcHR1RlNmZnVwRnFMQXdwUG9sVVl4SklVWENCY0Qra1RtQUhibVcvOGlT
M0c2bkcwZytweGlSMWlpOUlZQ0RWTysydUxrbnR5Z0kxd2xVZHorc0Q5Z3Y2TmIzQmJPK094WEF0
aERQMldqeFM1S3RGdnhhNWY3aDExaVZycUZrMWJOdFdJUlNGZFkwcldkZFY1Mm1TOGZXUnYzbHhR
d2dqQ3pkejlUZzNhTjZOYnlGSWovcWhPWVZWUGJpV2oybzkrQytpYUlkbWhFS1lkc3hLTVN4TFJa
Z0hKZ3dkMmN2ZkRpYzNNSzR6Vk90cStlbmZ3L3Z4WWlRYmxldmgvRXM3cjVacldCVXNxdG03MGZ1
aENDUHoyZFY0c1pqTXBzTWJQalNhemUvczlua3hGQmdCRTRLWHUzNklxSGlaTlp3dXhjUzNzK2xr
Skc0KzNIeStGRFJMQWNQcGtod1RaSHVZRlYyOEJCZ3ZscHp2NCt6bTVzdjliSFlwOUNDWEtTd3dj
TEdQcXRENHFmN1cwSWU2SFJvdTBSZ2FOZ2N5YkljOFE0eHVKdU9wV0hZeG5uK2VqTVlMWWU0QU5w
RUhMVnpnK0VhUFJ4eUkvNjQ2MWVKdVBKcmNqcWVDV3k5cFdJY1pNQ1R0MjN2L3BNSWtiaGtwK0pi
OGRJd1B1VkJJY2NPdkw1UG9LYzBPZWJJNmlNZjVjOHl2b3NNaFd5VVJwREErc01tZU12RXNGWVBS
WnRORzM3SVNIOWxHKzcvRWRiU1BqZVh6ZmZRWXEwVFp1bnRldTlXdU9BalZibDgzYWdBQnhlVkdu
ZDJDSFphTEM2V09DbXZrSWJKOEc0bjlmVFZjTENmVDY0dnBySDdFaG9tSS9VUmtJc0pPRllyakgz
N0ZJNVpsSG5rQUJhL1N4U1RpWG9sSXhodG80UE50TnpCZlZXTmRaQ2hhQWxpS09MYlBBOEN5MHVn
MDJzYkdsaVZZSEs4b1RCTnh3RCtQMGlmQlV5cGQzWTZFK1FFSldONVNtR2RIc2VCczNUaU5Nb01U
VUlqUlR2SEN1cG9CcXVwNEg2ZXJ1SUc5aXE4dWk1S1FMNmpLV3BUbVhEMmh1U0Vjb0hTeGpNUU5x
alNsNURvRjFnRHppUHh4OFpsREl5SzRYbDhMUDF0K3VST3hybkQvcThuSWdGUlRnaUtKaG04ODdR
TVFUT2hCaVVJVmdNTVBocUVyVzZtRXNBRlpQQzRqYkRkTXhWYTBEak5KSCtQL2ROaUhObXRkc1l0
N2dnSm1JRDdtNStJYTVVLzVUa29SWDBDZngvdmRQczdWVTNwRllLKzN3Q2JsVC9rTzJPZWw5UEpq
Q3V6M0Z0aWsvQ25mZjBLRmdGNUFQNDJmd0xiZmpMZ0VXYWUzcUNibFQva3lTUWNZY2wwSHpmanJN
Zm1XcmVUdmtoVDV3dDd5bVpRLzVmdXZFN0xwMzd1TUhSazFtUktqM3JLZUpFWEZvVW5mMlRUUzVY
TWlTNnJESWZyT3I0OTVza24rRzR0SCszaVZiUitTTkpKdFN2NTlGdzhPN09odG5hekVCR21lUE1Y
cG9RRWc2UTlRSTgxRkFmbVlySXZzbmJPQ2tZOUJ2aHlJczViMVB0c3F3eUtCSnVrNlhyRll5YXE5
WW1UWWdLOGxmemZoMDBoMzBzWmNVNGZqUmlocEZhVnBsa3Y4VUhPbVQ4ZmtJRjREUE1UNTM3SDh6
UVBvdU9vQ2kyclpRSGtxM3lrb05kSmRKS3MxcVJDaGo4bTZDVUZWaWtnR2NTOTJ4ZUhJTmtCUnZS
dFEreWRlbmZSQmxubFZaVjlxMWF6OVV4a3JpOXRzenk5aUVXUWFleFMyeXczQS9ST25UbnA0em80
YjBjRThWSkIzc2RMWkpFSjdkQ0NPTWNIMmY4bE51WlFBZC9HK2VBdGZsS2tHelA3cFRpZGRQVWY3
Q0t5MVQ5U2VTclpJaG9hSzYrZElLcmZheVEvVnBvVW1JSHJZd0padTNBVDlFNVpPdXBhbTNNV1A0
UEI3R1dSMjJlNjRLWW9mMllBbTIrMHh6U0JDN1NBRUpBZXA4MTM1a28vUkdkRDY1eHFkVkNKTDR5
eU44a2cwczRmVkh2UUNIbTRjZGtCMzNSTEQrL1FIakRmQVdMN1huZC9OK1lwL0ZLY2l5OW44ajNl
OUd3RWR5WXM2QVlMclVPN1A1K01yY2M2em5Dekg4NDd1UUdlZWo0ZWo1ZVR6dUhkelFMVFVOWjFO
QjlVa3BnbFZxVThsU0RCUi94U2xrMWErVzltbXlxclNmZEpCRGtFaFMrTnR0TkZUWnc2TzlJL0tF
L2N4T0VEOHZra3FRTm8vV2Vta0FrdzdrRldXcmhQMkc2QnMvMTNCSnZaNFU2Z3o4UFZQVXpvcGoz
M1NnNC9wSmo0SVRlNzJpZlM5dy9mZE0xUW80cEdlb3A2and6czlWaGt3KzZjb25mUXhXeDIzRUZr
a3ppcGM1VlU5eGNOUFV6Z29NZ2hoditOL2VUandpaTRiaVVhNzJuSW5IVkRqeEJkWXBLTCtIWG9i
OUVhdjAyaGxyQ25PMi80SFFjQlJxd3BsYm1SemRISmxZVzBLWlc1a2IySnFDakUySURBZ2IySnFD
anc4TDFSNWNHVXZXRTlpYW1WamRDOURiMnh2Y2xOd1lXTmxXeTlKUTBOQ1lYTmxaQ0F5TkNBd0lG
SmRMMU4xWW5SNWNHVXZTVzFoWjJVdlRtRnRaUzlKYlRFdlFtbDBjMUJsY2tOdmJYQnZibVZ1ZENB
NEwxZHBaSFJvSURJNE15OU1aVzVuZEdnZ016UXhPQzlJWldsbmFIUWdNVEV6TDBacGJIUmxjaTlH
YkdGMFpVUmxZMjlrWlQ0K2MzUnlaV0Z0Q25pYzdaMi9ydXU0RWNiZko5VW1nSkhITU5MdFE5eGky
MjFUcExoSWxTcDVnVlJCbWdCYnUwaVhLbFg2dkloWHVJTXo0SjEvbktGSVNmYjVQaENHajQ5RVVU
Si9tdUZ3S0QrZkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFS
QkVBUkJFQVJCUitoLy8vL1BQLy85VnlwLy9QdFBiZUhQdDdKdGRuWkxJZWh5MnJnZ2dqWmU3bi82
NGZiemIvSmwyMzRyeEJyNGdqNjV4aUNLQzFteHM4OE1nbzdUWmtxMmJ2L2xiNy96ak02QWtlTENX
TUZtUVc4dlFvbTdQYjNScng1VzVOMTFCMURzUTJLY0JiMnJZcFRNUHdWRVFBT0NTQUlsWFV5czRM
TkJrTkJHQkkrVlBIekU1N0JIRUdScVF5T3dTcnJBSkVHUUtUWk1RQW1DZG1wejJMUTdCNVFnYUVB
YlRVbVVOaE9HR1ZnSUNoVFR0QkhFcnpCTXBoNy8vV1VyWC8veGh4Ly8vSHNxMi9Yazk5dm4yMy9Q
YmlOMGtDZ0VFYURFYjJDWXRJaWpaSElJeU1yb3BTOFJqWnU2aG1sN2hXRVMycjUzc2tUVkFxeUV0
cXVoTDlIWmpScVJGNFVRS0cwbTdPeVdYazU1cStRVk1NWFNRRzEzcXJNYlZkWm1jVXhQanptaXNv
Z21zbmVVdk1kL3ZvcjIwd1NtV3IwQlVQRjhFek0xZDlCRWFZR1V6blQvUHFXV1czTDlvRWRNRTRj
ZzJqQUZtSXIxQmtDWmdRaTJTbk5wR2xnOFJRR1FDNUtsdi9yTXlDZ2ViWUdwVndlcUd5U2ZRaFBa
bzUxTzBhWGlpaDVOeVJHMHQvdHJkWjRWZW1tZ3RuNnVBeEh0dUdsL2VGeXMrTmhacmhNU01hMU1L
UjdsbVNxdkVuWWR1V1FPVWQzbCtSSDhGMlhNZExLdjI5WVRWMlVDVldyL2lUS0hUaTFRZTJneXJk
Szl0eXhSajZjMFU2ZTdmNlo5R1lqdWVuYks3RG5WKy9aQS9Mazd5c3VUMVoxSElFenkxK1Q2MWlw
dzl2YmJwdjBvQldTZGJxZk1yakpXVlo3TnBVQ1Y1dEc2VE1WUXhGaDE5NzNzdEZSc25vWTdiYnQ0
S2srUWVPM2FyQlBIVTdQTUUwdjNaQk9XZFVEbCszL21mS3Z6Q09KRU1vMjVvSjJLemRNd1RWUnR3
SkVZc29rMmRGbHJ5MW1Pbi9tTjczSHZreFV1QW1xQXB1Q1VCMnFyV3FndTBhZEk5L1A3dnN3aVBX
SWFRRWtYcjU1YnhmR2JHM1hYZCtEOVgrNkpRSG1CRVc1QU1JT21HMmxlbkxhcU50M1JIRWFaUUhG
cWNWdXVFNk9JemRPQU42WFh5QWR2dWtXVDdnMnZrczJiKzVRLzNiWDJmN01aU0ZjQVpicG4zdW5v
RTljVmltMENKOU9MYjd4aTJGdy9JSUxMR0UyNnE1Y0l5dkJsd3BWczdiYlpkc3IxNjJSb3VyL25W
YXQ3MFFxZ1NqY0g4OXpqQ2dldXpNc0IxYWJ0aWI0NjBPdW90cHZsbU0wdCtoQzNpdGUzYlQvRjY4
dDBxaW5WSGdEVVFGeGQ3eUtRRVVBTnNQQnlRSEhjWUwrenh3bnFHcVZGV09uNmswMjlmOHNNckY4
dHFYY0NTdnQ3R1lNUzEybEdMRXQyNnJXQWFsTWpSSit2OWplUlplRlpQYStJNVlyaXozeEoycDBT
ZllIZXllVWJzeVlhbWZhL1hzdzh2MVQ1dFlBU1llMjJlNWM4b2paQnZXU014T29xRXlYeGVXQ2hi
dW5nT1VVZzk0Y21GZ0YxU2xCQ0E5VXUyemVMR2U1clQ3OGI5TzZTOVZwQXRZbmxMUWpWbnRhR05i
cEFlUkNKVjVPdnJzRkt0cHhPZklyWGx3bDJyYWh6T2xCeHo4K1hzWW1rZk9yUmxZSHlRQ2laSnow
Szg1Z3k2UkNMRmx1VTlDZGRza3BBVFluMWFXdXk4eHMvWldKM2VENDMwOVI4SWxObUh1cXlRSG54
N1pKNUVqUjVLSm1tUnhmeHVXZXdnaEZXQ2FqYm1nQ0MyVEh5TXNjZGVyTzVRT2tLSndMRkRjaWtJ
WFZqajFjR3FtMG45OGxTRGZkRWVGeFRFR1BWTFMxaW91U0RFblRXVTRMbnVsZGt2dlIyL2NLaldj
YmI3V1BtUVJlTm9RWktKbGMydjFUNWhZQnFqUXUvbHN4VDhKQXhiOFMwc3dUV3FnUVVXNmdwS1JP
bEJJTjRyL3c5WDI4V0gyNVJsRytQTWplUUZ3S3F6YlZqcHZKM2JFNVl5bHVvNlVVRFc3VlE2MmFq
TWt6dFNhV3VIcTRiT1J5Ymg5cXZHSmtYQXVxTCt2bk9mTzhpWjYvTDBVN1hic0JhSmRzL0Y2aW5i
MjUyK2ovQk5HZ3B1cGhaWXpMY2RhZFBFN3dvVVB2TlUyQ2JXazhzNXVJdi8vcXRmdFVmZHVIS1J5
VGF3V09ld2E0OExycTVBWUdkQ2pwUE10ODcyRGlUeTVmTVBvcFp6aXdOZm5XZ1JFU2kycldtK0ho
TWlvbVA0TWpEcXJWVHlSdUNtTTRldllSU3NmK21uNTlBZjNianlWNXY5R3lpQ0FzRWg5QTFlNGJN
bXlGcTJ4Q3ZyZ29tY0hVTHUvRjh2UWJrOUxVYkdxalNlcUxBTm1VQ0VhWlZNaTBVbHdBclBrbzFJ
akVYcU9mVTJaenVQVG1UaERDQWFqZFpLRmdQMWZVaFJUMWVVQ0xPc0RWUDhJSkE1ZU5kWDhLZlhl
dWFKODh3dGV3SXIwK2daR0tWdnlGOCtYN3dPSG9KYmVVbk1hdE02VDVUV2wyZWQrZUcyOS9OakUy
MmMrQTByd1pVL2thZEhEMlpXQVVvZWViSmZHTWFxZndOWWV6RVM2bytTS0h0VHNHK3V0c2tPeTBa
aFNSUVkrM2ZreURSUmVPTmdZcm5ucExtU1Z1bHVIampyTFlrL1QxdG1uZGN4VWdEM1ltSEJvRTdw
OTJxcEd0WFhlNlVaeXFPdW5TZlJaYXBwK3ZmWGcybzB0SzhtMk9lNHFHVGlWSUpxeUQ2VngwQUR0
eEp4aFNNT0xnWG1hTjFJaVg1OEFRUHEzWmpYV0Z5OVVRd2hDazlsOCs3RHNuR2VEVlVGMWd0a2dD
cUZIRDJ6Rk5nbTdTek4xQUNPNVVQK09zbkJPNjRpalU5aWc5TjNYT0lkVFh2ci85UmYzcXR0L3R3
RzZaTEFKWGNpLzI5cW5tS0kzZzd5YXJPUng5cG9hQlBvaGFvZktjYWkrK05qWnZ5THQvQWZEU0Fn
cWFybW40VDU1WWZZNXRNckFaT2VXRHdDRUd4ZURTUjdGVGVqNFFLbWdSV1UwWlBBVk41OHlTZTd3
U2dvTGthQU1velQza0xOUmVvNm1LVDFzS1dvakVRMUJVUEtLcEFMUm85YmZXTE4xM3psRC9aTmox
K0lMd0pRVjF4WEtLMGJIekFRbzBacVM1VzFRZGZpQWJmaWduMkVOVFZHRkFERmlybUlsL29PZi9W
cC8yTDFWdnJRbng3Rm9hM05jeHQxWHVMcHA0dk1pZDFyeXg3SDdOUUdhOXY5V255ajhzTHBxWkhK
THgwaVB5MFBtVUN6RzNWUzZ2TEM2VklyYjRMOFYyUjc0M21UWktHUmFlUG9aWU9aT2dobk5yWld6
R0F1dm5MM3g3Zi8yNkxWOFBWRWdCT0YyWHhCZGZrbUt3SjVwb1NwWjdmdnV0WlFDMks4czIvQ3Qr
a3pSTmJxT2tEcUJnV0VtRjF6V1duRjFRWHFNT2FRVjlaTnhueW5uNk11VGNQbFVFcEdlV2Izc04x
TEdLZHYvZk1BZlg4NkNSZ0txT3JBVVcrWDVBWXZIVzVVcWFFWjZGbVRVWE52UTQ4MTZ5Wld1Rm41
akVaOXZ3SFBKeURNMUdydThRYmQ1OVpNYjFKTzMxSSt1M08wdUx4dVZHK2RlT3AxdGtUNW1sNmZJ
OVVzanRtL0lIdWZ1TEQ0WlVMNXVJTDNzczhGdmZlZHNTWFBGeitLWjNlOW5UbkY2ZWd0OUViZUEz
TE44bGNqejhXUDh3RGxjdysycDk2VkQwRnM2bmNCczNVb295akVsRDA5WW52eSt6a1BPd3luOFlR
UDhXbGRVN2F2Zmk5UGdWZTNpdWVoVUpreFE5ak1YY3hyd25iNkxadCtoRHNIbnR6RUI1UTdkSE5K
b2xkK05EbXRUS3ZzQ2VhNGtsdUdUdDcrMTIrS2VNcGl1eDV6dDY2K2R6cXlFajNUeE9vcC8vc08r
b0crcit4Uy9uMTQzZHFUS0NDWG1RZWpta3lkekVIaklGWk1TdVBvM3ptQnQ2VmVWcHVaTDQ5MDhV
WmdJdENFMVBzMU5iSWx2Rmp6Tk96RGhUSFlGa2VVSjdNSVVZbTZPRUZHK043c25tNG9PdDZlOUVu
UWZQRWxsV2dNazFxLzJzYTYyT2twM1dxUVlra1ZudU1DTG1tWGp2WHBSc05BSFZUUC9sWGpmN3BY
VXhuVXV0bXJTM3Rub0s0Q1NTREJ1Sk04N0c3QWFBRzRoakpLN1pJd1VKNHpSU1BvZkpHYWtxSDU0
QjVpOVZTOC9SY0R4U1BudG9WOUhvWGJmaVNSMzlhWHFpUXVKa251NkxlckJ1eUlBMEFOVUJIN0xV
ZUlKMDFFWmduN2ZWNVdNMmRpaklub1pabXc2NXorWUlubk9pREpwc1JCQ1h5ZXlWenBVeXZqeHNm
UEdGakdLaHVrM1E5b2ozVkduYks3SzVkc2dLZ1ZuUjEwY2pWaXpWS1FKbWVpUW1VQ0VEeDdvK1Bo
em1mQzFSK0xsdlhMSUxWT3ZnMkFOU2VmRWd4MFhCd29qS0Zwc2RDRS96aElwVGFSaDdnN0pGV2hN
MjdEb3pwOG1WNjFCU1hiOWhDNlEzTU1QVXhMcCt1TXdpd0x4VXRwdEJNeFVhS1VGcVJhMlNLWm5n
UE9GWWVLQzhRcCtuSXhPdEtjNTF4QXc0YlF5VmJkUXBRUVh1T0VXSFZCcXROVTdWQnRHMURIQjI4
c3UrWXcrVXZmakIvcElHS2U3anBkTVZ4NDlheDBhZFFBbW9zeWxldGYzV1VMOURwQzJyMFNzQlRD
RHBGR2FEaWdGTFZRbm0zMEllZjJNQnp2bFBHVU0raGVhaDgvUmxmMGZTY1MvTlFnVTRINmpPcjIv
bTcyU3lsTWRRanpPMTVOajhsUUpFci9yUE4xdE9uVUFYcUdVNEhtOGgvOVJjbVYyTXN3NWtTYlow
Nmg3RGQ4dURReFBFcUpmUWVLZTZ1b25DZVQ2YTdldjRialk3YjRON3RJeVd2Uy9HUEgwdDQybENo
NlN1T0FkVWF4RWVUYmVqeHpqZVc5cVM4dXczM2Y5NHNFN1V3dy9KZWsvalFYMVcyNVBFRHFJUEZl
WHFydzRNRE1xZUtiaC9QdzgvYzZJSjVLRjJuTjdHYmIrMHNvTHFOMUhwVXNydkZsdmt3b0Q1RTE5
eUw5Z1NYNHRWRnc3RTJoL3lhZG1xZEhzV2xSbkZWaTV5WmFpUHoydytmZUtsSnM2N3d4VVZ1bmdn
YmZrS21rdXAyaVc0a0FYcFh0U2pwcFNKZ3lwUVlkclgvaXNPTTBIc3JScW1kVFFaVFFtSlFJTjZE
cGs4bEhpNlpDeGpOWllQYjUyZTMrb3A2ZlA5RGFhZWtmVUluaWgwOHZmZ2lLUEQ2SUtnVnBWSzBL
T25rd0lDbXM1c1BRVmNSSlFHeTU1YXhSekJNMEh1cmxLM0h4bWlNSTlxWWtteFhueGNFbmFMV3lo
QXB1ckRuSmlhajc4M0R4c1dyZ0loUmdsV0NQb1BJN3BpNU41bWlhV3IvZGNCNld3aTZwb2dzYll3
Q2pyeC84ZnFwczg4SmdpNGhFWE9JYlJQRjlNaEZCRVFRMUZYN1c0UlVQdFVLUkFpQ0lBaUNJQWlD
SUFpQ0lBaUNJQWlDb1BmV3IyNlgzWGdLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ295TkNBd0lHOWlh
Z284UEM5TVpXNW5kR2dnTWpVNU5pOU9JRE12Um1sc2RHVnlMMFpzWVhSbFJHVmpiMlJsUGo1emRI
SmxZVzBLZUp5ZGxuZFVVOWtXaDgrOU43MVFraENLbE5CcmFGSUNTQTI5U0pFdUtqRUpFRXJBa0FB
aU5rUlVjRVJSa2FZSU1pamdnS05Ea2JFaWlvVUJVYkhyQkJsRTFIRndGQnVXU1dTdEdkKzhlZS9O
bTk4ZjkzNXJuNzNQM1dmdmZkYTZBSkQ4Z3dYQ1RGZ0pnQXloV0JUaDU4V0lqWXRuWUFjQkRQQUFB
MndBNEhDenMwSVcrRVlDbVFKODJJeHNtUlA0RjcyNkRpRDUreXJUUDR6QkFQK2ZsTGxaSWpFQVVK
aU01L0w0MlZ3WkY4azRQVmVjSmJkUHlaaTJORTNPTUVyT0lsbUNNbGFUYy9Jc1czejJtV1VQT2ZN
eWhEd1p5M1BPNG1YdzVOd240NDA1RXI2TWtXQVpGK2NJK0xreXZpWmpnM1JKaGtER2IrU3hHWHhP
TmdBb2t0d3U1bk5UWkd3dFk1SW9Nb0l0NDNrQTRFakpYL0RTTDFqTXp4UExEOFhPekZvdUVpU25p
QmttWEZPR2paTVRpK0hQejAzbmk4WE1NQTQzalNQaU1kaVpHVmtjNFhJQVpzLzhXUlI1YlJteUlq
dllPRGs0TUcwdGJiNG8xSDlkL0p1UzkzYVdYb1IvN2hsRUgvakQ5bGQrbVEwQXNLWmx0ZG42aDIx
cEZRQmQ2d0ZRdS8ySHpXQXZBSXF5dm5VT2ZYRWV1bnhlVXNUaUxHY3JxOXpjWEVzQm4yc3BMK2p2
K3A4T2YwTmZmTTlTdnQzdjVXRjQ4NU00a25ReFExNDNibVo2cGtURXlNN2ljUGtNNXArSCtCOEgv
blVlRmhIOEpMNklMNVJGUk11bVRDQk1sclZieUJPSUJabENoa0Q0bjVyNEQ4UCtwTm01bG9uYStC
SFFsbGdDcFNFYVFINGVBQ2dxRVNBSmUyUXIwTzk5QzhaSEEvbk5pOUdabUozN3o0TCtmVmU0VFA3
SUZpUi9qbU5IUkRLNEVsSE83SnI4V2dJMElBQkZRQVBxUUJ2b0F4UEFCTGJBRWJnQUQrQURBa0Vv
aUFSeFlESGdnaFNRQVVRZ0Z4U0F0YUFZbElLdFlDZW9CbldnRVRTRE5uQVlkSUZqNERRNEJ5NkJ5
MkFFM0FGU01BNmVnQ253Q3N4QUVJU0Z5QkFWVW9kMElFUElITEtGV0pBYjVBTUZReEZRSEpRSUpV
TkNTQUlWUU91Z1VxZ2Nxb2Jxb1dib1crZ29kQnE2QUExRHQ2QlJhQkw2RlhvSEl6QUpwc0Zhc0JG
c0JiTmdUemdJam9RWHdjbndNamdmTG9LM3dKVndBM3dRN29SUHc1ZmdFVmdLUDRHbkVZQVFFVHFp
aXpBUkZzSkdRcEY0SkFrUklhdVFFcVFDYVVEYWtCNmtIN21LU0pHbnlGc1VCa1ZGTVZCTWxBdktI
eFdGNHFLV29WYWhOcU9xVVFkUW5hZysxRlhVS0dvSzlSRk5SbXVpemRITzZBQjBMRG9abllzdVJs
ZWdtOUFkNkxQb0VmUTQraFVHZzZGampER09HSDlNSENZVnN3S3pHYk1iMDQ0NWhSbkdqR0dtc1Zp
c090WWM2NG9OeFhLd1ltd3h0Z3A3RUhzU2V3VTdqbjJESStKMGNMWTRYMXc4VG9ncnhGWGdXbkFu
Y0Zkd0U3Z1p2QkxlRU8rTUQ4WHo4TXZ4WmZoR2ZBOStDRCtPbnlFb0U0d0pyb1JJUWlwaExhR1Mw
RVk0UzdoTGVFRWtFdldJVHNSd29vQzRobGhKUEVROFR4d2x2aVZSU0dZa05pbUJKQ0Z0SWUwbm5T
TGRJcjBnazhsR1pBOXlQRmxNM2tKdUpwOGgzeWUvVWFBcVdDb0VLUEFVVml2VUtIUXFYRkY0cG9o
WE5GVDBWRnlzbUs5WW9YaEVjVWp4cVJKZXlVaUpyY1JSV3FWVW8zUlU2WWJTdERKVjJVWTVWRGxE
ZWJOeWkvSUY1VWNVTE1XSTRrUGhVWW9vK3lobktHTlVoS3BQWlZPNTFIWFVSdXBaNmpnTlF6T21C
ZEJTYWFXMGIyaUR0Q2tWaW9xZFNyUktua3FOeW5FVktSMmhHOUVENk9uME12cGgrblg2TzFVdFZV
OVZ2dW9tMVRiVks2cXYxZWFvZWFqeDFVclUydFZHMU42cE05UjkxTlBVdDZsM3FkL1RRR21ZYVlS
cjVHcnMwVGlyOFhRT2JZN0xITzZja2ptSDU5eldoRFhOTkNNMFYyanUweHpRbk5iUzF2TFR5dEtx
MGpxajlWU2JydTJobmFxOVEvdUU5cVFPVmNkTlI2Q3pRK2Vrem1PR0NzT1RrYzZvWlBReHBuUTFk
ZjExSmJyMXVvTzZNM3JHZWxGNmhYcnRldmYwQ2Zvcy9TVDlIZnE5K2xNR09nWWhCZ1VHclFhM0Rm
R0dMTU1VdzEyRy9ZYXZqWXlOWW93MkdIVVpQVEpXTXc0d3pqZHVOYjVyUWpaeE4xbG0wbUJ5elJS
anlqSk5NOTF0ZXRrTU5yTTNTekdyTVJzeWg4MGR6QVhtdTgySExkQVdUaFpDaXdhTEcwd1MwNU9a
dzJ4bGpsclNMWU10Q3kyN0xKOVpHVmpGVzIyejZyZjZhRzF2blc3ZGFIM0hobUlUYUZObzAyUHpx
NjJaTGRlMnh2YmFYUEpjMzdtcjUzYlBmVzVuYnNlMzIyTjMwNTVxSDJLL3diN1gvb09EbzRQSW9j
MWgwdEhBTWRHeDF2RUdpOFlLWTIxbW5YZENPM2s1clhZNjV2VFcyY0ZaN0h6WStSY1hwa3VhUzR2
TG8zbkc4L2p6R3VlTnVlcTVjbHpyWGFWdURMZEV0NzF1VW5kZGQ0NTdnL3NERDMwUG5rZVR4NFNu
cVdlcTUwSFBaMTdXWGlLdkRxL1hiR2YyU3ZZcGI4VGJ6N3ZFZTlDSDRoUGxVKzF6MzFmUE45bTMx
WGZLejk1dmhkOHBmN1Iva1A4Mi94c0JXZ0hjZ09hQXFVREh3SldCZlVHa29BVkIxVUVQZ3MyQ1Jj
RTlJWEJJWU1qMmtMdnpEZWNMNTNlRmd0Q0EwTzJoOThLTXc1YUZmUitPQ1E4THJ3bC9HR0VUVVJE
UnY0QzZZTW1DbGdXdklyMGl5eUx2UkpsRVNhSjZveFdqRTZLYm8xL0hlTWVVeDBoanJXSlh4bDZL
MDRnVHhIWEhZK09qNDV2aXB4ZjZMTnk1Y0R6QlBxRTQ0Zm9pNDBWNWl5NHMxbGljdnZqNEVzVWxu
Q1ZIRXRHSk1Za3RpZTg1b1p3R3p2VFNnS1cxUzZlNGJPNHU3aE9lQjI4SGI1THZ5aS9uVHlTNUpw
VW5QVXAyVGQ2ZVBKbmlubEtSOGxUQUZsUUxucWY2cDlhbHZrNExUZHVmOWlrOUpyMDlBNWVSbUhG
VVNCR21DZnN5dFRQek1vZXp6TE9LczZUTG5KZnRYRFlsQ2hJMVpVUFppN0s3eFRUWno5U0F4RVN5
WGpLYTQ1WlRrL01tTnpyM1NKNXluakJ2WUxuWjhrM0xKL0o5ODc5ZWdWckJYZEZib0Z1d3RtQjBw
ZWZLK2xYUXFxV3JlbGZycnk1YVBiN0diODJCdFlTMWFXdC9LTFF1TEM5OHVTNW1YVStSVnRHYW9y
SDFmdXRiaXhXS1JjVTNOcmhzcU51STJpallPTGhwN3FhcVRSOUxlQ1VYUzYxTEswcmZiK1p1dnZp
VnpWZVZYMzNha3JSbHNNeWhiTTlXekZiaDF1dmIzTGNkS0ZjdXp5OGYyeDZ5dlhNSFkwZkpqcGM3
bCt5OFVHRlhVYmVMc0V1eVMxb1pYTmxkWlZDMXRlcDlkVXIxU0kxWFRYdXRadTJtMnRlN2VidXY3
UEhZMDFhblZWZGE5MjZ2WU8vTmVyLzZ6Z2FqaG9wOW1IMDUreDQyUmpmMmY4MzZ1cmxKbzZtMDZj
Tis0WDdwZ1lnRGZjMk96YzB0bWkxbHJYQ3JwSFh5WU1MQnk5OTRmOVBkeG15cmI2ZTNseDRDaHlT
SEhuK2IrTzMxdzBHSGU0K3dqclI5Wi9oZGJRZTFvNlFUNmx6ZU9kV1YwaVh0anVzZVBocDR0TGZI
cGFmamU4dnY5eC9UUFZaelhPVjQyUW5DaWFJVG4wN21uNXcrbFhYcTZlbmswMk85UzNydm5Jazlj
NjB2dkcvd2JORFo4K2Q4ejUzcDkrdy9lZDcxL0xFTHpoZU9YbVJkN0xya2NLbHp3SDZnNHdmN0h6
b0dIUVk3aHh5SHVpODdYZTRabmpkODRvcjdsZE5YdmErZXV4Wnc3ZExJL0pIaDYxSFhiOTVJdUNH
OXlidjU2RmI2cmVlM2MyN1AzRmx6RjMyMzVKN1N2WXI3bXZjYmZqVDlzVjNxSUQwKzZqMDY4R0RC
Z3p0ajNMRW5QMlgvOUg2ODZDSDVZY1dFemtUekk5dEh4eVo5Snk4L1h2aDQvRW5XazVtbnhUOHIv
MXo3ek9UWmQ3OTQvREl3RlRzMS9sejAvTk92bTErb3Y5ai8wdTVsNzNUWTlQMVhHYTltWHBlOFVY
OXo0QzNyYmYrN21IY1RNN252c2U4clA1aCs2UGtZOVBIdXA0eFBuMzREOTRUeit3cGxibVJ6ZEhK
bFlXMEtaVzVrYjJKcUNqSTVJREFnYjJKcUNqdzhMMHhsYm1kMGFDQTFOalE1TDBacGJIUmxjaTlH
YkdGMFpVUmxZMjlrWlQ0K2MzUnlaV0Z0Q25pY3ZWMWJjeHMzc243WHIyRFZlVGgyMVhvMHdOejlK
dHUwclYxWmRpUWxxVlN5RHhRMXNxYVdGNFdrNHMzNTlRZVlHUURkUUdNNEltanZiallraU12M2RU
ZlEzVE1BeENheCtPOHJKdjZ2cVBoa3ZqejU4NFMxWld6Q1N2bS90cWdvbzdLc3Vyb0ppekx4N3lT
SldCYkhjZHZvOUh6Skp1L1dKeitkdkxrNU9YMmZUZExKelgzZmtlaWNKZWtrVFNQTzhzbk5jdkw3
aThuTHliOG5OLzhVTmNWdkhGZk5xeWhKZUJ5TGozSEVjNmRGTVdFTXRVakxPSXF6TW1icHBJcFkx
ZFcvcWgvWG05M0xpV3o0NG5vMzJ6MXRYL2ZmM2plcjJVSjNaMFBOaWt4Z2lMS0U3eDA0aXdYVWds
ZGxQdUdGR0RtV29OdEcxNS9PYno3K294L3ZuK2NYRjMwbjB4c2h5M2lTWmxGZXBsSjB5OG1yT0Vw
eVdaTHdWTFpmVEhoY1JMSHNLeHNvN3R2TDRqekswNjQ0aitKVWZFeEVjZGNyS0hpWS9IcXlPaEVT
allzeVRjVHZhWkZtZ2tyRThyU0k4OG5WaDVQZi95MTQzWW1pZ3JkVXZwMW9jQnF1QjhXMTBQeWZK
K1NQcUUxV1JHV3NDV25rb2poTlV6K2JnOEEvRDQzRHdQeTRGRDNEcXExUUtNaTY3Q0M4TVJweUVD
YXUra29CMHJWY280cVJ1aHpyd0pTZUI3K0Zic2F5cFhXdEZvVkNUTThNVGFBazR1a2tTNktxakt1
cW43aGZacnVtWHFtWmU3NjZYMitXb21pOWdsTklBTE4xaXRpbWNVWjkxL3pUT0kzeXBLcktGRWxC
eWp6SlczVWN3L29RUkJ0Q3AwaGMydFdDd2dOQXRYWTg0QTlDdVc5OGc5S3lUV3NtYTdsUktNT21C
UjdNQjlHdWhjWHZWUzJGL0NqcXRrVTBNQXU0OUhPaW11U0Y1OEwxWXoxdmx2VnFlREpJU1lzbVZW
NVpxb1RGZWlwa1JSNGxtZEJMWmhjamVRazNTQzNFUXZpNmRianRrYmd4UUd1K1lKaDJaWW9rVklK
c2piOW56dEx0SWY0c2hxeXFDc213UjZzWFJudDh3d2tidUpZTFhnb3l3TWtCRzJhKzVKZyt3SjdL
cEQ2OUprUFIrVzVMbUdmbXBYRVo4VVJPTjJ2aXZWM3M5MEdPdTNhREc5bTE2THVVK0dIb0FBcU9F
eW1NWEJCWnlvU2tlVlVsR0tFc2owdTNQQmpvWGhBR0t5ZzI5Y3BZRktRNm9FRkZNZTVKVjZDSW9Q
S0FTSmdFYVpHSmNTMEN1UnV2VWZHbGJUVUJIQnlUaVRHZ1hndFJ4aWQ1SnVxM1U0SlZwWEJOa1pp
aXNzMm1ia2RVcWFHcG04cjByNTlmVm43VURtMVNzb0drU005UUZyc0JZaVZ5SzFhSWRhWHI1dDNu
TnlxVFkveVVsNmVzeXNxK0s5MndFaTJUVXF3dWR1dXpEMVBWV3JlU1NTQTFNQlA1WGNtU09FNjd0
aC9xMVYyOWVXMlBsWW4wTTQyN2hCVTMrTlNONUlObVYzZXFkaWc0bDltb2NDbGtnUHh1Q0kvVjlQ
cnMvVlJJby9zUGhhMGJNTWtpbmdsWXZjZysxclBGN21IVWVGYkxNc3NMRnNkVkh2TXlUZk1DREtu
RCtLSFFEc2FRWURyQW9PM1lLOVM0QUZoK1IxTWZJRVh6MU1QZ1lFYzNDTUpnUlN1UUt0RFQzVmxk
Q2QrZ0pleWpFNzZrT3F1K2h4RHBIWHpwQjIwbXh3RzcxNVAxejc2c3RRVEU5M2tWRlVscUhoUDE4
YjB6cFhpZTlvR0oxZUxYajBrV1Z4bTdjVnFZUVVvZXBWa2JESFd4ekhxeHFPZTcrbTVnRkt0Sm5K
MnkrSlRIckhBV0NKYXFnTk5xYzZyVzVPUjFrdmVmdjd3YndsbGxFU3RTdmZwZDFmTzYrV3NRcHRW
Q3dtVDdZRnB0Rk15NGZCMnpVVENaTUtPeVN2UWkyajFaSE1ScE54a0YxRzZrQmNwZTg5SkJhbWQr
UTFFN3pCTEEvSUFSZVBqYTlJejh3VTU0L05tYUtrYXJsV3lPcGg3Z2h5YTZoL2ZCcVp6TmpJaWhM
R3hMTHdrZ3NLRnk0R0F5MkEvRk1YeVJvd2QzU0RnT2gyNDFJbytscmZFWVJFYTRTbnExTmptaHRm
U2luUEIvVkJBcGd1TlUrSmpFbnRpbUcydWQvTmZacjlQcnR6b08vbkIyOVJ1TWc5SGJsMEtFVmlK
d1ZRRzJnMVZVWTVIZzArRzdPSjllM3FnM0h0T3JYODdmVHE4VnpESVh1WkFJaGN1a2NHSmxub2gx
SzROZFhYK1p2ajMvTkwxVXJXMnZJeVAxVWlMeHEyWHpGY0xrV1ZTV1JwUS9QZFhiblpKQSs2WC8v
SzZaZlYydHQ3dG12bFUvN3g3cS90TnN1MTNQbTVsWWV2dUN4ZnJyV3YyMlVvV3p4Y0pYM3pOU1g3
S2NiZjZqUHM4MnRUUDhiak83cTJHbDlmMXd2NUZYcnl4dlg1cUp0STVYS2VPdDVXWnBKZjdOUzU1
a2laU2VyRnhFWEFRYVFxUXkvYnFYcitGa0FaTkIrckw3a1lzdTJ2d1JmR3AvYnorMVRSZWdHeldk
MkVUUEdpN0xaWDZJK3UzNzBOTkVwQzJ0dmlkSXJZeUxHVkxoNUVXd0hlUWx1eGN0eGRSdlUvTVVF
MlFpcDh4a09kTjRZRkZQRWxLSGNDRlIyR3dQZHloVkJ3QVFRdElKZ1VFaHBHbVV5S1dxUXNJNFg5
MkxrS3RaUDIyMVdXenIyYmJlamhTU1JDRWpWekdSQ0N0Z0JSZExXeXlmbzJuWW9LZ1hET2lES3Vy
SndTSWxPZERYSHNrNUhXSWtZNndJZEVHWkUvV0cySXhBdlNFMjYxcWFSRXlxc2lEcjdkT0JtaEdj
NjI2QUZyd0dVWmFSV0JEbGNwOGtVVlgwZEc3TUNuRTVXOVlqSWNDaFdmZEVvaHdGZ3VlSjhIV0Zm
TWdBVVZ6VjI2ZkZidVRnU1NLR2xQNVVUUTdPOGtoOGplTnhna2lTWExYSEdPN3JUYjJhcTJYMWFy
YjZPbFllV1ZySUxxdXkwcERVODZreGlFQnppT2hpZGp0Mi9MeU1oRkNyc3V6SHQ2YW0xOGhCUXpn
eU1zVXFFUU5tRTJsNE1sS0oyNjBWYlR6SkxBK1E4U2pyOHRyMlhhditwcDRjOGxidWJVRmZYWDlY
MFpTUHBPOXhNeGdSSXdCdnBFR2RWd3FJcnRXL2tkYkUyamZTOEp2enMwM2xlZEM3bDlLNlAxdFEv
Wk1GTTcrR0dOcEN4TTNDWkd2cms0U2s4SUlwT2FLTkJ5YnVKQXk5UjRBa1RwMGl0Yk9ReVFoOWZ4
TVBXTlJIR0FXUFRDbVUrK0toMW9TclNDNHdsWm5oTHo2ZS82SlMrVlBlZnpxN3ZEbi9NTDA4bGY5
KzgvbmRieXJhVmYrOC8venoxYzFIbFNOTUw2ZFhaemZubnk5VlBINTY5ZjdDMURZUEJNQTY0NUpw
Rno3SUJoY2I0YUpPd3FSTGpyeWNrRGpSTzE0d2MrRTdYckJBd0tjR2tGU1JXOS9OUXdCSUVyem1C
WjAraXlSNnpZc0JlMmlOa0lGSCtoNGFoeW5GWXlVRWJHanNsQisxekgxNmFheVJ0YTdNZE5pN3Nv
d3JWemJzVnZydkZiZjhnUzc0YnE1TWx1WnBGSmZhYzVodlBRNFJYdlZkZGtEaDl3Tnh3UkV4QXVO
aVlaM09vY0phcnRPbGd3TXMwc09oTytLTUNkQWovUnNYS1VvcEUwS00wRGFDNys5aVBSNE5GRU9P
QURhVW80Zk5NVjJzQjVCRFlzaXNiTXYxc0RsWTZIRHNBYnhlaDFwSkk4dmpLR2RtaFRITzlPekQ2
ZGtiNVRkVDZDeWQxNHpQaWxLU0pLYVVKenZKNUpPQjhydnBkREJzOHNRcG9CaktGWkNBcXZSd08y
Ymc1QUhra0JoaEhFRGtIaExCWnVxWktZTWtQRzBHb25EQ2JqemNmdEFTUWJyMTdubEorOURBbW5T
WG55OWZYVTNQM3Q2Yy96S0ZFMHVLU1k1UVVySHpubkJUUzBKMmNxeUo5VHhBTUI5cGY3Uk5vTzhL
VHl4RzZRMTJFcXBPY21SRWdwNVlSQnRTSGw2UmU3ajlzTlhoZWNrQ0x0WWtQRmIyNDdJWDgrTUk3
WG5zQm5ZU3FnbVBmWk00Q1JKREdRSk9Tb3dLYU0xODcxeUZTTEc4S2FJcVJyb29jdXU3Wm9kMFE1
TStPSE8wYVJIYVFLVmUxWG1NeGtNalZCc0lFQUdiZERIeW1iQmFZY2E1bU9IRXFQOHU5eFNEakFZ
VWZMZGtUSlltVmRtK2lCQWR5dVFIZk8yUnlKSjJ2M1BTWTBVRkIySkRvMW93VEtxSWFyM1NhSFE5
TjMyazBseGJ0QUg0SGJuR0ZQQ1JhUU11MWhodGMvamVtUXVLQllmMTRtamZhaGxtRlk0MTByajJS
TERlWEFJV2ErRjZkUEREd25EdzR5anFQb0ZiL1lRcHdtY1BOTmc5YVpGNUJ1MkdESDJwRnJ0SFNh
R3gyMzQ0OWtQOVViUjlNc2ZkaEtuQ1p4OGsxRDNKd0FpUEM0U09Pd25UUldEMFJqRHYzbjlDNmxh
NTBRYnVKMHdkOU9CTGV4QmJIK01DRGhqalFFWFErdm5lb1E4UnNYa2pUbFdNRlZMa2RvSG1oelZF
OHo0NEZyV1pVUnJCeFg0Ritxekh4eVZVS3hnVUJUNk9xcTdQcnlkZGVKTXJrVWxNWE5UbGN1OHVl
SmRmRVU4bHhiS1M4RW1SaUtpOVBjclc3ZS9RMjhRMjlXTXQ5NXd0L3RZRnMvbXUrVXY5dnAxdjZu
clZyTDZhWFdvelU3WGJuOUYrYWRCbUlZeThDRUJlWXVUejllcSsyU3oxSnJsYkJlYnU2WEhSekFV
VlJFeHRocXUzTzhGQlBYNDEyKythMVYzYmFBQjhHUUMrd3VCbmFsLzA1K3ZyOHpjWDAvN3JveEFr
MkdLaU4rcDlQUC9sRmRPUWQ4M3QrcTZwOVhhK0RhakY4VE5rbTBJVlFJSEZGZ2NOQkVqekZLRlJt
Qjk1Q3RCL3JWZVJlaForZDlmSTg0bjZYZ3NDTTR0RFFETU11dGMvTU5YZVJ2NThhamJhbHU0MWk3
dHVXMlN6allZRnkxZ0lTSTVCRG8zRFE4Wko1RGhKVldWNjhtOXF3YlVHZTFhM3Z2bmV6WEc5NmZS
Sjd3dTdWUzNtNjgybVhwaDlxMTRPU1FpSEZIUDQxdWdqWGhpaG5qeUM0cUwrcjhiWXJocXozWHFq
MWd0cEV0cUVtOVY4OFhUWHN2YkNUMFBnWnhpKzJhYmJ6cGRUTUlmVkJOUHJXblBmN2tEYk5mMlJY
bWNaRnZOUDg3amZvNE1zaEVTT1NhenFlUzFnYlA1Mjl6N0RWZURxOHF6LzlPZlRiTkhzWnNDNzNI
dzZpd2JRaG5nOFZtQzBRMUlKOFUrc2RHYVhlc21uVFZRc2ZmVUdxcS9UdXQ1ZDA2Mk9wMmRhODE2
a0ljNklWUmpwZkwyOGJWWVFWck5jUHEzVzBMYjBVcWxjbDcwKzdNeE8wZGFyZXBHSCtDQWVZK1Ri
aC9YVFFxM2FxN1d6SkQxdGE3Ty9mcjFTeGY3MXZUTlVFQXI1YVBBUXI4UVpwbUdGV25naHU5K3Ns
ODY4R2pBcG9CZ3YrQkJ2MWI0QmhFc1lVTHcrZnJCZTZUaXlqNndNUFJqVzZEcmR2blBGNGR1RHZq
eGs5N0RlMWdOVVFod2l0eHppc004ejdPelljNmVPYzJqRGV4UTJCU2pmRGxsU2lEdmtsanVzaFR1
c055OXRjM0dYR2VCWTNwR081UXhNZmpsZHZQQkQzQ0VmZG9lTzR3QzJwdVA5WWRmQlF4d2R6MGU3
RGg3aW9yamxvcjVjVE0rdVZWSncrZmxHSC8yL2VkRHJjQU52OTJoTEhtYnF0OXRhVDUrN1pqdGZy
TGZJVkwwY1F0d2Z0OXpmMytzbmR3SGIxQ0pJdkZNd3YzVlQyMHlwdTlZSVJXaWdkTHZVSm5nN3RB
YUVPRU51T2NQSHpYclhIanUyN1d5N016bmxZdllOT294enRhSUowaHVpZXA5ZUtON2JwL25EQUpz
UUI1bkVKQnRoSkNBMk0wdHJUWE5UaTlobS9kRGNObm9CdEZYcVk1Q0UrTWJFOG8zTDJYL0FRNGVW
MHNiOTB3YXNkTDJWUDIwY0gyTTROdFIxT0E3MEVNK1ljRGMzV1QvdFhHbkw0L1AzelZ4TmcwMnoy
Mm1saUltd05lYzFDUjZQOVdZN1NDSEVJeWFXUjlTZVRjeFZOWW1iblVHeW16VXJuVHpwcUVvdlJH
dXBvMi9ORm1CZlNyTE81T29tbEpkU2lJdE1MQmVwZkVrWE9PbERsMDlDVjV2bS8rQ0Nhc0xFSFho
TXRwQUg0bXoxaUZoQUJEa0xJQWd2bHhCL21WaitjZzNtZ09zUXRLOFFMa1F2UGZmQzhNQ0JZTWhS
MTM5ODJvZ0FwaDdTU0loYlRjYTcxU1RFclNhRkx5TVRkdGdLaTNqV0JzUUE4eC9qWEdHYVlXYnRv
bGxKQXhoS0daSVE5NXBZN3ZVdjRTYnZ3Qm5oUmlGNTdLN1pVV2dYSWpQWHpHYXFrb29FLzY1bkd6
MVhGM2REQ2cveHNVazFwSEJ6Zmt3KytWYWJadHhkOStCWDg2SzZMMUF2cXF1SXlUMHBxWG54RDBv
Q05pNzR4elh2LzFNbXVwWnZKWXAybHdENHFvNkp4VlZVWlZXVnErMzNxT0JBZEdxWU5PL1JnUUt6
clFKaFUyZmFBRDZ6MDBJVGk2MnZqamhkVGdmc3JFREN0WVNHZDZ6b1d0YTdhbzBRbFFPY2ptVUVi
VlhZQzhQWnFvQmtieGtLWVFld1piQjlXQWFCVUJPR1FuTnkzb2RycnFnY1NOaW5pbVBzVGRnTHl0
bWJnQlJBSzhZdmR0aFBzRHBvNlNNcWhGWm9vdmFPQU0wZkZnUForM1IxakUwSyt5RFpteTJRUm1o
TitTVVB1Z2xXQ0MxNHlNUFJ4NTV6bENMM0tiTXFqdmNkcEh6VGYzaDMvdjc5UzVOS3luLytlSEg5
ODVjdkY5TlAwOHViTTNWZThtZjlRT0R6NWNWdmY3dzA5Y0V4U3J4WHdXZ0Z2MjAybGdMTGdVbWdm
a0pONWJtZ25BMFV5RmpnR1Q1b0xMQWNHUXZvSjloYWlNRTdhM0hCZ3VsTEV6WHYrbzA2NEE0RHFB
NlBtbzZ4ODhDUEJtK2JnUFhnM2c4QUhweDJoWW9wY3J2QW5HQkZtdkt3UDNoVGlFT1BDQzZzWWxL
VkhXcVBIZm5ZaE9vRzJ4ZEFTYTVENUJGWGF5Vnl6N2kyWGNxeEN5cmNIaEcyaUlKYzRqVi91QUdX
aEFTMEhTb3dibGVBd20zTzJ1TlVlZDVGanVhckFpTks1RjBpbVlJTHZoK0tEWTVwZ1FEQk5xejFT
bVBSOVlqNG0wd1hYUEVlekFDbENpcEJjYkU3YVl3L1d0SkhMaEZNeHl6Q29sWmxCallNYkEyK1dC
dVdRNjRRUEpDb2o5T3hJcjFCVEM2VFFWT3o3ZGxENlhEcHc5R0hNTU5MYTdwN3d1QU5hdTFKMkpT
VlVWSzBOd2RiUjJIVkN4NTFtNFFkei9pRTZJOFlZMUtENE5EaThUV3JiTlFHaFczVWw0N0FjaWhi
U0FVbzFNZndXTUh2SUNhWHlSZ3JnY0wzTUFtMVdOKzBHU2JpYXpXVUlWSlc1Q0g0dzVZTmZHK1VP
aFFyL3pLQXZLNDdjK2JmbDgvWDU5MXhKVGVEQUFjdm54MTJRNW1BSTVuSHNWTUlTczA0R3hTZWNm
QlgyeWhVYjNqR01VcU5WamRCMnFXSFh0cGpFQk9PYWtYcnlpOTdEOEVmdUhUUVZqUXU2SVpNZkZa
M2xLUk9XNWNGeXJJdThPc1lWWHJNeU9vbVNDYytnNmVoN2syMGgvSTJwQXlQa282U0FXbGxLRFNX
RnB6MHpaK0Y2bktrbGlLM0N3eExxQ2NQK1lCN2wyeFpFNnJCeFg1TmVxekl3eVZZTVFnU0JkMzdp
QXljbzdXOTB1WDB3eGsrUkl1dkZ1ekhrRGVBRUxtcStSVUh5NVVKbHJsYW1IUXlCVXBDOGtGNVIz
SUJ4KzBLVUU2VkpNcjgyc3pMZkZWZ0VxN3VuTzd4d29KRDBjRlJMUmdnVzRXMSt0UVUxc01KYkN2
UTJQcnFpTlBsZEVpNkNwVWFVK0F0VFpOaFV1VmtmQUNuWXhsaENaT3lCQnNHTmdnYUpHNEZ1VUx3
VUtRK1VzY0tvUWRCdVZRR2pjMHhhUitwd3hVQXh4OUNQWHh0VThxcnFCUXV0Q3pzWkpVL0kxbUZF
aVJDb3NySjhJRDZVRHB4YkxVcUM3VkJZUXVsSWVOV1VLeVFDbFNtajJKd3lEa0dsRXRsaklWQTZm
dW9CTnVyYjlvTVUvRzE4aTk2dENINUtQNndkWU8reFNsTDFaODVzT2VnR3hxUVNWSGxpYjhySi80
R3drQkowVEZNRklKU3M4MEdoV2NiL05XMkJ0VWJubTJNMUIvcUoxU3Y5T0NZQ2ozYnFGYTB0dnpT
OTFIOGdRc0hiVWhrREY0NU1UaWc0ak84bzZSNDJzQXNVSmFCZ1YvSDZOSm5TS2lmVUszNHJKNEdP
NUIyVjNZYVVqbDVIRlNIUjAxSFNZcTBPaFFhU3c4WTVKTEtTbnZ3cGh3cHBzanRBc01TYWNyRC92
QjAxUkUyb1J0YzdGZWx6NDU4YklKMWcwQlI0UGRkK2pUR0krM0x0MVNCdnNsS3AxcWhWL0NPeWZQ
YXkyU0ZTR0w1RUtCTHFNQlhkY2x1WGlpMTkzZll3b0tEakNmR28xb3d3QzM4c0ZaL0l6Q3NSeVNt
ZEI1dEMvaHdDdHdWYmt5Qkg1MTlXT1hvSnVad08zaFdFb1F2bHgzVWtHTUhxR1dvZlRoMlNlUGFG
d1A3TXhOVURxNE1wbFh4QThONWVOUGtHQUg0eEk3NkNWV0h6eXBvc1B1U0xMQ0x6bzB2VkRHNEg1
ZldWWERRTndLUzh5Y2V4cEQzU1I1MkU2b1FuNVdRVVBkbEZLTWNNbjA3YkxoR2dnTStnbjkzeFNr
VUFDcUhPb0g5aENxRkhoeGZzRXBvWld4RWd1SWcrbmJWSTZqak9mRVJGZHo1WTFSOWR5bFNUSkhi
QmVZK1VxUXBEL3ZEWTFlYkhxVWJYT3hYcGMrT2ZHd09RKzB6ZWdxOGZWSW5UVElsdE9lZjFFbFRM
djhNbVB6N2R2dU9acVZweURnWkh1Y0xQaTkvVDE0alpHNGNHamlvbEdZaHNQTHg5UE9RY1FvOHpz
WHNkcjJCbDlMVWY4bkQwTU0zUWRtWEpwamplKzAxVXZvK3JoVitVdTBRS1VLSWxKaUlkZnJzNjBa
ZXBHRk9HSm9EYU9wQ3FPVjZ0WHR3N3V5WmZhMzNYTGlVbGlHb3EvRnFyZ0xHeVdJOHp2bnpEdW50
bFpHK2VFdDFpMmRSYnl3K2Fsa2NRbzFoYXFQdWxQRGVHYmNFeGNoNnZkaFpwcGJMQTdCejIyaTNX
eU8xM1dhMjJ0NXJvelZIZktVbHI4eUI0WjZ3dWdkZ1dMZGVIanlFUjRKNUhHUTcrRVkwY015OG8v
Ry8rdEtDL20rK0QzQkpRcmhZamdmYzY3WHZVcENmcU51a0NJdjdBMTRmTWwvZjFYdE1MQTJoWS9r
M2xyTXkwNGQyaUhQbGtOcTd5N04vdU54VTBaZTNWM3ZJZVJsbElZd3MxMmdFK0tKTVk2YTVnVHYx
NXV1bE1KZzc5NXFjL3Y0Y2dycjJhZWlQRVA4L01ZbmJxd3BsYm1SemRISmxZVzBLWlc1a2IySnFD
ak13SURBZ2IySnFDanc4TDFSNWNHVXZXRTlpYW1WamRDOURiMnh2Y2xOd1lXTmxXeTlKUTBOQ1lY
TmxaQ0F6T0NBd0lGSmRMMU4xWW5SNWNHVXZTVzFoWjJVdlRtRnRaUzlKYlRFdlFtbDBjMUJsY2tO
dmJYQnZibVZ1ZENBNEwxZHBaSFJvSURJNE15OU1aVzVuZEdnZ016UXhPQzlJWldsbmFIUWdNVEV6
TDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlQ0K2MzUnlaV0Z0Q25pYzdaMi9ydXU0RWNiZko5VW1n
SkhITU5MdFE5eGkyMjFUcExoSWxTcDVnVlJCbWdCYnUwaVhLbFg2dkloWHVJTXo0SjEvbktGSVNm
YjVQaENHajQ5RVVUSi9tdUZ3S0QrZkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFS
QkVBUkJFQVJCRUFSQkVBUkJFQVJCUitoLy8vL1BQLy85VnlwLy9QdFBiZUhQdDdKdGRuWkxJZWh5
MnJnZ2dqWmU3bi82NGZiemIvSmwyMzRyeEJyNGdqNjV4aUNLQzFteHM4OE1nbzdUWmtxMmJ2L2xi
Ny96ak02QWtlTENXTUZtUVc4dlFvbTdQYjNScng1VzVOMTFCMURzUTJLY0JiMnJZcFRNUHdWRVFB
T0NTQUlsWFV5czRMTkJrTkJHQkkrVlBIekU1N0JIRUdScVF5T3dTcnJBSkVHUUtUWk1RQW1DZG1w
ejJMUTdCNVFnYUVBYlRVbVVOaE9HR1ZnSUNoVFR0QkhFcnpCTXBoNy8vV1VyWC8veGh4Ly8vSHNx
Mi9Yazk5dm4yMy9QYmlOMGtDZ0VFYURFYjJDWXRJaWpaSElJeU1yb3BTOFJqWnU2aG1sN2hXRVMy
cjUzc2tUVkFxeUV0cXVoTDlIWmpScVJGNFVRS0cwbTdPeVdYazU1cStRVk1NWFNRRzEzcXJNYlZk
Wm1jVXhQanptaXNvZ21zbmVVdk1kL3ZvcjIwd1NtV3IwQlVQRjhFek0xZDlCRWFZR1V6blQvUHFX
V1czTDlvRWRNRTRjZzJqQUZtSXIxQmtDWmdRaTJTbk5wR2xnOFJRR1FDNUtsdi9yTXlDZ2ViWUdw
VndlcUd5U2ZRaFBabzUxTzBhWGlpaDVOeVJHMHQvdHJkWjRWZW1tZ3RuNnVBeEh0dUdsL2VGeXMr
TmhacmhNU01hMU1LUjdsbVNxdkVuWWR1V1FPVWQzbCtSSDhGMlhNZExLdjI5WVRWMlVDVldyL2lU
S0hUaTFRZTJneXJkSzl0eXhSajZjMFU2ZTdmNlo5R1lqdWVuYks3RG5WKy9aQS9Mazd5c3VUMVox
SElFenkxK1Q2MWlwdzl2YmJwdjBvQldTZGJxZk1yakpXVlo3TnBVQ1Y1dEc2VE1WUXhGaDE5NzNz
dEZSc25vWTdiYnQ0S2srUWVPM2FyQlBIVTdQTUUwdjNaQk9XZFVEbCszL21mS3Z6Q09KRU1vMjVv
SjJLemRNd1RWUnR3SkVZc29rMmRGbHJ5MW1Pbi9tTjczSHZreFV1QW1xQXB1Q1VCMnFyV3FndTBh
ZEk5L1A3dnN3aVBXSWFRRWtYcjU1YnhmR2JHM1hYZCtEOVgrNkpRSG1CRVc1QU1JT21HMmxlbkxh
cU50M1JIRWFaUUhGcWNWdXVFNk9JemRPQU42WFh5QWR2dWtXVDdnMnZrczJiKzVRLzNiWDJmN01a
U0ZjQVpicG4zdW5vRTljVmltMENKOU9MYjd4aTJGdy9JSUxMR0UyNnE1Y0l5dkJsd3BWczdiYlpk
c3IxNjJSb3VyL25WYXQ3MFFxZ1NqY0g4OXpqQ2dldXpNc0IxYWJ0aWI0NjBPdW90cHZsbU0wdCto
QzNpdGUzYlQvRjY4dDBxaW5WSGdEVVFGeGQ3eUtRRVVBTnNQQnlRSEhjWUwrenh3bnFHcVZGV09u
NmswMjlmOHNNckY4dHFYY0NTdnQ3R1lNUzEybEdMRXQyNnJXQWFsTWpSSit2OWplUlplRlpQYStJ
NVlyaXozeEoycDBTZllIZXllVWJzeVlhbWZhL1hzdzh2MVQ1dFlBU1llMjJlNWM4b2paQnZXU014
T29xRXlYeGVXQ2hidW5nT1VVZzk0Y21GZ0YxU2xCQ0E5VXUyemVMR2U1clQ3OGI5TzZTOVZwQXRZ
bmxMUWpWbnRhR05icEFlUkNKVjVPdnJzRkt0cHhPZklyWGx3bDJyYWh6T2xCeHo4K1hzWW1rZk9y
UmxZSHlRQ2laSnowSzg1Z3k2UkNMRmx1VTlDZGRza3BBVFluMWFXdXk4eHMvWldKM2VENDMwOVI4
SWxObUh1cXlRSG54N1pKNUVqUjVLSm1tUnhmeHVXZXdnaEZXQ2FqYm1nQ0MyVEh5TXNjZGVyTzVR
T2tLSndMRkRjaWtJWFZqajFjR3FtMG45OGxTRGZkRWVGeFRFR1BWTFMxaW91U0RFblRXVTRMbnVs
ZGt2dlIyL2NLaldjYmI3V1BtUVJlTm9RWktKbGMydjFUNWhZQnFqUXUvbHN4VDhKQXhiOFMwc3dU
V3FnUVVXNmdwS1JPbEJJTjRyL3c5WDI4V0gyNVJsRytQTWplUUZ3S3F6YlZqcHZKM2JFNVl5bHVv
NlVVRFc3VlE2MmFqTWt6dFNhV3VIcTRiT1J5Ymg5cXZHSmtYQXVxTCt2bk9mTzhpWjYvTDBVN1hi
c0JhSmRzL0Y2aW5iMjUyK2ovQk5HZ3B1cGhaWXpMY2RhZFBFN3dvVVB2TlUyQ2JXazhzNXVJdi8v
cXRmdFVmZHVIS1J5VGF3V09ld2E0OExycTVBWUdkQ2pwUE10ODcyRGlUeTVmTVBvcFp6aXdOZm5X
Z1JFU2kycldtK0hoTWlvbVA0TWpEcXJWVHlSdUNtTTRldllSU3NmK21uNTlBZjNianlWNXY5R3lp
Q0FzRWg5QTFlNGJNbXlGcTJ4Q3ZyZ29tY0hVTHUvRjh2UWJrOUxVYkdxalNlcUxBTm1VQ0VhWlZN
aTBVbHdBclBrbzFJakVYcU9mVTJaenVQVG1UaERDQWFqZFpLRmdQMWZVaFJUMWVVQ0xPc0RWUDhJ
SkE1ZU5kWDhLZlhldWFKODh3dGV3SXIwK2daR0tWdnlGOCtYN3dPSG9KYmVVbk1hdE02VDVUV2wy
ZWQrZUcyOS9OakUyMmMrQTByd1pVL2thZEhEMlpXQVVvZWViSmZHTWFxZndOWWV6RVM2bytTS0h0
VHNHK3V0c2tPeTBaaFNSUVkrM2ZreURSUmVPTmdZcm5ucExtU1Z1bHVIampyTFlrL1QxdG1uZGN4
VWdEM1ltSEJvRTdwOTJxcEd0WFhlNlVaeXFPdW5TZlJaYXBwK3ZmWGcybzB0SzhtMk9lNHFHVGlW
SUpxeUQ2VngwQUR0eEp4aFNNT0xnWG1hTjFJaVg1OEFRUHEzWmpYV0Z5OVVRd2hDazlsOCs3RHNu
R2VEVlVGMWd0a2dDcUZIRDJ6Rk5nbTdTek4xQUNPNVVQK09zbkJPNjRpalU5aWc5TjNYT0lkVFh2
ci85UmYzcXR0L3R3RzZaTEFKWGNpLzI5cW5tS0kzZzd5YXJPUng5cG9hQlBvaGFvZktjYWkrK05q
WnZ5THQvQWZEU0FncWFybW40VDU1WWZZNXRNckFaT2VXRHdDRUd4ZURTUjdGVGVqNFFLbWdSV1Uw
WlBBVk41OHlTZTd3U2dvTGthQU1velQza0xOUmVvNm1LVDFzS1dvakVRMUJVUEtLcEFMUm85YmZX
TE4xM3psRC9aTmoxK0lMd0pRVjF4WEtLMGJIekFRbzBacVM1VzFRZGZpQWJmaWduMkVOVFZHRkFE
RmlybUlsL29PZi9WcC8yTDFWdnJRbng3Rm9hM05jeHQxWHVMcHA0dk1pZDFyeXg3SDdOUUdhOXY5
V255ajhzTHBxWkhKTHgwaVB5MFBtVUN6RzNWUzZ2TEM2VklyYjRMOFYyUjc0M21UWktHUmFlUG9a
WU9aT2dobk5yWld6R0F1dm5MM3g3Zi8yNkxWOFBWRWdCT0YyWHhCZGZrbUt3SjVwb1NwWjdmdnV0
WlFDMks4czIvQ3Qra3pSTmJxT2tEcUJnV0VtRjF6V1duRjFRWHFNT2FRVjlaTnhueW5uNk11VGNQ
bFVFcEdlV2Izc04xTEdLZHYvZk1BZlg4NkNSZ0txT3JBVVcrWDVBWXZIVzVVcWFFWjZGbVRVWE52
UTQ4MTZ5Wld1Rm41akVaOXZ3SFBKeURNMUdydThRYmQ1OVpNYjFKTzMxSSt1M08wdUx4dVZHK2Rl
T3AxdGtUNW1sNmZJOVVzanRtL0lIdWZ1TEQ0WlVMNXVJTDNzczhGdmZlZHNTWFBGeitLWjNlOW5U
bkY2ZWd0OUViZUEzTE44bGNqejhXUDh3RGxjdysycDk2VkQwRnM2bmNCczNVb295akVsRDA5WW52
eSt6a1BPd3luOFlRUDhXbGRVN2F2Zmk5UGdWZTNpdWVoVUpreFE5ak1YY3hyd25iNkxadCtoRHNI
bnR6RUI1UTdkSE5Kb2xkK05EbXRUS3ZzQ2VhNGtsdUdUdDcrMTIrS2VNcGl1eDV6dDY2K2R6cXlF
ajNUeE9vcC8vc08rb0crcit4Uy9uMTQzZHFUS0NDWG1RZWpta3lkekVIaklGWk1TdVBvM3ptQnQ2
VmVWcHVaTDQ5MDhVWmdJdENFMVBzMU5iSWx2Rmp6Tk96RGhUSFlGa2VVSjdNSVVZbTZPRUZHK043
c25tNG9PdDZlOUVuUWZQRWxsV2dNazFxLzJzYTYyT2twM1dxUVlra1ZudU1DTG1tWGp2WHBSc05B
SFZUUC9sWGpmN3BYVXhuVXV0bXJTM3Rub0s0Q1NTREJ1Sk04N0c3QWFBRzRoakpLN1pJd1VKNHpS
U1BvZkpHYWtxSDU0QjVpOVZTOC9SY0R4U1BudG9WOUhvWGJmaVNSMzlhWHFpUXVKa251NkxlckJ1
eUlBMEFOVUJIN0xVZUlKMDFFWmduN2ZWNVdNMmRpaklub1pabXc2NXorWUlubk9pREpwc1JCQ1h5
ZXlWenBVeXZqeHNmUEdGakdLaHVrM1E5b2ozVkduYks3SzVkc2dLZ1ZuUjEwY2pWaXpWS1FKbWVp
UW1VQ0VEeDdvK1Boem1mQzFSK0xsdlhMSUxWT3ZnMkFOU2VmRWd4MFhCd29qS0Zwc2RDRS96aElw
VGFSaDdnN0pGV2hNMjdEb3pwOG1WNjFCU1hiOWhDNlEzTU1QVXhMcCt1TXdpd0x4VXRwdEJNeFVh
S1VGcVJhMlNLWm5nUE9GWWVLQzhRcCtuSXhPdEtjNTF4QXc0YlF5VmJkUXBRUVh1T0VXSFZCcXRO
VTdWQnRHMURIQjI4c3UrWXcrVXZmakIvcElHS2U3anBkTVZ4NDlheDBhZFFBbW9zeWxldGYzV1VM
OURwQzJyMFNzQlRDRHBGR2FEaWdGTFZRbm0zMEllZjJNQnp2bFBHVU0raGVhaDgvUmxmMGZTY1Mv
TlFnVTRINmpPcjIvbTcyU3lsTWRRanpPMTVOajhsUUpFci9yUE4xdE9uVUFYcUdVNEhtOGgvOVJj
bVYyTXN3NWtTYlowNmg3RGQ4dURReFBFcUpmUWVLZTZ1b25DZVQ2YTdldjRialk3YjRON3RJeVd2
Uy9HUEgwdDQybENoNlN1T0FkVWF4RWVUYmVqeHpqZVc5cVM4dXczM2Y5NHNFN1V3dy9KZWsvalFY
MVcyNVBFRHFJUEZlWHFydzRNRE1xZUtiaC9QdzgvYzZJSjVLRjJuTjdHYmIrMHNvTHFOMUhwVXNy
dkZsdmt3b0Q1RTE5eUw5Z1NYNHRWRnc3RTJoL3lhZG1xZEhzV2xSbkZWaTV5WmFpUHoydytmZUts
SnM2N3d4VVZ1bmdnYmZrS21rdXAyaVc0a0FYcFh0U2pwcFNKZ3lwUVlkclgvaXNPTTBIc3JScW1k
VFFaVFFtSlFJTjZEcGs4bEhpNlpDeGpOWllQYjUyZTMrb3A2ZlA5RGFhZWtmVUluaWgwOHZmZ2lL
UEQ2SUtnVnBWSzBLT25rd0lDbXM1c1BRVmNSSlFHeTU1YXhSekJNMEh1cmxLM0h4bWlNSTlxWWtt
eFhueGNFbmFMV3loQXB1ckRuSmlhajc4M0R4c1dyZ0loUmdsV0NQb1BJN3BpNU41bWlhV3IvZGNC
Nld3aTZwb2dzYll3Q2pyeC84ZnFwczg4SmdpNGhFWE9JYlJQRjlNaEZCRVFRMUZYN1c0UlVQdFVL
UkFpQ0lBaUNJQWlDSUFpQ0lBaUNJQWlDb1BmV3IyNlgzWGdLWlc1a2MzUnlaV0Z0Q21WdVpHOWlh
Z296T0NBd0lHOWlhZ284UEM5TVpXNW5kR2dnTWpVNU5pOU9JRE12Um1sc2RHVnlMMFpzWVhSbFJH
VmpiMlJsUGo1emRISmxZVzBLZUp5ZGxuZFVVOWtXaDgrOU43MVFraENLbE5CcmFGSUNTQTI5U0pF
dUtqRUpFRXJBa0FBaU5rUlVjRVJSa2FZSU1pamdnS05Ea2JFaWlvVUJVYkhyQkJsRTFIRndGQnVX
U1dTdEdkKzhlZS9ObTk4ZjkzNXJuNzNQM1dmdmZkYTZBSkQ4Z3dYQ1RGZ0pnQXloV0JUaDU4V0lq
WXRuWUFjQkRQQUFBMndBNEhDenMwSVcrRVlDbVFKODJJeHNtUlA0RjcyNkRpRDUreXJUUDR6QkFQ
K2ZsTGxaSWpFQVVKaU01L0w0MlZ3WkY4azRQVmVjSmJkUHlaaTJORTNPTUVyT0lsbUNNbGFUYy9J
c1czejJtV1VQT2ZNeWhEd1p5M1BPNG1YdzVOd240NDA1RXI2TWtXQVpGK2NJK0xreXZpWmpnM1JK
aGtER2IrU3hHWHhPTmdBb2t0d3U1bk5UWkd3dFk1SW9Nb0l0NDNrQTRFakpYL0RTTDFqTXp4UExE
OFhPekZvdUVpU25pQmttWEZPR2paTVRpK0hQejAzbmk4WE1NQTQzalNQaU1kaVpHVmtjNFhJQVpz
LzhXUlI1YlJteUlqdllPRGs0TUcwdGJiNG8xSDlkL0p1UzkzYVdYb1IvN2hsRUgvakQ5bGQrbVEw
QXNLWmx0ZG42aDIxcEZRQmQ2d0ZRdS8ySHpXQXZBSXF5dm5VT2ZYRWV1bnhlVXNUaUxHY3JxOXpj
WEVzQm4yc3BMK2p2K3A4T2YwTmZmTTlTdnQzdjVXRjQ4NU00a25ReFExNDNibVo2cGtURXlNN2lj
UGtNNXArSCtCOEgvblVlRmhIOEpMNklMNVJGUk11bVRDQk1sclZieUJPSUJabENoa0Q0bjVyNEQ4
UCtwTm01bG9uYStCSFFsbGdDcFNFYVFINGVBQ2dxRVNBSmUyUXIwTzk5QzhaSEEvbk5pOUdabUoz
N3o0TCtmVmU0VFA3SUZpUi9qbU5IUkRLNEVsSE83SnI4V2dJMElBQkZRQVBxUUJ2b0F4UEFCTGJB
RWJnQUQrQURBa0VvaUFSeFlESGdnaFNRQVVRZ0Z4U0F0YUFZbElLdFlDZW9CbldnRVRTRE5uQVlk
SUZqNERRNEJ5NkJ5MkFFM0FGU01BNmVnQ253Q3N4QUVJU0Z5QkFWVW9kMElFUElITEtGV0pBYjVB
TUZReEZRSEpRSUpVTkNTQUlWUU91Z1VxZ2Nxb2Jxb1dib1crZ29kQnE2QUExRHQ2QlJhQkw2Rlhv
SEl6QUpwc0Zhc0JGc0JiTmdUemdJam9RWHdjbndNamdmTG9LM3dKVndBM3dRN29SUHc1ZmdFVmdL
UDRHbkVZQVFFVHFpaXpBUkZzSkdRcEY0SkFrUklhdVFFcVFDYVVEYWtCNmtIN21LU0pHbnlGc1VC
a1ZGTVZCTWxBdktIeFdGNHFLV29WYWhOcU9xVVFkUW5hZysxRlhVS0dvSzlSRk5SbXVpemRITzZB
QjBMRG9abllzdVJsZWdtOUFkNkxQb0VmUTQraFVHZzZGampER09HSDlNSENZVnN3S3pHYk1iMDQ0
NWhSbkdqR0dtc1Zpc090WWM2NG9OeFhLd1ltd3h0Z3A3RUhzU2V3VTdqbjJESStKMGNMWTRYMXc4
VG9ncnhGWGdXbkFuY0Zkd0U3Z1p2QkxlRU8rTUQ4WHo4TXZ4WmZoR2ZBOStDRCtPbnlFb0U0d0py
b1JJUWlwaExhR1MwRVk0UzdoTGVFRWtFdldJVHNSd29vQzRobGhKUEVROFR4d2x2aVZSU0dZa05p
bUJKQ0Z0SWUwbm5TTGRJcjBnazhsR1pBOXlQRmxNM2tKdUpwOGgzeWUvVWFBcVdDb0VLUEFVVml2
VUtIUXFYRkY0cG9oWE5GVDBWRnlzbUs5WW9YaEVjVWp4cVJKZXlVaUpyY1JSV3FWVW8zUlU2WWJT
dERKVjJVWTVWRGxEZWJOeWkvSUY1VWNVTE1XSTRrUGhVWW9vK3lobktHTlVoS3BQWlZPNTFIWFVS
dXBaNmpnTlF6T21CZEJTYWFXMGIyaUR0Q2tWaW9xZFNyUktua3FOeW5FVktSMmhHOUVENk9uME12
cGgrblg2TzFVdFZVOVZ2dW9tMVRiVks2cXYxZWFvZWFqeDFVclUydFZHMU42cE05UjkxTlBVdDZs
M3FkL1RRR21ZYVlScjVHcnMwVGlyOFhRT2JZN0xITzZja2ptSDU5eldoRFhOTkNNMFYyanUweHpR
bk5iUzF2TFR5dEtxMGpxajlWU2JydTJobmFxOVEvdUU5cVFPVmNkTlI2Q3pRK2Vrem1PR0NzT1Rr
YzZvWlBReHBuUTFkZjExSmJyMXVvTzZNM3JHZWxGNmhYcnRldmYwQ2Zvcy9TVDlIZnE5K2xNR09n
WWhCZ1VHclFhM0RmR0dMTU1VdzEyRy9ZYXZqWXlOWW93MkdIVVpQVEpXTXc0d3pqZHVOYjVyUWpa
eE4xbG0wbUJ5elJSanlqSk5NOTF0ZXRrTU5yTTNTekdyTVJzeWg4MGR6QVhtdTgySExkQVdUaFpD
aXdhTEcwd1MwNU9adzJ4bGpsclNMWU10Q3kyN0xKOVpHVmpGVzIyejZyZjZhRzF2blc3ZGFIM0ho
bUlUYUZObzAyUHpxNjJaTGRlMnh2YmFYUEpjMzdtcjUzYlBmVzVuYnNlMzIyTjMwNTVxSDJLL3di
N1gvb09EbzRQSW9jMWgwdEhBTWRHeDF2RUdpOFlLWTIxbW5YZENPM2s1clhZNjV2VFcyY0ZaN0h6
WStSY1hwa3VhUzR2TG8zbkc4L2p6R3VlTnVlcTVjbHpyWGFWdURMZEV0NzF1VW5kZGQ0NTdnL3NE
RDMwUG5rZVR4NFNucVdlcTUwSFBaMTdXWGlLdkRxL1hiR2YyU3ZZcGI4VGJ6N3ZFZTlDSDRoUGxV
KzF6MzFmUE45bTMxWGZLejk1dmhkOHBmN1Iva1A4Mi94c0JXZ0hjZ09hQXFVREh3SldCZlVHa29B
VkIxVUVQZ3MyQ1JjRTlJWEJJWU1qMmtMdnpEZWNMNTNlRmd0Q0EwTzJoOThLTXc1YUZmUitPQ1E4
THJ3bC9HR0VUVVJEUnY0QzZZTW1DbGdXdklyMGl5eUx2UkpsRVNhSjZveFdqRTZLYm8xL0hlTWVV
eDBoanJXSlh4bDZLMDRnVHhIWEhZK09qNDV2aXB4ZjZMTnk1Y0R6QlBxRTQ0Zm9pNDBWNWl5NHMx
bGljdnZqNEVzVWxuQ1ZIRXRHSk1Za3RpZTg1b1p3R3p2VFNnS1cxUzZlNGJPNHU3aE9lQjI4SGI1
THZ5aS9uVHlTNUpwVW5QVXAyVGQ2ZVBKbmlubEtSOGxUQUZsUUxucWY2cDlhbHZrNExUZHVmOWlr
OUpyMDlBNWVSbUhGVVNCR21DZnN5dFRQek1vZXp6TE9LczZUTG5KZnRYRFlsQ2hJMVpVUFppN0s3
eFRUWno5U0F4RVN5WGpLYTQ1WlRrL01tTnpyM1NKNXluakJ2WUxuWjhrM0xKL0o5ODc5ZWdWckJY
ZEZib0Z1d3RtQjBwZWZLK2xYUXFxV3JlbGZycnk1YVBiN0diODJCdFlTMWFXdC9LTFF1TEM5OHVT
NW1YVStSVnRHYW9ySDFmdXRiaXhXS1JjVTNOcmhzcU51STJpallPTGhwN3FhcVRSOUxlQ1VYUzYx
TEswcmZiK1p1dnZpVnpWZVZYMzNha3JSbHNNeWhiTTlXekZiaDF1dmIzTGNkS0ZjdXp5OGYyeDZ5
dlhNSFkwZkpqcGM3bCt5OFVHRlhVYmVMc0V1eVMxb1pYTmxkWlZDMXRlcDlkVXIxU0kxWFRYdXRa
dTJtMnRlN2VidXY3UEhZMDFhblZWZGE5MjZ2WU8vTmVyLzZ6Z2FqaG9wOW1IMDUreDQyUmpmMmY4
MzZ1cmxKbzZtMDZjTis0WDdwZ1lnRGZjMk96YzB0bWkxbHJYQ3JwSFh5WU1MQnk5OTRmOVBkeG15
cmI2ZTNseDRDaHlTSEhuK2IrTzMxdzBHSGU0K3dqclI5Wi9oZGJRZTFvNlFUNmx6ZU9kV1YwaVh0
anVzZVBocDR0TGZIcGFmamU4dnY5eC9UUFZaelhPVjQyUW5DaWFJVG4wN21uNXcrbFhYcTZlbmsw
Mk85UzNydm5JazljNjB2dkcvd2JORFo4K2Q4ejUzcDkrdy9lZDcxL0xFTHpoZU9YbVJkN0xya2NL
bHp3SDZnNHdmN0h6b0dIUVk3aHh5SHVpODdYZTRabmpkODRvcjdsZE5YdmErZXV4Wnc3ZExJL0pI
aDYxSFhiOTVJdUNHOXlidjU2RmI2cmVlM2MyN1AzRmx6RjMyMzVKN1N2WXI3bXZjYmZqVDlzVjNx
SUQwKzZqMDY4R0RCZ3p0ajNMRW5QMlgvOUg2ODZDSDVZY1dFemtUekk5dEh4eVo5Snk4L1h2aDQv
RW5XazVtbnhUOHIvMXo3ek9UWmQ3OTQvREl3RlRzMS9sejAvTk92bTErb3Y5ai8wdTVsNzNUWTlQ
MVhHYTltWHBlOFVYOXo0QzNyYmYrN21IY1RNN252c2U4clA1aCs2UGtZOVBIdXA0eFBuMzREOTRU
eit3cGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqTTVJREFnYjJKcUNqdzhMMHhsYm1kMGFDQTNOREl6
TDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlQ0K2MzUnlaV0Z0Q25pY3hWMWJjOXcyc243M3I1aXE4
M0NTcWhYRis4V1ZGMFdXSGUzYXNpTXJtOXJhN01ONE5MS21kaTdPekNpdW5GOS9BSklBdXh2ZEhB
NHhjblkzRzdHSEFMNnZ1d0YwZ3dBWlRVTDEzN05JL1Y5UnhaUFo2c1h2TDZKYUZrMmlVdit2RmhW
bFVKWlZjMjhTQlpuNmQ1SUVVUmFHWVYzby9Ib1ZUVjV0WHZ6ODRzZTdGK2V2czBrNnVYdG9LMUtW
UjBrNlNkTWdqdkxKM1dyeTcrOG0zMC8rTTduN3U3cFQvUmJqVy9NcVNKSTRETldmWVJEblRvbGlF
a1dvUkZxR1FaaVZZWlJPcWlDcW12dHY1MTgyMi8zM0UxM3d1NC83NmY1cDk3SzllcjFZVDVlMk9n
bzFLektGSWNpUytHRERXYWlnRm5GVjVwTzRVQzJIR25SZDZPTzc2N3VmL3RhMjkvZnJ0Mi9iU3E3
dWxDN0RTWm9GZVpscTFhMG1aMkdRNUZxU3hLa3V2NXpFWVJHRXVxNnNSOXlXMStJOHlOTkduQWRo
cXY1TWxMaXBGUWdlSjcrK1dMOVFHZzJMTWszVTcybVJab3BLRU9WcEVlYVQyemN2L3YwZnhldGVp
WXE0cHZMMWhRVm40UW9vUGlyTC8vNkMvUkdWeVlxZ0RDMGhpMXlKMHpTVjJZd0NmeHdhaDBIMzQw
clZERyt0bGNKQnRySlJlRVBVWkM5TWZPdVpBV1R2Y3AwcVJPWnl2QU5UT2c1K0RiMXJpMnJyb3hr
VUN0VTlNOVNCa2lCT0oxa1NWR1ZZVlczSC9URGRMK1pyMDNPdjF3K2I3VXFKTm12WWhSUXdhbFBF
Tmcwejd0cnlUOE0weUpPcUtsT2tCYTN6SksvTmNRcnZReEFwaE1hUVdOcmNCWlVIZ0ZyckNPQkhv
VHpVZm9lUytDYnB5Vlp2SEVxL2JvRWJreURTdTdENlJkTnl5RTlpYnFxaW5sNFE2M2xPM2FaNTRi
N3c4Y3Q4dGxqTjEvMmRRV3RhRmFueWlwZ1NpbTFYeUlvOFNESmxsNHlLa2I3VU5NZ054RXI1dHJT
Lzc3RzRNVURTWHpCTWVqTkhFaHBCbDhiWG1UTjBDOFNQWWhoVlZhRVp0bWp0d0VqYjd6aGhCN2Q2
d1VOQkJqZzVZUDNjbDIxVEFpemN6TnBUZEJtT3pyTU5ZVUxQUzhNeWlCUGQzVWpIdTF3ZW5vT2M2
ZG9OYm5UVnF1NVM0NGVoQXhDY0psSVlPQ0JHYWFRMEhWZFZnaEZxZVZpNmNtK2dCMEYwV0lHNHU2
OE1sU0MxQVEwU2hiZ21ld05IQk1rOUltRVdKQ0VUNHJzWTVHNjh4c1dYMUdzOE9EZ3VFMkpBclJX
Q0xKN2ttYnEvN2hKUlZhcXBLVkJkVkpmWnp1c1dUV3JZM1p2cTlLL3RYeVEvcXB2dVVyS2VwTWoy
MENoMEE4Uks1VlpSb2NhVnBwcFg3MzgwbVZ3VW44ZmxlVlJsWlZ1VkxWaXBra21wUmhkYSt1TE5s
U2x0Uytra2tHczRVdmxkR1NWaG1EWmwzOHpYOS9QdFM5cFdwdExQTkd3U1ZsemdYZE9TQkkzZTd0
emFvSWhqblkycUtZVU5rRi8xNFNGRlAxNjh2bExhYVA3RFlXc2FUTElnemhTc1ZtVS96YWZML2VP
ZzlrakpNc3VMS0F5clBJekxOTTBMMEtRTjQvdENPeGhEZ3U0QWc3WlRqMUREQW1COWpibytRSXI2
cWNCZzlFVFhDNkxEaWtZZ0k3RGQzUmxkbWJuQmFsaWk0eitrT3FPK1FJaWRIYVQwZzNlVDA0QTlP
Sk8xYTE5a0xBSHhmVjRGUlpKMnkwUnRmTzkwcVRoUDI4Q0VsUGoxcHlRTHF5eTZjMHAwalpSeGtH
WjFNTlRFTXB2bGNqN2J6Kzk3V2lGRnd1dzhDcy9qTUNxY0FTSktUY0JKeXB5Yk1UbDVtZVR0M3g5
ZTllR3NzaUFxVWp2NjNjNW44OFVmdlRCSkNRMHpPZ1NUbERFd3cvSmxHQTJDR1NrM0txdkVEcUxO
eW1JdlRscGtFRkJheUNvMGVobVhEbEthK2ZWRjdUQkxBUDBEUnVEK1k5TVIrUU5OZU9Sc3pZalJh
S1dMbzY0SCtLR09MdkFlbmNwUlprd01SYkN0UkJKQVlYMXlNTUZrc0I2T28vOGd4emZ1a0hBbUhM
N1VnRHlXOThaVEVCa3dWZktqZFpjVGtxRVg1WVQvWTRKSUZSeW5hbzVKYU1mdXFpSGo1RDh1ZnIz
NmVHbmo0RGNYdC8rQ2NUQjYrbEtvMEVvRnJpYkFkckNxMjZKQThXbnd2YjIrdXJrelR6eXVidjk1
ZlhuMTBjQXNjNVVMcVZDNFRBb25WbzRUTlc1bHNLcVBINjR1cjk5ZDNaalNkTmJSa1hxcGtjaG0y
WDZHTU9Nc0tNdE9sVDgvelhkN280SDZvdjM3MVdMNmViM1o3UmV6bmZsNS96aHYvNXJ1ZHB2Wllx
cUczbGF3M0h6ZW1OL1dSamhkTHFYN2haWmF5V3E2L2EvNWU3cWRPODN2dDlQN09ieHA4OUJmYnlE
YU5jcnJoMllxcll1ck5JcHJ6ODNTU3YwN0x1TWtTN1QyOU0xRkVLdEFRNmxVcDE4UCtqR2NGa1E2
U0Y4MVA4YXFpanAvQkgvVnY5ZC8xVVdYb0JyVG5hS0o3VFd4bHV2OEVOWGIxbUc3aVVwYmFudFBr
Rm1qV1BXUUNpY3ZpbTB2TDEyOUtxbTZmcDJhcDVoZ3BITEtUTXNqaXdlS1dwS1FPb1FMaWNKaUI3
aERyVG9BZ0JLU1Jna1JWRUthQm9rZXFpcWtqT3YxZ3dxNUZwdW5uWFdMM1h5Nm0rOEdLa21qMEpH
cjZraU1GMFJGcklhMlVLK2pXZGhBMUNvRzFNR0pXbkpRWkRRSDZqcWdPYWRDakdTSUY0RXFPSGZp
bmhCM0xYQlBpTHR4TFUyQ1NKdXlZTzg3WkFQVEkrTFlWZ09zSURwRVdRWnFRTlREZlpJRVZkSFN1
ZXRHaUp2cGFqNFFBbXc2YWxZa3lrRWc0anhSYzEyaEZ4a2dpdHY1N21tNUg5aDRrcWdtOVh4cU9r
Y2M1WUc2RE1OaGlraVMzSlRIR0I3bTIvbDZab2JWMituNjgxQjlaR21ocTZ6S3lrSXk2MU5ERUlI
aUVOSGI2YWVoN2VkbG9KUmFsV1hiUHVtYW9wT0RnckJsdEJnU1RuU0FFb2JOS3JhdXVidGVtdXNp
RCtFVFhDQXdjWklFWDFoSTdtdXpDZThham5rUWFVL002c1ZEY05raWlWWDBWbVN0cENrQkJDT3hv
VllKakc2MUZkMTExcUlCOTUwWlZWbGVJYjZpbW5RSkhZZmYwV3ZJQWNmS1hzRmhCcUxEWW91UnVz
TW9EUStFMEs3Q3dHR3d6eTZPOVZGSlg2OXd2SkhIeGFDR1RNSFlCcGxpc1ZXdVlJTlIrSThEMUpD
QUkvRVE2cExDVVQyK2hwRDhnUWZMVUlIMG01RTUway95QUhza3RXb1hqRFNLeEZGdzJnemYvamFJ
dHFSeldJMnZLU1QvWUtGaUh2VmtpS2gzTXhVeUJSSmJwZU5LL0d4eEhLQ1dCSmlRWGVaTm9BQ3BJ
em0wQnF6SDF4eDg0NnNKRDVhaGd1Z1hlTzZDMnhPZ0lYajdqTU0vREFuWWtJSHZzay83RVd3cnhn
WXBjaXF3L0xDRmVONUhFVVRiTWdnenppSllMQnRROGg2Smk2OVZNQ2dPZktoaXpMck96eSthOENa
cFdpOXJUTEhLbm1LOVNnMmkxb3FKV3RXd290TEdMQXpLc2w3SmN0TW4zRXJtMFVxT1cvbnc5dXJp
NDVYSm1ON2YyWWUyZDQ4TGsxTXY0TDZNV3ZJNE5iOTltdHRkVS9lTDNXeTUyZGxWb1AxR1pwQjdN
Q2pDWm8yclhVUDdjL1BVTnZpdzNhemFQN2Z6MldaN2IwQitmVlN3MnI5bm0vWEQ0bjYrM2krbXk4
WCtUN3NtOWFjbEpLTXVFdE1oamtkZFl0UmZ0cHQ5L2JESU5HdmEzKzJuZTROMU9mMGF0SC9XajRU
Tk9waWl2R1Z1Mzg1L2YxcHM1NGIxN21uMktITXBQYmhVTEJmbEhtQXRjZjA5WGRjanpOcS9WT0hI
eGFmRmZ0ZHhjOHdwY2FnOE9LajBHcEZZVGYrN1dIKzJxNXpHSEE5UFc4WEFhTHQxOFNlN2FtbVhK
anVhQzI0WEUwVWVoVDdRSXd6OTYyTC91SG5hdXdyWFR6MGZGalBUQzdhTC9kN2FSZldEWGJmTXp2
RDRNdC91ZWlsRVBoUmlUR0Z2MXBkVlZ6VjllTEh2a095bmk3VmRxZDRZYzloUmFLTnQ5SFd4QTlo
WG1xelR1NW9lSlZLS2ZTZ2xtTkpGMitUbitYcStuZHExOGlkbHErM2kvK0JvK21BSmRkcmZ6cGQ2
SFpPYVp6Vy9YOHhzWmJxY3lDVkp6RVE0Z2t1S3VXeEFIM0JuQXp0UnFQbkRqajBQeXZIQWN4ekkw
ZDcvNVduN1JZM01mUlpKZlZoa21FWFBTQkpsUHUza3VKM1huWVBlM3krMG9xekZYT1Y5Z1hiZTZq
VzdBZE5ubFB2QUpSUG80MzcvNWVYNStmeithVllEQzM3WGoxbnV3Zk9WMldaMS9qRDkvZnoxeGM5
Um1QZkFLbnhna1JueU54aUNMQmZyLzFKdit6VHZCbXcxaS95aFp2Vjd4OXVBd3FmTDh4N29wUTkw
TWlGYVZWcTd0NTV1eDZ2MThzL2d0Kzk3NEZRZWNPSlE5SHRuSFU5WVZjb0R2YWhkNWQwcUhaQTg0
eXBqTGRiNzNIU0VtcGo3bEtCOWhtVldHWkVvaEVVTTRMUUs4cUtWMUpWQXdTZ0dYY3NPT3R1MlhT
dUZkekdRbWVWVGZyWFhNY1I0R3E0UlFneEtXSVlldFBvRmNEb2U5STNYSDVIdWlkeHlkZnpLTWFY
ak5MQXFiMmR5SEowbmNHaFJlTkJxR0RDRlpMTy9abVVTS1lESXJXRWtDMG9Lazh3RTYvYzJuK1J1
UExsRDY4dkMraUVXVzF0SnR2M1dTNXIxajVBOEZsdERTWWFWZENVWkNsVHZiVC9KQ1ZsbXpFcnU4
Y3RWd0ZDa0hqOERlaStDWXY1WWJtMEZXK21SVzRWQk9iSWhxTi9iaUh6akRnbHF4YUhyZTJoVkVa
cFBNT3Z6cnpaeVM2WHllcStWSTRNVk9iRVVZSWtzSmJBZnZSRHMwbk5qRDRKdUpkT1EvRlF3dmVS
M0VudHZXL2FRSVA1b3Rxc2xlZ2VpM2c0ZGxuWWpZbVEyVjNUdmpnaHl1M1Q3K09kTzVkaFRrMGxl
YmxZcmxYRHZYc0x0Y0lkMjNtU1p3Y1B2Z1ZQUVk4MnBNdEZ1VVJndWRjaEtMKzN0eldWV3o1S2wz
VDhHQmV4ZXAxQnZJSzhEMWJhcXZMUXRXOEhCL1hKeFhnUkZVVlpWZlB5ZU9hQ1NJWnZub0lLUUhD
akdVUnhSTGFNY1ZOVkFwUkV0RVR5Yzl2bzMybEV0bm5DelhaL2Z3WTF0U0x0UURwUUpxeFhsUU5k
SURsVU82eCtvY3FhTlJ2TXVoOE4rQ3lzVEhMaC9sMTZzS2tqQ0FkdjAyQnNIN05QcjFEaDZzMTVj
VmtFWVZUcnlPdEdHdlE3VWlGMTdGTTdvblh0QU5hTzM3N2xnVHJPRkQySWJ1WStQUWh1M2w2OERN
bUpESDRXQWwzTVQxWEkycWIyMFV1RksycTdpNitjVVpFNUx3c0owTTcwRUFpN2JOUll0YVk0VU5B
TXp2QjY1OXFXcjBDTnhrYmV6R1JCMHEwWUkyWm5GWXRHMXEwWWR2M3FTUlpmdURaVFJtRVdqcmtK
SFk4NzZCQ0pCOU8zcWt4VDBValBSNjRwV1R2UU5laS9DekhNUm9aSnF2Qmp3Z0ZlMERVS2tTMW9S
RDU2ZkNCalg0a1dEaDdzaVRTQVdjakRYK0c4YVJJa2F0MHJiOWIvNzZlckR4ZDMxM2ZYSGRuRDhz
ZjMzeDE5dVgxOWNtaTBONXArTG03dnJOMWMzN2RXdjU3ZFhyOSthdVBuOXpldnIyM2ZkemQxaU9k
eE9ERlVMTnpoRDFSSzVWUzJ1eGt1M3BJbE90N2dONmlKRmpuc3h6RW5nY0FIa21GbVJVNEhObkJC
VmtGREJlc2VualFRMU4vb1FzYU9NRGpSdkNJR0xieEtJN2ROaUZMMmUzVDFQL0Y0N3NQSE9xSjdz
QUwxMnNzdGlNOWtkbW5hTW9NcnFGQUhNRlZieWpOTmRMWTZxZWswZ2I1NUdnRXNESmlycjUyQ3Bu
WXVoWUN5NnRwbkVuTUlDQWpBWlEyenRaQXp4ZGZPekpSYVNTMGVkTHFjUnN6RlNMbEVhVU8yUWlU
Q09WZTZRMUNzN0NLZmpHZDlpUHBZbVB5aUhYQ0Y0cUZLSjFFbG5aQW1VU3dXNkVmRjV4cVVsVXVN
TkFKMmR3WlZ3SisrYUZTbDR0TFRTM3BkRWFwek1TbnR5ZnRnVWJLZGU4RDZTSStPY1JPK3RZVXlx
NjhtYWZZVFBaK3IrNEV1S2RhQWNXaHhTZ1FhV0tKNDBBSk5BdVZTZzE4b2RzTk8rUk1YYmgzbVha
YW1BNFZ2cWdQSkF5RHVTUlBHYmpTVTROemZyRjFrVVZLa3U3M1RKMjZ1THk3dnJmMTV4MGF4V1di
dXF4WVRsTktSMG9sbXJGRjNQeVhyZHNhQ2NSM0hJdnJBMjNPc2kxbzZvSGwvN01vM1hyc3FBQmE3
S1E4WlU4RmpJYTEraStBMEhrR056RXlLM1ZDVEgrNVlKRS9nVldvVjNQTm1SVUQyK1Z1RWRDVk54
SFd4d1JrTFNvTTRjZ3BtZVB6L3FVanQ0SDB4UUFmaE9qZ3hUNUZUUXNVU1dFdGlQemx4ZGVreVB3
V0xXbEhuVzQwY1NHMi9iSVA4Q0tKT0RMeHJRQzlwMklNS3owODM3bTdOdWhtSlhiMDA3OWM1SE42
SHRmc1hSZE5WRjAxV1Fsb29QeUxlQXhETmw1TnNGV1pjS2ZkcjN0dFc1V1hkcHdDaUpmUnBrU2xq
QldIUnRNNWxOYURzQlNHZ2h0ak9MeHVMRE9XNjdKeEZmT3VwME9ZMUphS0Z5aWRMY3RRSzZHUkFo
SkhLTDAvRU03M3lxRjRZYmhFTGRFMGRoL0lDVTlQTVA0aEFyV2p0eEZKNFRPL1hUcllaSXc1SXBU
cFVGOUlKeUV4cG9BTjR3c3RwSlBYN200TFcvb28wUXEvQkUwWkk2NUkvRlZ2ZVNyYnhqeEFHUW5H
Y1YwQ0s4cFdUTjQycjhETUlyZmpWeG9XWUg1NzVtUE5RZktTbEsvYmtTOFduRnBWa2MrWkY3SkhI
M25qeSsrT255bitZWjhNMkZmYUhYamZucncrVXQrL2pDalJmcDNrRHNOVmh1M1lQVTQrYzJ4NEp5
ZzFqb09PaFZNOEJ4aUx4ekhGeVBuK2N3aldjMEhuZTdNazhVUjFsMEF5STJoMkNtVThWOFBCbzNZ
S1ViRUFuNFRvNE1VK1JVMExGRWxoTFlqNC9ISFhwdW9FSEVyQ25MdE1lUEpEYmV0a0grQlZDeVl4
TDdMSW1NU3N5ekpGMWwreHBQSnZRZUVNS0FrTkFuMk81d2dKWWFBWW9JMHppSWxJc1ZTUk0zZHBj
R2hYNkRnVFo0WVJCQ3dWaDBzRlVDQXdUYjhLNDJzb2IzTWZFM255NUVMSmt4VVRaSlRWelVUZ0lq
eDBuZFE0b2tRdGIzaTFDTjBXbkQyUFpTWEEzbGtCMkVDNVhvMERoVlBOZUx4dVhRNjFDTzIwcHN4
bXNldHQrSGVzZ1RvcVRVRzVUMTY1elpKMFNYNEpuUWorOWYvWXRHTEpJeTVmZ3d4Q2FFQy9hbnM2
bnhTd29EKzZXVWJrQTUxQ2tFRHkzcGtEcFZXTnVMeHVVd3hDK2d2aVVPM2w0cWRaWitLbEtwdnV3
UHVZN0U3WnNORXdjZi9wRGVOdlRoejlFQk5IMis0T2VWRUlicFdSUUc3bG53VitvQXBqYmNzeUxX
Y3FnZVg0dnlqV01xZkFmalN2SDJZZFF1Y2Z1R2d3VHZNd09EWlpwUWp2Y2wzbWRjR01TWHdLOUR6
Q2I1REtySDF3NlNnL05nRHliRnZUa1dUU0U5RE1BcUdyUlBOTzhrVjNLT2FPWElGRVZPQlIwdlpC
dktkM3pTNk9pVk1RTVd5MWFUWEVhaTRXMFVCSW9EUCtnaERwbGxoanpFU2UwWkdTNlRIQkR3eGtH
bXpGQldYZllESk0rWXVkWGlMS2xQQXVidGR2ZnUwb0JSa2tTQlNlMHVTaWdZaTY1dEpqRnZDQVlD
a0ZkQ2JHY1dqY1hIcEpwOFp1d29lRHdGVjdsRWFVTEtQaWhmQXpnZHozaitsR2RZRkFtNVF2QlFw
Uktwa3diRUVpaVhDblFqNHZPTVMwdWt4aHNBT2p1RHkvcjhrSnd6VSsxRnBUNmwyWHhVNC9yTnpZ
V3prbjc1eTkzWis5ZXYreExPSWFrRnltdUFHVkd1OEZ6bUhaZTZRVG0wTXFRQ2pTcFI5QTR3aDRC
eXFVQlBsVHRkcDMySmlyZmY4bTdLVWtrT2Q3cEJDYlhnWUNlbE1uVDg0SlBSUEZRRjZ0TVp0QnZx
ayt3aGZJUWxaYU5IQitGQUt5Z1pPb1d2SHAvUXdWK2hnV0Z0dU50RnJDRkpQWDRHWmhwUFlrTEY5
VlVlOHNBMFc3REtTYWdjUDRJY20xQVJ1YVVpT2Q1ZmxPVkJxL0NPSnpzU3FjZlBLcndqcldnanhN
RUc1eVlvSTRMbUVNejAvSmtTbCtiSmFhcVZJOE1VT1JWMExKR2xCUGJqczFpSEh0TmpzSmcxWlI3
MytKSEV4dHMyeUw4QVNod2tIc3BpeWZUMFExUlBUL0RGaUtaZSsyby9JREJCY2RwOGdoZWtUVURp
bWZueDdZS3ZtTVQyZFNRNnhRS1g1dU1xU3FMZnFsR1l6WVZJTVBiRE5XMHp1VUVIQkYxZWlyQ2RX
VFFXSDA1VnF6WXZSWmVPT2wxT1kvSlNxRnlpTkRmbHA2L2lRd2lSSE9CMFBNTTdMZXFGNFg1d0Jl
cWVPQXJqQjZTa24zOFFoMWpSMm9tajhKell5WnkrQ3c1cFdETEZxUUw3WGxEdUYxYWdBWGpEeUdv
bjlmaVpnOWYraWpaQ3JNSVRSVHZnSUg4b0JycVhiT1VkOVEyQVJEY1hJb3Z3bHBJMWo2dnhNd2l2
K05YRWhacjNwaFQweFhiWUlGQU9OSS9xOGJYSXNhRGNyNjFBbThDUDBFQ2JFSGxuRTF5UG4xR1l4
bk5DaGJNS1N4U0hKUFNsY3RnY2dwbE9GU0R4YU56b2pyNlVqb0R2dml1RERGUGtWTkI5S0FaWlNt
QS9QbmlsOUpnNW5JaFpVOUlYQkVxb1QrQmZyQjloOE5heDZLdS9reXczU2p2KzFkOUpucGd2UFI5
NjVYMlMrN1JUNEhaZWI1Ykx6ZGZ1ZmV5WHI4eE9ILzBsRnYxZXd2djZoZWptelhHL2ZmZnUzYTlt
ei9MTnhuemxKSS9Oam1ZMU5pYS9mZDk5VDJTeDYyRlMrREFwTVpNdkN1ZDh2ZjlmZzdUYmVYMngz
aTgrYmU3TnB5UnU1OVBaZnZHSC9kakdkUFZsYVM2K0x1ekhrVC9aenhyUGQzdjhnbnFSVCtuRHA4
Sjh3QWM5dHZNZGVKbVkvYVlFMmx0dVVCdVdVMk9qcDlseWJqOGxjakZiR0NZWGlyYit5TWlCRDU0
a2xRZW5OTVNjd0R2amZ2dnU1dUxpVHI5SzMzNDBvZmxTeTN5dnZ3R3l0bDlsWVQ1dzBsaTZ2ZW8r
YVdSZnFJbnNXMnRKWXBlR1B1d2l6RzdSdm1aeDNmTmRqRFR5YVRBV0I0bG1JekFZTVpuSHQ4UFNE
ZjBkRmJ0M0ZRbzgwdEQ2TlVDdzFWYUFrdVNrQ2lxOVlOTG1lOTJsd2FJa2VrMGdONXVDa1dBc090
Z3FnUUdTWkhqWG1VVmo3MlB5WmluTngrb2R6d0NsK0daaHdjWHVMRDhNekhJTVRPb1ZYcm1tZFFQ
U0dQRUcrR3V2ZVJ3bklDWDluTU54U2g3WG9ieCtZQkpqRkN6WTRSUkpwVlUvYVpxb0gvNDZoTDZr
ZEZLUG56RWtuK0RCSGtyMTJYeVQ1bzlHOVlLaFRwRlZXb3ZnbG9sQndJOURxRXQ2eDlYNG1VUHlF
UmJxa0tOM2FaSUhhVmJwTUw0N2VzZWVuZnRGYjBHL3U4RGJaWnU3cnJyZEE5ZnZ6SytIajlpTnlU
K01GNUJxdkp5RDFOVTVCMjZhZWdmNDFUVkZVeHUwQlpGMzdvSHI4Zk1QdnZFVmJZUjBWM0hONFVB
S2E0M0IyK2dVcVdCbmpCWUx0WUtUeDhycHVKVWpzeFE1RlhRY2taMTQ3dU8vOCtwb21qRU1Gc3Qy
bEp4SUl1TnRHZ1NLQTMvb2RCMGRlT0RwT3JRMXNxNVpGWW9TTnJZK0hLaWtJWGpGZmozbVFja3p4
cSsxT0l1Q1ZLK05ORnNqd2FVQm95U2hBcE9aclpGSU1CWmQyMHdhR1hTZEFFVFhFTnVaUldQeE1R
RTNteCs0Q2g1UHdWVXVVWnFRdU1oQmt0MkloM0E2bnZHdFExV3BGT1FLd1VPVlNxUk9HdUZKb0Z3
cTBJMkl6ek11TFpFYWJ3RG83QXd1Ni9NRHRrYW1hb0NxaWtydncyNk80dzBNaFhwQ0lIYnI1TUNB
TW1UTkRIYTJQWi81aHdmNFVpbm9CWkFLTkxwRThhVEJzUVRLcFFJOVdlNlVuZllsS3Q1K3pic3hT
d1VNNlZLbjdNc2dPVWVTS0g2ejhVWFlPcWxmYkozcHowVFFiaHBsQS9aTkhoMmxRNVdBSFhxbmNk
UmpRRGtQT1pGMVlXMjR6MFdzRlVrOWZ0WmxHcThkbFFFTEhKV0hqS25RMUpyVHZrVHhHdzRmeDJa
Y1VBNnBTSTczRjZXQjBDcTg0OG1PUk9yeHN3cnZTQ3ZhQ0hHd3dha0tUSkNRT1FRelBYL2l4R1Y5
Y3U1cTVjZ3dSVTRGSFV0a0tZSDkrS1RXb2NmMEdDeG1UVm5FUFg0a3NmRzJEZkl2Z0JKSGtBZjJU
ZEs1NlFjN09WMy9jcjU2Nnp3NjBtMmdqKytnOUhaUWJOM2lCOW1YbGZna2tPWWpFclpkODIwS2tJ
UGxjZjNpenp4cU1yWHUwb0JSRXEyWDFMeHVFZ25Hb29PdEVoZ2d2WVYzblZrMDlqNG00NVVTZEtM
ZzhSUlFkbTdXQkZ6d3pzckJ3QXpSNG5ROHd5KzdNcDVBWVdDSEdCSitRcTRRUEZTcFJPcFVrWFF2
S0pkS3I3TTVMaTJSR204QTJINGY2aUhwYlZZRnFacEtxK1NaMDFzYTFBM0lDYTJaU2ZaeFd2TWJU
NmFnc0NkTE9TR1VRL1ZES3REb0VrWHYrSFFJS0pmS0VFK0MycGVvZVB1MTFMMzZxVWlsQm1icXJJ
T2RsTXJROFVWSWIrTWdWN0ZUbVR2ZFZDVkY1WkFFZDBUUWJwVkNVaWwvVjRXZzdPZW9DQ2pjNitD
djFDdE1iYmpYUmF3ZFNUMSs5dVViWDlGR21GN0hsUnFZcTdOV09RbVY0d2NRYWRsaFlOUnVxVWlP
ZDVLczBEb1lBVVVjRFB3NnhKYVNJNUY2L0t3aWVUMFA5bUN1ZmlEMTY4d2htT2trU1JUOC9CeG5C
eWNEbEJOWkswZUdLWElxNkZnaVN3bnN4eWU0anJJWjIyQ3hiRXJKanlRMjNyWkJvRGp3Z3hKY01q
djlBS2FudDV2UGZMSUxFN0tLUnRKVkYwa25pbHlvbDNodHJnVWtQdWxpcmh3d2h1MDJBcGh4Wlhr
QlQ3NkJ5eGFNbGxnd3BzUTRkTWFuUXR3cWdkRWxzK2l1TTR2RzNvZnoyK2JiZWVUU1VhZkxhVXd5
QzQwYWN1Q0pwZG5ReUg0N3lzb1RyR2wvUHlDR2QyRmdod0MvOWx2SThRTlMwczgvSEwva2NmV0V5
SlVRV050dklGbDV3bkx3MXp5dmFCY1VOZ0Q0ZFpBQ0pMV1RldnpNSVhrRkQ3WW5CNnU2dUtQZXRR
ZU5Bc1VKUzhUZkpyenVIVWpZSk4yUGc4aExtc2ZWK0JsRThoSVdhaytpVVFuek5QMmVFOUk4cXNm
WEloU1V0UWdCUlV6Uy9jcndyMnREQ2lEeWpncXV4ODhvZk9NcjJralB5VWRrbFlKTWJDZzhTbGdP
SnpBSHEzYUFodGdCZzF4eG9Xc0wzc3F4WVlxY0NpeExiQ21CL2ZpUWxpcWJzdzBXeTZhVS9FaGlN
dzYxNVBRY2VPY2tVSjZaNWtlY0JDcGlsY3lrQjg4S3BvVlBJeVZvNU1OeVB0MlpNMVhyelg3KzBx
eStOcWV4ekNHc3I0djlZL3ZuYkxHZFBTM1Z6L1owNFhTOVg1ejFIOGdxZlFCWEFQQzBPZlczbUJ0
ays4ZHBkMmJNSGcvVDU4MW0rK21uSlRvdlJrN1YyU05tOW5UYWZRK0Z5b05DRmdJSzlqRGZ6Y1dk
V1JYZlBXNmVsdVlNbnoyak9OdXNkNHY3K2RhZVU3VG42UURWRWVmanN0Q0hTNlM1Sk9ZYmN2QjRY
T001MEtWbW0rMTJycHpGbnJwOG5OdmZIaGJyZStWRWpJdlZod0pGOEpFUCtCaUJwNmRMWjh2RmVq
R2Jtc09pajR2ZGZyTzFaeS9YOS9Zdkk5c29xRnZqUll2cDUvVm10MS9NZWc3SFpyRVArZ1NoTndv
MFRyUll6NVpQOTdCZkdwanpQNVFiTVdkTmw4cGhMUHcvZHc5UDYwTW5IYlBFQjMrSzhCTlBhWHdk
dWtEenc1TnlJWHN1OUc0N24rNVgzZldiSjFWSVdjMk9CNzFIZWJQVUIzMkcwSGNJVjlQMTlQTWNn
TnFBMDYwN2NyNjFPM0w5ZDlOVjUrcW56ZEpZTVVxVDVDeFNvOFhmZW5oa1BqeHl4T1A5Yks5QzJl
aTM3NEhWZjM3eC8vOXNMazhLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ28wTUNBd0lHOWlhZ284UEM5
TVpXNW5kR2dnTXpFNU55OUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVStQbk4wY21WaGJRcDRuTFZi
VzNQYnRoSis5Ni9nekhsSlptb1lWeEwwbTJMTGpscGZFa2xKNXB5bUQ0eE0yNXJxNGtpeU8vbjNC
VWdDWElBZ0xacytiZE9RUzJEMzJ3c1dpNHRJaE5XL2gwVDlMMGxwTkZzZS9Ed2dCWTFFUk9yL0Ns
SWlrWlJwMlpZUkpOVGZqQ0VpTU1aRnA2UFJra1NuNjRQUEJ4K21CMGRuSXVMUjlMWmlwSmdUeGlQ
T0VTVnhORjFHZjc2TDNrZC9SZFBmVlV2MWpicE40eFF4UmpGV2p4alJ1TkVqaVFoeGVuQ0pFUllT
RXg2bGlLUmwrM0grc043czNrZTY0N3ZKTHRzOWJvK3J0N1A1S2x0WWRqNVVrUWlGQVFsR254VXNz
SUthMEZUR0VVMlVaS3hCRjUwbWw2UHB4OThxZWIrUExpNHFKc09wc2lXT3VFQ3g1TnAweStnUUl4
WnJDcU5jOTE5RUZDY0lhMTZpZzF6MTErUVl4YndreHdoejljZ1V1ZVFLQ1BmUnQ0UFZnYklvVGlS
bjZqdFB1RkNxSUJMekJNZlIrUHpnejcrVVhqZUtsTkJDbFg4T0xEZ0x0d1hGUkhuKzUwSHdvOU5I
SkVoaXE1QkZyc2ljODNadFhnWCtaV2dhR3RRZmw0b3piRm9ZSlFUWjBsNkZGenNpTzJHNlRROE5J
TnVxR1ZUWWNWY2pPbHlWWGdhL2dGN0w4cTAxTVVraFVjTlRPQU9JSWNvandWQXFjWnBXQS9kVHRw
dm5Lek55UjZ2YjlXYXBTT3NWSEVJS21POVRSMXVPUmVqZDZzOHhSekZMVThrZEsyaWJzN2h3eDF0
RW53UFJoMUE2MHFXV3JhRHhBRkRyblJid3IwTDVuUHdhcFJlYjNraTJkZ3VoN0Rjc1hHRnRFUDFX
cnZsYlhSdEMvaWJ1OWszVU1RcW9udWRVTTYyWE94WW1EL2xzdnN4WDNZTkJXMXAxU2VQVWN5VWsy
NkVna2hneG9md2lmTEpqTHpVTmhoS3hNcjd0M1QvMmdyaGRnTjU0Y1dINmpVTktRaWZvM3U2N2FL
VHVGc1ZmcENGSjAwUnJXS0cxaWRHWFgrdmtCcmkxaTVzS0JOQ3BBYlpmK0FabHRnRnVhUnowWjJ2
SWhOVDV2Nld3bHBISHNVU1U2ZUhtRGJ5VHhmTnpVR082YmhZM21yWGlMVFYrV0RvQXd0dFVDbnNt
Uk1LSnNqUk5VK1lpMUhRc20vVGVRSjhGVVdNRjVMcWR4SXJBYlVIamtMREx5VFlJS2VMUWUxVENR
WkNlTXRodEZVRGVyTmRDOWFVZk5UMTBhSVFNZGdGVlhrQ0NSckZRN1lzaFFWS3BwaWFraHFqdXM4
a0xpV1pwV0xmbGV2bFhqUzl2ZlZTSXJwZGtIWXNpTzBJSmJoYUlxVnBia1VUbGxaTE42ZlVIczVJ
ajlJaktJNUlLV2JHeUhWUFZrMG1WWGZ6ZWcvT2g2VzE3NlVWZ1NEQlI2enRKR01hODdIdWVyMjd5
emJFdlM2amxKOGZsZ3RYdGNGbEthb1BtTjI4MExWRlFxbGVqYWtvSkZzaW5YWGk4cnBQQjJWQlpv
L3duaEswVXlBU2lRc0dxVFBZeHp4YTcrNzNrZVQybGlCT0NjUnBqS2ptUEV5RFNsdkZkcFIyc0lj
RndnRVhiVzJlby9RcGcvZTRNZllEVUdhY3RHcng2b3VzRVVXTjFNcEFoMk9IZXlLNkJ1Y0ZhdUUy
ZC9pbTFrZlZiRkFyT0RtM0xqM0NZdkEzWVoyZXlhdS9MeXlXZ3ZvOVRsREJlYnhOVjlYMWpTTkdZ
VjRXSjErUGJSeVp3S3NpMDBhTVdJaW5pb2lpR3lscG12VmprczExKzB5SEY2NExGRWNGSEZKT2tr
U0FJTndXbjErZkk1R1Iyek9McStkTnBGODVVSUpKd20vM0crU3lmUDNYQzlIcG9tT1E1bUY0ZkF4
UExZMHoyZ2tsVUdNbVUyU1JhN2l4MjR2Uzc3QVhVNzJRTlNvNnBiQ0QxVjM1ZFZUdGNKWUR4QVN2
dy9ybnBCZXNIZjhIVHZsb3paQ2RiNmU3TzBBUDZPUU85UmU5WEwrVjh6UUkxbElkdDJhb0VNRmdY
SFV3d0F2SUo2ZGcveVlXRk41Um9URGpoWG51c1k4UFIrQmFLN0RGVmhyTjF2U2IwVXErekp2eVBL
U0pWY2N6VkhNUDhnVjJ6OGZMa0g0TnZ3OG1KcllQUEIrUC93anJZT1gxSlZHbWxDbGRUWURld3Ft
WUVLWDFLZkJlajRkWFVuSGdNeDE5SEo4T0pnU2xqdFJaU3BiQmtTYU5XcGt6bExRRlpUVDROVDBh
WHd5dlQyNTkxZEtVdU5aSjJ0Mnp1SUV3cWtKUzFLVDgvNXR1ZHNVRHhVajJmenJPNzFYcTdtOCsy
NXZQdVBxK2VzdTEyUFp0bkt2VldoTVg2Ym0yK3JRd3hXeXphMnJkSXFpakxiUE8zZWM0MmVVUDhi
cFBkNUxEUityYWJMMnIxSzRtTFF6TzFyS01wSjdTSVhNRlQ5VGVWbEFtbXJhY2JKNGlxUWtPWlZD
Ky9idlV4bkNZUVhhUXZ5NDlVc1NqV2orQ3ArRjQ4RlYwWGdJMFpUaVN5bzRacXVsNGZPbndySG5h
WXFHVkw0ZS9JY1N1aGFvU2s3dUpGYWR1cGwyYXZlcXFoWHl6TnVhc2dVV3RLb2VuRTRvR2tTa21v
T29RTEZZWGRudEVkV3JVQkFCaUJsVVlnMEFpY0k2WlRWZW9ZWTdTNlZTWFhmUDI0dFdHeHpiTnR2
dDNUU0JxRnJselZRQXBFQVVtb1NtMVk3Nk5aMklCVUdRYndDSkVxNVNESldBN3dlc1p5RFlZdWtu
MmlDTEFJaFZQb2hMaVdFRG9ocnZNYVo0aG9WeWJCZHMvNXdJd0lTaTBiNElYV2dKQVNxWVNvMHox
aktFMHFkYVoxaHJqS2x2bWVFS0JvVXU1SXlMMUEwSmlwdVM3Um13d1F4VGpmUGk1MmV3cG5USW5V
ODZrWkhKVEVTTDFpdko4aEdJdE5meGZEYmI3SlZ6T1RWc2ZaNm01ZmV3aWVhSmFwVEMwa3N6KzFE
eUxRSFNLNnlIN3NLeitXU0JrMWxiS1M3dzNOMWlBSEhhRmtaek1FUjdwQXdiamN4ZGFjNi9lRmVV
OWlERTl3QWNIVVNXM3dXemFTdTJTVzVaMm1paGdSV295NDRuVFh2cG05U2xIaktKcUwzcmlnUkJj
Qk9BTUhiYW85VmREcTBKakk2b1BkTjkrQ0RWVmVCcjFoVGh3QTdacDRDWk1MeE9hU0hkdjI5dm1l
RUtxOWwvcGpsMGQ4cDhOdWZXUEJqNzhncEFCZXFDUElaVkJIbHh4QzM5dmFMd05VS2dFKzdxRjRp
NjBoazc0dWFJbUNJTTZBRWxEeE1nY1RmV1lIOUhhb0lSVjYrK0ZGY0txMXZQMjJoOUl0NWdZOCtq
cWhKU3BDS0YwTmlnblBVYnFlalJ3bk9HUlBCY09rbnc0dkExUXBVWDlzNmwyd2dvcERNdlFEWU5M
WEVVSEpqaElCVDRRMExIZVJIQmVBeXdja2lMNi9DL1pEQXE1YnVLM3NXYjREdTk3QWc3NUlZdSs5
M28rRHZna3IvU0x0bkJzWG5sb0JiempVVnRlMUJFMkxHbjI5NFFBS3dNYXFiaXc0M2gyVXBRdERp
VjZweWdJUVZTc2lxbmVlUVNXYUJpcFJsVVRVVWxCZ0pDV3oxeDI4T2xSTEx0STltT25MOTRWNTU5
SVdUTlZManpxdlRWWmRNcWxGaHpsakxKdHBnZzIvNm9nZGtqRHNVaUZOVXhUTFNnWHovQ3JVdGJ3
R0ppdlIzZ1dBclFKQTY3clZhSTNkTjJoalI0MVhWS2ZRMk5qRjRkYjZwcEUzOFJ0UUxwbExMeTU2
bFhuUGlHNlVlWTZCUGJxemVnb1NyTDlnVUFBdXZlS2tFYmxoMkMyMXRqR0VOKzhiUTdoa0xzTnVl
WXR5N3hrZ2pYTFBVZG1qaDFZNFhYUnJvb0JQQU90ZWJtb0xwckJLTFVXNk1aSmJqaGtiT1ZRdXcr
NTdpNnF3RzRaZjF6cnF1dVRRR3FtTGJxMFQ4RXJOdVplZjJrSXNxRStnQkhiczQ4NjcxazhPbWRm
Z0RZUFhPK3BsUUJwVm82dXhTL2VXVVlXTUxybzFFYUJiWDlXc2V6a3JMTElCM2ZkV3lCcDFPV1Rk
QkNvdzQ2YW01OTZpSUd0RDROYVJvQldzZzJ1NDlmR3A0NVlrOXZ4UjYyWDkwVlQxMVlXeHIxQ2dB
UEFnTGR1eHQ0VmdpMzhEY1JYUXRxL0x1cUI3b1dhTzQ1ZytZWTNWWjJuUFdZblpPNjUvR29kaSsv
dVUrMS9iK1d5ZW1VdjVKK3ZsTWwvdHRzZnd0Qzk4bTFFZjF6TEVVbTd2ZUF6dHNlWFZlcGRiSHZx
bzE0VkE5R0ViUjRJbGVrRlFYc3M3K1dxMjBLOEc5akQxeStCcU9wb09wcU92dzRway9veUhnNHZx
Y1RxNk5GOC9uWXdiOS9sRWlvUytqMEFhTW9kWE5jTzI0eG1GbEVsRWNHeDcxWTFUVHkyUmxJZHRV
djlDVURtQzZ3czM1WUZKZmV5N3loYS9kdk5aWnM1MUgvSk5jU0c3UGtPWTNXZWJiTGJMTjNONG9H
dlBaM2YzODIxRHlWb3lkeVZuMjIzMnErcDVuejBaR1Q5eSt6dU1tMXlKV3M1WDltRDVoMm5mZmhM
Y1BKNENDRVNiN3N2MXpmeFdxYTd2bm0rYm1GYnJYUlBkYkpGbkd3dHR2VEZtZkhqWXJKOGN5SzE0
WWhkUGZRWitkanBBSm9ZS281cURkbUN4YlJQU1U3YVkzNENEK0lmSHpmWXhzNWNwZHVZVTN3cHFS
WmE0eUU0dVJvT3E3eWEvZTF3NGhxcnZCRmlrajF1TDRkWmFacmFZcjJCNFBXNGUxdHZjT08yWlVK
ZXZDSFhwdTl2aTI5WGg4NDgxWkJYdkZ2bmpkcjY2YTF4UE9MbitNSmg4ZnpmKy9uNndmRmpNUDIz
eWg2TU9RNmFlSVczdmFmYnpNbHNWajNXRzBjZVh2ejFSaEZHWE1TaCt1VEVvZG9HY1diY3MxL1lT
eGh6K0FxTU02NVUxZ0dNOGt3ZnR4WkRkdW5sZnVSWk9YT0gzdTkzRDhkRlJmdk5ZRGpuMFU0L25H
ekNRWit2bDBXMzI4K2hzOEpuU0o5TEJtcnFzdjBNM3E0RDcydy9OSDNudFZUMVM1emVCVUFXR3lC
WWQ3cVZlTnJVYU5hTGMyblB4QzMxL0R4eldtTHNvRjJhWjFQeGhkS094cmpWU29jK0t5MWx6T0Q2
N0hsK09yczRyZ1pQUmRBaW51OWo3YVk1aUVSZVh5YlU2ZHU3eER2Z3BJcW9vOEJ0Ky9qS2NtSHRR
cDZQQitkWDFaRG82bVJ4K3E4a2ZSeGNYRXhNcmt0dWJvR2VEaTRzUDQrdnJQNnIzd2RmaDFaZWhh
ZGpHNE1Ua29KUXd6QThacGVZQzdFWDJZNzNKZHV1TlNZK244MDArVSsvbVp0WHdhanhTZU0wd0c0
N0hnLzhOSnI5ZG5scmVLc09aeGxpYzRwaXJVaWlCdGNhL0ZRMUFvQXBsYm1SemRISmxZVzBLWlc1
a2IySnFDalF4SURBZ2IySnFDanc4TDB4bGJtZDBhQ0F4T1RrMEwwWnBiSFJsY2k5R2JHRjBaVVJs
WTI5a1pUNCtjM1J5WldGdENuaWN0VmxiYzV2SUVuN1hyNkRxdkNSVmF6eFhHSHllRkFrN2JHVEpr
YlNiT3J2WkJ5SmptenE2T0VpT2EvLzk5Z2htbUJsQWNpeXY0M0tnNmN2WFBkTTkzWUE5QlAvT01Q
d0pJK0l0VnIzdlBieW5ZUThMK2JzbmhjSVhJaXA1S2ZZNS9FK3BqemxDYUM5MG5xeXdOOXowUHZj
K3pIdm5sOXhqM3Z5dVVnVEtNV1VlWXo3QmdUZGZlWCsrODk1N2YzbnpYNEVUbmhHYk5ZaDhTZ2xD
Y0lsOEVqUWtRZzlqUzRJSjVDTXVFR1plNU9PbzVKOW1qNXRpOTk2VGd1OW11M1QzdEwybzdpN3pk
YnJVNmx5b1BPU0F3ZWVVSERYTUVVQU5TU1FDajRSZ0dVblFlNkhaZFRMLytFdGw3OWRrTktxVXhI
T0lKZklZOXdQQlpPaFczaG55YVNBcGxEQXB2L1FJQ24wa2RmRUQ1RXBla2dNL1lDVTU4QkdEU3dy
a1VxdEJlUEMrOU5ZOWlDZ0tCYVB3bklXTWd5cytEbGlJQW05NjFmdnpML0RyRmtnaDJidnkzTlBn
Tk53T0ZETlkrZSs5MW9lV0RBOTlnYlJER2ptUUdXUGQzcndLL00raGFYaFFQMXlCWnBOMUg1UTJ5
SnIyS3J6SU1ua1FwczE2cGdCcHJ1YW1RdFp5TlhhSDdkTFB3ZDlEcjIyNTBacXBvaEJDZW5Jcmdh
aFBtTWVwSHdrVVJWWGkzcVM3UEZ1cnpFM1dkNXRpQmFUTjJrd2hBT2F1cWVVdFE3enRYdnZQRVBN
REdrV0NXVkdRTWFmQmZqbmVZdmRaRUYwSTVVTGExSkxMREo0QlZLOU9CL2hYb1R4bXYwYnA3RTBu
azNYYzJsQ2VsaGEyc1M2SUxwY2QvczZsYlVQK0pzdnRodWhBRmhCNXpnR2I5TXZPaGRsanRzaFgy
ZnB3TXNoSWcwZ1VSTTVTbW1TZENqd01mTXBoWGJoTHR1SUZ4MkJiSVliZ2ErblQ5MTRyYmh1Z2t5
ODJUSmU1elVsekVhUzBmYzhicGJ2RDhaL3lFRWRSS0QyczBPckM2TnF2ZmJJM3VJNkxYUXE0NFZN
RDdHbmJ0OVZtRitBTzV0YjE3Tnd5YmU3OGF5V3NJL01ZRWo2aE10MmN4QnNzajU5QmplTzYyZHhJ
MWFCYlNQeG02MkFRM3FaVGVHRkJ4QXhEcEVrVVVSdWhwQ1BScEo4TTlDaUlHcXRCcnZrRUFnTFRE
WTFGUXJZbXpkRG1pRVUvb1JOdUJlazRnMnl1RnVUTmZxMnR2M1IzelFrK05MWU1zZ0ZWcStCejRn
VWMrUGNwZ1NNQlI1TVBLU3BsaW14dlVZMkdOUytUNDErVlg4NTh0RGRkajJRSGhpS2RvUmcxRzhR
SVppc2NRbDBwMVF3bkg5UWtoOGs1RWVjNDRxSlNwUVVqa0tRQ3Fvc3IzYitLbGJTV2trTmdtMkVN
ODUzQUZDRld5bDVsNjl1c3VIQnRjUmcvR1NvSFZsdmd1clRVQmMxbGI3Q1dLQWlSMHlnY0thME44
dkFRSGtkMDFyK01JUnJsVHh1MjBpRGxQdUVBcXdyWnh5eGQ3aDVlWk0rUkZEd0lNVUpSZ0loZ0xB
Z05rN3FOUDlUYW1UMmtrUTVtMC9iV0ZlcGxEYkM4dDFMZlFHcmxhWWNIcno3b0RvS29zVm9WU0JG
MHVqZXFhOHZab0NQYzVjN3BKYlZSOVRzY2FqMGR1c2FQOW0zeU5tQ1BubVRWdXkrbmxoajlmUkQ1
SVdYMWE2S3F2MitrRkFsWTFaZzRFbDgrVW80aWp1Y05pZHFJSUQ3aisyYW83R1UyeTJXMjJHVzNC
Nnc0SW9pZlkzUk9FQTRiQlFJejFYQTZNdWVxSnRNTEdsVFhOOE5ET0NQdTQ1RHA2amZORmxuKzR5
Qk1SMExDeE1kZ09qSUtKaElYQ0w4SUpvWnRKQ0txaTJqNVp2RWdUbGZrUlVCZElSMVFmRUZFQTZr
NytSM3EyczBwd2NnUHN3TS92VGI5eFB6Z0RqemQwNW9pVzlWS2lsdXBaL2huSlhxSDM2OGU1VnpQ
V25vb0I5dXEwd2tqWUlmb3hnSERUVDF0UHA1ZTVOcU5ONXhvSERqdFVpK1lZOXQzNDFzNDhvS2pz
cjFhMXpPaFUzcXRtZkEvcW9tRTVwakJHVVBkeEs3Vk9IWHlVLzlMUEJ2b1B2aXFQLzJmMlFkYlgx
OUNhSzJnY1ZVTmRnTXJzR0VmL0NueGpaSjRQRmRmUE9McDc4a2duaW1ZSW9CWkNGcGhRY05HcjB3
bzFDMXVxcHJkeElQa09oNHJhZmZVa1oyNmtFaTZsNlc0TjJFUzdndFJoL0x6VTdiZHFRanNiNnJy
WVo3ZXJ6ZmJYYjdZcXNlN2g2eTZTcmZielNKUG9mUldoT1htZnFPZXJSVXhYUzY3K0Rzc1ZaUlZX
dnhmWGFkRjFqQy9LOUxiekdUYTNCM1c2M2V1S3c2SVh0U291YWl5YldsOEo4TXVINXhRQXVhcjBH
ZlZ6cHJYS01icEttc3NNd3h6MVdoWHl5VHEzZUkwWGQ4cmtSS251WUpFYmgwaTVKdWJXbmJ5cE14
TjdscTFHQXFvWUpDTlZINHFxeFZNczd1c3lOYUxyRVc2bmk2NHpCOHVxMk10T1VxLzZjaEVIbldU
QXVaU0pOd0l0Z1NhNkFheGZmNnFRdXl3cWV6UUU1RUsrbVNlWENhRC9qeVpqQTk0NFdpTEc3eklv
eS9ENWJCZEo3TlpNcjdTRldBd0dROE5qSjJBamxsREhqdkNRVUdYSFBTd3krbTh3RjZtMzdLbHpy
Y252VjN6OVdMNWRLc1Q3VmxsdFh6djFzaTJSM1ArN2NMQmJSekowRmRiZGIzOFcybGNLNHRQNi96
N2s3ckpiMEY3ZnBkblJVVjRUaFdHeHlMYjFtZkFScm1sYTBRWG1zQkdzMDFYajh2czY3dnQxL2NL
MXJ3dU01REYrZnErdXZ0NzgxUmRGZGwzV1daME1Ydk9kYUg3ZHNSOGFKdC9MRGFMYkx2TmJ2OWJ5
VDlzbnJNZldhRXE3djJtdGc4cjhKd1d5aWFnVHJlWkRzYm1SMzU3eExTd1RkZExXMGRaMTl5dDRX
bGVhRWUvcWZXcVMvRitwTGxYZDJwbmRHR0liQXo5VlZia2kxUXQzazI2ZTlqQVNaSnZkd3JBMTNl
RC9zMStiZW92LzgyRE40SWM1TlVybVhoNk9abGVHOG1Yek9NTExRNXpuL1BpR2VTSmdPT1c2VmNs
elRKQWlJODViVEIrL2kyZXFWTittUFN2eHBQWlBCbk16cjdVNUkvSmFEU3JydUhVVldQT1pYODAr
akNkVEQ1VjkvM2Y0L0Z2Y1hYVElUN29WeGNScG9pZFVVTFViSGNkRDZIV2pUU1NhVHlZVDZhcVk0
akgwK1N6Vmo2UHA5UCtILzNaTDllcUlFR3pvalNQSjBvSThTRUtHQkVrTkUvT2Z3Q09va0NRQ21W
dVpITjBjbVZoYlFwbGJtUnZZbW9LTkRJZ01DQnZZbW9LUER3dlZIbHdaUzlZVDJKcVpXTjBMME52
Ykc5eVUzQmhZMlZiTDBsRFEwSmhjMlZrSURVd0lEQWdVbDB2VTNWaWRIbHdaUzlKYldGblpTOU9Z
VzFsTDBsdE1TOUNhWFJ6VUdWeVEyOXRjRzl1Wlc1MElEZ3ZWMmxrZEdnZ01qZ3pMMHhsYm1kMGFD
QXpOREU0TDBobGFXZG9kQ0F4TVRNdlJtbHNkR1Z5TDBac1lYUmxSR1ZqYjJSbFBqNXpkSEpsWVcw
S2VKenRuYit1NjdnUnh0OG4xU2FBa2NjdzB1MUQzR0xiYlZPa3VFaVZLbm1CVkVHYUFGdTdTSmNx
VmZxOGlGZTRnelBnblgrY29VaEo5dmsrRUlhUGowUlJNbithNFhBb1A1OFFCRUVRQkVFUUJFRVFC
RUVRQkVFUUJFRVFCRUVRQkVFUUJFRVFCRUVRQkVFUUJFRVFCRUVRQkVGSDZILy8vODgvLy8xWEtu
LzgrMDl0NGMrM3NtMTJka3NoNkhMYXVDQ0NObDd1Zi9yaDl2TnY4bVhiZml2RUd2aUNQcm5HSUlv
TFdiR3p6d3lDanRObVNyWnUvK1Z2di9PTXpvQ1I0c0pZd1daQmJ5OUNpYnM5dmRHdkhsYmszWFVI
VU94RFlwd0Z2YXRpbE13L0JVUkFBNEpJQWlWZFRLemdzMEdRMEVZRWo1VThmTVRuc0VjUVpHcERJ
N0JLdXNBa1FaQXBOa3hBQ1lKMmFuUFl0RHNIbENCb1FCdE5TWlEyRTRZWldBZ0tGTk8wRWNTdk1F
eW1Idi85WlN0Zi8vR0hILy84ZXlyYjllVDMyK2ZiZjg5dUkzU1FLQVFSb01SdllKaTBpS05rY2dq
SXl1aWxMeEdObTdxR2FYdUZZUkxhdm5leVJOVUNySVMycTZFdjBkbU5HcEVYaFJBb2JTYnM3Slpl
VG5tcjVCVXd4ZEpBYlhlcXN4dFYxbVp4VEUrUE9hS3lpQ2F5ZDVTOHgzKytpdmJUQktaYXZRRlE4
WHdUTXpWMzBFUnBnWlRPZFA4K3BaWmJjdjJnUjB3VGh5RGFNQVdZaXZVR1FKbUJDTFpLYzJrYVdE
eEZBWkFMa3FXLytzeklLQjV0Z2FsWEI2b2JKSjlDRTltam5VN1JwZUtLSGszSkViUzMrMnQxbmhW
NmFhQzJmcTRERWUyNGFYOTRYS3o0MkZtdUV4SXhyVXdwSHVXWktxOFNkaDI1WkE1UjNlWDVFZndY
WmN4MHNxL2IxaE5YWlFKVmF2K0pNb2RPTFZCN2FES3QwcjIzTEZHUHB6UlRwN3QvcG4wWmlPNTZk
c3JzT2RYNzlrRDh1VHZLeTVQVm5VY2dUUExYNVByV0tuRDI5dHVtL1NnRlpKMXVwOHl1TWxaVm5z
MmxRSlhtMGJwTXhWREVXSFgzdmV5MFZHeWVoanR0dTNncVQ1QjQ3ZHFzRThkVHM4d1RTL2RrRTVa
MVFPWDdmK1o4cS9NSTRrUXlqYm1nbllyTjB6Qk5WRzNBa1JpeWlUWjBXV3ZMV1k2ZitZM3ZjZStU
RlM0Q2FvQ200SlFIYXF0YXFDN1JwMGozOC91K3pDSTlZaHBBU1Jldm5sdkY4WnNiZGRkMzRQMWY3
b2xBZVlFUmJrQXdnNlliYVY2Y3RxbzIzZEVjUnBsQWNXcHhXNjRUbzRqTjA0QTNwZGZJQjIrNlJa
UHVEYStTelp2N2xEL2R0Zlovc3hsSVZ3Qmx1bWZlNmVnVDF4V0tiUUluMDR0dnZHTFlYRDhnZ3Nz
WVRicXJsd2pLOEdYQ2xXenR0dGwyeXZYclpHaTZ2K2RWcTN2UkNxQktOd2Z6M09NS0I2N015d0hW
cHUySnZqclE2NmkybStXWXpTMzZFTGVLMTdkdFA4WHJ5M1NxS2RVZUFOUkFYRjN2SXBBUlFBMnc4
SEpBY2R4Z3Y3UEhDZW9hcFVWWTZmcVRUYjEveXd5c1h5MnBkd0pLKzNzWmd4TFhhVVlzUzNicXRZ
QnFVeU5FbjYvMk41Rmw0Vms5cjRqbGl1TFBmRW5hblJKOWdkN0o1UnV6SmhxWjlyOWV6RHkvVlBt
MWdCSmg3Ylo3bHp5aU5rRzlaSXpFNmlvVEpmRjVZS0Z1NmVBNVJTRDNoeVlXQVhWS1VFSUQxUzdi
TjRzWjdtdFB2eHYwN3BMMVdrQzFpZVV0Q05XZTFvWTF1a0I1RUlsWGs2K3V3VXEybkU1OGl0ZVhD
WGF0cUhNNlVISFB6NWV4aWFSODZ0R1ZnZkpBS0prblBRcnptRExwRUlzV1c1VDBKMTJ5U2tCTmlm
VnBhN0x6R3o5bFluZDRQamZUMUh3aVUyWWU2ckpBZWZIdGtua1NOSGtvbWFaSEYvRzVaN0NDRVZZ
SnFOdWFBSUxaTWZJeXh4MTZzN2xBNlFvbkFzVU55S1FoZFdPUFZ3YXFiU2YzeVZJTjkwUjRYRk1R
WTlVdExXS2k1SU1TZE5aVGd1ZTZWMlMrOUhiOXdxTlp4dHZ0WStaQkY0MmhCa29tVnphL1ZQbUZn
R3FOQzcrV3pGUHdrREZ2eExTekJOYXFCQlJicUNrcEU2VUVnM2l2L0QxZmJ4WWZibEdVYjQ4eU41
QVhBcXJOdFdPbThuZHNUbGpLVzZqcFJRTmJ0VkRyWnFNeVRPMUpwYTRlcmhzNUhKdUgycThZbVJj
QzZvdjYrYzU4N3lKbnI4dlJUdGR1d0ZvbDJ6OFhxS2R2Ym5iNlA4RTBhQ202bUZsak10eDFwMDhU
dkNoUSs4MVRZSnRhVHl6bTRpLy8rcTErMVI5MjRjcEhKTnJCWTU3QnJqd3V1cmtCZ1owS09rOHkz
enZZT0pQTGw4dytpbG5PTEExK2RhQkVSS0xhdGFiNGVFeUtpWS9neU1PcXRWUEpHNEtZemg2OWhG
S3gvNmFmbjBCL2R1UEpYbS8wYktJSUN3U0gwRFY3aHN5YklXcmJFSyt1Q2lad2RRdTc4WHk5QnVU
MHRSc2FxTko2b3NBMlpRSVJwbFV5TFJTWEFDcytTalVpTVJlbzU5VFpuTzQ5T1pPRU1JQnFOMWtv
V0EvVjlTRkZQVjVRSXM2d05VL3dna0RsNDExZndwOWQ2NW9uenpDMTdBaXZUNkJrWXBXL0lYejVm
dkE0ZWdsdDVTY3hxMHpwUGxOYVhaNTM1NGJiMzgyTVRiWno0RFN2QmxUK1JwMGNQWmxZQlNoNTVz
bDhZeHFwL0ExaDdNUkxxajVJb2UxT3diNjYyeVE3TFJtRkpGQmo3ZCtUSU5GRjQ0MkJpdWVla3Va
Slc2VzRlT09zdGlUOVBXMmFkMXpGU0FQZGlZY0dnVHVuM2Fxa2ExZGQ3cFJuS282NmRKOUZscW1u
Njk5ZURhalMwcnliWTU3aW9aT0pVZ21ySVBwWEhRQU8zRW5HRkl3NHVCZVpvM1VpSmZud0JBK3Jk
bU5kWVhMMVJEQ0VLVDJYejdzT3ljWjROVlFYV0MyU0FLb1VjUGJNVTJDYnRMTTNVQUk3bFEvNDZ5
Y0U3cmlLTlQyS0QwM2RjNGgxTmUrdi8xRi9lcTIzKzNBYnBrc0FsZHlML2IycWVZb2plRHZKcXM1
SEgybWhvRStpRnFoOHB4cUw3NDJObS9JdTM4QjhOSUNDcHF1YWZoUG5saDlqbTB5c0JrNTVZUEFJ
UWJGNE5KSHNWTjZQaEFxYUJGWlRSazhCVTNuekpKN3ZCS0NndVJvQXlqTlBlUXMxRjZqcVlwUFd3
cGFpTVJEVUZROG9xa0F0R2oxdDlZczNYZk9VUDlrMlBYNGd2QWxCWFhGY29yUnNmTUJDalJtcExs
YlZCMStJQnQrS0NmWVExTlVZVUFNV0t1WWlYK2c1LzlXbi9ZdlZXK3RDZkhzV2hyYzF6RzNWZTR1
bW5pOHlKM1d2TEhzZnMxQVpyMi8xYWZLUHl3dW1wa2NrdkhTSS9MUStaUUxNYmRWTHE4c0xwVWl0
dmd2eFhaSHZqZVpOa29aRnA0K2hsZzVrNkNHYzJ0bGJNWUM2K2N2Zkh0Ly9ib3RYdzlVU0FFNFha
ZkVGMStTWXJBbm1taEtsbnQrKzYxbEFMWXJ5emI4SzM2VE5FMXVvNlFPb0dCWVNZWFhOWmFjWFZC
ZW93NXBCWDFrM0dmS2Vmb3k1TncrVlFTa1o1WnZldzNVc1lwMi85OHdCOWZ6b0pHQXFvNnNCUmI1
ZmtCaThkYmxTcG9Sbm9XWk5SYzI5RGp6WHJKbGE0V2ZtTVJuMi9BYzhuSU16VWF1N3hCdDNuMWt4
dlVrN2ZVajY3YzdTNHZHNVViNTE0Nm5XMlJQbWFYcDhqMVN5TzJiOGdlNSs0c1BobFF2bTRndmV5
endXOTk1MnhKYzhYUDRwbmQ3MmRPY1hwNkMzMFJ0NERjczN5VnlQUHhZL3pBT1Z6RDdhbjNwVVBR
V3pxZHdHemRTaWpLTVNVUFQxaWUvTDdPUTg3REtmeGhBL3hhVjFUdHE5K0wwK0JWN2VLNTZGUW1U
RkQyTXhkekd2Q2R2b3RtMzZFT3dlZTNNUUhsRHQwYzBtaVYzNDBPYTFNcSt3SjVyaVNXNFpPM3Y3
WGI0cDR5bUs3SG5PM3JyNTNPcklTUGRQRTZpbi8rdzc2Z2I2djdGTCtmWGpkMnBNb0lKZVpCNk9h
VEozTVFlTWdWa3hLNCtqZk9ZRzNwVjVXbTVrdmozVHhSbUFpMElUVSt6VTFzaVc4V1BNMDdNT0ZN
ZGdXUjVRbnN3aFJpYm80UVViNDN1eWViaWc2M3A3MFNkQjg4U1dWYUF5VFdyL2F4cnJZNlNuZGFw
QmlTUldlNHdJdWFaZU85ZWxHdzBBZFZNLytWZU4vdWxkVEdkUzYyYXRMZTJlZ3JnSkpJTUc0a3p6
c2JzQm9BYmlHTWtydGtqQlFuak5GSStoOGtacVNvZm5nSG1MMVZMejlGd1BGSStlMmhYMGVoZHQr
SkpIZjFwZXFKQzRtU2U3b3Q2c0c3SWdEUUExUUVmc3RSNGduVFVSbUNmdDlYbFl6WjJLTWllaGxt
YkRyblA1Z2llYzZJTW1teEVFSmZKN0pYT2xUSytQR3g4OFlXTVlxRzZUZEQyaVBkVWFkc3Jzcmwy
eUFxQldkSFhSeU5XTE5VcEFtWjZKQ1pRSVFQSHVqNCtIT1o4TFZINHVXOWNzZ3RVNitEWUExSjU4
U0RIUmNIQ2lNb1dteDBJVC9PRWlsTnBHSHVEc2tWYUV6YnNPak9ueVpYclVGSmR2MkVMcERjd3c5
VEV1bjY0ekNMQXZGUzJtMEV6RlJvcFFXcEZyWklwbWVBODRWaDRvTHhDbjZjakU2MHB6blhFRERo
dERKVnQxQ2xCQmU0NFJZZFVHcTAxVHRVRzBiVU1jSGJ5eTc1akQ1UzkrTUgra2dZcDd1T2wweFhI
ajFySFJwMUFDYWl6S1Y2MS9kWlF2ME9rTGF2Ukt3Rk1JT2tVWm9PS0FVdFZDZWJmUWg1L1l3SE8r
VThaUXo2RjVxSHo5R1YvUjlKeEw4MUNCVGdmcU02dmIrYnZaTEtVeDFDUE03WGsyUHlWQWtTditz
ODNXMDZkUUJlb1pUZ2VieUgvMUZ5WlhZeXpEbVJKdG5UcUhzTjN5NE5ERThTb2w5QjRwN3E2aWNK
NVBwcnQ2L2h1Tmp0dmczdTBqSmE5TDhZOGZTM2phVUtIcEs0NEIxUnJFUjVOdDZQSE9ONWIycEx5
N0RmZC8zaXdUdFRERDhsNlQrTkJmVmJiazhRT29nOFY1ZXF2RGd3TXlwNHB1SDgvRHo5em9nbmtv
WGFjM3NadHY3U3lndW8zVWVsU3l1OFdXK1RDZ1BrVFgzSXYyQkpmaTFVWERzVGFIL0pwMmFwMGV4
YVZHY1ZXTG5KbHFJL1BiRDU5NHFVbXpydkRGUlc2ZUNCdCtRcWFTNm5hSmJpUUJlbGUxS09tbElt
REtsQmgydGYrS3c0elFleXRHcVoxTkJsTkNZbEFnM29PbVR5VWVMcGtMR00xbGc5dm5aN2Y2aW5w
OC8wTnBwNlI5UWllS0hUeTkrQ0lvOFBvZ3FCV2xVclFvNmVUQWdLYXptdzlCVnhFbEFiTG5sckZI
TUV6UWU2dVVyY2ZHYUl3ajJwaVNiRmVmRndTZG90YktFQ202c09jbUpxUHZ6Y1BHeGF1QWlGR0NW
WUkrZzhqdW1MazNtYUpwYXY5MXdIcGJDTHFtaUN4dGpBS092SC94K3Ftenp3bUNMaUVSYzRodEU4
WDB5RVVFUkJEVVZmdGJoRlErMVFwRUNJSWdDSUlnQ0lJZ0NJSWdDSUlnQ0lLZzk5YXZicGZkZUFw
bGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pVd0lEQWdiMkpxQ2p3OEwweGxibWQwYUNBeU5UazJMMDRn
TXk5R2FXeDBaWEl2Um14aGRHVkVaV052WkdVK1BuTjBjbVZoYlFwNG5KMldkMVJUMlJhSHo3MDN2
VkNTRUlxVTBHdG9VZ0pJRGIxSWtTNHFNUWtRU3NDUUFDSTJSRlJ3UkZHUnBnZ3lLT0NBbzBPUnNT
S0toUUZSc2VzRUdVVFVjWEFVRzVaSlpLMFozN3g1NzgyYjN4LzNmbXVmdmMvZForOTkxcm9Ba1B5
REJjSk1XQW1BREtGWUZPSG54WWlOaTJkZ0J3RU04QUFEYkFEZ2NMT3pRaGI0UmdLWkFuellqR3la
RS9nWHZib09JUG43S3RNL2pNRUEvNStVdVZraU1RQlFtSXpuOHZqWlhCa1h5VGc5VjV3bHQwL0pt
TFkwVGM0d1NzNGlXWUl5VnBOejhpeGJmUGFaWlE4NTh6S0VQQm5MYzg3aVpmRGszQ2ZqalRrU3Zv
eVJZQmtYNXdqNHVUSytKbU9EZEVtR1FNWnY1TEVaZkU0MkFDaVMzQzdtYzFOa2JDMWpraWd5Z2kz
amVRRGdTTWxmOE5JdldNelBFOHNQeGM3TVdpNFNKS2VJR1NaY1U0YU5reE9MNGMvUFRlZUx4Y3d3
RGplTkkrSXgySmtaV1J6aGNnQm16L3haRkhsdEdiSWlPOWc0T1Rnd2JTMXR2aWpVZjEzOG01TDNk
cFplaEgvdUdVUWYrTVAyVjM2WkRRQ3dwbVcxMmZxSGJXa1ZBRjNyQVZDNy9ZZk5ZQzhBaXJLK2RR
NTljUjY2ZkY1U3hPSXNaeXVyM054Y1N3R2ZheWt2Nk8vNm53NS9RMTk4ejFLKzNlL2xZWGp6a3pp
U2RERkRYamR1Wm5xbVJNVEl6dUp3K1F6bW40ZjRId2YrZFI0V0Vmd2t2b2d2bEVWRXk2Wk1JRXlX
dFZ2SUU0Z0ZtVUtHUVBpZm12Z1B3LzZrMmJtV2lkcjRFZENXV0FLbElScEFmaDRBS0NvUklBbDda
Q3ZRNzMwTHhrY0QrYzJMMFptWW5mdlBndjU5VjdoTS9zZ1dKSCtPWTBkRU1yZ1NVYzdzbXZ4YUFq
UWdBRVZBQStwQUcrZ0RFOEFFdHNBUnVBQVA0QU1DUVNpSUJIRmdNZUNDRkpBQlJDQVhGSUMxb0Jp
VWdxMWdKNmdHZGFBUk5JTTJjQmgwZ1dQZ05EZ0hMb0hMWUFUY0FWSXdEcDZBS2ZBS3pFQVFoSVhJ
RUJWU2gzUWdROGdjc29WWWtCdmtBd1ZERVZBY2xBZ2xRMEpJQWhWQTY2QlNxQnlxaHVxaFp1aGI2
Q2gwR3JvQURVTzNvRkZvRXZvVmVnY2pNQW1td1Zxd0VXd0ZzMkJQT0FpT2hCZkJ5ZkF5T0I4dWdy
ZkFsWEFEZkJEdWhFL0RsK0FSV0FvL2dhY1JnQkFST3FLTE1CRVd3a1pDa1hna0NSRWhxNUFTcEFK
cFFOcVFIcVFmdVlwSWthZklXeFFHUlVVeFVFeVVDOG9mRllYaW9wYWhWcUUybzZwUkIxQ2RxRDdV
VmRRb2FncjFFVTFHYTZMTjBjN29BSFFzT2htZGl5NUdWNkNiMEIzb3MrZ1I5RGo2RlFhRG9XT01N
WTRZZjB3Y0poV3pBck1ac3h2VGpqbUZHY2FNWWFheFdLdzYxaHpyaWczRmNyQmliREcyQ25zUWV4
SjdCVHVPZllNajRuUnd0amhmWER4T2lDdkVWZUJhY0Nkd1YzQVR1Qm04RXQ0UTc0d1B4ZlB3eS9G
bCtFWjhEMzRJUDQ2ZklTZ1RqQW11aEVoQ0ttRXRvWkxRUmpoTHVFdDRRU1FTOVloT3hIQ2lnTGlH
V0VrOFJEeFBIQ1crSlZGSVppUTJLWUVrSVcwaDdTZWRJdDBpdlNDVHlVWmtEM0k4V1V6ZVFtNG1u
eUhmSjc5Um9DcFlLZ1FvOEJSV0s5UW9kQ3BjVVhpbWlGYzBWUFJVWEt5WXIxaWhlRVJ4U1BHcEVs
N0pTSW10eEZGYXBWU2pkRlRwaHRLME1sWFpSamxVT1VONXMzS0w4Z1hsUnhRc3hZamlRK0ZSaWlq
N0tHY29ZMVNFcWs5bFU3blVkZFJHNmxucU9BMURNNllGMEZKcHBiUnZhSU8wS1JXS2lwMUt0RXFl
U28zS2NSVXBIYUViMFFQbzZmUXkrbUg2ZGZvN1ZTMVZUMVcrNmliVk50VXJxcS9WNXFoNXFQSFZT
dFRhMVViVTNxa3oxSDNVMDlTM3FYZXAzOU5BYVpocGhHdmthdXpST0t2eGRBNXRqc3NjN3B5U09Z
Zm4zTmFFTmMwMEl6UlhhTzdUSE5DYzF0TFc4dFBLMHFyU09xUDFWSnV1N2FHZHFyMUQrNFQycEE1
VngwMUhvTE5ENTZUT1k0WUt3NU9SenFoazlER21kRFYxL1hVbHV2VzZnN296ZXNaNlVYcUZldTE2
OS9RSitpejlKUDBkK3IzNlV3WTZCaUVHQlFhdEJyY044WVlzd3hURFhZYjlocStOakkxaWpEWVlk
Ums5TWxZekRqRE9OMjQxdm10Q05uRTNXV2JTWUhMTkZHUEtNazB6M1cxNjJRdzJzemRMTWFzeEd6
S0h6UjNNQmVhN3pZY3QwQlpPRmtLTEJvc2JUQkxUazVuRGJHV09XdEl0Z3kwTExic3NuMWtaV01W
YmJiUHF0L3BvYlcrZGJ0MW9mY2VHWWhOb1UyalRZL09yclprdDE3Ykc5dHBjOGx6ZnVhdm5kczk5
Ym1kdXg3ZmJZM2ZUbm1vZllyL0J2dGYrZzRPamc4aWh6V0hTMGNBeDBiSFc4UWFMeGdwamJXYWRk
MEk3ZVRtdGRqcm05TmJad1Zuc2ZOajVGeGVtUzVwTGk4dWplY2J6K1BNYTU0MjU2cmx5WE90ZHBX
NE10MFMzdlc1U2QxMTNqbnVEK3dNUGZRK2VSNVBIaEtlcFo2cm5RYzluWHRaZUlxOE9yOWRzWi9a
SzlpbHZ4TnZQdThSNzBJZmlFK1ZUN1hQZlY4ODMyYmZWZDhyUDNtK0YzeWwvdEgrUS96Yi9Hd0Zh
QWR5QTVvQ3BRTWZBbFlGOVFhU2dCVUhWUVErQ3pZSkZ3VDBoY0VoZ3lQYVF1L01ONXd2bmQ0V0Mw
SURRN2FIM3dvekRsb1Y5SDQ0SkR3dXZDWDhZWVJOUkVORy9nTHBneVlLV0JhOGl2U0xMSXU5RW1V
UkpvbnFqRmFNVG9wdWpYOGQ0eDVUSFNHT3RZbGZHWG9yVGlCUEVkY2RqNDZQam0rS25GL29zM0xs
d1BNRStvVGpoK2lMalJYbUxMaXpXV0p5KytQZ1N4U1djSlVjUzBZa3hpUzJKN3ptaG5BYk85TktB
cGJWTHA3aHM3aTd1RTU0SGJ3ZHZrdS9LTCtkUEpMa21sU2M5U25aTjNwNDhtZUtlVXBIeVZNQVdW
QXVlcC9xbjFxVytUZ3ROMjUvMktUMG12VDBEbDVHWWNWUklFYVlKK3pLMU0vTXloN1BNczRxenBN
dWNsKzFjTmlVS0VqVmxROW1Mc3J2Rk5OblAxSURFUkxKZU1wcmpsbE9UOHlZM092ZElubktlTUc5
Z3VkbnlUY3NuOG4zenYxNkJXc0ZkMFZ1Z1c3QzJZSFNsNThyNlZkQ3FwYXQ2Vit1dkxsbzl2c1p2
ellHMWhMVnBhMzhvdEM0c0wzeTVMbVpkVDVGVzBacWlzZlYrNjF1TEZZcEZ4VGMydUd5bzI0amFL
Tmc0dUdudXBxcE5IMHQ0SlJkTHJVc3JTdDl2NW02KytKWE5WNVZmZmRxU3RHV3d6S0ZzejFiTVZ1
SFc2OXZjdHgwb1Z5N1BMeC9iSHJLOWN3ZGpSOG1PbHp1WDdMeFFZVmRSdDR1d1M3SkxXaGxjMlYx
bFVMVzE2bjExU3ZWSWpWZE5lNjFtN2FiYTE3dDV1Ni9zOGRqVFZxZFZWMXIzYnE5Zzc4MTZ2L3JP
QnFPR2luMllmVG43SGpaR04vWi96ZnE2dVVtanFiVHB3MzdoZnVtQmlBTjl6WTdOelMyYUxXV3Rj
S3VrZGZKZ3dzSEwzM2gvMDkzR2JLdHZwN2VYSGdLSEpJY2VmNXY0N2ZYRFFZZDdqN0NPdEgxbitG
MXRCN1dqcEJQcVhONDUxWlhTSmUyTzZ4NCtHbmkwdDhlbHArTjd5Ky8zSDlNOVZuTmM1WGpaQ2NL
Sm9oT2ZUdWFmbkQ2VmRlcnA2ZVRUWTcxTGV1K2NpVDF6clMrOGIvQnMwTm56NTN6UG5lbjM3RDk1
M3ZYOHNRdk9GNDVlWkYzc3V1UndxWFBBZnFEakIvc2ZPZ1lkQmp1SEhJZTZMenRkN2htZU4zemlp
dnVWMDFlOXI1NjdGbkR0MHNqOGtlSHJVZGR2M2tpNEliM0p1L25vVnZxdDU3ZHpicy9jV1hNWGZi
ZmtudEs5aXZ1YTl4dCtOUDJ4WGVvZ1BUN3FQVHJ3WU1HRE8yUGNzU2MvWmYvMGZyem9JZmxoeFlU
T1JQTWoyMGZISm4wbkx6OWUrSGo4U2RhVG1hZkZQeXYvWFB2TTVObDN2M2o4TWpBVk96WCtYUFQ4
MDYrYlg2aS8yUC9TN21YdmROajAvVmNacjJaZWw3eFJmM1BnTGV0dC83dVlkeE16dWUreDd5cy9t
SDdvK1JqMDhlNm5qRStmZmdQM2hQUDdDbVZ1WkhOMGNtVmhiUXBsYm1Sdlltb0tOVEVnTUNCdllt
b0tQRHd2Vkhsd1pTOURZWFJoYkc5bkwxQmhaMlZ6SURFMElEQWdVajQrQ21WdVpHOWlhZ28xTWlB
d0lHOWlhZ284UEM5RGNtVmhkRzl5S0ZGMVpYTjBJRVJwWVdkdWIzTjBhV056SUZKbGNHOXlkR2x1
WnlCVFpYSjJhV05sY3lrdlVISnZaSFZqWlhJb2FWUmxlSFFnTWk0eExqUWdYQ2hpZVNCc2IzZGha
MmxsTG1OdmJWd3BLUzlUZFdKcVpXTjBLRkJoZEdsbGJuUWdVbVZ3YjNKMGN5a3ZUVzlrUkdGMFpT
aEVPakl3TVRjd05URXhNVFF5T1RNNUxUQTBKekF3SnlrdlFYVjBhRzl5S0ZGMVpYTjBJRVJwWVdk
dWIzTjBhV056SUVsdVkyOXljRzl5WVhSbFpDa3ZRM0psWVhScGIyNUVZWFJsS0VRNk1qQXhOekEx
TVRFeE5ESTVNemt0TURRbk1EQW5LVDQrQ21WdVpHOWlhZ295SURBZ2IySnFDanc4TDFSNWNHVXZU
MkpxVTNSdEwwNGdNamd2VEdWdVozUm9JRFkxTUM5R2FYSnpkQ0F5TVRBdlJtbHNkR1Z5TDBac1lY
UmxSR1ZqYjJSbFBqNXpkSEpsWVcwS2VKenRWbTF2MmpBUS9pdjNCeXEvblJOSHFwQVdPalkwYlVP
QXRFcUlEMm53cWt5UVZFbVl1bisvYzV5Z0RrcFZDbFNydGsvbmMrem43am5mNDFnQUI2RWcxQ0FW
S0tOQmhLQlZCTUtBMWdaRUJBRjVra01vRWFRQXcwT1FFb3dKUUNCRWdRRkplN2lpelNFQklRY2w2
RXRFdmdTaGhRVDZKTFR6RVVRUVJxQmNqSURtQ2NHZ0FFazJvdURTQVNzTzBrRXFBMGhoRFFhQXRK
VnpEb2hrS1IvVUZNTDVBVmxLR0VNS1JYbWdvVkRrWEY2eU9LbnNvTWhyTnMxV3Ryb1lGNnNrWjlO
ZmQ1WTFzKy96dEZoaytTMzdsdVh2OGlyYitKUDFUZTFXdWFXaTEzTlFvNlMwZWUyNGNoaXpQbTBu
dDVvSjRYd2k1bzEwWnU1RGpKSmJ5OGEyS3RabGFpdUN1UDU2ODhPbU5ZMkdLNnBONE5iMmVteFVG
dW5FMWpCam82c0JzS205cjRGVzBPNjR0ZjNXRHVjVWVGbVVrN3NrdFFSelpiOG42MlU5L2hDNzAv
Sm9qaGg5R2doM2NpN1ZBYVZJMVdxRzJoMWdNNHJjR1RhajVoamQ2RHFqRHZBb2hETXRzMVZjM00v
YytvQjRoWkdjczg5MmtTVTdzL0hTMnNYMnJLL2EwNVFieGkzVmxtbEQvNXcwSFRrcTliRGZkODJ4
QU5rYzZQeVBidmxvbHo5dG5hWEp3YjNDdmlRcjJ0RDJ6QWF3VHoyUTJmSWlMcGFMRjJOdWd4N1Qw
eTJtZmp6UGw4SkZqMlo0RE9uUUkyNzBWTGtVU1lhYWZjb1dwRDdWeUU1NjljbkFtOUNicGkvbVQ2
cTNYZG0wRFpqbmExZnhVMnBYaVoybVZsNlNBK1Z1emJhbkZYWTlyWFRYMHlwb3BTdk9MTjF0eG9k
TDkyaVcyOHBWNWhXVXV3RThxbzNWdnl2ZFBjcnppbFZlZWNGYlZwNDh1ZkwybE16WENybC9hZkMz
WERQMVdqWHovd2YwanpSOGZzbFFuckprcUhaS2hyaDV0YUR1YW9aZGZSQkVWejBNdStxaE9lc052
MDM1OEJ2K1FKcDd5RDI4NGpYLy96ajd1Mi80M3lKVUxvNEtaVzVrYzNSeVpXRnRDbVZ1Wkc5aWFn
bzFNeUF3SUc5aWFnbzhQQzlVZVhCbEwxaFNaV1l2VjFzeElESWdNbDB2VW05dmRDQTFNU0F3SUZJ
dlNXNWtaWGhiTUNBMU5GMHZTVVFnV3p4bVpXTXdNVE5qTmpVNFpUazVZakF4T0RBek56YzRNV1Zs
WkdaaU1XRmpNajQ4WkRjMFpUWXlabUl4TjJWbFl6SXlaall6T1Rrek9UVTJOVEJpTmpZMU1tVStY
UzlNWlc1bmRHZ2dNVFl3TDBsdVptOGdOVElnTUNCU0wxTnBlbVVnTlRRdlJtbHNkR1Z5TDBac1lY
UmxSR1ZqYjJSbFBqNXpkSEpsWVcwS2VKd2x6RHNTQVZFUWhlSHVPK00xSHNONFB5SUpxUVhJWkdL
UlphaENSaWlWcUpLUnFCSUliY0E2YkVHa3hLUC91aDE4d2VuVExTSnA2c1NKNlBWc1NBeExlQnM2
aGp2OERMZUdseEhNNENqQ3JVSkJ3OFN5eXNObkFZU1FnU3prSUE5T0IwL2ZpeUNCT2pSME5MUXYw
NjNmbHFBTUZZaWhDalVvNm54djVjWEhXRTJNM2RjNE9IL2Jnalowb0FzOTZFTlRUNUdWTHh1NGla
OC9tVjBVcXdwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ25OMFlYSjBlSEpsWmdvME1qRXhNd29sSlVW
UFJnbz18fHx8fHxGfHx8fHx8fHx8fHx8UVVFU1QgRElBR05PU1RJQ1MtV0VTVCBISUxMU15eXl5e
XkZJXkNMSUFeXjA1RDA2NDI4Mjd8ODQwMSBGQUxMQlJPT0sgQVZFTlVFXl5XRVNUIEhJTExTXkNB
XjkxMzA0LTMyMjZ8MTM2NjQ3OTA5OV5URVJSQVpBU15FTlJJUVVFXl5NRF5eXl5eXl5eTlBJXkVO
Cg==</inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>true</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>3</metaDataId>
          <name>FHIR_submit</name>
          <properties class="com.mirth.connect.connectors.http.HttpDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <host>${SparkURL}</host>
            <useProxyServer>false</useProxyServer>
            <proxyAddress></proxyAddress>
            <proxyPort></proxyPort>
            <method>post</method>
            <headers class="linked-hash-map"/>
            <parameters class="linked-hash-map"/>
            <responseXmlBody>true</responseXmlBody>
            <responseParseMultipart>true</responseParseMultipart>
            <responseIncludeMetadata>false</responseIncludeMetadata>
            <responseBinaryMimeTypes>application/xml</responseBinaryMimeTypes>
            <responseBinaryMimeTypesRegex>true</responseBinaryMimeTypesRegex>
            <multipart>false</multipart>
            <useAuthentication>false</useAuthentication>
            <authenticationType>Basic</authenticationType>
            <usePreemptiveAuthentication>false</usePreemptiveAuthentication>
            <username></username>
            <password></password>
            <content>${ORUBundle}</content>
            <contentType>application/xml</contentType>
            <dataTypeBinary>false</dataTypeBinary>
            <charset>UTF-8</charset>
            <socketTimeout>30000</socketTimeout>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Construct Bundle</name>
                <script>var resBundle = &lt;Bundle xmlns=&quot;http://hl7.org/fhir&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
		&lt;type value=&quot;message&quot;/&gt;
	&lt;/Bundle&gt;;

// Patient resource
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resPatient = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + channelMap.get(&quot;Patient&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBundle.appendChild(resPatient);

// DiagnosticReport resource
addEntry(&quot;DiagnosticReport&quot;);

// Practitioner resource for Ordering Provider
addEntry(&quot;Practitioner&quot;);

// Specimen resource
addEntry(&quot;Specimen&quot;);

// Binary resourse with original HL7v2 ORU_R01 message
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resBinary = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + globalChannelMap.get(&quot;Binary&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBinary.resource.Binary.id.@value = &quot;oru-r01-&quot; + channelMap.get(&quot;MessageControlID&quot;);
resBundle.appendChild(resBinary);

// Bundle settings
//resBundle.id.@value = channelMap.get(&quot;MessageControlID&quot;);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var resBundle = &lt;Bundle xmlns=&quot;http://hl7.org/fhir&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
		&lt;type value=&quot;message&quot;/&gt;
	&lt;/Bundle&gt;;

// Patient resource
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resPatient = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + channelMap.get(&quot;Patient&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBundle.appendChild(resPatient);

// DiagnosticReport resource
addEntry(&quot;DiagnosticReport&quot;);

// Practitioner resource for Ordering Provider
addEntry(&quot;Practitioner&quot;);

// Specimen resource
addEntry(&quot;Specimen&quot;);

// Binary resourse with original HL7v2 ORU_R01 message
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resBinary = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + globalChannelMap.get(&quot;Binary&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBinary.resource.Binary.id.@value = &quot;oru-r01-&quot; + channelMap.get(&quot;MessageControlID&quot;);
resBundle.appendChild(resBinary);

// Bundle settings
//resBundle.id.@value = channelMap.get(&quot;MessageControlID&quot;);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Send to Left Side</name>
                <script>//logger.debug(&quot;Bundle: &quot; + resBundle.toString());

channelMap.put(&quot;ORUBundle&quot;, resBundle.toString());</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>//logger.debug(&quot;Bundle: &quot; + resBundle.toString());

channelMap.put(&quot;ORUBundle&quot;, resBundle.toString());</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>Add Entry function</name>
                <script>/**
	Constructs multiple resource entries from the storred array.
	This function uses the global resBundle variable.

	@param {String} arrName - array name to extract from the channel map
*/
function addEntry(arrName) {
	var arrResource = channelMap.get(arrName);
	for (var i = 0; i &lt; arrResource.length; i++) {
		default xml namespace = &quot;http://hl7.org/fhir&quot;;
		var resource = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + arrResource[i] + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
		resBundle.appendChild(resource);	
	}
	channelMap.remove(arrName);
	arrResource.length = 0;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Constructs multiple resource entries from the storred array.
	This function uses the global resBundle variable.

	@param {String} arrName - array name to extract from the channel map
*/
function addEntry(arrName) {
	var arrResource = channelMap.get(arrName);
	for (var i = 0; i &lt; arrResource.length; i++) {
		default xml namespace = &quot;http://hl7.org/fhir&quot;;
		var resource = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + arrResource[i] + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
		resBundle.appendChild(resource);	
	}
	channelMap.remove(arrName);
	arrResource.length = 0;
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>true</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Validate Spark Server response</name>
                <script>var resp =  $(&apos;responseStatusLine&apos;);

//logger.info(&quot;ORU Processing: Destination - Response - &quot; + msg.toString());
//logger.info(&quot;ORU Processing: Destination - Response - &quot; + resp);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var resp =  $(&apos;responseStatusLine&apos;);

//logger.info(&quot;ORU Processing: Destination - Response - &quot; + msg.toString());
//logger.info(&quot;ORU Processing: Destination - Response - &quot; + resp);</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>HTTP Sender</transportName>
          <mode>DESTINATION</mode>
          <enabled>false</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data

message = stripNonValidXMLChars(message);

return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

globalMap.put(&quot;ORUProcessingChannelId&quot;, channelId);

return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set">
          <string>CURRENT</string>
        </tags>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <className>com.mirth.connect.server.attachments.javascript.JavaScriptAttachmentHandlerProvider</className>
          <type>JavaScript</type>
          <properties>
            <entry>
              <string>javascript.script</string>
              <string>// Modify the message variable below to create attachments

// Create Binary resourse with the original HL7v2 message
var resBinary = &lt;Binary&gt;				
				&lt;id value=&quot;&quot;/&gt;				
				&lt;contentType value=&quot;application/hl7-v2&quot;/&gt;
				&lt;content value=&quot;&quot;/&gt;
			&lt;/Binary&gt;;

// Encode original ORU message
var bytes = new java.lang.String(message.toString()).getBytes();
resBinary.content.@value = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

// Store to be processed by the FHIR_submit destination
globalChannelMap.put(&quot;Binary&quot;, resBinary.toString());


return message;</string>
            </entry>
          </properties>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
      <dependentIds/>
    </channel>
    <channel version="3.4.2">
      <id>9b81980c-9c03-4c6d-bb30-46bd533aaed5</id>
      <nextMetaDataId>4</nextMetaDataId>
      <name>ORU Processing - SAVED</name>
      <description>LRI ORU_R01 processing downstream channel.
The channel receives ORU_R01 messages routed from the LRI getResults channel.

(SN) This channel should use Strict Parser for incoming HL7v2 ORU messages.

Last updated: March 25, 2017</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1496778659466</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>7</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Route ORU to Destination</name>
              <script>// Different HL7v2.x.x versions will be processed differently
var version = msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;VID.1&apos;].toString();

channelMap.put(&quot;MessageControlID&quot;, msg[&apos;MSH&apos;][&apos;MSH.10&apos;].toString());
 
if (&quot;2.5.1&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.5.1&quot;,&quot;FHIR_submit&quot;]);
	
} else if (&quot;2.3.1&quot; == version || &quot;2.3&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.3.x&quot;,&quot;FHIR_submit&quot;]);
	
} else {
	logger.error(&quot;ORU Processing: unknown ORU_R01 message version (MSH.12) - &quot; + version);
	destinationSet.removeAllExcept([&quot;FHIR_submit&quot;]);
}</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Different HL7v2.x.x versions will be processed differently
var version = msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;VID.1&apos;].toString();

channelMap.put(&quot;MessageControlID&quot;, msg[&apos;MSH&apos;][&apos;MSH.10&apos;].toString());
 
if (&quot;2.5.1&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.5.1&quot;,&quot;FHIR_submit&quot;]);
	
} else if (&quot;2.3.1&quot; == version || &quot;2.3&quot; == version) {
	destinationSet.removeAllExcept([&quot;ORU_R01_2.3.x&quot;,&quot;FHIR_submit&quot;]);
	
} else {
	logger.error(&quot;ORU Processing: unknown ORU_R01 message version (MSH.12) - &quot; + version);
	destinationSet.removeAllExcept([&quot;FHIR_submit&quot;]);
}</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>HL7V2</inboundDataType>
          <outboundDataType>HL7V2</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules>
            <rule>
              <sequenceNumber>0</sequenceNumber>
              <name>Check for ORU messages</name>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Continue processing only if the incoming message is ORU_R01
if(&quot;ORU&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.1&apos;].toString() &amp;&amp; &quot;R01&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.2&apos;].toString()) {
	return true;
} else {
	logger.debug(&quot;ORU Processing: non-ORU message is rejected &quot; + msg.toString());
	return false;
}</string>
                </entry>
              </data>
              <type>JavaScript</type>
              <script>// Continue processing only if the incoming message is ORU_R01
if(&quot;ORU&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.1&apos;].toString() &amp;&amp; &quot;R01&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.2&apos;].toString()) {
	return true;
} else {
	logger.debug(&quot;ORU Processing: non-ORU message is rejected &quot; + msg.toString());
	return false;
}</script>
              <operator>NONE</operator>
            </rule>
          </rules>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>ORU_R01_2.5.1</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Patient resource</name>
                <script>// Mar 16: &lt;value value=&quot;&quot;/&gt; removed from identifier


var resPatient = &lt;Patient&gt;
			&lt;id value=&quot;PID-patient-identification&quot;/&gt;
			&lt;text&gt;
				&lt;status value=&quot;generated&quot;/&gt;
				&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
			&lt;/text&gt;			
			&lt;identifier&gt;
				&lt;use value=&quot;official&quot;/&gt;				
			&lt;/identifier&gt;
			&lt;name&gt;
				&lt;use value=&quot;official&quot;/&gt;
				&lt;family value=&quot;&quot;/&gt;
			&lt;/name&gt;
				&lt;telecom&gt;
					&lt;system value=&quot;phone&quot;/&gt;
					&lt;value value=&quot;&quot;/&gt;
					&lt;use value=&quot;home&quot;/&gt;
				&lt;/telecom&gt;
			&lt;gender value=&quot;&quot;/&gt;
			&lt;birthDate value=&quot;&quot;/&gt;
			&lt;address&gt;
				&lt;use value=&quot;home&quot;/&gt;
			&lt;/address&gt;
		&lt;/Patient&gt;;


// Process NTE segments
// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot;  
resPatient.text.*::div.* = new XMLList();
var 	patientComment = false;
for each (var nte in msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;].children()) {
	if (&quot;NTE&quot; == nte.name().toString()) {

		patientComment = true;
		
		// Source of Comment - Optional
		var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
		var source = nte[&apos;NTE.2&apos;].toString();
		
		// Comments that are contained in the segment - Required
		var comment = nte[&apos;NTE.3&apos;].toString();

		if (commentSources.indexOf(source) &gt; -1) {	
			resPatient.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
		} else {
			resPatient.text.*::div.* += new XML(&apos;&lt;p&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
		}
	}
}

if (!patientComment) delete resPatient.text;

// Patient Quest360 identifier list (repeatable)
// (SN)  Only first PID.3.1 [ID Number] is mapped in this version
var identifierTypeCode = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.5&apos;].toString();
if (identifierTypeCode) {
	resPatient.identifier.type.coding.code.@value = identifierTypeCode;
}

//======================= ~~ RKW IMPORTANT: This is where the patient SAFE ID is found
// Quest identifier - Required
var patientID = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.1&apos;].toString();
resPatient.identifier.(use.@value == &quot;official&quot;).value.@value = patientID;


// Patient name (repeatable)
// (SN) PID.5.4 [Suffix], PID.5.5 [Preffix] and PID.5.7 [Name Type Code] are not mapped in this version
// (SN) Additional coding (as per p.458) is not used in this version
var familyName = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.5&apos;][&apos;XPN.1&apos;][&apos;FN.1&apos;].toString();
if (familyName) {
	resPatient.name.* = new XMLList();
	resPatient.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);

	var given = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.5&apos;][&apos;XPN.2&apos;].toString();
	if (given)
		resPatient.name.* += new XML(&apos;&lt;given value=&quot;&apos; + given +&apos;&quot;/&gt;&apos;);
	
	given = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.5&apos;][&apos;XPN.3&apos;].toString();
	if (given)
		resPatient.name.* += new XML(&apos;&lt;given value=&quot;&apos; + given +&apos;&quot;/&gt;&apos;);	
} else {
	// (SN) This should never happen since Family Name is Required
	delete resPatient.name;
}

// Patient Home Phone (repeatable)
// (SN) Only first PID.13.6 [Area/City Code] and PID.13.7 [Local Number] are used in this version
var telecom = &quot;(&quot; + msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.13&apos;][&apos;XTN.6&apos;].toString() + &quot;) &quot; +
convertPhone(msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.13&apos;][&apos;XTN.7&apos;].toString());
if (telecom.length &gt; 4) {
	resPatient.telecom.value.@value = telecom;
} else delete resPatient.telecom;


// Date of birth is HL7v2 RE (Required or Empty)
var dob = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.7&apos;][&apos;TS.1&apos;].toString();
if (dob) {
	resPatient.birthDate.@value = convertHL7DateTime(dob);
} else {
	resPatient.birthDate.@value = &quot;0000-00-00&quot;;
}

// Convert administrative sex into FHIR value set
var gender = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.8&apos;].toString().toUpperCase();
resPatient.gender.@value = getGenderValue(gender);


// Patient Address (repeatable)
// (SN) Only first PID.11 [Patient Address] is used in this version
var addressInUse = false;
var line = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
if (line) {
	addressInUse = true;
	resPatient.address.line.@value = line;
}

var city = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.3&apos;].toString();
if (city) {
	addressInUse = true;
	resPatient.address.city.@value = city;
}

var district = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.9&apos;].toString();
if (district) {
	addressInUse = true;
	resPatient.address.district.@value = district;
}

var state = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.4&apos;].toString();
if (state) {
	addressInUse = true;
	resPatient.address.state.@value = state;
}

var postalCode = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.5&apos;].toString();
if (postalCode) {
	addressInUse = true;
	resPatient.address.postalCode.@value = postalCode;
}

var country = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.6&apos;].toString();
if (country) {
	addressInUse = true;
	resPatient.address.country.@value = country;
}

if (!addressInUse) delete resPatient.address;

// ============================ RKW ~~ New Stuff

importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( patientID ))
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;

if( msSize )
{
	var patientResource = ms.get(0).getResource();
	var patientString = ctx.newJsonParser().encodeResourceToString(patientResource);
	
//	logger.error( &quot;Patient: \n&quot; + patientResource.getIdentifier().get(0).getValue() );
//	logger.error( &quot;Patient: \n&quot; + patientString );	
}
else
{
	throw &quot;ORU Processing: Patient Not Found&quot;;
}

var PatientSource = JSON.parse( patientString );
channelMap.put(&quot;PatientResourceID&quot;, PatientSource.id );


 //=========================================================== ~~ RKW Leave - this is part of old code
// Store Patient resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Patient&quot;, resPatient);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Mar 16: &lt;value value=&quot;&quot;/&gt; removed from identifier


var resPatient = &lt;Patient&gt;
			&lt;id value=&quot;PID-patient-identification&quot;/&gt;
			&lt;text&gt;
				&lt;status value=&quot;generated&quot;/&gt;
				&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
			&lt;/text&gt;			
			&lt;identifier&gt;
				&lt;use value=&quot;official&quot;/&gt;				
			&lt;/identifier&gt;
			&lt;name&gt;
				&lt;use value=&quot;official&quot;/&gt;
				&lt;family value=&quot;&quot;/&gt;
			&lt;/name&gt;
				&lt;telecom&gt;
					&lt;system value=&quot;phone&quot;/&gt;
					&lt;value value=&quot;&quot;/&gt;
					&lt;use value=&quot;home&quot;/&gt;
				&lt;/telecom&gt;
			&lt;gender value=&quot;&quot;/&gt;
			&lt;birthDate value=&quot;&quot;/&gt;
			&lt;address&gt;
				&lt;use value=&quot;home&quot;/&gt;
			&lt;/address&gt;
		&lt;/Patient&gt;;


// Process NTE segments
// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot;  
resPatient.text.*::div.* = new XMLList();
var 	patientComment = false;
for each (var nte in msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;].children()) {
	if (&quot;NTE&quot; == nte.name().toString()) {

		patientComment = true;
		
		// Source of Comment - Optional
		var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
		var source = nte[&apos;NTE.2&apos;].toString();
		
		// Comments that are contained in the segment - Required
		var comment = nte[&apos;NTE.3&apos;].toString();

		if (commentSources.indexOf(source) &gt; -1) {	
			resPatient.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
		} else {
			resPatient.text.*::div.* += new XML(&apos;&lt;p&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
		}
	}
}

if (!patientComment) delete resPatient.text;

// Patient Quest360 identifier list (repeatable)
// (SN)  Only first PID.3.1 [ID Number] is mapped in this version
var identifierTypeCode = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.5&apos;].toString();
if (identifierTypeCode) {
	resPatient.identifier.type.coding.code.@value = identifierTypeCode;
}

//======================= ~~ RKW IMPORTANT: This is where the patient SAFE ID is found
// Quest identifier - Required
var patientID = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.3&apos;][&apos;CX.1&apos;].toString();
resPatient.identifier.(use.@value == &quot;official&quot;).value.@value = patientID;


// Patient name (repeatable)
// (SN) PID.5.4 [Suffix], PID.5.5 [Preffix] and PID.5.7 [Name Type Code] are not mapped in this version
// (SN) Additional coding (as per p.458) is not used in this version
var familyName = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.5&apos;][&apos;XPN.1&apos;][&apos;FN.1&apos;].toString();
if (familyName) {
	resPatient.name.* = new XMLList();
	resPatient.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);

	var given = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.5&apos;][&apos;XPN.2&apos;].toString();
	if (given)
		resPatient.name.* += new XML(&apos;&lt;given value=&quot;&apos; + given +&apos;&quot;/&gt;&apos;);
	
	given = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.5&apos;][&apos;XPN.3&apos;].toString();
	if (given)
		resPatient.name.* += new XML(&apos;&lt;given value=&quot;&apos; + given +&apos;&quot;/&gt;&apos;);	
} else {
	// (SN) This should never happen since Family Name is Required
	delete resPatient.name;
}

// Patient Home Phone (repeatable)
// (SN) Only first PID.13.6 [Area/City Code] and PID.13.7 [Local Number] are used in this version
var telecom = &quot;(&quot; + msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.13&apos;][&apos;XTN.6&apos;].toString() + &quot;) &quot; +
convertPhone(msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.13&apos;][&apos;XTN.7&apos;].toString());
if (telecom.length &gt; 4) {
	resPatient.telecom.value.@value = telecom;
} else delete resPatient.telecom;


// Date of birth is HL7v2 RE (Required or Empty)
var dob = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.7&apos;][&apos;TS.1&apos;].toString();
if (dob) {
	resPatient.birthDate.@value = convertHL7DateTime(dob);
} else {
	resPatient.birthDate.@value = &quot;0000-00-00&quot;;
}

// Convert administrative sex into FHIR value set
var gender = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.8&apos;].toString().toUpperCase();
resPatient.gender.@value = getGenderValue(gender);


// Patient Address (repeatable)
// (SN) Only first PID.11 [Patient Address] is used in this version
var addressInUse = false;
var line = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
if (line) {
	addressInUse = true;
	resPatient.address.line.@value = line;
}

var city = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.3&apos;].toString();
if (city) {
	addressInUse = true;
	resPatient.address.city.@value = city;
}

var district = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.9&apos;].toString();
if (district) {
	addressInUse = true;
	resPatient.address.district.@value = district;
}

var state = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.4&apos;].toString();
if (state) {
	addressInUse = true;
	resPatient.address.state.@value = state;
}

var postalCode = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.5&apos;].toString();
if (postalCode) {
	addressInUse = true;
	resPatient.address.postalCode.@value = postalCode;
}

var country = msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.PATIENT&apos;][&apos;PID&apos;][&apos;PID.11&apos;][&apos;XAD.6&apos;].toString();
if (country) {
	addressInUse = true;
	resPatient.address.country.@value = country;
}

if (!addressInUse) delete resPatient.address;

// ============================ RKW ~~ New Stuff

importPackage(Packages.ca.uhn.fhir.context);
importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
importPackage(Packages.ca.uhn.fhir.rest.api);
importPackage(Packages.ca.uhn.fhir.rest.client);

var Url = configurationMap.get(&apos;sparkRawURL&apos;)

var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
var client = ctx.newRestfulGenericClient( Url );
		
ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 
channelMap.put( &quot;ctx&quot;, ctx );

var patientSearchResults = client
	.search()
	.forResource(Patient)
	.where(Packages.ca.uhn.fhir.model.dstu2.resource.Patient.IDENTIFIER.exactly().identifier( patientID ))
	.returnBundle(Bundle)
	.execute();

var ms = patientSearchResults.getEntry();

var msSize = ms.size();

var patientResource;
var patientString;

if( msSize )
{
	var patientResource = ms.get(0).getResource();
	var patientString = ctx.newJsonParser().encodeResourceToString(patientResource);
	
//	logger.error( &quot;Patient: \n&quot; + patientResource.getIdentifier().get(0).getValue() );
//	logger.error( &quot;Patient: \n&quot; + patientString );	
}
else
{
	throw &quot;ORU Processing: Patient Not Found&quot;;
}

var PatientSource = JSON.parse( patientString );
channelMap.put(&quot;PatientResourceID&quot;, PatientSource.id );


 //=========================================================== ~~ RKW Leave - this is part of old code
// Store Patient resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Patient&quot;, resPatient);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Specimen resource</name>
                <script>var arrSpecimen = [];

for each (var spm in msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][&apos;ORU_R01.SPECIMEN&apos;].children() ) {

	var resSpecimen = &lt;Specimen&gt;
					&lt;id value=&quot;&quot;/&gt;
					&lt;type&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/type&gt;
					&lt;subject id=&quot;Patient&quot;/&gt;
					&lt;receivedTime value=&quot;&quot;/&gt;
					&lt;collection&gt;
						&lt;collectedDateTime value=&quot;&quot;/&gt;
						&lt;quantity&gt;
							&lt;value value=&quot;&quot;/&gt;
						&lt;/quantity&gt;
					&lt;/collection&gt;
				&lt;/Specimen&gt;;

	// (SN) Issue #1 - similar Specimen id, Issue #10 - empty Specimen Id
	resSpecimen.id.@value = &quot;spm-specimen-&quot; + spm[&apos;SPM.2&apos;][&apos;EIP.1&apos;][&apos;EI.1&apos;].toString() + &quot;-&quot; + spm[&apos;SPM.2&apos;][&apos;EIP.2&apos;][&apos;EI.1&apos;].toString();

	resSpecimen.type.text.@value = spm[&apos;SPM.4&apos;][&apos;CWE.1&apos;].toString() + &quot;^&quot; + spm[&apos;SPM.4&apos;][&apos;CWE.2&apos;].toString() + &quot;^&quot; + spm[&apos;SPM.4&apos;][&apos;CWE.3&apos;].toString();

	var specimenCollectionDateTime = spm[&apos;SPM.17&apos;][&apos;DR.1&apos;][&apos;TS.1&apos;].toString();
	if (specimenCollectionDateTime) {
		resSpecimen.collection.collectedDateTime.@value = convertHL7DateTime(specimenCollectionDateTime);		
	} else delete resSpecimen.collection.collectedDateTime;

	var specimenReceivedDateTime = spm[&apos;SPM.18&apos;][&apos;TS.1&apos;].toString();
	if (specimenReceivedDateTime) {
		resSpecimen.receivedTime.@value = convertHL7DateTime(specimenReceivedDateTime);		
	} else delete resSpecimen.receivedTime;

	var specimenCollectionAmount = spm[&apos;SPM.12&apos;][&apos;CQ.1&apos;].toString();
	if (specimenCollectionAmount) {
		resSpecimen.collection.quantity.value.@value = specimenCollectionAmount;		
	} else delete resSpecimen.collection.quantity;

	if (specimenCollectionDateTime.length == 0 &amp;&amp; specimenCollectionAmount.length == 0) delete resSpecimen.collection;

	arrSpecimen.push(resSpecimen.toString());
}

// Store Specimen resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Specimen&quot;, arrSpecimen);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var arrSpecimen = [];

for each (var spm in msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][&apos;ORU_R01.SPECIMEN&apos;].children() ) {

	var resSpecimen = &lt;Specimen&gt;
					&lt;id value=&quot;&quot;/&gt;
					&lt;type&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/type&gt;
					&lt;subject id=&quot;Patient&quot;/&gt;
					&lt;receivedTime value=&quot;&quot;/&gt;
					&lt;collection&gt;
						&lt;collectedDateTime value=&quot;&quot;/&gt;
						&lt;quantity&gt;
							&lt;value value=&quot;&quot;/&gt;
						&lt;/quantity&gt;
					&lt;/collection&gt;
				&lt;/Specimen&gt;;

	// (SN) Issue #1 - similar Specimen id, Issue #10 - empty Specimen Id
	resSpecimen.id.@value = &quot;spm-specimen-&quot; + spm[&apos;SPM.2&apos;][&apos;EIP.1&apos;][&apos;EI.1&apos;].toString() + &quot;-&quot; + spm[&apos;SPM.2&apos;][&apos;EIP.2&apos;][&apos;EI.1&apos;].toString();

	resSpecimen.type.text.@value = spm[&apos;SPM.4&apos;][&apos;CWE.1&apos;].toString() + &quot;^&quot; + spm[&apos;SPM.4&apos;][&apos;CWE.2&apos;].toString() + &quot;^&quot; + spm[&apos;SPM.4&apos;][&apos;CWE.3&apos;].toString();

	var specimenCollectionDateTime = spm[&apos;SPM.17&apos;][&apos;DR.1&apos;][&apos;TS.1&apos;].toString();
	if (specimenCollectionDateTime) {
		resSpecimen.collection.collectedDateTime.@value = convertHL7DateTime(specimenCollectionDateTime);		
	} else delete resSpecimen.collection.collectedDateTime;

	var specimenReceivedDateTime = spm[&apos;SPM.18&apos;][&apos;TS.1&apos;].toString();
	if (specimenReceivedDateTime) {
		resSpecimen.receivedTime.@value = convertHL7DateTime(specimenReceivedDateTime);		
	} else delete resSpecimen.receivedTime;

	var specimenCollectionAmount = spm[&apos;SPM.12&apos;][&apos;CQ.1&apos;].toString();
	if (specimenCollectionAmount) {
		resSpecimen.collection.quantity.value.@value = specimenCollectionAmount;		
	} else delete resSpecimen.collection.quantity;

	if (specimenCollectionDateTime.length == 0 &amp;&amp; specimenCollectionAmount.length == 0) delete resSpecimen.collection;

	arrSpecimen.push(resSpecimen.toString());
}

// Store Specimen resource to be processed by FHIR_Submit destination
channelMap.put(&quot;Specimen&quot;, arrSpecimen);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>DiagnosticReport resource</name>
                <script>var arrDiagnosticReport = [];
var arrOrderingProvider = [];
var arrProviderID = [];

/*
* (SN) Practitioner resource for Performing Organization or Medical Doctor is not mapped (see comments below)
*
*/ 

for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	var resDiagnosticReport = &lt;DiagnosticReport&gt;
							&lt;text&gt;
								&lt;status value=&quot;generated&quot;/&gt;
								&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
							&lt;/text&gt;
						&lt;/DiagnosticReport&gt;;
	
	// Process only ORC-OBR-OBX group
	if (observation[&apos;ORC&apos;][&apos;ORC.1&apos;].toString() != &quot;RE&quot;) { continue; }


	// Reference to contained observations
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			logger.error( &quot;OBX Found: &quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString())
			var id = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			var resultReference = &lt;contained&gt;
									&lt;Observation&gt;
										&lt;id value=&quot;&quot;/&gt;
									&lt;/Observation&gt;
								&lt;/contained&gt;;
			resultReference.reference.@value = id;
			resDiagnosticReport.appendChild(resultReference);	
		}
	}

//	resDiagnosticReport.id.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString(); // Filler Order ID ~~ RKW: Fatal Gross Conceptual Error

	// Process Observation Request (OBR) level NTE segments
	// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot; 
	// March 14 2017: Issue #3 &quot;Comments appear twice&quot; fixed 
	resDiagnosticReport.text.*::div.* = new XMLList();
	var observationComment = false;	

	// Extract ORC-OBR-OBX group related comments only
	var orderObservationGroup = new XML(observation.toString());
	
	// March 14: This returns all children and grandchildren NTE segments of the this object
	for each (var nte in orderObservationGroup.descendants(&quot;NTE&quot;)) { 
		
		if (&quot;NTE&quot; == nte.name().toString()) {

			observationComment = true;

			// March 14, 2017: Comment source depends on the group and appended as a prefix 
			var prefix = &quot;&quot;;
			if (nte.parent().name().toString().indexOf(&quot;.ORDER_OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBR&quot;;
			} else if (nte.parent().name().toString().indexOf(&quot;.OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBX&quot;;
			}
			
			// Source of Comment - Optional
			var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
			var source = nte[&apos;NTE.2&apos;].toString();
			
			// Comments contained in the segment - Required
			var comment = nte[&apos;NTE.3&apos;].toString();

			if (commentSources.indexOf(source) &gt; -1) {	
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;-&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
			} else {
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
			}
		}
	}

	if (!observationComment) delete resDiagnosticReport.text;

	// Process single OBR segment
	resDiagnosticReport.appendChild(new XML(&quot;&lt;contained&gt;&quot; + getDiagnosticOrder(observation) + &quot;&lt;/contained&gt;&quot;));

	// Process Ordering Provider
	// (SN) Add only if such Ordering Provider is not in the list already
//	var provID =  observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
//	if (arrProviderID.indexOf(provID) &lt; 0) {
//		arrOrderingProvider.push(getOrderingProvider(observation));
//		arrProviderID.push(provID);
//	}

	// Process multiple OBX segments
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString()) {

			// OBX segments nested under DiagnosticReport as contained resources
			resDiagnosticReport.appendChild(new XML(&quot;&lt;contained&gt;&quot; + getObservationResource(obs) + &quot;&lt;/contained&gt;&quot;));

			// March 14 2017: Process Performing Organization: OBX.23, OBX.24, OBX.25
			var performingOrganization = new XML( getPerformingProvider(obs) );
			if (performingOrganization.contained.Organization) {
				var performID = performingOrganization.contained.Organization.identifier.value.@value.toString();
				if (arrProviderID.indexOf(performID) &lt; 0) {
					arrOrderingProvider.push(performingOrganization.toString());
					arrProviderID.push(performID);
				}
			}
		}	
	}	

	// Placer Order Number - If populated, this field contains the placer application’s order number.
	if (observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString()) {
		var identifier1 = &lt;identifier&gt;
						&lt;type id=&quot;99QDI&quot;/&gt;
						&lt;system value=&quot;&quot;/&gt;
						&lt;value value=&quot;&quot;/&gt;
					&lt;/identifier&gt;;
		identifier1.value.@value = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString();
		identifier1.system.@value = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.2&apos;].toString();
		resDiagnosticReport.appendChild(identifier1);
	}

	// Filler Order Number - The order number associated with the filler’s application. 
	if (observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString()) {
		var identifier2 = &lt;identifier&gt;
						&lt;type id=&quot;99QDI&quot;/&gt;
						&lt;system value=&quot;&quot;/&gt;
						&lt;value value=&quot;&quot;/&gt;
					&lt;/identifier&gt;;
		identifier2.value.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();
		identifier2.system.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.2&apos;].toString();
		resDiagnosticReport.appendChild(identifier2);		
	}

	// Order Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)
	var statusCode = observation[&apos;ORC&apos;][&apos;ORC.5&apos;].toString();
	if (statusCode) {
		var statusXML = &lt;status value=&quot;final&quot;&gt;
						&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
							&lt;valueCodeableConcept&gt;
								&lt;coding&gt;
									&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0038&quot;/&gt;
									&lt;code value=&quot;&quot;/&gt;
									&lt;display value=&quot;&quot;/&gt;
								&lt;/coding&gt;
							&lt;/valueCodeableConcept&gt;
						&lt;/extension&gt;
					&lt;/status&gt;;
		statusXML.extension.valueCodeableConcept.coding.code.@value = statusCode;
		statusXML.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0038&quot;, statusCode);
		resDiagnosticReport.appendChild(statusXML);
	}

	resDiagnosticReport.code.@id = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();

	// Hard-coded, required by FHIR
	resDiagnosticReport.appendChild(new XML(&apos;&lt;subject&gt;&lt;reference value=&quot;Patient&quot;/&gt;&lt;/subject&gt;&apos;));

	// Observation Date/Time
	resDiagnosticReport.effectiveDateTime.@value = convertHL7DateTime(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());
	resDiagnosticReport.issued.@value = convertHL7DateTime(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());
	
	var performer = &lt;performer&gt;
					&lt;reference value=&quot;Practitioner&quot;/&gt;
				&lt;/performer&gt;;
	var orderingProviderID = observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	if (orderingProviderID) {
		performer.reference.@value = &quot;Practitioner/&quot; + observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	} else {
		performer.reference.@value = &quot;Practitioner&quot;;
	}
	resDiagnosticReport.appendChild(performer);

	// Reference to speciments this report is based on
//	for each (var specimen in observation[&apos;ORU_R01.SPECIMEN&apos;].children()) {
//		var id = &quot;Specimen/spm-specimen-&quot; + specimen[&apos;SPM.2&apos;][&apos;EIP.1&apos;][&apos;EI.1&apos;].toString() + &quot;-&quot; + specimen[&apos;SPM.2&apos;][&apos;EIP.2&apos;][&apos;EI.1&apos;].toString();
//		var specimenReference = &lt;specimen&gt;
//								&lt;reference value=&quot;&quot;/&gt;
//							&lt;/specimen&gt;;
//		specimenReference.reference.@value = id;
//		resDiagnosticReport.appendChild(specimenReference);		
//	}

	// Reference to observation this report is based on
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;) {
			var id = &quot;#&quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			var resultReference = &lt;result&gt;
									&lt;reference value=&quot;&quot;/&gt;
							&lt;/result&gt;;
			resultReference.reference.@value = id;
			resDiagnosticReport.appendChild(resultReference);	
		}	
	}

	logger.error( &quot;Diagnostic Report\n:&quot; +  resDiagnosticReport.toString() );

	// ~~ STEPS: 
	// 1. Query for DiagnosticOrder (mostly for the resource ID)
	// 2. Pull array of Observations for each Order/Report
	// 3. Put Observations into Diagnostic Report
	// 4. Assemble array of Attachments
	// 5. Populate Conclusion
	// 4. Insert Diagnostic Report
	//
	// NOTE: Decide if we really need specimen, performer
	
//	arrDiagnosticReport.push(resDiagnosticReport.toString());
}

// Store DiagnosticReport resource to be processed by FHIR_Submit destination
//channelMap.put(&quot;DiagnosticReport&quot;, arrDiagnosticReport);

// Store Practitioner resource to be processed by FHIR_Submit destination
//channelMap.put(&quot;Practitioner&quot;, arrOrderingProvider);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var arrDiagnosticReport = [];
var arrOrderingProvider = [];
var arrProviderID = [];

/*
* (SN) Practitioner resource for Performing Organization or Medical Doctor is not mapped (see comments below)
*
*/ 

for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	var resDiagnosticReport = &lt;DiagnosticReport&gt;
							&lt;text&gt;
								&lt;status value=&quot;generated&quot;/&gt;
								&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;
							&lt;/text&gt;
						&lt;/DiagnosticReport&gt;;
	
	// Process only ORC-OBR-OBX group
	if (observation[&apos;ORC&apos;][&apos;ORC.1&apos;].toString() != &quot;RE&quot;) { continue; }


	// Reference to contained observations
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			logger.error( &quot;OBX Found: &quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString())
			var id = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			var resultReference = &lt;contained&gt;
									&lt;Observation&gt;
										&lt;id value=&quot;&quot;/&gt;
									&lt;/Observation&gt;
								&lt;/contained&gt;;
			resultReference.reference.@value = id;
			resDiagnosticReport.appendChild(resultReference);	
		}
	}

//	resDiagnosticReport.id.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString(); // Filler Order ID ~~ RKW: Fatal Gross Conceptual Error

	// Process Observation Request (OBR) level NTE segments
	// (SN) Known deficiency - &quot;p&quot; element namespace is not bound, must be &quot;xhtml:p&quot; 
	// March 14 2017: Issue #3 &quot;Comments appear twice&quot; fixed 
	resDiagnosticReport.text.*::div.* = new XMLList();
	var observationComment = false;	

	// Extract ORC-OBR-OBX group related comments only
	var orderObservationGroup = new XML(observation.toString());
	
	// March 14: This returns all children and grandchildren NTE segments of the this object
	for each (var nte in orderObservationGroup.descendants(&quot;NTE&quot;)) { 
		
		if (&quot;NTE&quot; == nte.name().toString()) {

			observationComment = true;

			// March 14, 2017: Comment source depends on the group and appended as a prefix 
			var prefix = &quot;&quot;;
			if (nte.parent().name().toString().indexOf(&quot;.ORDER_OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBR&quot;;
			} else if (nte.parent().name().toString().indexOf(&quot;.OBSERVATION&quot;) &gt; -1) {
				prefix = &quot;OBX&quot;;
			}
			
			// Source of Comment - Optional
			var commentSources = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;];
			var source = nte[&apos;NTE.2&apos;].toString();
			
			// Comments contained in the segment - Required
			var comment = nte[&apos;NTE.3&apos;].toString();

			if (commentSources.indexOf(source) &gt; -1) {	
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;-&apos; + source + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);
			} else {
				resDiagnosticReport.text.*::div.* += new XML(&apos;&lt;p class=&quot;&apos; + prefix + &apos;&quot;&gt;&apos; + stripNonValidXMLChars(comment) +&apos;&lt;/p&gt;&apos;);	
			}
		}
	}

	if (!observationComment) delete resDiagnosticReport.text;

	// Process single OBR segment
	resDiagnosticReport.appendChild(new XML(&quot;&lt;contained&gt;&quot; + getDiagnosticOrder(observation) + &quot;&lt;/contained&gt;&quot;));

	// Process Ordering Provider
	// (SN) Add only if such Ordering Provider is not in the list already
//	var provID =  observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
//	if (arrProviderID.indexOf(provID) &lt; 0) {
//		arrOrderingProvider.push(getOrderingProvider(observation));
//		arrProviderID.push(provID);
//	}

	// Process multiple OBX segments
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString()) {

			// OBX segments nested under DiagnosticReport as contained resources
			resDiagnosticReport.appendChild(new XML(&quot;&lt;contained&gt;&quot; + getObservationResource(obs) + &quot;&lt;/contained&gt;&quot;));

			// March 14 2017: Process Performing Organization: OBX.23, OBX.24, OBX.25
			var performingOrganization = new XML( getPerformingProvider(obs) );
			if (performingOrganization.contained.Organization) {
				var performID = performingOrganization.contained.Organization.identifier.value.@value.toString();
				if (arrProviderID.indexOf(performID) &lt; 0) {
					arrOrderingProvider.push(performingOrganization.toString());
					arrProviderID.push(performID);
				}
			}
		}	
	}	

	// Placer Order Number - If populated, this field contains the placer application’s order number.
	if (observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString()) {
		var identifier1 = &lt;identifier&gt;
						&lt;type id=&quot;99QDI&quot;/&gt;
						&lt;system value=&quot;&quot;/&gt;
						&lt;value value=&quot;&quot;/&gt;
					&lt;/identifier&gt;;
		identifier1.value.@value = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString();
		identifier1.system.@value = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.2&apos;].toString();
		resDiagnosticReport.appendChild(identifier1);
	}

	// Filler Order Number - The order number associated with the filler’s application. 
	if (observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString()) {
		var identifier2 = &lt;identifier&gt;
						&lt;type id=&quot;99QDI&quot;/&gt;
						&lt;system value=&quot;&quot;/&gt;
						&lt;value value=&quot;&quot;/&gt;
					&lt;/identifier&gt;;
		identifier2.value.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();
		identifier2.system.@value = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.2&apos;].toString();
		resDiagnosticReport.appendChild(identifier2);		
	}

	// Order Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)
	var statusCode = observation[&apos;ORC&apos;][&apos;ORC.5&apos;].toString();
	if (statusCode) {
		var statusXML = &lt;status value=&quot;final&quot;&gt;
						&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
							&lt;valueCodeableConcept&gt;
								&lt;coding&gt;
									&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0038&quot;/&gt;
									&lt;code value=&quot;&quot;/&gt;
									&lt;display value=&quot;&quot;/&gt;
								&lt;/coding&gt;
							&lt;/valueCodeableConcept&gt;
						&lt;/extension&gt;
					&lt;/status&gt;;
		statusXML.extension.valueCodeableConcept.coding.code.@value = statusCode;
		statusXML.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0038&quot;, statusCode);
		resDiagnosticReport.appendChild(statusXML);
	}

	resDiagnosticReport.code.@id = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();

	// Hard-coded, required by FHIR
	resDiagnosticReport.appendChild(new XML(&apos;&lt;subject&gt;&lt;reference value=&quot;Patient&quot;/&gt;&lt;/subject&gt;&apos;));

	// Observation Date/Time
	resDiagnosticReport.effectiveDateTime.@value = convertHL7DateTime(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());
	resDiagnosticReport.issued.@value = convertHL7DateTime(observation[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());
	
	var performer = &lt;performer&gt;
					&lt;reference value=&quot;Practitioner&quot;/&gt;
				&lt;/performer&gt;;
	var orderingProviderID = observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	if (orderingProviderID) {
		performer.reference.@value = &quot;Practitioner/&quot; + observation[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	} else {
		performer.reference.@value = &quot;Practitioner&quot;;
	}
	resDiagnosticReport.appendChild(performer);

	// Reference to speciments this report is based on
//	for each (var specimen in observation[&apos;ORU_R01.SPECIMEN&apos;].children()) {
//		var id = &quot;Specimen/spm-specimen-&quot; + specimen[&apos;SPM.2&apos;][&apos;EIP.1&apos;][&apos;EI.1&apos;].toString() + &quot;-&quot; + specimen[&apos;SPM.2&apos;][&apos;EIP.2&apos;][&apos;EI.1&apos;].toString();
//		var specimenReference = &lt;specimen&gt;
//								&lt;reference value=&quot;&quot;/&gt;
//							&lt;/specimen&gt;;
//		specimenReference.reference.@value = id;
//		resDiagnosticReport.appendChild(specimenReference);		
//	}

	// Reference to observation this report is based on
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) {
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;) {
			var id = &quot;#&quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			var resultReference = &lt;result&gt;
									&lt;reference value=&quot;&quot;/&gt;
							&lt;/result&gt;;
			resultReference.reference.@value = id;
			resDiagnosticReport.appendChild(resultReference);	
		}	
	}

	logger.error( &quot;Diagnostic Report\n:&quot; +  resDiagnosticReport.toString() );

	// ~~ STEPS: 
	// 1. Query for DiagnosticOrder (mostly for the resource ID)
	// 2. Pull array of Observations for each Order/Report
	// 3. Put Observations into Diagnostic Report
	// 4. Assemble array of Attachments
	// 5. Populate Conclusion
	// 4. Insert Diagnostic Report
	//
	// NOTE: Decide if we really need specimen, performer
	
//	arrDiagnosticReport.push(resDiagnosticReport.toString());
}

// Store DiagnosticReport resource to be processed by FHIR_Submit destination
//channelMap.put(&quot;DiagnosticReport&quot;, arrDiagnosticReport);

// Store Practitioner resource to be processed by FHIR_Submit destination
//channelMap.put(&quot;Practitioner&quot;, arrOrderingProvider);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>3</sequenceNumber>
                <name>Functions pool</name>
                <script>/**
	Creates the DiagnosticOrder resourse with OBR segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return DiagnosticOrder XML string
*/
/*
function getDiagnosticOrder(obs) {


(SN) Following fields are not mapped in this version:
* OBR.26 [Parent Result] - Optional - If OBR.11 (Specimen Action Code) is populated, then this field is populated with the data in the parent OBX.03 (Observation Identifier) subfield.
* OBR.29 [Parent] - Optional - This field is populated if OBR.11 (Specimen Action Code) is populated.
* OBR.50 [Parent Universal Service Identifier] - Optional - The universal service identifier of the parent order. This field is populated if OBR.11 (Specimen Action Code) is populated.

	var diagnosticOrder = &lt;DiagnosticOrder&gt;
					&lt;id value=&quot;obr-observation-request&quot;/&gt;
					&lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/diagnosticorder-precondition&quot;&gt;
						&lt;valueDateTime value=&quot;&quot;/&gt;
					&lt;/extension&gt;
					&lt;subject id=&quot;Patient&quot;/&gt;
					&lt;event&gt;
						&lt;status value=&quot;completed&quot;&gt;
							&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
								&lt;valueCodeableConcept&gt;
									&lt;coding&gt;
										&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0123&quot;/&gt;
										&lt;code value=&quot;&quot;/&gt;
										&lt;display value=&quot;&quot;/&gt;
									&lt;/coding&gt;
								&lt;/valueCodeableConcept&gt;
							&lt;/extension&gt;
						&lt;/status&gt;
						&lt;dateTime value=&quot;&quot;/&gt;
						&lt;actor&gt;
							&lt;reference value=&quot;Practitioner/ordering-provider&quot;/&gt;
						&lt;/actor&gt;
					&lt;/event&gt;
					&lt;item&gt;
						&lt;code&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/code&gt;
						&lt;specimen&gt;
							&lt;display value=&quot;G&quot;/&gt;
						&lt;/specimen&gt;
					&lt;/item&gt;
				&lt;/DiagnosticOrder&gt;;

	diagnosticOrder.extension.valueDateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());

	var resultHandling = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	if (resultHandling) {
		diagnosticOrder.supportingInformation.display.@value = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	} else {
		delete diagnosticOrder.supportingInformation;
	}

	// Result Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBR&apos;][&apos;OBR.25&apos;].toString();
	if (statusCode) {
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0123&quot;, statusCode);
	}

	//  The date/time the results were reported or status changed
	diagnosticOrder.event.dateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;TS.1&apos;].toString());

	// Quest samples contain local and LOINC codes
	diagnosticOrder.item.code.coding.system.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.3&apos;].toString();
	diagnosticOrder.item.code.coding.code.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	diagnosticOrder.item.code.coding.display.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.2&apos;].toString();

	// Specimen Action Code
	var specimenActionCode = obs[&apos;OBR&apos;][&apos;OBR.11&apos;].toString();
	if (specimenActionCode) {
		diagnosticOrder.item.specimen.display.@value = specimenActionCode;
	} else {
		delete diagnosticOrder.item.specimen;
	}

	return diagnosticOrder.toString();
}
*/

/**
	Creates the Observation resourse with a single OBX segment mappings

	@param {String} obs - original ORU_R01.OBSERVATION XML string
	@return {String} return Observation XML string
*/
function getObservationResource(obs) {

	var obsResource = &lt;Observation&gt;
					&lt;id value=&quot;OBX-observation-result&quot;/&gt;					
					&lt;identifier id=&quot;&quot;/&gt;
					&lt;status value=&quot;final&quot;&gt;
						&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
							&lt;valueCodeableConcept&gt;
								&lt;coding&gt;
									&lt;system value=&quot;http://hl7.
									
									org/fhir/ValueSet/v2-0085&quot;/&gt;
									&lt;code value=&quot;F&quot;/&gt;
									&lt;display value=&quot;Final results; can only be changed with a corrected result&quot;/&gt;
								&lt;/coding&gt;
							&lt;/valueCodeableConcept&gt;
						&lt;/extension&gt;
					&lt;/status&gt;
					&lt;code&gt;
						&lt;extension url=&quot;http://www.questdiagnostics.com&quot;&gt;
							&lt;valueCoding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/valueCoding&gt;
						&lt;/extension&gt;
						&lt;coding&gt;
							&lt;system value=&quot;http://loinc.org&quot;/&gt;
							&lt;code value=&quot;&quot;/&gt;
							&lt;display value=&quot;&quot;/&gt;
						&lt;/coding&gt;
					&lt;/code&gt;
					&lt;effectiveDateTime value=&quot;&quot;/&gt;
					&lt;issued value=&quot;&quot;/&gt;
					&lt;performer&gt;
						&lt;reference value=&quot;Practitioner/obx-performing-organization&quot;/&gt;
					&lt;/performer&gt;
					&lt;valueString value=&quot;&quot;/&gt;
					&lt;interpretation&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/interpretation&gt;
					&lt;referenceRange&gt;
						&lt;meaning&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/meaning&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/referenceRange&gt;
				&lt;/Observation&gt;;

	obsResource.id.@value= obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();

	obsResource.identifier.@id = obs[&apos;OBX.1&apos;].toString();

	// Result Status - the status of the result value
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBX.11&apos;].toString();
	if (statusCode) {
		 obsResource.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 obsResource.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0085&quot;, statusCode);
	}

	
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) {
		// Care360 own coding
		obsResource.code.extension.valueCoding.system.@value = obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.extension.valueCoding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.extension.valueCoding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();

		// LOINC coding
		obsResource.code.coding.system.@value = &quot;http://loinc.org&quot;;
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString();		
	} else {
		delete obsResource.code.extension;
		obsResource.code.coding.system.@value = obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();			
	}

	var dateTimeOfObservation = obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfObservation) {
		obsResource.effectiveDateTime.@value = convertHL7DateTime(dateTimeOfObservation);
	} else {
		delete obsResource.effectiveDateTime;
	}

	var dateTimeOfAnalysis = obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfAnalysis) {
		obsResource.issued.@value = convertHL7DateTime(dateTimeOfAnalysis);
	} else {
		delete obsResource.issued;
	}

	// March 15: Issues #13: OBX.5 [Observation Value] using SN (Structured Numeric) data type
	var observationValue = &quot;&quot;;
	if (obs[&apos;OBX.5&apos;][&apos;SN.3&apos;]) {
		for each (var sn in obs[&apos;OBX.5&apos;].children()) {
			if (sn.toString()) observationValue += sn.toString(); 
		}
	} else {
		observationValue = obs[&apos;OBX.5&apos;].toString();
	}
	
	if (observationValue) {
		obsResource.valueString.@value = observationValue;
	} else {
		delete obsResource.valueString;
	}

	var abnormalFlags = obs[&apos;OBX.8&apos;].toString();
	if (abnormalFlags) {
		obsResource.interpretation.text.@value = abnormalFlags;
	} else {
		delete obsResource.interpretation;
	}

	var unitsOfMeasure = obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString();
	var meaningPresent = true;
	if (unitsOfMeasure) {
		obsResource.referenceRange.meaning.coding.code.@value = unitsOfMeasure;
		if (obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.system.@value = obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.system;
		}
		if (obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.display.@value = obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.display;
		}
	} else {
		delete obsResource.referenceRange.meaning;
		meaningPresent = false;
	}
	
	var referencesRange = obs[&apos;OBX.7&apos;].toString();
	var rangePresent = true;
	if (referencesRange) {
		obsResource.referenceRange.text.@value = referencesRange;
	} else {
		delete obsResource.referenceRange.text;
		rangePresent = false;
	}

	if (!meaningPresent &amp;&amp; !rangePresent) delete obsResource.referenceRange;

	// Reference to performing organization
	obsResource.performer.reference.@value=&quot;Practitioner/obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	
	return obsResource.toString();
	
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates the DiagnosticOrder resourse with OBR segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return DiagnosticOrder XML string
*/
/*
function getDiagnosticOrder(obs) {


(SN) Following fields are not mapped in this version:
* OBR.26 [Parent Result] - Optional - If OBR.11 (Specimen Action Code) is populated, then this field is populated with the data in the parent OBX.03 (Observation Identifier) subfield.
* OBR.29 [Parent] - Optional - This field is populated if OBR.11 (Specimen Action Code) is populated.
* OBR.50 [Parent Universal Service Identifier] - Optional - The universal service identifier of the parent order. This field is populated if OBR.11 (Specimen Action Code) is populated.

	var diagnosticOrder = &lt;DiagnosticOrder&gt;
					&lt;id value=&quot;obr-observation-request&quot;/&gt;
					&lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/diagnosticorder-precondition&quot;&gt;
						&lt;valueDateTime value=&quot;&quot;/&gt;
					&lt;/extension&gt;
					&lt;subject id=&quot;Patient&quot;/&gt;
					&lt;event&gt;
						&lt;status value=&quot;completed&quot;&gt;
							&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
								&lt;valueCodeableConcept&gt;
									&lt;coding&gt;
										&lt;system value=&quot;http://hl7.org/fhir/ValueSet/v2-0123&quot;/&gt;
										&lt;code value=&quot;&quot;/&gt;
										&lt;display value=&quot;&quot;/&gt;
									&lt;/coding&gt;
								&lt;/valueCodeableConcept&gt;
							&lt;/extension&gt;
						&lt;/status&gt;
						&lt;dateTime value=&quot;&quot;/&gt;
						&lt;actor&gt;
							&lt;reference value=&quot;Practitioner/ordering-provider&quot;/&gt;
						&lt;/actor&gt;
					&lt;/event&gt;
					&lt;item&gt;
						&lt;code&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/code&gt;
						&lt;specimen&gt;
							&lt;display value=&quot;G&quot;/&gt;
						&lt;/specimen&gt;
					&lt;/item&gt;
				&lt;/DiagnosticOrder&gt;;

	diagnosticOrder.extension.valueDateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;TS.1&apos;].toString());

	var resultHandling = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	if (resultHandling) {
		diagnosticOrder.supportingInformation.display.@value = obs[&apos;OBR&apos;][&apos;OBR.49&apos;].toString();
	} else {
		delete diagnosticOrder.supportingInformation;
	}

	// Result Status - Indicates whether the result is partial or final.
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBR&apos;][&apos;OBR.25&apos;].toString();
	if (statusCode) {
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 diagnosticOrder.event.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0123&quot;, statusCode);
	}

	//  The date/time the results were reported or status changed
	diagnosticOrder.event.dateTime.@value = convertHL7DateTime(obs[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;TS.1&apos;].toString());

	// Quest samples contain local and LOINC codes
	diagnosticOrder.item.code.coding.system.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.3&apos;].toString();
	diagnosticOrder.item.code.coding.code.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	diagnosticOrder.item.code.coding.display.@value = obs[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.2&apos;].toString();

	// Specimen Action Code
	var specimenActionCode = obs[&apos;OBR&apos;][&apos;OBR.11&apos;].toString();
	if (specimenActionCode) {
		diagnosticOrder.item.specimen.display.@value = specimenActionCode;
	} else {
		delete diagnosticOrder.item.specimen;
	}

	return diagnosticOrder.toString();
}
*/

/**
	Creates the Observation resourse with a single OBX segment mappings

	@param {String} obs - original ORU_R01.OBSERVATION XML string
	@return {String} return Observation XML string
*/
function getObservationResource(obs) {

	var obsResource = &lt;Observation&gt;
					&lt;id value=&quot;OBX-observation-result&quot;/&gt;					
					&lt;identifier id=&quot;&quot;/&gt;
					&lt;status value=&quot;final&quot;&gt;
						&lt;extension url=&quot;http://hl7.org/fhir/ValueSet&quot;&gt;
							&lt;valueCodeableConcept&gt;
								&lt;coding&gt;
									&lt;system value=&quot;http://hl7.
									
									org/fhir/ValueSet/v2-0085&quot;/&gt;
									&lt;code value=&quot;F&quot;/&gt;
									&lt;display value=&quot;Final results; can only be changed with a corrected result&quot;/&gt;
								&lt;/coding&gt;
							&lt;/valueCodeableConcept&gt;
						&lt;/extension&gt;
					&lt;/status&gt;
					&lt;code&gt;
						&lt;extension url=&quot;http://www.questdiagnostics.com&quot;&gt;
							&lt;valueCoding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/valueCoding&gt;
						&lt;/extension&gt;
						&lt;coding&gt;
							&lt;system value=&quot;http://loinc.org&quot;/&gt;
							&lt;code value=&quot;&quot;/&gt;
							&lt;display value=&quot;&quot;/&gt;
						&lt;/coding&gt;
					&lt;/code&gt;
					&lt;effectiveDateTime value=&quot;&quot;/&gt;
					&lt;issued value=&quot;&quot;/&gt;
					&lt;performer&gt;
						&lt;reference value=&quot;Practitioner/obx-performing-organization&quot;/&gt;
					&lt;/performer&gt;
					&lt;valueString value=&quot;&quot;/&gt;
					&lt;interpretation&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/interpretation&gt;
					&lt;referenceRange&gt;
						&lt;meaning&gt;
							&lt;coding&gt;
								&lt;system value=&quot;&quot;/&gt;
								&lt;code value=&quot;&quot;/&gt;
								&lt;display value=&quot;&quot;/&gt;
							&lt;/coding&gt;
						&lt;/meaning&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/referenceRange&gt;
				&lt;/Observation&gt;;

	obsResource.id.@value= obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();

	obsResource.identifier.@id = obs[&apos;OBX.1&apos;].toString();

	// Result Status - the status of the result value
	// March 25 2017: updated to pass API validation (see Terminology Mapping spreadsheet)	
	var statusCode = obs[&apos;OBX.11&apos;].toString();
	if (statusCode) {
		 obsResource.status.extension.valueCodeableConcept.coding.code.@value = statusCode;
		 obsResource.status.extension.valueCodeableConcept.coding.display.@value = getHL7v2CodeDescription(&quot;0085&quot;, statusCode);
	}

	
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) {
		// Care360 own coding
		obsResource.code.extension.valueCoding.system.@value = obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.extension.valueCoding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.extension.valueCoding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();

		// LOINC coding
		obsResource.code.coding.system.@value = &quot;http://loinc.org&quot;;
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString();		
	} else {
		delete obsResource.code.extension;
		obsResource.code.coding.system.@value = obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString();
		obsResource.code.coding.code.@value = obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
		obsResource.code.coding.display.@value = obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString();			
	}

	var dateTimeOfObservation = obs[&apos;OBX.14&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfObservation) {
		obsResource.effectiveDateTime.@value = convertHL7DateTime(dateTimeOfObservation);
	} else {
		delete obsResource.effectiveDateTime;
	}

	var dateTimeOfAnalysis = obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString();
	if (dateTimeOfAnalysis) {
		obsResource.issued.@value = convertHL7DateTime(dateTimeOfAnalysis);
	} else {
		delete obsResource.issued;
	}

	// March 15: Issues #13: OBX.5 [Observation Value] using SN (Structured Numeric) data type
	var observationValue = &quot;&quot;;
	if (obs[&apos;OBX.5&apos;][&apos;SN.3&apos;]) {
		for each (var sn in obs[&apos;OBX.5&apos;].children()) {
			if (sn.toString()) observationValue += sn.toString(); 
		}
	} else {
		observationValue = obs[&apos;OBX.5&apos;].toString();
	}
	
	if (observationValue) {
		obsResource.valueString.@value = observationValue;
	} else {
		delete obsResource.valueString;
	}

	var abnormalFlags = obs[&apos;OBX.8&apos;].toString();
	if (abnormalFlags) {
		obsResource.interpretation.text.@value = abnormalFlags;
	} else {
		delete obsResource.interpretation;
	}

	var unitsOfMeasure = obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString();
	var meaningPresent = true;
	if (unitsOfMeasure) {
		obsResource.referenceRange.meaning.coding.code.@value = unitsOfMeasure;
		if (obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.system.@value = obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.system;
		}
		if (obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString() != &quot;&quot;) {
			obsResource.referenceRange.meaning.coding.display.@value = obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString();
		} else {
			delete obsResource.referenceRange.meaning.coding.display;
		}
	} else {
		delete obsResource.referenceRange.meaning;
		meaningPresent = false;
	}
	
	var referencesRange = obs[&apos;OBX.7&apos;].toString();
	var rangePresent = true;
	if (referencesRange) {
		obsResource.referenceRange.text.@value = referencesRange;
	} else {
		delete obsResource.referenceRange.text;
		rangePresent = false;
	}

	if (!meaningPresent &amp;&amp; !rangePresent) delete obsResource.referenceRange;

	// Reference to performing organization
	obsResource.performer.reference.@value=&quot;Practitioner/obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	
	return obsResource.toString();
	
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>4</sequenceNumber>
                <name>Practitioner (Ordering Provider) resource</name>
                <script>/**
	Creates the Practitioner resourse for Ordering Provider with ORC segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getOrderingProvider(obs) {

	// Mar 16 update: /Practitioner/practitionerRole/organization is changed to 
	// /Practitioner/practitionerRole/managingOrganization - tooling issue on the &quot;left side&quot;
	// Note: this breaks STU3 1.4.0 XML Schema validation

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;ordering-provider&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;id value=&quot;orc21-ordering-facility-1&quot;/&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
								&lt;/identifier&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;telecom&gt;
									&lt;system value=&quot;phone&quot;/&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;use value=&quot;work&quot;/&gt;
								&lt;/telecom&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;system value=&quot;NPI&quot;/&gt;
							&lt;value value=&quot;&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
						&lt;practitionerRole&gt;
							&lt;managingOrganization&gt;
								&lt;reference value=&quot;Organization/orc21-ordering-facility-1&quot;/&gt;
							&lt;/managingOrganization&gt;
						&lt;/practitionerRole&gt;
					&lt;/Practitioner&gt;;

	// Practitioner&apos;s own ID
	resPractitioner.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.system.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.13&apos;].toString();

	// Organization this Practitioner belongs to
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.1&apos;].toString();

	// Organization telecom
	var telecom = &quot;(&quot; + obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.6&apos;].toString() + &quot;) &quot; + convertPhone(obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.7&apos;].toString());
	if (telecom.length &gt; 4) {
		resPractitioner.contained.Organization.telecom.value.@value = telecom;
	} else delete resPractitioner.contained.Organization.telecom;

	// Organization address
	var addressInUse = false;
	var line = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;

	// Practitioner name
	var familyName = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);	
	} else {
		delete resPractitioner.name;
	}

	return resPractitioner.toString();	
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates the Practitioner resourse for Ordering Provider with ORC segment mappings

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getOrderingProvider(obs) {

	// Mar 16 update: /Practitioner/practitionerRole/organization is changed to 
	// /Practitioner/practitionerRole/managingOrganization - tooling issue on the &quot;left side&quot;
	// Note: this breaks STU3 1.4.0 XML Schema validation

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;ordering-provider&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;id value=&quot;orc21-ordering-facility-1&quot;/&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
								&lt;/identifier&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;telecom&gt;
									&lt;system value=&quot;phone&quot;/&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;use value=&quot;work&quot;/&gt;
								&lt;/telecom&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;system value=&quot;NPI&quot;/&gt;
							&lt;value value=&quot;&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
						&lt;practitionerRole&gt;
							&lt;managingOrganization&gt;
								&lt;reference value=&quot;Organization/orc21-ordering-facility-1&quot;/&gt;
							&lt;/managingOrganization&gt;
						&lt;/practitionerRole&gt;
					&lt;/Practitioner&gt;;

	// Practitioner&apos;s own ID
	resPractitioner.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.system.@value = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.13&apos;].toString();

	// Organization this Practitioner belongs to
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;ORC&apos;][&apos;ORC.21&apos;][&apos;XON.1&apos;].toString();

	// Organization telecom
	var telecom = &quot;(&quot; + obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.6&apos;].toString() + &quot;) &quot; + convertPhone(obs[&apos;ORC&apos;][&apos;ORC.23&apos;][&apos;XTN.7&apos;].toString());
	if (telecom.length &gt; 4) {
		resPractitioner.contained.Organization.telecom.value.@value = telecom;
	} else delete resPractitioner.contained.Organization.telecom;

	// Organization address
	var addressInUse = false;
	var line = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;

	// Practitioner name
	var familyName = obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;ORC&apos;][&apos;ORC.12&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);	
	} else {
		delete resPractitioner.name;
	}

	return resPractitioner.toString();	
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>5</sequenceNumber>
                <name>Practitioner (Performing Organization) resource</name>
                <script>/**
	Creates the Practitioner resourse for OBX.23 [Performing Organization Name],
	OBX.24 [Performing Organization Address] and OBX.25[Performing Organization Medical Director] for each OBX segment

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getPerformingProvider(obs) {

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;obx-performing-organization&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;assigner id=&quot;CLIA&quot;/&gt;
								&lt;/identifier&gt;
								&lt;type&gt;
									&lt;text value=&quot;FI&quot;/&gt;
								&lt;/type&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;type&gt;
								&lt;text value=&quot;NPI&quot;/&gt;
							&lt;/type&gt;
							&lt;value value=&quot;&quot;/&gt;
							&lt;assigner id=&quot;EN&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
					&lt;/Practitioner&gt;;

	// Performing Organization Name
	resPractitioner.id.@value = &quot;obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;OBX.23&apos;][&apos;XON.1&apos;].toString();
	

	// Performing Organization Address
	var addressInUse = false;
	var line = obs[&apos;OBX.24&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;OBX.24&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;OBX.24&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;OBX.24&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;


	// Medical Director
	resPractitioner.identifier.value.@value = obs[&apos;OBX.25&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.assigner.@id = obs[&apos;OBX.25&apos;][&apos;XCN.14&apos;][&apos;HD.1&apos;].toString()

	// Medical Director Name
	var familyName = obs[&apos;OBX.25&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;suffix value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString() +&apos;&quot;/&gt;&apos;);				
	} else {
		delete resPractitioner.name;
	}

	
	return resPractitioner.toString();		
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates the Practitioner resourse for OBX.23 [Performing Organization Name],
	OBX.24 [Performing Organization Address] and OBX.25[Performing Organization Medical Director] for each OBX segment

	@param {String} obs - original ORU_R01.ORDER_OBSERVATION XML string
	@return {String} return Practitioner XML string
*/
function getPerformingProvider(obs) {

	var resPractitioner = &lt;Practitioner&gt;
						&lt;id value=&quot;obx-performing-organization&quot;/&gt;
						&lt;contained&gt;
							&lt;Organization&gt;
								&lt;identifier&gt;
									&lt;value value=&quot;&quot;/&gt;
									&lt;assigner id=&quot;CLIA&quot;/&gt;
								&lt;/identifier&gt;
								&lt;type&gt;
									&lt;text value=&quot;FI&quot;/&gt;
								&lt;/type&gt;
								&lt;name value=&quot;&quot;/&gt;
								&lt;address&gt;
									&lt;line value=&quot;&quot;/&gt;
									&lt;city value=&quot;&quot;/&gt;
									&lt;state value=&quot;&quot;/&gt;
									&lt;postalCode value=&quot;&quot;/&gt;
								&lt;/address&gt;
							&lt;/Organization&gt;
						&lt;/contained&gt;
						&lt;identifier&gt;
							&lt;type&gt;
								&lt;text value=&quot;NPI&quot;/&gt;
							&lt;/type&gt;
							&lt;value value=&quot;&quot;/&gt;
							&lt;assigner id=&quot;EN&quot;/&gt;
						&lt;/identifier&gt;
						&lt;name/&gt;
					&lt;/Practitioner&gt;;

	// Performing Organization Name
	resPractitioner.id.@value = &quot;obx-performing-organization-&quot; + obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.identifier.value.@value = obs[&apos;OBX.23&apos;][&apos;XON.10&apos;].toString();
	resPractitioner.contained.Organization.name.@value = obs[&apos;OBX.23&apos;][&apos;XON.1&apos;].toString();
	

	// Performing Organization Address
	var addressInUse = false;
	var line = obs[&apos;OBX.24&apos;][&apos;XAD.1&apos;][&apos;SAD.1&apos;].toString();
	if (line) {
		addressInUse = true;
		resPractitioner.contained.Organization.address.line.@value = line;
	}

	var city = obs[&apos;OBX.24&apos;][&apos;XAD.3&apos;].toString();
	if (city) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.city.@value = city;
	}

	var state = obs[&apos;OBX.24&apos;][&apos;XAD.4&apos;].toString();
	if (state) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.state.@value = state;
	}	

	var postalCode = obs[&apos;OBX.24&apos;][&apos;XAD.5&apos;].toString();
	if (postalCode) {
		addressInUse = true;		
		resPractitioner.contained.Organization.address.postalCode.@value = postalCode;
	}

	if (!addressInUse) delete resPractitioner.contained.Organization.address;


	// Medical Director
	resPractitioner.identifier.value.@value = obs[&apos;OBX.25&apos;][&apos;XCN.1&apos;].toString();
	resPractitioner.identifier.assigner.@id = obs[&apos;OBX.25&apos;][&apos;XCN.14&apos;][&apos;HD.1&apos;].toString()

	// Medical Director Name
	var familyName = obs[&apos;OBX.25&apos;][&apos;XCN.2&apos;][&apos;FN.1&apos;].toString();
	if (familyName) {
		resPractitioner.name.* = new XMLList();
		resPractitioner.name.* += new XML(&apos;&lt;family value=&quot;&apos; + familyName +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.3&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;given value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.4&apos;].toString() +&apos;&quot;/&gt;&apos;);
		if (obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString())
			resPractitioner.name.* += new XML(&apos;&lt;suffix value=&quot;&apos; + obs[&apos;OBX.25&apos;][&apos;XCN.5&apos;].toString() +&apos;&quot;/&gt;&apos;);				
	} else {
		delete resPractitioner.name;
	}

	
	return resPractitioner.toString();		
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>true</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>2</metaDataId>
          <name>ORU_R01_2.3.x</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>3</metaDataId>
          <name>FHIR_submit</name>
          <properties class="com.mirth.connect.connectors.http.HttpDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <host>${SparkURL}</host>
            <useProxyServer>false</useProxyServer>
            <proxyAddress></proxyAddress>
            <proxyPort></proxyPort>
            <method>post</method>
            <headers class="linked-hash-map"/>
            <parameters class="linked-hash-map"/>
            <responseXmlBody>true</responseXmlBody>
            <responseParseMultipart>true</responseParseMultipart>
            <responseIncludeMetadata>false</responseIncludeMetadata>
            <responseBinaryMimeTypes>application/xml</responseBinaryMimeTypes>
            <responseBinaryMimeTypesRegex>true</responseBinaryMimeTypesRegex>
            <multipart>false</multipart>
            <useAuthentication>false</useAuthentication>
            <authenticationType>Basic</authenticationType>
            <usePreemptiveAuthentication>false</usePreemptiveAuthentication>
            <username></username>
            <password></password>
            <content>${ORUBundle}</content>
            <contentType>application/xml</contentType>
            <dataTypeBinary>false</dataTypeBinary>
            <charset>UTF-8</charset>
            <socketTimeout>30000</socketTimeout>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Construct Bundle</name>
                <script>var resBundle = &lt;Bundle xmlns=&quot;http://hl7.org/fhir&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
		&lt;type value=&quot;message&quot;/&gt;
	&lt;/Bundle&gt;;

// Patient resource
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resPatient = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + channelMap.get(&quot;Patient&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBundle.appendChild(resPatient);

// DiagnosticReport resource
addEntry(&quot;DiagnosticReport&quot;);

// Practitioner resource for Ordering Provider
addEntry(&quot;Practitioner&quot;);

// Specimen resource
addEntry(&quot;Specimen&quot;);

// Binary resourse with original HL7v2 ORU_R01 message
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resBinary = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + globalChannelMap.get(&quot;Binary&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBinary.resource.Binary.id.@value = &quot;oru-r01-&quot; + channelMap.get(&quot;MessageControlID&quot;);
resBundle.appendChild(resBinary);

// Bundle settings
//resBundle.id.@value = channelMap.get(&quot;MessageControlID&quot;);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var resBundle = &lt;Bundle xmlns=&quot;http://hl7.org/fhir&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
		&lt;type value=&quot;message&quot;/&gt;
	&lt;/Bundle&gt;;

// Patient resource
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resPatient = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + channelMap.get(&quot;Patient&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBundle.appendChild(resPatient);

// DiagnosticReport resource
addEntry(&quot;DiagnosticReport&quot;);

// Practitioner resource for Ordering Provider
addEntry(&quot;Practitioner&quot;);

// Specimen resource
addEntry(&quot;Specimen&quot;);

// Binary resourse with original HL7v2 ORU_R01 message
default xml namespace = &quot;http://hl7.org/fhir&quot;;
var resBinary = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + globalChannelMap.get(&quot;Binary&quot;) + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
resBinary.resource.Binary.id.@value = &quot;oru-r01-&quot; + channelMap.get(&quot;MessageControlID&quot;);
resBundle.appendChild(resBinary);

// Bundle settings
//resBundle.id.@value = channelMap.get(&quot;MessageControlID&quot;);</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Send to Left Side</name>
                <script>//logger.debug(&quot;Bundle: &quot; + resBundle.toString());

channelMap.put(&quot;ORUBundle&quot;, resBundle.toString());</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>//logger.debug(&quot;Bundle: &quot; + resBundle.toString());

channelMap.put(&quot;ORUBundle&quot;, resBundle.toString());</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>Add Entry function</name>
                <script>/**
	Constructs multiple resource entries from the storred array.
	This function uses the global resBundle variable.

	@param {String} arrName - array name to extract from the channel map
*/
function addEntry(arrName) {
	var arrResource = channelMap.get(arrName);
	for (var i = 0; i &lt; arrResource.length; i++) {
		default xml namespace = &quot;http://hl7.org/fhir&quot;;
		var resource = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + arrResource[i] + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
		resBundle.appendChild(resource);	
	}
	channelMap.remove(arrName);
	arrResource.length = 0;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Constructs multiple resource entries from the storred array.
	This function uses the global resBundle variable.

	@param {String} arrName - array name to extract from the channel map
*/
function addEntry(arrName) {
	var arrResource = channelMap.get(arrName);
	for (var i = 0; i &lt; arrResource.length; i++) {
		default xml namespace = &quot;http://hl7.org/fhir&quot;;
		var resource = new XML(&quot;&lt;entry&gt;&lt;resource&gt;&quot; + arrResource[i] + &quot;&lt;/resource&gt;&lt;/entry&gt;&quot;);
		resBundle.appendChild(resource);	
	}
	channelMap.remove(arrName);
	arrResource.length = 0;
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>true</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>Validate Spark Server response</name>
                <script>var resp =  $(&apos;responseStatusLine&apos;);

//logger.info(&quot;ORU Processing: Destination - Response - &quot; + msg.toString());
//logger.info(&quot;ORU Processing: Destination - Response - &quot; + resp);</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var resp =  $(&apos;responseStatusLine&apos;);

//logger.info(&quot;ORU Processing: Destination - Response - &quot; + msg.toString());
//logger.info(&quot;ORU Processing: Destination - Response - &quot; + resp);</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>HTTP Sender</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data

message = stripNonValidXMLChars(message);

return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

globalMap.put(&quot;ORUProcessingChannelId&quot;, channelId);

return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <className>com.mirth.connect.server.attachments.javascript.JavaScriptAttachmentHandlerProvider</className>
          <type>JavaScript</type>
          <properties>
            <entry>
              <string>javascript.script</string>
              <string>// Modify the message variable below to create attachments

// Create Binary resourse with the original HL7v2 message
var resBinary = &lt;Binary&gt;				
				&lt;id value=&quot;&quot;/&gt;				
				&lt;contentType value=&quot;application/hl7-v2&quot;/&gt;
				&lt;content value=&quot;&quot;/&gt;
			&lt;/Binary&gt;;

// Encode original ORU message
var bytes = new java.lang.String(message.toString()).getBytes();
resBinary.content.@value = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

// Store to be processed by the FHIR_submit destination
globalChannelMap.put(&quot;Binary&quot;, resBinary.toString());


return message;</string>
            </entry>
          </properties>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
      <dependentIds/>
    </channel>
    <channel version="3.4.2">
      <id>4c7bc0bd-aede-4e90-9ce8-cde50750f1e8</id>
      <nextMetaDataId>5</nextMetaDataId>
      <name>Submit Order</name>
      <description>Submits a new lab order, including both Basic Lab Orders and Patient Service Center (PSC) Hold Orders.&#xd;
The Order object contains the inbound lab order message (HL7v2.5.1 OML_O21).&#xd;
&#xd;
This channel expects JSON feed with all data filled to build the outbound OML_O21 message.&#xd;
&#xd;
Last updated: March 12, 2017</description>
      <enabled>true</enabled>
      <lastModified>
        <time>1495386486812</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>97</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>Outcome</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Validate JSON feed</name>
              <script>var error = [];				// A list of possible incoming JSON feed validation errors
var hasPatient = false;			// PID
var hasDiagnosticReport = false;	// ORC
var hasDiagnosticOrder = false;	// OBR
var hasCoverage = false;			// IN1
var hasPerson = false;			// GT1
var hasPractitioner = false;		// OBR.16
var conditionCount = 0;

// Feed UUID ~~ RKW The placement of static text in an ID value is pointless, and usually requires stripping out later - such as here. How about not putting it there in the first place?
var uuid = msg.Bundle.id.value.toString().toLowerCase().replace(&quot;oml-o21&quot;,&quot;&quot;);

// TODO: Define min length for UUID
if (uuid)
	channelMap.put(&quot;FeedUUID&quot;, uuid);
else 
	error.push(&quot;Feed Bundle id/@value should contain UUID in format OML-O21-xxxxxxxx-...&quot;);	


// The Data Exchange verifies that fields are populated depending on the coverage type
var billType = [&apos;T&apos;,&apos;P&apos;,&apos;C&apos;];
var coverageType;
msg.Bundle.entry.forEach(function(obj){
	if (obj.resource.Coverage) {
		coverageType = obj.resource.Coverage.type.code.value.toString();
		if (billType.indexOf(coverageType) &lt; 0) error.push(&quot;resource.Coverage.type.code.value for IN1.47[Coverage Type] is required and must be T, P or C&quot;);
	}
});

// Store IN1.47 [Coverage Type] value for future use
channelMap.put(&quot;CoverageType&quot;, coverageType);


// Validate incoming JSON field for required resources (aka segments)
msg.Bundle.entry.forEach(function(objRes){

	// Need to set the hasSomeResource only once
	if (objRes.resource.Patient != null &amp;&amp; objRes.resource.Patient != undefined) hasPatient = true;
	if (objRes.resource.DiagnosticReport != null &amp;&amp; objRes.resource.DiagnosticReport != undefined) hasDiagnosticReport = true;
	if (objRes.resource.DiagnosticOrder != null &amp;&amp; objRes.resource.DiagnosticOrder != undefined) hasDiagnosticOrder = true;
	if (objRes.resource.Coverage != null &amp;&amp; objRes.resource.Coverage != undefined) hasCoverage = true;
	if (objRes.resource.Person != null &amp;&amp; objRes.resource.Person != undefined) hasPerson = true;
	if (objRes.resource.Practitioner != null &amp;&amp; objRes.resource.Practitioner != undefined) hasPractitioner = true;
	if (objRes.resource.Condition != null &amp;&amp; objRes.resource.Condition != undefined) {
		conditionCount ++;
	}
});


// Validate for required segments
if (!hasPatient) error.push(&quot;resource.Patient for PID segment is Required&quot;);
if (!hasCoverage) error.push(&quot;resource.Coverage for IN1 segment is Required&quot;);
if (!hasDiagnosticReport) error.push(&quot;resource.DiagnosticReport for ORC segment is Required&quot;); // ~~ RKW - Expecting a diagnostic report - a result observation artifact - in an order? Why? 
if (!hasDiagnosticOrder) error.push(&quot;resource.DiagnosticOrder for OBR segment is Required&quot;);
if (!hasPractitioner) error.push(&quot;resource.Practitioner for OBR.16 [Ordering Provider] field is Required&quot;);
if (coverageType == &quot;T&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Third-Party Bill type&quot;);

// Updated to comply with CS12 Billing certification criteria
if (coverageType == &quot;P&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Patient Bill type&quot;);
if (conditionCount &gt; 12) error.push(&quot;Maximum of 12 resource.Condition with unique ICD-10 codes are permitted. You sent &quot; + conditionCount);  // ~~ RKW - Conditions? Not going to happen, and not in requirements

// Verify for errors 
if (error.length &gt; 0) {
	
	// OML_O21 message will not be created ~~ RKW. There is this thing called a filter. Manipulation of the destinationSet is hacking, as it makes the channel more opaque.
	destinationSet.removeAll();

	var messages = {request:&quot;&quot;, resp:&quot;&quot;};
	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	
	// To be sent to the upstream channel
	responseMap.put(&quot;Outcome&quot;, outcome);
	//logger.debug(&quot;SubmitOrder (Source): &quot; + outcome);
}</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>var error = [];				// A list of possible incoming JSON feed validation errors
var hasPatient = false;			// PID
var hasDiagnosticReport = false;	// ORC
var hasDiagnosticOrder = false;	// OBR
var hasCoverage = false;			// IN1
var hasPerson = false;			// GT1
var hasPractitioner = false;		// OBR.16
var conditionCount = 0;

// Feed UUID ~~ RKW The placement of static text in an ID value is pointless, and usually requires stripping out later - such as here. How about not putting it there in the first place?
var uuid = msg.Bundle.id.value.toString().toLowerCase().replace(&quot;oml-o21&quot;,&quot;&quot;);

// TODO: Define min length for UUID
if (uuid)
	channelMap.put(&quot;FeedUUID&quot;, uuid);
else 
	error.push(&quot;Feed Bundle id/@value should contain UUID in format OML-O21-xxxxxxxx-...&quot;);	


// The Data Exchange verifies that fields are populated depending on the coverage type
var billType = [&apos;T&apos;,&apos;P&apos;,&apos;C&apos;];
var coverageType;
msg.Bundle.entry.forEach(function(obj){
	if (obj.resource.Coverage) {
		coverageType = obj.resource.Coverage.type.code.value.toString();
		if (billType.indexOf(coverageType) &lt; 0) error.push(&quot;resource.Coverage.type.code.value for IN1.47[Coverage Type] is required and must be T, P or C&quot;);
	}
});

// Store IN1.47 [Coverage Type] value for future use
channelMap.put(&quot;CoverageType&quot;, coverageType);


// Validate incoming JSON field for required resources (aka segments)
msg.Bundle.entry.forEach(function(objRes){

	// Need to set the hasSomeResource only once
	if (objRes.resource.Patient != null &amp;&amp; objRes.resource.Patient != undefined) hasPatient = true;
	if (objRes.resource.DiagnosticReport != null &amp;&amp; objRes.resource.DiagnosticReport != undefined) hasDiagnosticReport = true;
	if (objRes.resource.DiagnosticOrder != null &amp;&amp; objRes.resource.DiagnosticOrder != undefined) hasDiagnosticOrder = true;
	if (objRes.resource.Coverage != null &amp;&amp; objRes.resource.Coverage != undefined) hasCoverage = true;
	if (objRes.resource.Person != null &amp;&amp; objRes.resource.Person != undefined) hasPerson = true;
	if (objRes.resource.Practitioner != null &amp;&amp; objRes.resource.Practitioner != undefined) hasPractitioner = true;
	if (objRes.resource.Condition != null &amp;&amp; objRes.resource.Condition != undefined) {
		conditionCount ++;
	}
});


// Validate for required segments
if (!hasPatient) error.push(&quot;resource.Patient for PID segment is Required&quot;);
if (!hasCoverage) error.push(&quot;resource.Coverage for IN1 segment is Required&quot;);
if (!hasDiagnosticReport) error.push(&quot;resource.DiagnosticReport for ORC segment is Required&quot;); // ~~ RKW - Expecting a diagnostic report - a result observation artifact - in an order? Why? 
if (!hasDiagnosticOrder) error.push(&quot;resource.DiagnosticOrder for OBR segment is Required&quot;);
if (!hasPractitioner) error.push(&quot;resource.Practitioner for OBR.16 [Ordering Provider] field is Required&quot;);
if (coverageType == &quot;T&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Third-Party Bill type&quot;);

// Updated to comply with CS12 Billing certification criteria
if (coverageType == &quot;P&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Patient Bill type&quot;);
if (conditionCount &gt; 12) error.push(&quot;Maximum of 12 resource.Condition with unique ICD-10 codes are permitted. You sent &quot; + conditionCount);  // ~~ RKW - Conditions? Not going to happen, and not in requirements

// Verify for errors 
if (error.length &gt; 0) {
	
	// OML_O21 message will not be created ~~ RKW. There is this thing called a filter. Manipulation of the destinationSet is hacking, as it makes the channel more opaque.
	destinationSet.removeAll();

	var messages = {request:&quot;&quot;, resp:&quot;&quot;};
	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	
	// To be sent to the upstream channel
	responseMap.put(&quot;Outcome&quot;, outcome);
	//logger.debug(&quot;SubmitOrder (Source): &quot; + outcome);
}</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">eyJCdW5kbGUiOiB7CiAgImVudHJ5IjogWwogICAgeyJyZXNvdXJjZSI6IHsiUGF0aWVudCI6IHsK
ICAgICAgImlkZW50aWZpZXIiOiBbCiAgICAgICAgewogICAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAic2Vjb25kYXJ5In0sCiAgICAgICAgICAidHlwZSI6IHsiY29kaW5nIjogeyJjb2RlIjogeyJ2
YWx1ZSI6ICJQVCJ9fX0sCiAgICAgICAgICAidmFsdWUiOiB7InZhbHVlIjogMjA1MjY2MTl9CiAg
ICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJvZmZpY2lhbCJ9
LAogICAgICAgICAgImFzc2lnbmVyIjogeyJkaXNwbGF5IjogeyJ2YWx1ZSI6ICJNUk4ifX0sCiAg
ICAgICAgICAidHlwZSI6IHsiY29kaW5nIjogeyJjb2RlIjogeyJ2YWx1ZSI6ICJQVCJ9fX0sCiAg
ICAgICAgICAidmFsdWUiOiB7InZhbHVlIjogMjA1MjY2MTl9CiAgICAgICAgfQogICAgICBdLAog
ICAgICAiYWRkcmVzcyI6IHsKICAgICAgICAiY291bnRyeSI6IHsidmFsdWUiOiAiVVNBIn0sCiAg
ICAgICAgImNpdHkiOiB7InZhbHVlIjogIk1hc29uIn0sCiAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAiaG9tZSJ9LAogICAgICAgICJsaW5lIjogeyJ2YWx1ZSI6ICI0NjkwIFBhcmt3YXkgRHIuIn0s
CiAgICAgICAgInBvc3RhbENvZGUiOiB7InZhbHVlIjogNDUwNDB9LAogICAgICAgICJzdGF0ZSI6
IHsidmFsdWUiOiAiT0gifQogICAgICB9LAogICAgICAiZ2VuZGVyIjogeyJ2YWx1ZSI6ICJtYWxl
In0sCiAgICAgICJuYW1lIjogewogICAgICAgICJnaXZlbiI6IFsKICAgICAgICAgIHsidmFsdWUi
OiAiUGF0aWVudF9GaXJzdG5hbWUifSwKICAgICAgICAgIHsidmFsdWUiOiAiTWlkZGxlIn0KICAg
ICAgICBdLAogICAgICAgICJ1c2UiOiB7InZhbHVlIjogIm9mZmljaWFsIn0sCiAgICAgICAgImZh
bWlseSI6IHsidmFsdWUiOiAiUGF0aWVudF9MYXN0bmFtZSJ9CiAgICAgIH0sCiAgICAgICJ0ZWxl
Y29tIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0sCiAgICAgICAgInVz
ZSI6IHsidmFsdWUiOiAiaG9tZSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFsdWUiOiAiMV4zMzNe
NDQ0NTU1NSJ9CiAgICAgIH0sCiAgICAgICJpZCI6IHsidmFsdWUiOiAiUElELXBhdGllbnQtaWRl
bnRpZmljYXRpb24ifSwKICAgICAgInRleHQiOiB7CiAgICAgICAgImRpdiI6IHsKICAgICAgICAg
ICJwIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIkZpcnN0IFBhdGllbnQgcmVsYXRlZCBpbnRlcm5hbCBjb21tZW50
IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiY2xhc3Mi
OiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiU2Vjb25kIFBhdGllbnQgcmVsYXRlZCBp
bnRlcm5hbCBjb21tZW50IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAg
ICAgICAgICAiY2xhc3MiOiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiVGhpcmQgUGF0
aWVudCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAg
ICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6ICJJIiwKICAgICAgICAgICAgICAiY29udGVu
dCI6ICJGb3J0aCBQYXRpZW50IHJlbGF0ZWQgaW50ZXJuYWwgY29tbWVudCBsaW5lIgogICAgICAg
ICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIlIiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIkZpcnN0IFBhdGllbnQgcmVsYXRlZCByZXBvcnQgY29tbWVudCBs
aW5lIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjog
IlIiLAogICAgICAgICAgICAgICJjb250ZW50IjogIlNlY29uZCBQYXRpZW50IHJlbGF0ZWQgcmVw
b3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAg
ICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJUaGlyZCBQYXRpZW50
IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAg
ewogICAgICAgICAgICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJG
b3J0aCBQYXRpZW50IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfQog
ICAgICAgICAgXSwKICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3ho
dG1sIgogICAgICAgIH0sCiAgICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAiZ2VuZXJhdGVkIn0K
ICAgICAgfSwKICAgICAgImJpcnRoRGF0ZSI6IHsidmFsdWUiOiAiMTk2OC0wMS0wMSJ9CiAgICB9
fX0sCiAgICB7InJlc291cmNlIjogeyJEaWFnbm9zdGljUmVwb3J0IjogewogICAgICAicmVzdWx0
IjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIk9ic2VydmF0aW9uIn19LAogICAgICAiaWRlbnRp
ZmllciI6IHsKICAgICAgICAic3lzdGVtIjogeyJ2YWx1ZSI6ICJRVUVTVF9TS0JfNzE4NjEyMSJ9
LAogICAgICAgICJ0eXBlIjogeyJpZCI6ICI5OVFESSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFs
dWUiOiA5ODc2NTQzMjF9CiAgICAgIH0sCiAgICAgICJyZXF1ZXN0IjogeyJyZWZlcmVuY2UiOiB7
InZhbHVlIjogIkRpYWdub3N0aWNPcmRlci9vYnItb2JzZXJ2YXRpb24tcmVxdWVzdCJ9fSwKICAg
ICAgImNvbnRhaW5lZCI6IHsiUHJhY3RpdGlvbmVyIjogewogICAgICAgICJpZGVudGlmaWVyIjog
eyJ2YWx1ZSI6IHsidmFsdWUiOiAiTlBQX0lEIn19LAogICAgICAgICJuYW1lIjogeyJmYW1pbHki
OiB7InZhbHVlIjogIk5QUF9OYW1lIn19LAogICAgICAgICJpZCI6IHsidmFsdWUiOiAiT1JDMTEt
dmVyaWZpZWQtYnkifQogICAgICB9fSwKICAgICAgImNvZGUiOiB7ImlkIjogMTAxMjR9LAogICAg
ICAicGVyZm9ybWVyIjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIlByYWN0aXRpb25lci9PUkMx
MS12ZXJpZmllZC1ieSJ9fSwKICAgICAgImVmZmVjdGl2ZURhdGVUaW1lIjogeyJleHRlbnNpb24i
OiB7InVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YzL051bGxGbGF2b3IvTkkifX0sCiAgICAg
ICJzdWJqZWN0IjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIlBhdGllbnQifX0sCiAgICAgICJp
ZCI6IHsidmFsdWUiOiAiT1JDLWNvbW1vbi1vcmRlciJ9LAogICAgICAiaXNzdWVkIjogeyJleHRl
bnNpb24iOiB7InVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YzL051bGxGbGF2b3IvTkkifX0s
CiAgICAgICJzdGF0dXMiOiB7InZhbHVlIjogImZpbmFsIn0KICAgIH19fSwKICAgIHsicmVzb3Vy
Y2UiOiB7IkRpYWdub3N0aWNPcmRlciI6IHsKICAgICAgIml0ZW0iOiB7CiAgICAgICAgImNvZGUi
OiB7ImNvZGluZyI6IHsKICAgICAgICAgICJjb2RlIjogeyJ2YWx1ZSI6IDg0NzJ9LAogICAgICAg
ICAgImRpc3BsYXkiOiB7InZhbHVlIjogIkhFUEFUSVRJUyBDIFZJUlVTIEFCIn0KICAgICAgICB9
fSwKICAgICAgICAic3BlY2ltZW4iOiB7ImRpc3BsYXkiOiB7InZhbHVlIjogIkcifX0KICAgICAg
fSwKICAgICAgInN1YmplY3QiOiB7ImlkIjogIlBhdGllbnQifSwKICAgICAgImlkIjogeyJ2YWx1
ZSI6ICJPQlItb2JzZXJ2YXRpb24tcmVxdWVzdCJ9LAogICAgICAidGV4dCI6IHsKICAgICAgICAi
ZGl2IjogewogICAgICAgICAgInAiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiY2xh
c3MiOiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiRmlyc3QgT2JzZXJ2YXRpb24gUmVx
dWVzdCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAg
ICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6ICJJIiwKICAgICAgICAgICAgICAiY29udGVu
dCI6ICJTZWNvbmQgT2JzZXJ2YXRpb24gUmVxdWVzdCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQg
bGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6
ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJGaXJzdCBPYnNlcnZhdGlvbiBSZXF1ZXN0
IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAg
ewogICAgICAgICAgICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJT
ZWNvbmQgT2JzZXJ2YXRpb24gUmVxdWVzdCByZWxhdGVkIHJlcG9ydCBjb21tZW50IGxpbmUiCiAg
ICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAieG1sbnMiOiAiaHR0cDovL3d3dy53
My5vcmcvMTk5OS94aHRtbCIKICAgICAgICB9LAogICAgICAgICJzdGF0dXMiOiB7InZhbHVlIjog
ImdlbmVyYXRlZCJ9CiAgICAgIH0sCiAgICAgICJldmVudCI6IHsKICAgICAgICAiZGF0ZVRpbWUi
OiB7InZhbHVlIjogIjIwMTYtMTEtMThUMjA6NTE6NTUrMDA6MDAifSwKICAgICAgICAiYWN0b3Ii
OiB7InJlZmVyZW5jZSI6IHsidmFsdWUiOiAiUHJhY3RpdGlvbmVyL29yZGVyaW5nLXByb3ZpZGVy
In19LAogICAgICAgICJzdGF0dXMiOiB7InZhbHVlIjogImNvbXBsZXRlZCJ9CiAgICAgIH0KICAg
IH19fSwKICAgIHsicmVzb3VyY2UiOiB7Ik9ic2VydmF0aW9uIjogewogICAgICAiY29kZSI6IHsi
Y29kaW5nIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogImh0dHA6Ly9zbm9tZWQuaW5m
by9zY3QifSwKICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAzNjU5ODEwMDd9LAogICAgICAgICJk
aXNwbGF5IjogeyJ2YWx1ZSI6ICJGaW5kaW5nIG9mIHRvYmFjY28gc21va2luZyBiZWhhdmlvciJ9
CiAgICAgIH19LAogICAgICAidmFsdWVTdHJpbmciOiB7InZhbHVlIjogIlNtb2tlIHR3byBjaWdh
cnMgZGFpbHkifSwKICAgICAgImlkIjogeyJ2YWx1ZSI6ICJPQlgtb2JzZXJ2YXRpb24ifSwKICAg
ICAgInRleHQiOiB7CiAgICAgICAgImRpdiI6IHsKICAgICAgICAgICJwIjogWwogICAgICAgICAg
ICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAgICAgICAgICJjb250ZW50Ijog
IkZpcnN0IG9ic2VydmF0aW9uIHJlbGF0ZWQgaW50ZXJuYWwgY29tbWVudCBsaW5lIgogICAgICAg
ICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIlNlY29uZCBvYnNlcnZhdGlvbiByZWxhdGVkIGludGVybmFsIGNv
bW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICJj
bGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJGaXJzdCBvYnNlcnZhdGlvbiBy
ZWxhdGVkIHJlcG9ydCBjb21tZW50IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsK
ICAgICAgICAgICAgICAiY2xhc3MiOiAiUiIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiU2Vj
b25kIG9ic2VydmF0aW9uIHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAg
fQogICAgICAgICAgXSwKICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8xOTk5
L3hodG1sIgogICAgICAgIH0sCiAgICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAiZ2VuZXJhdGVk
In0KICAgICAgfSwKICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAicHJlbGltaW5hcnkifQogICAg
fX19LAogICAgeyJyZXNvdXJjZSI6IHsiQ29uZGl0aW9uIjogewogICAgICAiY29kZSI6IHsiY29k
aW5nIjogWwogICAgICAgIHsKICAgICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogImh0dHA6Ly9o
bDcub3JnL2ZoaXIvVmFsdWVTZXQvaWNkLTEwIn0sCiAgICAgICAgICAiY29kZSI6IHsidmFsdWUi
OiAiSTI1NzAwIn0sCiAgICAgICAgICAiZGlzcGxheSI6IHsidmFsdWUiOiAiQXRoZXJvc2NsZXJv
c2lzIG9mIENBQkcifQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgInN5c3RlbSI6IHsi
dmFsdWUiOiAiaHR0cDovL2hsNy5vcmcvZmhpci9zaWQvaWNkLTkifSwKICAgICAgICAgICJjb2Rl
IjogeyJ2YWx1ZSI6IDQxNC4zfQogICAgICAgIH0KICAgICAgXX0sCiAgICAgICJ2ZXJpZmljYXRp
b25TdGF0dXMiOiB7InZhbHVlIjogImNvbmZpcm1lZCJ9LAogICAgICAicGF0aWVudCI6IHsicmVm
ZXJlbmNlIjogeyJ2YWx1ZSI6ICJQYXRpZW50In19LAogICAgICAiaWQiOiB7InZhbHVlIjogIkRH
MS1kaWFnbm9zaXMifQogICAgfX19LAogICAgeyJyZXNvdXJjZSI6IHsiQ292ZXJhZ2UiOiB7CiAg
ICAgICJpZGVudGlmaWVyIjogeyJ2YWx1ZSI6IHsidmFsdWUiOiAxMjM0NTY3ODl9fSwKICAgICAg
ImNvbnRhaW5lZCI6IFsKICAgICAgICB7Ik9yZ2FuaXphdGlvbiI6IHsKICAgICAgICAgICJpZGVu
dGlmaWVyIjogeyJ2YWx1ZSI6IHsidmFsdWUiOiAiQVVIU0MifX0sCiAgICAgICAgICAiYWRkcmVz
cyI6IHsKICAgICAgICAgICAgImNvdW50cnkiOiB7InZhbHVlIjogIlVTQSJ9LAogICAgICAgICAg
ICAiY2l0eSI6IHsidmFsdWUiOiAiTWFzb24ifSwKICAgICAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAid29yayJ9LAogICAgICAgICAgICAibGluZSI6IHsidmFsdWUiOiAiNDY5MCBQYXJrd2F5IERy
LiJ9LAogICAgICAgICAgICAicG9zdGFsQ29kZSI6IHsidmFsdWUiOiA0NTA0MH0sCiAgICAgICAg
ICAgICJzdGF0ZSI6IHsidmFsdWUiOiAiT0gifQogICAgICAgICAgfSwKICAgICAgICAgICJuYW1l
IjogeyJ2YWx1ZSI6ICJBRVROQSJ9LAogICAgICAgICAgInRlbGVjb20iOiB7CiAgICAgICAgICAg
ICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0sCiAgICAgICAgICAgICJ1c2UiOiB7InZhbHVl
IjogIndvcmsifSwKICAgICAgICAgICAgInZhbHVlIjogeyJ2YWx1ZSI6ICIxXjMzM140NDQ1NTU1
In0KICAgICAgICAgIH0sCiAgICAgICAgICAiaWQiOiB7InZhbHVlIjogImluc3VyYW5jZS1jb21w
YW55In0KICAgICAgICB9fSwKICAgICAgICB7IlBlcnNvbiI6IHsKICAgICAgICAgICJhZGRyZXNz
IjogewogICAgICAgICAgICAiY291bnRyeSI6IHsidmFsdWUiOiAiVVNBIn0sCiAgICAgICAgICAg
ICJjaXR5IjogeyJ2YWx1ZSI6ICJNYXNvbiJ9LAogICAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6
ICJob21lIn0sCiAgICAgICAgICAgICJsaW5lIjogeyJ2YWx1ZSI6ICIxMjMgTWFpbiBSb2FkIn0s
CiAgICAgICAgICAgICJwb3N0YWxDb2RlIjogeyJ2YWx1ZSI6IDQ1MDc3fSwKICAgICAgICAgICAg
InN0YXRlIjogeyJ2YWx1ZSI6ICJPSCJ9CiAgICAgICAgICB9LAogICAgICAgICAgIm5hbWUiOiB7
CiAgICAgICAgICAgICJnaXZlbiI6IFsKICAgICAgICAgICAgICB7InZhbHVlIjogIkluc3VyZWRf
Rmlyc3RuYW1lIn0sCiAgICAgICAgICAgICAgeyJ2YWx1ZSI6ICJNaWRkbGUifQogICAgICAgICAg
ICBdLAogICAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJvZmZpY2lhbCJ9LAogICAgICAgICAg
ICAiZmFtaWx5IjogeyJ2YWx1ZSI6ICJJbnN1cmVkX0xhc3RuYW1lIn0KICAgICAgICAgIH0sCiAg
ICAgICAgICAiaWQiOiB7InZhbHVlIjogImluc3VyZWQtcGVyc29uIn0KICAgICAgICB9fQogICAg
ICBdLAogICAgICAiZXh0ZW5zaW9uIjogWwogICAgICAgIHsKICAgICAgICAgICJ2YWx1ZUlkZW50
aWZpZXIiOiB7InZhbHVlIjogeyJ2YWx1ZSI6ICJBRVROQSJ9fSwKICAgICAgICAgICJ1cmwiOiAi
aHR0cDovL3d3dy5xdWVzdGRpYWdub3N0aWNzLmNvbSIKICAgICAgICB9LAogICAgICAgIHsKICAg
ICAgICAgICJ2YWx1ZVRpbWluZyI6IHsKICAgICAgICAgICAgImNvZGUiOiB7ImNvZGluZyI6IHsK
ICAgICAgICAgICAgICAic3lzdGVtIjogeyJ2YWx1ZSI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3Yy
LzA0ODUifSwKICAgICAgICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAiUyJ9LAogICAgICAgICAg
ICAgICJkaXNwbGF5IjogeyJ2YWx1ZSI6ICJTdGF0In0KICAgICAgICAgICAgfX0sCiAgICAgICAg
ICAgICJldmVudCI6IHsidmFsdWUiOiAiMjAxNi0wMS0wN1QwOTowMDowMC0wNTowMCJ9CiAgICAg
ICAgICB9LAogICAgICAgICAgInVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YyL3RxMSIKICAg
ICAgICB9CiAgICAgIF0sCiAgICAgICJwbGFuaG9sZGVyUmVmZXJlbmNlIjogeyJyZWZlcmVuY2Ui
OiB7InZhbHVlIjogIlBhdGllbnQvUElELXBhdGllbnQtaWRlbnRpZmljYXRpb24ifX0sCiAgICAg
ICJzdWJQbGFuIjogeyJ2YWx1ZSI6ICJDMTIzNDU2In0sCiAgICAgICJpc3N1ZXJSZWZlcmVuY2Ui
OiB7InJlZmVyZW5jZSI6IHsidmFsdWUiOiAiT3JnYW5pemF0aW9uL2luc3VyYW5jZS1jb21wYW55
In19LAogICAgICAiYmVuZWZpY2lhcnlJZGVudGlmaWVyIjogIiIsCiAgICAgICJpZCI6IHsidmFs
dWUiOiAiSU4xLWluc3VyYW5jZSJ9LAogICAgICAidHlwZSI6IHsiY29kZSI6IHsidmFsdWUiOiAi
UCJ9fSwKICAgICAgInJlbGF0aW9uc2hpcCI6IHsKICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAx
fSwKICAgICAgICAiZGlzcGxheSI6IHsidmFsdWUiOiAiU2VsZiJ9CiAgICAgIH0sCiAgICAgICJw
bGFuIjogeyJ2YWx1ZSI6ICJQMTIzNDU2UiJ9LAogICAgICAiZ3JvdXAiOiB7InZhbHVlIjogIkEx
MjM0NSJ9CiAgICB9fX0sCiAgICB7InJlc291cmNlIjogeyJQZXJzb24iOiB7CiAgICAgICJhZGRy
ZXNzIjogewogICAgICAgICJjb3VudHJ5IjogeyJ2YWx1ZSI6ICJVU0EifSwKICAgICAgICAiY2l0
eSI6IHsidmFsdWUiOiAiTWFzb24ifSwKICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJob21lIn0s
CiAgICAgICAgImxpbmUiOiB7InZhbHVlIjogIjQ2OTAgUGFya3dheSBEci4ifSwKICAgICAgICAi
cG9zdGFsQ29kZSI6IHsidmFsdWUiOiA0NTA0MH0sCiAgICAgICAgInN0YXRlIjogeyJ2YWx1ZSI6
ICJPSCJ9CiAgICAgIH0sCiAgICAgICJuYW1lIjogewogICAgICAgICJnaXZlbiI6IFsKICAgICAg
ICAgIHsidmFsdWUiOiAiSW5zdXJlZF9GaXJzdG5hbWUifSwKICAgICAgICAgIHsidmFsdWUiOiAi
TWlkZGxlIn0KICAgICAgICBdLAogICAgICAgICJ1c2UiOiB7InZhbHVlIjogIm9mZmljaWFsIn0s
CiAgICAgICAgImZhbWlseSI6IHsidmFsdWUiOiAiSW5zdXJlZF9MYXN0bmFtZSJ9CiAgICAgIH0s
CiAgICAgICJ0ZWxlY29tIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0s
CiAgICAgICAgInVzZSI6IHsidmFsdWUiOiAiaG9tZSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFs
dWUiOiAiMV4zMzNeNDQ0NTU1NSJ9CiAgICAgIH0sCiAgICAgICJpZCI6IHsidmFsdWUiOiAiR1Qx
LWd1YXJhbnRvciJ9CiAgICB9fX0sCiAgICB7InJlc291cmNlIjogeyJQcmFjdGl0aW9uZXIiOiB7
CiAgICAgICJpZGVudGlmaWVyIjogewogICAgICAgICJhc3NpZ25lciI6IHsiZGlzcGxheSI6IHsi
dmFsdWUiOiAiTlBJIn19LAogICAgICAgICJ2YWx1ZSI6IHsidmFsdWUiOiAxMzY2NDcyNTU3fQog
ICAgICB9LAogICAgICAibmFtZSI6IHsKICAgICAgICAiZ2l2ZW4iOiBbCiAgICAgICAgICB7InZh
bHVlIjogIkphc29uIn0sCiAgICAgICAgICB7InZhbHVlIjogIlMuIn0KICAgICAgICBdLAogICAg
ICAgICJmYW1pbHkiOiB7InZhbHVlIjogIkphdmlsbG8ifQogICAgICB9LAogICAgICAiaWQiOiB7
InZhbHVlIjogIm9yZGVyaW5nLXByb3ZpZGVyIn0KICAgIH19fQogIF0sCiAgImlkIjogeyJ2YWx1
ZSI6ICJPTUwtTzIxLWIxYTE3Y2QyLTg2NWYtNDg2YS05NjBkLThlYTc3NjRlYzAwZCJ9LAogICJ0
eXBlIjogeyJ2YWx1ZSI6ICJzZWFyY2hzZXQifQp9fQ==</inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>2</metaDataId>
          <name>Create OML_O21</name>
          <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <script>return true;
</script>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>OML templates</name>
                <script>// OML_O21 template with placeholders for required fields only
var oml_template = &quot;MSH|^~\&amp;|||||||OML^O21|||2.5.1\r&quot; + &quot;PID|1|||||||\r&quot;;
var oml = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(oml_template));

// MSH segment required fields (may be overwritten by MessageHeader resource)
oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = $(&quot;application&quot;);
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = $(&quot;account&quot;);
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = $(&quot;receivingFacility&quot;);

// Overrides
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = &quot;MET&quot;;
oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = &quot;PSC&quot;;
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = &quot;90046003&quot;;

// (Quest) Note: All date timestamps are set to Coordinated Universal Time (UTC).
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmssZ&quot;);
oml[&apos;MSH&apos;][&apos;MSH.7&apos;] = currentDate;

// Message Control ID is calculated based on date of submission
oml[&apos;MSH&apos;][&apos;MSH.10&apos;] = currentDate.toString().substring(0,14) + UUIDGenerator.getUUID().toString().substring(0,6);
oml[&apos;MSH&apos;][&apos;MSH.11&apos;] = $(&quot;processingID&quot;);


// A list of possible incoming JSON feed validation errors based on IN1.47 [Coverage Type] value
var error = [];</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// OML_O21 template with placeholders for required fields only
var oml_template = &quot;MSH|^~\&amp;|||||||OML^O21|||2.5.1\r&quot; + &quot;PID|1|||||||\r&quot;;
var oml = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(oml_template));

// MSH segment required fields (may be overwritten by MessageHeader resource)
oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = $(&quot;application&quot;);
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = $(&quot;account&quot;);
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = $(&quot;receivingFacility&quot;);

// Overrides
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = &quot;MET&quot;;
oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = &quot;PSC&quot;;
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = &quot;90046003&quot;;

// (Quest) Note: All date timestamps are set to Coordinated Universal Time (UTC).
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmssZ&quot;);
oml[&apos;MSH&apos;][&apos;MSH.7&apos;] = currentDate;

// Message Control ID is calculated based on date of submission
oml[&apos;MSH&apos;][&apos;MSH.10&apos;] = currentDate.toString().substring(0,14) + UUIDGenerator.getUUID().toString().substring(0,6);
oml[&apos;MSH&apos;][&apos;MSH.11&apos;] = $(&quot;processingID&quot;);


// A list of possible incoming JSON feed validation errors based on IN1.47 [Coverage Type] value
var error = [];</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Iterate JSON resources</name>
                <script>// Global NTE Set ID value
var countNTE = 1; 

// Insurance list to retain primary and secondary
var coverageMap = new Packages.java.util.HashMap(2);

// Guarantor
var guarantorMap = new Packages.java.util.HashMap(1);

// Common Order
var commonOrderMap = new Packages.java.util.HashMap(4);
var placedOrderNumberMap = new Packages.java.util.HashMap(4);

// Timing/Quantity
var timingQuantityMap = new Packages.java.util.HashMap(4);

// Observation Request
var observationRequestMap = new Packages.java.util.HashMap(4);
var observationRequestCommentsMap = new Packages.java.util.HashMap(4);

// Diagnosis
var diagnosisMap = new Packages.java.util.HashMap(12);

// Observation/Result aka AOEs
var observationMap = new Packages.java.util.HashMap(4);
var observationCommentsMap = new Packages.java.util.HashMap(4);
var observationReferencesMap = new Packages.java.util.HashMap(4);

// ORC.12 Ordering Provider
// OBX.16 Ordering Provider
var practitionerMap = new Packages.java.util.HashMap(4);



// Preliminary store referenced resources
for each (obj in msg.Bundle.entry) {

	if (obj.resource.Practitioner != null &amp;&amp; obj.resource.Practitioner != undefined) {
	
		// Practitioner is required to complete ORC and OBR segments
		var id = ((obj.resource.Practitioner.id != undefined) ? obj.resource.Practitioner.id.value.toString() : &quot;&quot;);
		if (id.length &gt; 0)
			practitionerMap.put(id.toString(), obj);
	}
}

var PatientResourceID;
var AccountNumber;

// Iterate over all inbound feed resource
for each (obj in msg.Bundle.entry) {

	if (obj.resource.MessageHeader != null &amp;&amp; obj.resource.MessageHeader != undefined) {
		// Update MessageHeader segment
		AccountNumber = obj.resource.MessageHeader.source.endpoint.value.toString();
		processMessageHeader(obj);

	} else if (obj.resource.Patient != null &amp;&amp; obj.resource.Patient != undefined) {
		// Populate PID segment
		PatientResourceID = obj.resource.Patient.id.toString();
		processPatient(obj);
		
	} else if (obj.resource.DiagnosticReport != null &amp;&amp; obj.resource.DiagnosticReport != undefined) {
		// Populate ORC segment
		processCommonOrder(obj);
		
	} else if (obj.resource.DiagnosticOrder != null &amp;&amp; obj.resource.DiagnosticOrder != undefined) {
		// Populate OBR segment
		processObservationRequest(obj);

	} else if (obj.resource.Coverage != null &amp;&amp; obj.resource.Coverage != undefined) {
		// Populate IN1 segment
		processCoverage(obj);
		
	} else if (obj.resource.Person != null &amp;&amp; obj.resource.Person != undefined) {
		// Populate GT1 segment
		processGuarantor(obj);
		
	} else if (obj.resource.Observation != null &amp;&amp; obj.resource.Observation != undefined) {
		// Store Observation resource for OBX segment
		processObservation(obj);
	}

}


// ==================== COMPILE THE OML MESSAGE ====================

// Required primary insurance segment
var segInsurancePrimary = coverageMap.get(1);
if (segInsurancePrimary != null) try {
	oml.appendChild(new XML(segInsurancePrimary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding primary insurance segment - &quot; + ex);
}
// Optional secondary insurance segment
var segInsuranceSecondary = coverageMap.get(2);
if (segInsuranceSecondary != null) try {
	oml.appendChild(new XML(segInsuranceSecondary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding secondary insurance segment - &quot; + ex);
} 



// Optional Guarantor segment
var segGuarantor = guarantorMap.get(1);
if (segGuarantor != null) try {
	oml.appendChild(new XML(segGuarantor));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding Guarantor segment - &quot; + ex);	
}



// Required ORDER group
for (var i = 0; i &lt; commonOrderMap.size(); i++) {

	// ORC [Common Order] segment
	var segCommonOrder = commonOrderMap.get((i+1).toString());
	if (segCommonOrder != null) try {
		oml.appendChild(new XML(segCommonOrder));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding CommonOrder segment - &quot; + ex);
	}

	// TQ1 [Timing/Quantity] segment
	var segTimingQuantity = timingQuantityMap.get((i+1).toString());
	if (segTimingQuantity != null) try {
		oml.appendChild(new XML(segTimingQuantity));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Timing/Quantity segment - &quot; + ex);
	}

	// OBR [Observation Request] segment
	var segObservation = observationRequestMap.get((i+1).toString());
	if (segObservation != null) try {
		oml.appendChild(new XML(segObservation));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Observation Request segment - &quot; + ex);
	}
		

	// Observation level NTE [Comments] segments
	var obsComments = observationRequestCommentsMap.get((i+1).toString());
	if (obsComments != null &amp;&amp; Array.isArray(obsComments)) {
		for (var kk = 0; kk &lt; obsComments.length; kk++) {
			var nte = obsComments[kk];
			if (nte.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(nte.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Observation Comment segment - &quot; + ex);
			}
		}
		obsComments.length = 0;
	}
	
	// DG1 [Diagnosis] segments
	var conditions = diagnosisMap.get((i+1).toString());
	if (conditions != null &amp;&amp; Array.isArray(conditions)) {
		for (var dd = 0; dd &lt; conditions.length; dd++) {
			var dg1 = conditions[dd];
			if (dg1.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(dg1.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Diagnosis segment - &quot; + ex);
			}
		}
		conditions.length = 0;		
	}

	// OBX [Observation] segments
	// Get the list of OBX segment references
	var obsReference = observationReferencesMap.get((i+1).toString());
	if (obsReference != null &amp;&amp; Array.isArray(obsReference)) {
		for (var rr = 0; rr &lt; obsReference.length; rr++) {
			// Get the actual OBX segments
			var obx = observationMap.get(obsReference[rr]);
			if (obx != null &amp;&amp; obx.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(obx.toString()));

				// OBX level NTE [Comment] segments
				var observationComments = observationCommentsMap.get(obsReference[rr]);
				if (observationComments != null &amp;&amp; Array.isArray(observationComments)) {
					for (var oc = 0; oc &lt; observationComments.length; oc++) {
						var obxNTE = observationComments[oc];
						if (obxNTE != null &amp;&amp; obxNTE.length &gt; 0)
							oml.appendChild(new XML(obxNTE.toString()));
					}
				}
				observationComments.length = 0;
				
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding OBX segment - &quot; + ex);
			}		
		}		
		obsReference.length = 0;		
	}

}


// Clear all temporary maps
coverageMap.clear();
guarantorMap.clear();
commonOrderMap.clear();
placedOrderNumberMap.clear();
timingQuantityMap.clear();
observationRequestMap.clear();
observationRequestCommentsMap.clear();
diagnosisMap.clear();
observationMap.clear();
observationCommentsMap.clear(); 
observationReferencesMap.clear();
practitionerMap.clear();</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Global NTE Set ID value
var countNTE = 1; 

// Insurance list to retain primary and secondary
var coverageMap = new Packages.java.util.HashMap(2);

// Guarantor
var guarantorMap = new Packages.java.util.HashMap(1);

// Common Order
var commonOrderMap = new Packages.java.util.HashMap(4);
var placedOrderNumberMap = new Packages.java.util.HashMap(4);

// Timing/Quantity
var timingQuantityMap = new Packages.java.util.HashMap(4);

// Observation Request
var observationRequestMap = new Packages.java.util.HashMap(4);
var observationRequestCommentsMap = new Packages.java.util.HashMap(4);

// Diagnosis
var diagnosisMap = new Packages.java.util.HashMap(12);

// Observation/Result aka AOEs
var observationMap = new Packages.java.util.HashMap(4);
var observationCommentsMap = new Packages.java.util.HashMap(4);
var observationReferencesMap = new Packages.java.util.HashMap(4);

// ORC.12 Ordering Provider
// OBX.16 Ordering Provider
var practitionerMap = new Packages.java.util.HashMap(4);



// Preliminary store referenced resources
for each (obj in msg.Bundle.entry) {

	if (obj.resource.Practitioner != null &amp;&amp; obj.resource.Practitioner != undefined) {
	
		// Practitioner is required to complete ORC and OBR segments
		var id = ((obj.resource.Practitioner.id != undefined) ? obj.resource.Practitioner.id.value.toString() : &quot;&quot;);
		if (id.length &gt; 0)
			practitionerMap.put(id.toString(), obj);
	}
}

var PatientResourceID;
var AccountNumber;

// Iterate over all inbound feed resource
for each (obj in msg.Bundle.entry) {

	if (obj.resource.MessageHeader != null &amp;&amp; obj.resource.MessageHeader != undefined) {
		// Update MessageHeader segment
		AccountNumber = obj.resource.MessageHeader.source.endpoint.value.toString();
		processMessageHeader(obj);

	} else if (obj.resource.Patient != null &amp;&amp; obj.resource.Patient != undefined) {
		// Populate PID segment
		PatientResourceID = obj.resource.Patient.id.toString();
		processPatient(obj);
		
	} else if (obj.resource.DiagnosticReport != null &amp;&amp; obj.resource.DiagnosticReport != undefined) {
		// Populate ORC segment
		processCommonOrder(obj);
		
	} else if (obj.resource.DiagnosticOrder != null &amp;&amp; obj.resource.DiagnosticOrder != undefined) {
		// Populate OBR segment
		processObservationRequest(obj);

	} else if (obj.resource.Coverage != null &amp;&amp; obj.resource.Coverage != undefined) {
		// Populate IN1 segment
		processCoverage(obj);
		
	} else if (obj.resource.Person != null &amp;&amp; obj.resource.Person != undefined) {
		// Populate GT1 segment
		processGuarantor(obj);
		
	} else if (obj.resource.Observation != null &amp;&amp; obj.resource.Observation != undefined) {
		// Store Observation resource for OBX segment
		processObservation(obj);
	}

}


// ==================== COMPILE THE OML MESSAGE ====================

// Required primary insurance segment
var segInsurancePrimary = coverageMap.get(1);
if (segInsurancePrimary != null) try {
	oml.appendChild(new XML(segInsurancePrimary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding primary insurance segment - &quot; + ex);
}
// Optional secondary insurance segment
var segInsuranceSecondary = coverageMap.get(2);
if (segInsuranceSecondary != null) try {
	oml.appendChild(new XML(segInsuranceSecondary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding secondary insurance segment - &quot; + ex);
} 



// Optional Guarantor segment
var segGuarantor = guarantorMap.get(1);
if (segGuarantor != null) try {
	oml.appendChild(new XML(segGuarantor));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding Guarantor segment - &quot; + ex);	
}



// Required ORDER group
for (var i = 0; i &lt; commonOrderMap.size(); i++) {

	// ORC [Common Order] segment
	var segCommonOrder = commonOrderMap.get((i+1).toString());
	if (segCommonOrder != null) try {
		oml.appendChild(new XML(segCommonOrder));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding CommonOrder segment - &quot; + ex);
	}

	// TQ1 [Timing/Quantity] segment
	var segTimingQuantity = timingQuantityMap.get((i+1).toString());
	if (segTimingQuantity != null) try {
		oml.appendChild(new XML(segTimingQuantity));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Timing/Quantity segment - &quot; + ex);
	}

	// OBR [Observation Request] segment
	var segObservation = observationRequestMap.get((i+1).toString());
	if (segObservation != null) try {
		oml.appendChild(new XML(segObservation));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Observation Request segment - &quot; + ex);
	}
		

	// Observation level NTE [Comments] segments
	var obsComments = observationRequestCommentsMap.get((i+1).toString());
	if (obsComments != null &amp;&amp; Array.isArray(obsComments)) {
		for (var kk = 0; kk &lt; obsComments.length; kk++) {
			var nte = obsComments[kk];
			if (nte.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(nte.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Observation Comment segment - &quot; + ex);
			}
		}
		obsComments.length = 0;
	}
	
	// DG1 [Diagnosis] segments
	var conditions = diagnosisMap.get((i+1).toString());
	if (conditions != null &amp;&amp; Array.isArray(conditions)) {
		for (var dd = 0; dd &lt; conditions.length; dd++) {
			var dg1 = conditions[dd];
			if (dg1.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(dg1.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Diagnosis segment - &quot; + ex);
			}
		}
		conditions.length = 0;		
	}

	// OBX [Observation] segments
	// Get the list of OBX segment references
	var obsReference = observationReferencesMap.get((i+1).toString());
	if (obsReference != null &amp;&amp; Array.isArray(obsReference)) {
		for (var rr = 0; rr &lt; obsReference.length; rr++) {
			// Get the actual OBX segments
			var obx = observationMap.get(obsReference[rr]);
			if (obx != null &amp;&amp; obx.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(obx.toString()));

				// OBX level NTE [Comment] segments
				var observationComments = observationCommentsMap.get(obsReference[rr]);
				if (observationComments != null &amp;&amp; Array.isArray(observationComments)) {
					for (var oc = 0; oc &lt; observationComments.length; oc++) {
						var obxNTE = observationComments[oc];
						if (obxNTE != null &amp;&amp; obxNTE.length &gt; 0)
							oml.appendChild(new XML(obxNTE.toString()));
					}
				}
				observationComments.length = 0;
				
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding OBX segment - &quot; + ex);
			}		
		}		
		obsReference.length = 0;		
	}

}


// Clear all temporary maps
coverageMap.clear();
guarantorMap.clear();
commonOrderMap.clear();
placedOrderNumberMap.clear();
timingQuantityMap.clear();
observationRequestMap.clear();
observationRequestCommentsMap.clear();
diagnosisMap.clear();
observationMap.clear();
observationCommentsMap.clear(); 
observationReferencesMap.clear();
practitionerMap.clear();</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>MSH segment</name>
                <script>/**
	Populates MSG segment with data from the MessageHeader resource
	@param {Object} obj - MessageHeader object resource
	@return - nothing, uses global HL7v2 message object
*/
function processMessageHeader(obj) {

	if (obj.resource.MessageHeader.source) {
		
		// The name of the sending application
		var sendingApplication = ((obj.resource.MessageHeader.source.name) ? obj.resource.MessageHeader.source.name.value.toString() : &quot;&quot;);
		if (sendingApplication) oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = sendingApplication;
		
		// Primary or secondary account number(s) defined for the placer. ~~ RKW - And the actual account number was less important?
		var sendingFacility = ((obj.resource.MessageHeader.source.endpoint) ? obj.resource.MessageHeader.source.endpoint.value.toString() : &quot;&quot;);
		if (sendingFacility) oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = sendingFacility;
			
	} 

	if (obj.resource.MessageHeader.destination) {
		
		// If provided must be hard-coded to &quot;PSC&quot; for PSC hold orders. If the &lt;name&gt; element is not provided or value is other than &quot;PSC&quot; the order is considered to be a basic lab order.
		var receivingApplication = ((obj.resource.MessageHeader.destination.name) ? obj.resource.MessageHeader.destination.name.value.toString() : &quot;&quot;);
		if (receivingApplication) oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = receivingApplication;


		// The receiving facility. The three-letter ID of the facility that performs the test.
		var receivingFacility = ((obj.resource.MessageHeader.destination.endpoint) ? obj.resource.MessageHeader.destination.endpoint.value.toString() : &quot;&quot;);
		if (receivingFacility) oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = receivingFacility;			
	}

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates MSG segment with data from the MessageHeader resource
	@param {Object} obj - MessageHeader object resource
	@return - nothing, uses global HL7v2 message object
*/
function processMessageHeader(obj) {

	if (obj.resource.MessageHeader.source) {
		
		// The name of the sending application
		var sendingApplication = ((obj.resource.MessageHeader.source.name) ? obj.resource.MessageHeader.source.name.value.toString() : &quot;&quot;);
		if (sendingApplication) oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = sendingApplication;
		
		// Primary or secondary account number(s) defined for the placer. ~~ RKW - And the actual account number was less important?
		var sendingFacility = ((obj.resource.MessageHeader.source.endpoint) ? obj.resource.MessageHeader.source.endpoint.value.toString() : &quot;&quot;);
		if (sendingFacility) oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = sendingFacility;
			
	} 

	if (obj.resource.MessageHeader.destination) {
		
		// If provided must be hard-coded to &quot;PSC&quot; for PSC hold orders. If the &lt;name&gt; element is not provided or value is other than &quot;PSC&quot; the order is considered to be a basic lab order.
		var receivingApplication = ((obj.resource.MessageHeader.destination.name) ? obj.resource.MessageHeader.destination.name.value.toString() : &quot;&quot;);
		if (receivingApplication) oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = receivingApplication;


		// The receiving facility. The three-letter ID of the facility that performs the test.
		var receivingFacility = ((obj.resource.MessageHeader.destination.endpoint) ? obj.resource.MessageHeader.destination.endpoint.value.toString() : &quot;&quot;);
		if (receivingFacility) oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = receivingFacility;			
	}

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>3</sequenceNumber>
                <name>PID segment</name>
                <script>/**
	Populates PID segment with data from the Patient resource
	@param {Object} obj - Patient object resource
	@return - nothing, uses global HL7v2 message object
*/
function processPatient(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var comments = [];

	// Iterate over all patient identifiers
	obj.resource.Patient.identifier.forEach(function(item){

		// PID.3 [Patient Identifier List]
		if (item.use.value.toString() == &quot;official&quot;) {
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = id;

			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.5&apos;] = type;

			var assigner = ((item.assigner) ? item.assigner.display.value.toString() : &quot;&quot;);
			if (assigner)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = assigner;								

		// PID.2 [Patient ID]	
		} else if (item.use.value.toString() == &quot;secondary&quot;) {
		
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.1&apos;] = id;
				
			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.5&apos;] = type;			
						
		}
		
	});


	// Parse patient&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Patient.name, true);
	oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = nameParts.family;
	if (nameParts.given1) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = nameParts.given1;
	if (nameParts.given2) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = nameParts.given2;


	// Patient&apos;s DOB
	if (obj.resource.Patient.birthDate) {
		var dob = obj.resource.Patient.birthDate.value.toString();
		oml[&apos;PID&apos;][&apos;PID.7&apos;] = dob.replace(/-/g,&quot;&quot;);
	} else {
		error.push(&quot;resource.Patient.birthDate for PID.7[DateTime of Birth] is required&quot;);
	}

	// Administrative Gender 
	if (obj.resource.Patient.gender) {
		var gender = obj.resource.Patient.gender.value;
		oml[&apos;PID&apos;][&apos;PID.8&apos;] = convertTable(&quot;0001&quot;, gender);
	} else {
		error.push(&quot;resource.Patient.gender for PID.8[Administrative Sex] is required&quot;);		
	}




	// Patient Address
	if (obj.resource.Patient.address) {

		var street = ((obj.resource.Patient.address.line) ? obj.resource.Patient.address.line.value.toString() : &quot;&quot;);
		if (street)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = street;
		
		var city = ((obj.resource.Patient.address.city) ? obj.resource.Patient.address.city.value.toString() : &quot;&quot;);
		if (city)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = city;	
		
		var state = ((obj.resource.Patient.address.state) ? obj.resource.Patient.address.state.value.toString() : &quot;&quot;);
		if (state)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.4&apos;] = state;
	
		var postal = ((obj.resource.Patient.address.postalCode) ? obj.resource.Patient.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;] = postal;
	
		var country = ((obj.resource.Patient.address.country) ? obj.resource.Patient.address.country.value.toString() : &quot;&quot;);
		if (country)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.6&apos;] = country;

		// There might be a better definition what is required &quot;patient’s address&quot;.
		hasAddress = (street || city || state || postal);	
	}

	// Patient Phone Number (Home)	
	var phone = ((obj.resource.Patient.telecom) ? obj.resource.Patient.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		oml[&apos;PID&apos;][&apos;PID.13&apos;] = convertPhoneXTN(phone);
	}


	// Validate conditional fields
	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (!hasAddress) error.push(&quot;resource.Patient.address for PID.11[Patient Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Patient.telecom for PID.13[Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);
	}


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.Patient.text &amp;&amp; obj.resource.Patient.text.div) {	
		
		var internalCommentsCount = 0; //  only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.Patient.text.div.p.length &amp;&amp; obj.resource.Patient.text.div.p.length &gt; 0) {
			obj.resource.Patient.text.div.p.forEach(function(item){
				// For internal (I) or report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					// If the comment is not internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				} 		
			});	
		} else if (obj.resource.Patient.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.Patient.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.Patient.text.div.p, countNTE++));
		}

		for (var i = comments.length - 1; i &gt;= 0; i--) {
			var nte = comments[i];
			if (nte.toString() != &quot;&quot;)
				oml[&apos;PID&apos;] += new XML(nte.toString());
		}

		comments.length = 0;
	}

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates PID segment with data from the Patient resource
	@param {Object} obj - Patient object resource
	@return - nothing, uses global HL7v2 message object
*/
function processPatient(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var comments = [];

	// Iterate over all patient identifiers
	obj.resource.Patient.identifier.forEach(function(item){

		// PID.3 [Patient Identifier List]
		if (item.use.value.toString() == &quot;official&quot;) {
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = id;

			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.5&apos;] = type;

			var assigner = ((item.assigner) ? item.assigner.display.value.toString() : &quot;&quot;);
			if (assigner)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = assigner;								

		// PID.2 [Patient ID]	
		} else if (item.use.value.toString() == &quot;secondary&quot;) {
		
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.1&apos;] = id;
				
			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.5&apos;] = type;			
						
		}
		
	});


	// Parse patient&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Patient.name, true);
	oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = nameParts.family;
	if (nameParts.given1) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = nameParts.given1;
	if (nameParts.given2) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = nameParts.given2;


	// Patient&apos;s DOB
	if (obj.resource.Patient.birthDate) {
		var dob = obj.resource.Patient.birthDate.value.toString();
		oml[&apos;PID&apos;][&apos;PID.7&apos;] = dob.replace(/-/g,&quot;&quot;);
	} else {
		error.push(&quot;resource.Patient.birthDate for PID.7[DateTime of Birth] is required&quot;);
	}

	// Administrative Gender 
	if (obj.resource.Patient.gender) {
		var gender = obj.resource.Patient.gender.value;
		oml[&apos;PID&apos;][&apos;PID.8&apos;] = convertTable(&quot;0001&quot;, gender);
	} else {
		error.push(&quot;resource.Patient.gender for PID.8[Administrative Sex] is required&quot;);		
	}




	// Patient Address
	if (obj.resource.Patient.address) {

		var street = ((obj.resource.Patient.address.line) ? obj.resource.Patient.address.line.value.toString() : &quot;&quot;);
		if (street)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = street;
		
		var city = ((obj.resource.Patient.address.city) ? obj.resource.Patient.address.city.value.toString() : &quot;&quot;);
		if (city)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = city;	
		
		var state = ((obj.resource.Patient.address.state) ? obj.resource.Patient.address.state.value.toString() : &quot;&quot;);
		if (state)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.4&apos;] = state;
	
		var postal = ((obj.resource.Patient.address.postalCode) ? obj.resource.Patient.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;] = postal;
	
		var country = ((obj.resource.Patient.address.country) ? obj.resource.Patient.address.country.value.toString() : &quot;&quot;);
		if (country)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.6&apos;] = country;

		// There might be a better definition what is required &quot;patient’s address&quot;.
		hasAddress = (street || city || state || postal);	
	}

	// Patient Phone Number (Home)	
	var phone = ((obj.resource.Patient.telecom) ? obj.resource.Patient.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		oml[&apos;PID&apos;][&apos;PID.13&apos;] = convertPhoneXTN(phone);
	}


	// Validate conditional fields
	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (!hasAddress) error.push(&quot;resource.Patient.address for PID.11[Patient Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Patient.telecom for PID.13[Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);
	}


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.Patient.text &amp;&amp; obj.resource.Patient.text.div) {	
		
		var internalCommentsCount = 0; //  only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.Patient.text.div.p.length &amp;&amp; obj.resource.Patient.text.div.p.length &gt; 0) {
			obj.resource.Patient.text.div.p.forEach(function(item){
				// For internal (I) or report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					// If the comment is not internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				} 		
			});	
		} else if (obj.resource.Patient.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.Patient.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.Patient.text.div.p, countNTE++));
		}

		for (var i = comments.length - 1; i &gt;= 0; i--) {
			var nte = comments[i];
			if (nte.toString() != &quot;&quot;)
				oml[&apos;PID&apos;] += new XML(nte.toString());
		}

		comments.length = 0;
	}

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>4</sequenceNumber>
                <name>IN1 primary and secondary segments</name>
                <script>/**
	Populates IN1 [Insurance] segments with data from the primary and secondary Coverage resources	
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCoverage(obj) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var isContainedPerson = hasPersonAddress = false;
	var isContainedOrganization = hasOrganizationAddress = false;

	var segIns = &lt;IN1&gt;
				&lt;IN1.1&gt;
					&lt;IN1.1.1&gt;1&lt;/IN1.1.1&gt;
				&lt;/IN1.1&gt;
				&lt;IN1.2/&gt;&lt;IN1.3/&gt;&lt;IN1.4/&gt;&lt;IN1.5/&gt;&lt;IN1.6/&gt;&lt;IN1.7/&gt;&lt;IN1.8/&gt;&lt;IN1.9/&gt;
				&lt;IN1.10/&gt;&lt;IN1.11/&gt;&lt;IN1.12/&gt;&lt;IN1.13/&gt;&lt;IN1.14/&gt;&lt;IN1.15/&gt;&lt;IN1.16/&gt;&lt;IN1.17/&gt;&lt;IN1.18/&gt;&lt;IN1.19/&gt;
				&lt;IN1.20/&gt;&lt;IN1.21/&gt;&lt;IN1.22/&gt;&lt;IN1.23/&gt;&lt;IN1.24/&gt;&lt;IN1.25/&gt;&lt;IN1.26/&gt;&lt;IN1.27/&gt;&lt;IN1.28/&gt;&lt;IN1.29/&gt;
				&lt;IN1.30/&gt;&lt;IN1.31/&gt;&lt;IN1.32/&gt;&lt;IN1.33/&gt;&lt;IN1.34/&gt;&lt;IN1.35/&gt;&lt;IN1.36/&gt;&lt;IN1.37/&gt;&lt;IN1.38/&gt;&lt;IN1.39/&gt;
				&lt;IN1.40/&gt;&lt;IN1.41/&gt;&lt;IN1.42/&gt;&lt;IN1.43/&gt;&lt;IN1.44/&gt;&lt;IN1.45/&gt;&lt;IN1.46/&gt;&lt;IN1.47/&gt;
			&lt;/IN1&gt;;

	// Insurance Set ID
	var coverageType = 1; 
	var setID = obj.resource.Coverage.id.value.toString();
	if (setID.indexOf(&quot;2&quot;) &gt; -1) {
		segIns[&apos;IN1.1&apos;] = &quot;2&quot;;
		coverageType = 2; // secondary - &quot;IN1-insurance-2&quot;
	} else {
		segIns[&apos;IN1.1&apos;] = &quot;1&quot;;
		coverageType = 1; // primary - &quot;IN1-insurance-1&quot;		
	}


	// Insurance Plan ID
	var planID = obj.resource.Coverage.identifier.value.value.toString();
//	if (planID)
//		segIns[&apos;IN1.2&apos;] = planID;


	if (obj.resource.Coverage.contained.length &amp;&amp; obj.resource.Coverage.contained.length &gt; 0) {

		// Loop through contained resources
		obj.resource.Coverage.contained.forEach(function(item){

			// Process contained insurance company
			processInsuranceOrganization(segIns, item);

			if (item.Person != null &amp;&amp; item.Person != undefined) {

				isContainedPerson = true;
				
				// Process insured person name with DEX name length limitation applied
				nameParts = processPersonName(item.Person.name, true);
	
				// Insured&apos;s Address
				if (item.Person.address) {
					var street = item.Person.address.line.value.toString();
					if (street)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.1&apos;] = street;
					
					var city = ((item.Person.address.city) ? item.Person.address.city.value.toString() : &quot;&quot;);
					if (city)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.3&apos;] = city;	
					
					var state = ((item.Person.address.state) ? item.Person.address.state.value.toString() : &quot;&quot;);
					if (state)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.4&apos;] = state;
				
					var postal = ((item.Person.address.postalCode) ? item.Person.address.postalCode.value.toString() : &quot;&quot;);
					if (postal)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.5&apos;] = postal;
				
					var country = ((item.Person.address.country) ? item.Person.address.country.value.toString() : &quot;&quot;);
					if (country)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.6&apos;] = country;
						
					// There might be a better definition what is required &quot;insured’s Address&quot;.
					hasPersonAddress = (street || city || state || postal);	
				}
			}
		});

	} else {
		// When only contained  insurance company is present
		processInsuranceOrganization(segIns, obj.resource.Coverage.contained);
	}

	// Insured&apos;s Group Employer Name 
	if (obj.resource.Coverage.extension) {
		var emplName = ((obj.resource.Coverage.extension.valueIdentifier) ? obj.resource.Coverage.extension.valueIdentifier.value.value.toString() : &quot;&quot;);
		if (emplName)
			segIns[&apos;IN1.11&apos;] = emplName;
	}


	// Group Number
	var groupNumber = ((obj.resource.Coverage.group) ? obj.resource.Coverage.group.value.toString() : &quot;&quot;);
	if (groupNumber)
		segIns[&apos;IN1.8&apos;] = groupNumber;



	

	// Name Of Insured
	// (SN) March 11, 2017: Fix to downgrade to DSTU3 Coverage resource. Previously checked only planholderReference.
/*	
	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
*/

	// Name Of Insured
	// (SN) March 13 2017: Disabled
	//var insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();

	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
	
	if (insuredRef == &quot;Patient/PID-patient-identification&quot;) {
		// Same as the PID segment
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString();
		
	} else if (insuredRef == &quot;Person/insured-person&quot;) {
		// Taken from the contained Person resource
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = nameParts.family;
		if (nameParts.given1.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = nameParts.given1;
		if (nameParts.given2.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = nameParts.given2;		
	}

	// Insured&apos;s Relationship To Patient
	if ( obj.resource.Coverage.relationship) {
		var relationship = ((obj.resource.Coverage.relationship.code) ? obj.resource.Coverage.relationship.code.value.toString() : &quot;&quot;);
		if (relationship)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;] = relationship;
		
		var relationshipDesc = ((obj.resource.Coverage.relationship.display) ? obj.resource.Coverage.relationship.display.value.toString() : &quot;&quot;);
		if (relationshipDesc)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.2&apos;] = relationshipDesc;
	}

	// Company Plan Code
	var planCode = (( obj.resource.Coverage.subPlan) ? obj.resource.Coverage.subPlan.value.toString() : &quot;&quot;);
	if (planCode)
		segIns[&apos;IN1.35&apos;] = planCode;

	// Policy Number
	var policyNumber = ((obj.resource.Coverage.plan) ? obj.resource.Coverage.plan.value.toString() : &quot;&quot;);
	if (policyNumber)
		segIns[&apos;IN1.36&apos;] = policyNumber;

	// Coverage Type
	segIns[&apos;IN1.47&apos;] = channelMap.get(&quot;CoverageType&quot;);


	if (coverage == &quot;T&quot;) {
		if (segIns[&apos;IN1.4&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Organization.name for IN1.4[Insurance Company Name] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.8&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.group for IN1.8[Group Number] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Person.name for IN1.16[Name Of Insured] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.relationship.code for IN1.17[Insured Relationship To Patient] is required if IN1.47[Coverage Type] is T&quot;);
		if (isContainedPerson &amp;&amp; !hasPersonAddress) error.push(&quot;resource.Coverage.contained.Person.address for IN1.19[Insured Address] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.36&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.plan for IN1.36[Policy Number] is required if IN1.47[Coverage Type] is T&quot;);		
	}


	// Store the segment to be later compiled into a message
	coverageMap.put(coverageType, segIns.toString());

	return;
}


/**
	Populates IN1.3 [Insurance Company ID] field with data from the contained Organization resource
	@param {Object} obj - Organization object resource
	@return - nothing, uses global HL7v2 message object
*/
function processInsuranceOrganization(segIns, item) {
return;
	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;

	if (item.Organization != null &amp;&amp; item.Organization != undefined) {

		isContainedOrganization = true;
		
		// Insurance Company ID
		var companyID = ((item.Organization.identifier) ? item.Organization.identifier.value.value.toString() : &quot;&quot;);
		if (companyID) 
			segIns[&apos;IN1.3&apos;] = companyID;
	
		// Insurance Company Name
		var companyName = ((item.Organization.name) ? item.Organization.name.value.toString() : &quot;&quot;);
		if (companyName)
			segIns[&apos;IN1.4&apos;] = companyName;

		// Insurance Company Address
		if (item.Organization.address) {
			var street = ((item.Organization.address.line) ? item.Organization.address.line.value.toString() : &quot;&quot;);
			if (street)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.1&apos;] = street;
				
			var city = ((item.Organization.address.city) ? item.Organization.address.city.value.toString() : &quot;&quot;);
			if (city)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.3&apos;] = city;
			
			var state = ((item.Organization.address.state) ? item.Organization.address.state.value.toString() : &quot;&quot;);
			if (state)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.4&apos;] = state;
		
			var postal = ((item.Organization.address.postalCode) ? item.Organization.address.postalCode.value.toString() : &quot;&quot;);
			if (postal)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.5&apos;] = postal;
		
			var country = ((item.Organization.address.country) ? item.Organization.address.country.value.toString() : &quot;&quot;);
			if (country)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.6&apos;] = country;

			// There might be a better definition what is required &quot;Insurance Company Address&quot;
			hasOrganizationAddress = (street || city || state || postal);						
		}		

		// Insurance Co Phone Number
		var phone = ((item.Organization.telecom) ? item.Organization.telecom.value.value.toString() : &quot;&quot;);
		if (phone) {
			hasPhone = true;
			segIns[&apos;IN1.7&apos;] = convertPhoneXTN(phone);
		}
	}

	// Validate conditional fields
	if (coverage == &quot;T&quot;) {		
		if (isContainedOrganization &amp;&amp; !hasOrganizationAddress) error.push(&quot;resource.Coverage.contained.Organization.address for IN1.5[Insurance Company Address] is required if IN1.47[Coverage Type] is T&quot;);
	}


	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates IN1 [Insurance] segments with data from the primary and secondary Coverage resources	
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCoverage(obj) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var isContainedPerson = hasPersonAddress = false;
	var isContainedOrganization = hasOrganizationAddress = false;

	var segIns = &lt;IN1&gt;
				&lt;IN1.1&gt;
					&lt;IN1.1.1&gt;1&lt;/IN1.1.1&gt;
				&lt;/IN1.1&gt;
				&lt;IN1.2/&gt;&lt;IN1.3/&gt;&lt;IN1.4/&gt;&lt;IN1.5/&gt;&lt;IN1.6/&gt;&lt;IN1.7/&gt;&lt;IN1.8/&gt;&lt;IN1.9/&gt;
				&lt;IN1.10/&gt;&lt;IN1.11/&gt;&lt;IN1.12/&gt;&lt;IN1.13/&gt;&lt;IN1.14/&gt;&lt;IN1.15/&gt;&lt;IN1.16/&gt;&lt;IN1.17/&gt;&lt;IN1.18/&gt;&lt;IN1.19/&gt;
				&lt;IN1.20/&gt;&lt;IN1.21/&gt;&lt;IN1.22/&gt;&lt;IN1.23/&gt;&lt;IN1.24/&gt;&lt;IN1.25/&gt;&lt;IN1.26/&gt;&lt;IN1.27/&gt;&lt;IN1.28/&gt;&lt;IN1.29/&gt;
				&lt;IN1.30/&gt;&lt;IN1.31/&gt;&lt;IN1.32/&gt;&lt;IN1.33/&gt;&lt;IN1.34/&gt;&lt;IN1.35/&gt;&lt;IN1.36/&gt;&lt;IN1.37/&gt;&lt;IN1.38/&gt;&lt;IN1.39/&gt;
				&lt;IN1.40/&gt;&lt;IN1.41/&gt;&lt;IN1.42/&gt;&lt;IN1.43/&gt;&lt;IN1.44/&gt;&lt;IN1.45/&gt;&lt;IN1.46/&gt;&lt;IN1.47/&gt;
			&lt;/IN1&gt;;

	// Insurance Set ID
	var coverageType = 1; 
	var setID = obj.resource.Coverage.id.value.toString();
	if (setID.indexOf(&quot;2&quot;) &gt; -1) {
		segIns[&apos;IN1.1&apos;] = &quot;2&quot;;
		coverageType = 2; // secondary - &quot;IN1-insurance-2&quot;
	} else {
		segIns[&apos;IN1.1&apos;] = &quot;1&quot;;
		coverageType = 1; // primary - &quot;IN1-insurance-1&quot;		
	}


	// Insurance Plan ID
	var planID = obj.resource.Coverage.identifier.value.value.toString();
//	if (planID)
//		segIns[&apos;IN1.2&apos;] = planID;


	if (obj.resource.Coverage.contained.length &amp;&amp; obj.resource.Coverage.contained.length &gt; 0) {

		// Loop through contained resources
		obj.resource.Coverage.contained.forEach(function(item){

			// Process contained insurance company
			processInsuranceOrganization(segIns, item);

			if (item.Person != null &amp;&amp; item.Person != undefined) {

				isContainedPerson = true;
				
				// Process insured person name with DEX name length limitation applied
				nameParts = processPersonName(item.Person.name, true);
	
				// Insured&apos;s Address
				if (item.Person.address) {
					var street = item.Person.address.line.value.toString();
					if (street)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.1&apos;] = street;
					
					var city = ((item.Person.address.city) ? item.Person.address.city.value.toString() : &quot;&quot;);
					if (city)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.3&apos;] = city;	
					
					var state = ((item.Person.address.state) ? item.Person.address.state.value.toString() : &quot;&quot;);
					if (state)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.4&apos;] = state;
				
					var postal = ((item.Person.address.postalCode) ? item.Person.address.postalCode.value.toString() : &quot;&quot;);
					if (postal)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.5&apos;] = postal;
				
					var country = ((item.Person.address.country) ? item.Person.address.country.value.toString() : &quot;&quot;);
					if (country)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.6&apos;] = country;
						
					// There might be a better definition what is required &quot;insured’s Address&quot;.
					hasPersonAddress = (street || city || state || postal);	
				}
			}
		});

	} else {
		// When only contained  insurance company is present
		processInsuranceOrganization(segIns, obj.resource.Coverage.contained);
	}

	// Insured&apos;s Group Employer Name 
	if (obj.resource.Coverage.extension) {
		var emplName = ((obj.resource.Coverage.extension.valueIdentifier) ? obj.resource.Coverage.extension.valueIdentifier.value.value.toString() : &quot;&quot;);
		if (emplName)
			segIns[&apos;IN1.11&apos;] = emplName;
	}


	// Group Number
	var groupNumber = ((obj.resource.Coverage.group) ? obj.resource.Coverage.group.value.toString() : &quot;&quot;);
	if (groupNumber)
		segIns[&apos;IN1.8&apos;] = groupNumber;



	

	// Name Of Insured
	// (SN) March 11, 2017: Fix to downgrade to DSTU3 Coverage resource. Previously checked only planholderReference.
/*	
	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
*/

	// Name Of Insured
	// (SN) March 13 2017: Disabled
	//var insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();

	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
	
	if (insuredRef == &quot;Patient/PID-patient-identification&quot;) {
		// Same as the PID segment
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString();
		
	} else if (insuredRef == &quot;Person/insured-person&quot;) {
		// Taken from the contained Person resource
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = nameParts.family;
		if (nameParts.given1.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = nameParts.given1;
		if (nameParts.given2.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = nameParts.given2;		
	}

	// Insured&apos;s Relationship To Patient
	if ( obj.resource.Coverage.relationship) {
		var relationship = ((obj.resource.Coverage.relationship.code) ? obj.resource.Coverage.relationship.code.value.toString() : &quot;&quot;);
		if (relationship)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;] = relationship;
		
		var relationshipDesc = ((obj.resource.Coverage.relationship.display) ? obj.resource.Coverage.relationship.display.value.toString() : &quot;&quot;);
		if (relationshipDesc)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.2&apos;] = relationshipDesc;
	}

	// Company Plan Code
	var planCode = (( obj.resource.Coverage.subPlan) ? obj.resource.Coverage.subPlan.value.toString() : &quot;&quot;);
	if (planCode)
		segIns[&apos;IN1.35&apos;] = planCode;

	// Policy Number
	var policyNumber = ((obj.resource.Coverage.plan) ? obj.resource.Coverage.plan.value.toString() : &quot;&quot;);
	if (policyNumber)
		segIns[&apos;IN1.36&apos;] = policyNumber;

	// Coverage Type
	segIns[&apos;IN1.47&apos;] = channelMap.get(&quot;CoverageType&quot;);


	if (coverage == &quot;T&quot;) {
		if (segIns[&apos;IN1.4&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Organization.name for IN1.4[Insurance Company Name] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.8&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.group for IN1.8[Group Number] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Person.name for IN1.16[Name Of Insured] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.relationship.code for IN1.17[Insured Relationship To Patient] is required if IN1.47[Coverage Type] is T&quot;);
		if (isContainedPerson &amp;&amp; !hasPersonAddress) error.push(&quot;resource.Coverage.contained.Person.address for IN1.19[Insured Address] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.36&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.plan for IN1.36[Policy Number] is required if IN1.47[Coverage Type] is T&quot;);		
	}


	// Store the segment to be later compiled into a message
	coverageMap.put(coverageType, segIns.toString());

	return;
}


/**
	Populates IN1.3 [Insurance Company ID] field with data from the contained Organization resource
	@param {Object} obj - Organization object resource
	@return - nothing, uses global HL7v2 message object
*/
function processInsuranceOrganization(segIns, item) {
return;
	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;

	if (item.Organization != null &amp;&amp; item.Organization != undefined) {

		isContainedOrganization = true;
		
		// Insurance Company ID
		var companyID = ((item.Organization.identifier) ? item.Organization.identifier.value.value.toString() : &quot;&quot;);
		if (companyID) 
			segIns[&apos;IN1.3&apos;] = companyID;
	
		// Insurance Company Name
		var companyName = ((item.Organization.name) ? item.Organization.name.value.toString() : &quot;&quot;);
		if (companyName)
			segIns[&apos;IN1.4&apos;] = companyName;

		// Insurance Company Address
		if (item.Organization.address) {
			var street = ((item.Organization.address.line) ? item.Organization.address.line.value.toString() : &quot;&quot;);
			if (street)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.1&apos;] = street;
				
			var city = ((item.Organization.address.city) ? item.Organization.address.city.value.toString() : &quot;&quot;);
			if (city)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.3&apos;] = city;
			
			var state = ((item.Organization.address.state) ? item.Organization.address.state.value.toString() : &quot;&quot;);
			if (state)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.4&apos;] = state;
		
			var postal = ((item.Organization.address.postalCode) ? item.Organization.address.postalCode.value.toString() : &quot;&quot;);
			if (postal)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.5&apos;] = postal;
		
			var country = ((item.Organization.address.country) ? item.Organization.address.country.value.toString() : &quot;&quot;);
			if (country)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.6&apos;] = country;

			// There might be a better definition what is required &quot;Insurance Company Address&quot;
			hasOrganizationAddress = (street || city || state || postal);						
		}		

		// Insurance Co Phone Number
		var phone = ((item.Organization.telecom) ? item.Organization.telecom.value.value.toString() : &quot;&quot;);
		if (phone) {
			hasPhone = true;
			segIns[&apos;IN1.7&apos;] = convertPhoneXTN(phone);
		}
	}

	// Validate conditional fields
	if (coverage == &quot;T&quot;) {		
		if (isContainedOrganization &amp;&amp; !hasOrganizationAddress) error.push(&quot;resource.Coverage.contained.Organization.address for IN1.5[Insurance Company Address] is required if IN1.47[Coverage Type] is T&quot;);
	}


	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>5</sequenceNumber>
                <name>GT1 segment</name>
                <script>/**
	Creates and populates GT1 [Guarantor] segment from the Person resource
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processGuarantor(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var gt1 = &lt;GT1&gt;
				&lt;GT1.1&gt;&lt;GT1.1.1&gt;1&lt;/GT1.1.1&gt;&lt;/GT1.1&gt;
				&lt;GT1.2/&gt;
				&lt;GT1.3&gt;&lt;GT1.3.1/&gt;&lt;GT1.3.2/&gt;&lt;/GT1.3&gt;
			&lt;/GT1&gt;;

	// Parse guarantor&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Person.name, true);
	gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;] = nameParts.family;
	if (nameParts.given1.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.2&apos;] = nameParts.given1;
	if (nameParts.given2.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.3&apos;] = nameParts.given2;	


	// Guarantor Address
	if (obj.resource.Person.address) {
		var street = ((obj.resource.Person.address.line) ? obj.resource.Person.address.line.value.toString() : &quot;&quot;);
		if (street)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.1&apos;] = street;
		
		var city = ((obj.resource.Person.address.city) ? obj.resource.Person.address.city.value.toString() : &quot;&quot;);
		if (city)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.3&apos;] = city;	
		
		var state = ((obj.resource.Person.address.state) ? obj.resource.Person.address.state.value.toString() : &quot;&quot;);
		if (state)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.4&apos;] = state;
	
		var postal = ((obj.resource.Person.address.postalCode) ? obj.resource.Person.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.5&apos;] = postal;
	
		var country = ((obj.resource.Person.address.country) ? obj.resource.Person.address.country.value.toString() : &quot;&quot;);
		if (country)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.6&apos;] = country;

		// There might be a better definition what is required &quot;guarantor address&quot;.
		hasAddress = (street || city || state || postal);			
	}


	// Guarantor Phon Number - Home
	var phone = ((obj.resource.Person.telecom) ? obj.resource.Person.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		gt1[&apos;GT1.6&apos;] = convertPhoneXTN(phone);
	}


	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Person.name for GT1.3[Guarantor Name] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasAddress) error.push(&quot;resource.Person.address for GT1.5[Guarantor Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Person.telecom for GT1.6[Guarantor Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);		
	}

	// Store the segment to be later compiled into a message
	guarantorMap.put(1, gt1.toString());

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates and populates GT1 [Guarantor] segment from the Person resource
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processGuarantor(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var gt1 = &lt;GT1&gt;
				&lt;GT1.1&gt;&lt;GT1.1.1&gt;1&lt;/GT1.1.1&gt;&lt;/GT1.1&gt;
				&lt;GT1.2/&gt;
				&lt;GT1.3&gt;&lt;GT1.3.1/&gt;&lt;GT1.3.2/&gt;&lt;/GT1.3&gt;
			&lt;/GT1&gt;;

	// Parse guarantor&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Person.name, true);
	gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;] = nameParts.family;
	if (nameParts.given1.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.2&apos;] = nameParts.given1;
	if (nameParts.given2.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.3&apos;] = nameParts.given2;	


	// Guarantor Address
	if (obj.resource.Person.address) {
		var street = ((obj.resource.Person.address.line) ? obj.resource.Person.address.line.value.toString() : &quot;&quot;);
		if (street)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.1&apos;] = street;
		
		var city = ((obj.resource.Person.address.city) ? obj.resource.Person.address.city.value.toString() : &quot;&quot;);
		if (city)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.3&apos;] = city;	
		
		var state = ((obj.resource.Person.address.state) ? obj.resource.Person.address.state.value.toString() : &quot;&quot;);
		if (state)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.4&apos;] = state;
	
		var postal = ((obj.resource.Person.address.postalCode) ? obj.resource.Person.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.5&apos;] = postal;
	
		var country = ((obj.resource.Person.address.country) ? obj.resource.Person.address.country.value.toString() : &quot;&quot;);
		if (country)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.6&apos;] = country;

		// There might be a better definition what is required &quot;guarantor address&quot;.
		hasAddress = (street || city || state || postal);			
	}


	// Guarantor Phon Number - Home
	var phone = ((obj.resource.Person.telecom) ? obj.resource.Person.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		gt1[&apos;GT1.6&apos;] = convertPhoneXTN(phone);
	}


	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Person.name for GT1.3[Guarantor Name] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasAddress) error.push(&quot;resource.Person.address for GT1.5[Guarantor Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Person.telecom for GT1.6[Guarantor Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);		
	}

	// Store the segment to be later compiled into a message
	guarantorMap.put(1, gt1.toString());

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>6</sequenceNumber>
                <name>ORC segment</name>
                <script>/**
	Populates ORC [Common Order] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticReport object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCommonOrder(obj) {


	var orc = &lt;ORC&gt;&lt;ORC.1&gt;&lt;ORC.1.1&gt;NW&lt;/ORC.1.1&gt;&lt;/ORC.1&gt;&lt;/ORC&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticReport.id) ? obj.resource.DiagnosticReport.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);

//	logger.error( &quot;Group Count: &quot; + groupCount );
//	logger.error( &quot;Group ID: &quot; + groupID );
			
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticReport.id element is undefined or not properly formatted, expected: ORC-common-order-n, where n identifies the order group&quot;);
	}


	// Placer Order Number
	// The value in ORC.02.01 (Entity Identifier) is the same as the value in OBR.02.01 (Entity Identifier)
	// All values for this field in all ORC and OBR segments are identical.
	// March 12: Moved into DiagnosticReport.identifier verified block 
	//var id = obj.resource.DiagnosticReport.identifier.value.value.toString();
	//if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;

	if (obj.resource.DiagnosticReport.identifier) {

		var id = ((obj.resource.DiagnosticReport.identifier.value.value) ? obj.resource.DiagnosticReport.identifier.value.value.toString():&quot;&quot;);
		if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;
		
//		var namespaceID = ((obj.resource.DiagnosticReport.identifier.system) ? obj.resource.DiagnosticReport.identifier.system.value.toString() : &quot;&quot;);
//		if (namespaceID) orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;] = namespaceID;
	
//		var universalID = ((obj.resource.DiagnosticReport.identifier.type) ? obj.resource.DiagnosticReport.identifier.type.id.toString() : &quot;&quot;);
//		if (universalID) orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;] = universalID;
	}
	else
	{
		logger.error( &quot;Missing identifier in in Diagnostic Report:&quot; + groupID )
	}


	// Store the Placer Order Number for the OBR segment
	var diagnosticOrderID = ((obj.resource.DiagnosticReport.request) ? obj.resource.DiagnosticReport.request.reference.value.toString() : &quot;&quot;);
	if (diagnosticOrderID.indexOf(&quot;DiagnosticOrder/&quot;) &gt; -1) {
		diagnosticOrderID = diagnosticOrderID.substring(&quot;DiagnosticOrder/&quot;.length, diagnosticOrderID.length);
		
		var placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};

		
		placedOrderNumber.id = orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;].toString();
		placedOrderNumber.namespaceID = orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;].toString();
		placedOrderNumber.universalID = orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;].toString();
		placedOrderNumberMap.put(diagnosticOrderID, placedOrderNumber);		
	}
	else
	{
		logger.error( &quot;No Diagnostic Order Found&quot; );
	}


	// Verified By Practitioner
//	if (obj.resource.DiagnosticReport.contained != null &amp;&amp; obj.resource.DiagnosticReport.contained != undefined) {
//		var verifiedByID = obj.resource.DiagnosticReport.contained.Practitioner.identifier.value.value.toString();
//		if (verifiedByID)
//			orc[&apos;ORC.11&apos;][&apos;ORC.11.1&apos;] = verifiedByID;
//			
//		var familyName = ((obj.resource.DiagnosticReport.contained.Practitioner.name) ? obj.resource.DiagnosticReport.contained.Practitioner.name.family.value.toString() : &quot;&quot;);
//		if (familyName)
//			orc[&apos;ORC.11&apos;][&apos;ORC.11.2&apos;] = familyName;		
//	}

	// Process extension for TQ1 [Timing/Quantity] segment
	if (obj.resource.DiagnosticReport.extension.valueTiming != null &amp;&amp; obj.resource.DiagnosticReport.extension.valueTiming != undefined) {
		processTimingQuantity(groupCount, obj.resource.DiagnosticReport.extension.valueTiming);
	}

	// Process zero or many DiagnosticReport/codedDiagnosis elements for DG1 [Diagnosis] segment
	var conditions = [];
	if (obj.resource.DiagnosticReport.codedDiagnosis) {

		if (obj.resource.DiagnosticReport.codedDiagnosis.length &gt; 0) {
			var setID = 1;
			obj.resource.DiagnosticReport.codedDiagnosis.forEach(function(item){
				// A maximum of 12 unique ICD-10 codes are permitted per entire OML message
				// (SN) This code checks only codedDiagnosis in a single DiagnosticReport
				if (setID &lt;= 12) conditions.push(processCondition(item, setID++));				 
			});
		} else {
			conditions.push(processCondition(obj.resource.DiagnosticReport.codedDiagnosis, 1)); 
		}
	}

	// Process zero or many result/reference elements for OBX [Observation] segment
	var observationReferences = [];
	if (obj.resource.DiagnosticReport.result) {
		var ref;
		if (obj.resource.DiagnosticReport.result.length &gt; 0) {
			obj.resource.DiagnosticReport.result.forEach(function(item){
				ref = item.reference.value.toString();
				if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
			});
		} else {
			ref = ((obj.resource.DiagnosticReport.result.reference != undefined) ? obj.resource.DiagnosticReport.result.reference.value.toString() : &quot;&quot;);
			if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
		}		
	}


	// ORC.12 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticReport.performer != undefined) ? obj.resource.DiagnosticReport.performer.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(&quot;Practitioner/&quot;.length, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) orc[&apos;ORC.12&apos;][&apos;ORC.12.1&apos;] = id;
	
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) orc[&apos;ORC.12&apos;][&apos;ORC.12.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			orc[&apos;ORC.12&apos;][&apos;ORC.12.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.4&apos;] = nameParts.given2;				
		}
	}
	

	// Store the segment to be later compiled into a message
	commonOrderMap.put(groupCount.toString(), orc.toString());

	// Store the array of diagnosis to be later compiled into a message
	if (conditions.length &gt; 0) diagnosisMap.put(groupCount.toString(), conditions);

	// Store the array of Observations to be later compiled into a message
	if (observationReferences.length &gt; 0) observationReferencesMap.put(groupCount.toString(), observationReferences);

}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates ORC [Common Order] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticReport object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCommonOrder(obj) {


	var orc = &lt;ORC&gt;&lt;ORC.1&gt;&lt;ORC.1.1&gt;NW&lt;/ORC.1.1&gt;&lt;/ORC.1&gt;&lt;/ORC&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticReport.id) ? obj.resource.DiagnosticReport.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);

//	logger.error( &quot;Group Count: &quot; + groupCount );
//	logger.error( &quot;Group ID: &quot; + groupID );
			
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticReport.id element is undefined or not properly formatted, expected: ORC-common-order-n, where n identifies the order group&quot;);
	}


	// Placer Order Number
	// The value in ORC.02.01 (Entity Identifier) is the same as the value in OBR.02.01 (Entity Identifier)
	// All values for this field in all ORC and OBR segments are identical.
	// March 12: Moved into DiagnosticReport.identifier verified block 
	//var id = obj.resource.DiagnosticReport.identifier.value.value.toString();
	//if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;

	if (obj.resource.DiagnosticReport.identifier) {

		var id = ((obj.resource.DiagnosticReport.identifier.value.value) ? obj.resource.DiagnosticReport.identifier.value.value.toString():&quot;&quot;);
		if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;
		
//		var namespaceID = ((obj.resource.DiagnosticReport.identifier.system) ? obj.resource.DiagnosticReport.identifier.system.value.toString() : &quot;&quot;);
//		if (namespaceID) orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;] = namespaceID;
	
//		var universalID = ((obj.resource.DiagnosticReport.identifier.type) ? obj.resource.DiagnosticReport.identifier.type.id.toString() : &quot;&quot;);
//		if (universalID) orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;] = universalID;
	}
	else
	{
		logger.error( &quot;Missing identifier in in Diagnostic Report:&quot; + groupID )
	}


	// Store the Placer Order Number for the OBR segment
	var diagnosticOrderID = ((obj.resource.DiagnosticReport.request) ? obj.resource.DiagnosticReport.request.reference.value.toString() : &quot;&quot;);
	if (diagnosticOrderID.indexOf(&quot;DiagnosticOrder/&quot;) &gt; -1) {
		diagnosticOrderID = diagnosticOrderID.substring(&quot;DiagnosticOrder/&quot;.length, diagnosticOrderID.length);
		
		var placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};

		
		placedOrderNumber.id = orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;].toString();
		placedOrderNumber.namespaceID = orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;].toString();
		placedOrderNumber.universalID = orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;].toString();
		placedOrderNumberMap.put(diagnosticOrderID, placedOrderNumber);		
	}
	else
	{
		logger.error( &quot;No Diagnostic Order Found&quot; );
	}


	// Verified By Practitioner
//	if (obj.resource.DiagnosticReport.contained != null &amp;&amp; obj.resource.DiagnosticReport.contained != undefined) {
//		var verifiedByID = obj.resource.DiagnosticReport.contained.Practitioner.identifier.value.value.toString();
//		if (verifiedByID)
//			orc[&apos;ORC.11&apos;][&apos;ORC.11.1&apos;] = verifiedByID;
//			
//		var familyName = ((obj.resource.DiagnosticReport.contained.Practitioner.name) ? obj.resource.DiagnosticReport.contained.Practitioner.name.family.value.toString() : &quot;&quot;);
//		if (familyName)
//			orc[&apos;ORC.11&apos;][&apos;ORC.11.2&apos;] = familyName;		
//	}

	// Process extension for TQ1 [Timing/Quantity] segment
	if (obj.resource.DiagnosticReport.extension.valueTiming != null &amp;&amp; obj.resource.DiagnosticReport.extension.valueTiming != undefined) {
		processTimingQuantity(groupCount, obj.resource.DiagnosticReport.extension.valueTiming);
	}

	// Process zero or many DiagnosticReport/codedDiagnosis elements for DG1 [Diagnosis] segment
	var conditions = [];
	if (obj.resource.DiagnosticReport.codedDiagnosis) {

		if (obj.resource.DiagnosticReport.codedDiagnosis.length &gt; 0) {
			var setID = 1;
			obj.resource.DiagnosticReport.codedDiagnosis.forEach(function(item){
				// A maximum of 12 unique ICD-10 codes are permitted per entire OML message
				// (SN) This code checks only codedDiagnosis in a single DiagnosticReport
				if (setID &lt;= 12) conditions.push(processCondition(item, setID++));				 
			});
		} else {
			conditions.push(processCondition(obj.resource.DiagnosticReport.codedDiagnosis, 1)); 
		}
	}

	// Process zero or many result/reference elements for OBX [Observation] segment
	var observationReferences = [];
	if (obj.resource.DiagnosticReport.result) {
		var ref;
		if (obj.resource.DiagnosticReport.result.length &gt; 0) {
			obj.resource.DiagnosticReport.result.forEach(function(item){
				ref = item.reference.value.toString();
				if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
			});
		} else {
			ref = ((obj.resource.DiagnosticReport.result.reference != undefined) ? obj.resource.DiagnosticReport.result.reference.value.toString() : &quot;&quot;);
			if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
		}		
	}


	// ORC.12 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticReport.performer != undefined) ? obj.resource.DiagnosticReport.performer.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(&quot;Practitioner/&quot;.length, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) orc[&apos;ORC.12&apos;][&apos;ORC.12.1&apos;] = id;
	
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) orc[&apos;ORC.12&apos;][&apos;ORC.12.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			orc[&apos;ORC.12&apos;][&apos;ORC.12.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.4&apos;] = nameParts.given2;				
		}
	}
	

	// Store the segment to be later compiled into a message
	commonOrderMap.put(groupCount.toString(), orc.toString());

	// Store the array of diagnosis to be later compiled into a message
	if (conditions.length &gt; 0) diagnosisMap.put(groupCount.toString(), conditions);

	// Store the array of Observations to be later compiled into a message
	if (observationReferences.length &gt; 0) observationReferencesMap.put(groupCount.toString(), observationReferences);

}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>7</sequenceNumber>
                <name>TQ1 segment</name>
                <script>/**
	Populates TQ1 [Timing/Quantity] segment with data from the DiagnosticReport extension
	@param {Integer} count - Common Order group count
	@param {Object} valueTiming - valueTiming extension
	@return - nothing, uses global map
*/
function processTimingQuantity(count, valueTiming) {
	
	// TQ1 [Timing/Quantity] segment
	if (valueTiming != null &amp;&amp; valueTiming != undefined) {

		var tq1 = &lt;TQ1&gt;&lt;TQ1.1&gt;&lt;TQ1.1.1&gt;1&lt;/TQ1.1.1&gt;&lt;/TQ1.1&gt;&lt;/TQ1&gt;;

			
		var startDateTime = ((valueTiming.event) ? valueTiming.event.value.toString() : &quot;&quot;);
		if (startDateTime)
			tq1[&apos;TQ1.7&apos;] = convertJSONDateTime(startDateTime);

		var priorityCode = ((valueTiming.code) ? valueTiming.code.coding.code.value.toString() : &quot;&quot;);
		if (priorityCode)
			tq1[&apos;TQ1.9&apos;][&apos;TQ1.9.1&apos;] = priorityCode;
	}

	// Store the segment to be later compiled into a message
	timingQuantityMap.put(count.toString(), tq1.toString());

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates TQ1 [Timing/Quantity] segment with data from the DiagnosticReport extension
	@param {Integer} count - Common Order group count
	@param {Object} valueTiming - valueTiming extension
	@return - nothing, uses global map
*/
function processTimingQuantity(count, valueTiming) {
	
	// TQ1 [Timing/Quantity] segment
	if (valueTiming != null &amp;&amp; valueTiming != undefined) {

		var tq1 = &lt;TQ1&gt;&lt;TQ1.1&gt;&lt;TQ1.1.1&gt;1&lt;/TQ1.1.1&gt;&lt;/TQ1.1&gt;&lt;/TQ1&gt;;

			
		var startDateTime = ((valueTiming.event) ? valueTiming.event.value.toString() : &quot;&quot;);
		if (startDateTime)
			tq1[&apos;TQ1.7&apos;] = convertJSONDateTime(startDateTime);

		var priorityCode = ((valueTiming.code) ? valueTiming.code.coding.code.value.toString() : &quot;&quot;);
		if (priorityCode)
			tq1[&apos;TQ1.9&apos;][&apos;TQ1.9.1&apos;] = priorityCode;
	}

	// Store the segment to be later compiled into a message
	timingQuantityMap.put(count.toString(), tq1.toString());

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>8</sequenceNumber>
                <name>OBR segment</name>
                <script>/**
	Populates OBR [Observation Request] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticOrder object resource
	@return - nothing, uses global HL7v2 message object
*/
function processObservationRequest(obj) {

	var comments = [];

	var obr = &lt;OBR&gt;&lt;OBR.1&gt;&lt;OBR.1.1&gt;1&lt;/OBR.1.1&gt;&lt;/OBR.1&gt;
				&lt;OBR.2/&gt;&lt;OBR.3/&gt;
				&lt;OBR.4&gt;&lt;OBR.4.1/&gt;&lt;OBR.4.2/&gt;&lt;OBR.4.3/&gt;&lt;OBR.4.4/&gt;&lt;OBR.4.5/&gt;&lt;/OBR.4&gt;
				&lt;OBR.5/&gt;&lt;OBR.6/&gt;&lt;OBR.7/&gt;&lt;OBR.8/&gt;&lt;OBR.9/&gt;
				&lt;OBR.10/&gt;&lt;OBR.11/&gt;&lt;OBR.12/&gt;&lt;OBR.13/&gt;&lt;OBR.14/&gt;&lt;OBR.15/&gt;
				&lt;OBR.16&gt;&lt;OBR.16.1/&gt;&lt;OBR.16.2/&gt;&lt;OBR.16.3/&gt;&lt;OBR.16.4/&gt;&lt;OBR.16.5/&gt;&lt;OBR.16.6/&gt;&lt;OBR.16.7/&gt;&lt;OBR.16.8/&gt;&lt;/OBR.16&gt;
			&lt;/OBR&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticOrder.id) ? obj.resource.DiagnosticOrder.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);
		
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticOrder.id element is undefined or not properly formatted, expected: OBR-observation-request-n, where n identifies the order group&quot;);
	}

	obr[&apos;OBR.1&apos;][&apos;OBR.1.1&apos;] = groupCount;

	// OBR.2 [Placer Order Number] is stored during the DiagnosticReport resource processing	
	var resourceID = obj.resource.DiagnosticOrder.id.value.toString();
	// Extracts the following object - placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};
	var placedOrderNumber = placedOrderNumberMap.get(resourceID);
	if (placedOrderNumber) {
		if (placedOrderNumber.id) obr[&apos;OBR.2&apos;][&apos;OBR.2.1&apos;] = placedOrderNumber.id.toString();
		if (placedOrderNumber.namespaceID) obr[&apos;OBR.2&apos;][&apos;OBR.2.2&apos;] = placedOrderNumber.namespaceID.toString();
		if (placedOrderNumber.universalID) obr[&apos;OBR.2&apos;][&apos;OBR.2.3&apos;] = placedOrderNumber.universalID.toString();
	}
	

	// Universal Service Identifier	
	var alternateID = obj.resource.DiagnosticOrder.item.code.coding.code.value.toString();
	if (alternateID)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.4&apos;] = alternateID;

	var alternateText = obj.resource.DiagnosticOrder.item.code.coding.display.value.toString();
	if (alternateText)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.5&apos;] = alternateText;

	// Observation Date/Time	
	var observationDateTime = obj.resource.DiagnosticOrder.event.dateTime.value.toString();
	if (observationDateTime) {
		// Format : yyyymmddhhmm
		var specimenCollectionDate = convertJSONDateTime(observationDateTime);
		obr[&apos;OBR.7&apos;] = specimenCollectionDate.substring(0, 12);
	}

	// Specimen Action Code
	var actionCode = ((obj.resource.DiagnosticOrder.item.specimen) ? obj.resource.DiagnosticOrder.item.specimen.display.value.toString() : &quot;&quot;);
	if (actionCode)
		obr[&apos;OBR.11&apos;] = actionCode;

	// OBR.16 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticOrder.event.actor.reference != undefined) ? obj.resource.DiagnosticOrder.event.actor.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(13, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) obr[&apos;OBR.16&apos;][&apos;OBR.16.1&apos;] = id;
				
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) obr[&apos;OBR.16&apos;][&apos;OBR.16.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			obr[&apos;OBR.16&apos;][&apos;OBR.16.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.4&apos;] = nameParts.given2;			
		}
	}

	// Store the segment to be later compiled into a message
	observationRequestMap.put(groupCount.toString(), obr.toString());


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.DiagnosticOrder.text &amp;&amp; obj.resource.DiagnosticOrder.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.DiagnosticOrder.text.div.p.length &amp;&amp; obj.resource.DiagnosticOrder.text.div.p.length &gt; 0) {
			obj.resource.DiagnosticOrder.text.div.p.forEach(function(item){
				// For internal (I) and report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
						
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
						// If the comment is other than internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.DiagnosticOrder.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.DiagnosticOrder.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.DiagnosticOrder.text.div.p, countNTE++));			
		}

		// Store the comments array to be later compiled into a message
		observationRequestCommentsMap.put(groupCount.toString(), comments);

	}

/*
	importPackage(Packages.java.util);
	importPackage(Packages.ca.uhn.fhir.context);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.valueset);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);
	importPackage(Packages.ca.uhn.fhir.model.primitive);
	importPackage(Packages.ca.uhn.fhir.rest.api);
	importPackage(Packages.ca.uhn.fhir.rest.client);

	var HL7DateFormat = new java.text.SimpleDateFormat(&quot;YYYYMMdd&quot;);
	
	var Url = configurationMap.get(&apos;sparkRawURL&apos;)

	var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
	var client = ctx.newRestfulGenericClient( Url );
		
	ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
	ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 

	var testSystem = &quot;QUEST&quot;;
	var testCode = alternateID;
	var testDisplay = alternateText;
	var placerOrderNamespace = AccountNumber; // Account number 
	var placerOrderNumber = placedOrderNumber.id.toString();

	var order = new DiagnosticOrder();

	var theSubject = new ResourceReferenceDt();
	theSubject.setReference( $(&apos;sparkRawURL&apos;) + &quot;/&quot; +PatientResourceID);
	order.setSubject(theSubject);
			
	order.addIdentifier().setSystem( $(&apos;sparkRawURL&apos;) + &quot;/ClinicalOrder/&quot; + placerOrderNamespace ).setValue( placerOrderNumber );		
	order.addIdentifier().setSystem( $(&apos;sparkRawURL&apos;) + &quot;/&quot; + &quot;TestCode&quot; ).setValue( testCode );	
		
	order.setStatus(DiagnosticOrderStatusEnum.REQUESTED);
		
	var theEventArray = new ArrayList();
	var theEvent = new DiagnosticOrder.Event();
	theEvent.setDateTime( new DateTimeDt(DateUtil.getCurrentDate(&quot;yyyy-MM-dd&quot;) ) );
	theEventArray.add(theEvent );
		
	order.setEvent(theEventArray );

	var theCodeList = new ArrayList();	
	var theCode = new DiagnosticOrder.Item();
	var theCodeableConcept = new CodeableConceptDt();
	var theCoding = new CodingDt();
	theCoding.setSystem( $(&apos;sparkRawURL&apos;) + &quot;/&quot; + testSystem);
	theCoding.setCode(testCode);
	theCoding.setDisplay(testDisplay);
	theCodeableConcept.addCoding(theCoding );
	theCode.setCode(theCodeableConcept );
	theCodeList.add(theCode);
	order.setItem(theCodeList );
		
	var outcome = client.create()
		.resource(order)
		.execute();
		
	order = client.read(DiagnosticOrder, outcome.getId().getIdPart() );
	logger.error( &quot;New DiagnosticOrder: &quot; +  ctx.newJsonParser().encodeResourceToString(order) );
*/	

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates OBR [Observation Request] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticOrder object resource
	@return - nothing, uses global HL7v2 message object
*/
function processObservationRequest(obj) {

	var comments = [];

	var obr = &lt;OBR&gt;&lt;OBR.1&gt;&lt;OBR.1.1&gt;1&lt;/OBR.1.1&gt;&lt;/OBR.1&gt;
				&lt;OBR.2/&gt;&lt;OBR.3/&gt;
				&lt;OBR.4&gt;&lt;OBR.4.1/&gt;&lt;OBR.4.2/&gt;&lt;OBR.4.3/&gt;&lt;OBR.4.4/&gt;&lt;OBR.4.5/&gt;&lt;/OBR.4&gt;
				&lt;OBR.5/&gt;&lt;OBR.6/&gt;&lt;OBR.7/&gt;&lt;OBR.8/&gt;&lt;OBR.9/&gt;
				&lt;OBR.10/&gt;&lt;OBR.11/&gt;&lt;OBR.12/&gt;&lt;OBR.13/&gt;&lt;OBR.14/&gt;&lt;OBR.15/&gt;
				&lt;OBR.16&gt;&lt;OBR.16.1/&gt;&lt;OBR.16.2/&gt;&lt;OBR.16.3/&gt;&lt;OBR.16.4/&gt;&lt;OBR.16.5/&gt;&lt;OBR.16.6/&gt;&lt;OBR.16.7/&gt;&lt;OBR.16.8/&gt;&lt;/OBR.16&gt;
			&lt;/OBR&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticOrder.id) ? obj.resource.DiagnosticOrder.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);
		
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticOrder.id element is undefined or not properly formatted, expected: OBR-observation-request-n, where n identifies the order group&quot;);
	}

	obr[&apos;OBR.1&apos;][&apos;OBR.1.1&apos;] = groupCount;

	// OBR.2 [Placer Order Number] is stored during the DiagnosticReport resource processing	
	var resourceID = obj.resource.DiagnosticOrder.id.value.toString();
	// Extracts the following object - placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};
	var placedOrderNumber = placedOrderNumberMap.get(resourceID);
	if (placedOrderNumber) {
		if (placedOrderNumber.id) obr[&apos;OBR.2&apos;][&apos;OBR.2.1&apos;] = placedOrderNumber.id.toString();
		if (placedOrderNumber.namespaceID) obr[&apos;OBR.2&apos;][&apos;OBR.2.2&apos;] = placedOrderNumber.namespaceID.toString();
		if (placedOrderNumber.universalID) obr[&apos;OBR.2&apos;][&apos;OBR.2.3&apos;] = placedOrderNumber.universalID.toString();
	}
	

	// Universal Service Identifier	
	var alternateID = obj.resource.DiagnosticOrder.item.code.coding.code.value.toString();
	if (alternateID)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.4&apos;] = alternateID;

	var alternateText = obj.resource.DiagnosticOrder.item.code.coding.display.value.toString();
	if (alternateText)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.5&apos;] = alternateText;

	// Observation Date/Time	
	var observationDateTime = obj.resource.DiagnosticOrder.event.dateTime.value.toString();
	if (observationDateTime) {
		// Format : yyyymmddhhmm
		var specimenCollectionDate = convertJSONDateTime(observationDateTime);
		obr[&apos;OBR.7&apos;] = specimenCollectionDate.substring(0, 12);
	}

	// Specimen Action Code
	var actionCode = ((obj.resource.DiagnosticOrder.item.specimen) ? obj.resource.DiagnosticOrder.item.specimen.display.value.toString() : &quot;&quot;);
	if (actionCode)
		obr[&apos;OBR.11&apos;] = actionCode;

	// OBR.16 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticOrder.event.actor.reference != undefined) ? obj.resource.DiagnosticOrder.event.actor.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(13, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) obr[&apos;OBR.16&apos;][&apos;OBR.16.1&apos;] = id;
				
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) obr[&apos;OBR.16&apos;][&apos;OBR.16.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			obr[&apos;OBR.16&apos;][&apos;OBR.16.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.4&apos;] = nameParts.given2;			
		}
	}

	// Store the segment to be later compiled into a message
	observationRequestMap.put(groupCount.toString(), obr.toString());


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.DiagnosticOrder.text &amp;&amp; obj.resource.DiagnosticOrder.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.DiagnosticOrder.text.div.p.length &amp;&amp; obj.resource.DiagnosticOrder.text.div.p.length &gt; 0) {
			obj.resource.DiagnosticOrder.text.div.p.forEach(function(item){
				// For internal (I) and report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
						
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
						// If the comment is other than internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.DiagnosticOrder.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.DiagnosticOrder.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.DiagnosticOrder.text.div.p, countNTE++));			
		}

		// Store the comments array to be later compiled into a message
		observationRequestCommentsMap.put(groupCount.toString(), comments);

	}

/*
	importPackage(Packages.java.util);
	importPackage(Packages.ca.uhn.fhir.context);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.resource);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.valueset);
	importPackage(Packages.ca.uhn.fhir.model.dstu2.composite);
	importPackage(Packages.ca.uhn.fhir.model.primitive);
	importPackage(Packages.ca.uhn.fhir.rest.api);
	importPackage(Packages.ca.uhn.fhir.rest.client);

	var HL7DateFormat = new java.text.SimpleDateFormat(&quot;YYYYMMdd&quot;);
	
	var Url = configurationMap.get(&apos;sparkRawURL&apos;)

	var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();
	var client = ctx.newRestfulGenericClient( Url );
		
	ctx.getRestfulClientFactory().setSocketTimeout(60 * 1000); 
	ctx.getRestfulClientFactory().setConnectTimeout(60 * 1000); 

	var testSystem = &quot;QUEST&quot;;
	var testCode = alternateID;
	var testDisplay = alternateText;
	var placerOrderNamespace = AccountNumber; // Account number 
	var placerOrderNumber = placedOrderNumber.id.toString();

	var order = new DiagnosticOrder();

	var theSubject = new ResourceReferenceDt();
	theSubject.setReference( $(&apos;sparkRawURL&apos;) + &quot;/&quot; +PatientResourceID);
	order.setSubject(theSubject);
			
	order.addIdentifier().setSystem( $(&apos;sparkRawURL&apos;) + &quot;/ClinicalOrder/&quot; + placerOrderNamespace ).setValue( placerOrderNumber );		
	order.addIdentifier().setSystem( $(&apos;sparkRawURL&apos;) + &quot;/&quot; + &quot;TestCode&quot; ).setValue( testCode );	
		
	order.setStatus(DiagnosticOrderStatusEnum.REQUESTED);
		
	var theEventArray = new ArrayList();
	var theEvent = new DiagnosticOrder.Event();
	theEvent.setDateTime( new DateTimeDt(DateUtil.getCurrentDate(&quot;yyyy-MM-dd&quot;) ) );
	theEventArray.add(theEvent );
		
	order.setEvent(theEventArray );

	var theCodeList = new ArrayList();	
	var theCode = new DiagnosticOrder.Item();
	var theCodeableConcept = new CodeableConceptDt();
	var theCoding = new CodingDt();
	theCoding.setSystem( $(&apos;sparkRawURL&apos;) + &quot;/&quot; + testSystem);
	theCoding.setCode(testCode);
	theCoding.setDisplay(testDisplay);
	theCodeableConcept.addCoding(theCoding );
	theCode.setCode(theCodeableConcept );
	theCodeList.add(theCode);
	order.setItem(theCodeList );
		
	var outcome = client.create()
		.resource(order)
		.execute();
		
	order = client.read(DiagnosticOrder, outcome.getId().getIdPart() );
	logger.error( &quot;New DiagnosticOrder: &quot; +  ctx.newJsonParser().encodeResourceToString(order) );
*/	

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>9</sequenceNumber>
                <name>DG1 segment</name>
                <script>/**
	Populates DG1 [Diagnosis] segment from the Condition resource
	@param {Object} obj - Condition object resource
	@return {String} dg1 - DG1 segment serialized to string
*/
function processCondition(obj, setID) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);

	var dg1 = &lt;DG1&gt;
				&lt;DG1.1&gt;&lt;DG1.1.1&gt;1&lt;/DG1.1.1&gt;&lt;/DG1.1&gt;
				&lt;DG1.3&gt;&lt;DG1.3.1/&gt;&lt;DG1.3.2/&gt;&lt;DG1.3.3/&gt;&lt;DG1.3.4/&gt;&lt;/DG1.3&gt;
				&lt;DG1.6&gt;&lt;DG1.6.1&gt;F&lt;/DG1.6.1&gt;&lt;/DG1.6&gt;
			&lt;/DG1&gt;;

	dg1[&apos;DG1.1&apos;][&apos;DG1.1.1&apos;] = setID;

	// Diagnosis Code
	if (obj.coding) {
		if (obj.coding.length &gt; 0) {
			obj.coding.forEach(function(item){
	
				var code = ((item.code) ? item.code.value.toString() : &quot;&quot;);
				var system = item.system.value.toString().toLowerCase();
			
				if (system)
					if (system.indexOf(&quot;icd-10&quot;) &gt; -1) {
	
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
	
					var text = ((item.display) ? item.display.value.toString() : &quot;&quot;);
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
									
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
				} else {
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;] = code;
				}
			});
		} else {
			var code = ((obj.coding.code) ? obj.coding.code.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
			var text = ((obj.coding.display) ? obj.coding.display.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
		}
	}

	
	// DG1.6 [Diagnosis Type] - hard-coded, required by HL7v2.5.1, F - Final
	//dg1[&apos;DG1.6&apos;][&apos;DG1.6.1&apos;] = &quot;F&quot;;

	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;].toString() == &quot;&quot;) 
			error.push(&quot;resource.Condition.code for DG1.3[Diagnosis Code] is required if IN1.47[Coverage Type] is P or T&quot;);
	}

	return dg1.toString();
	
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates DG1 [Diagnosis] segment from the Condition resource
	@param {Object} obj - Condition object resource
	@return {String} dg1 - DG1 segment serialized to string
*/
function processCondition(obj, setID) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);

	var dg1 = &lt;DG1&gt;
				&lt;DG1.1&gt;&lt;DG1.1.1&gt;1&lt;/DG1.1.1&gt;&lt;/DG1.1&gt;
				&lt;DG1.3&gt;&lt;DG1.3.1/&gt;&lt;DG1.3.2/&gt;&lt;DG1.3.3/&gt;&lt;DG1.3.4/&gt;&lt;/DG1.3&gt;
				&lt;DG1.6&gt;&lt;DG1.6.1&gt;F&lt;/DG1.6.1&gt;&lt;/DG1.6&gt;
			&lt;/DG1&gt;;

	dg1[&apos;DG1.1&apos;][&apos;DG1.1.1&apos;] = setID;

	// Diagnosis Code
	if (obj.coding) {
		if (obj.coding.length &gt; 0) {
			obj.coding.forEach(function(item){
	
				var code = ((item.code) ? item.code.value.toString() : &quot;&quot;);
				var system = item.system.value.toString().toLowerCase();
			
				if (system)
					if (system.indexOf(&quot;icd-10&quot;) &gt; -1) {
	
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
	
					var text = ((item.display) ? item.display.value.toString() : &quot;&quot;);
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
									
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
				} else {
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;] = code;
				}
			});
		} else {
			var code = ((obj.coding.code) ? obj.coding.code.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
			var text = ((obj.coding.display) ? obj.coding.display.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
		}
	}

	
	// DG1.6 [Diagnosis Type] - hard-coded, required by HL7v2.5.1, F - Final
	//dg1[&apos;DG1.6&apos;][&apos;DG1.6.1&apos;] = &quot;F&quot;;

	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;].toString() == &quot;&quot;) 
			error.push(&quot;resource.Condition.code for DG1.3[Diagnosis Code] is required if IN1.47[Coverage Type] is P or T&quot;);
	}

	return dg1.toString();
	
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>10</sequenceNumber>
                <name>OBX segment</name>
                <script>/**
	Populates OBX [Observation/Result] segment from the Observation resource
	@param {Object} obj - Observation object resource
	@return {String} obx - OBX segment serialized to string
*/
function processObservation(obj) {

	var obx =	&lt;OBX&gt;
				&lt;OBX.1&gt;&lt;OBX.1.1/&gt;&lt;/OBX.1&gt;
				&lt;OBX.2&gt;&lt;OBX.2.1/&gt;&lt;/OBX.2&gt;
				&lt;OBX.3&gt;&lt;OBX.3.1/&gt;&lt;OBX.3.2/&gt;&lt;OBX.3.3/&gt;&lt;OBX.3.4/&gt;&lt;OBX.3.5/&gt;&lt;OBX.3.6/&gt;&lt;/OBX.3&gt;
				&lt;OBX.4/&gt;
				&lt;OBX.5&gt;&lt;OBX.5.1/&gt;&lt;/OBX.5&gt;
				&lt;OBX.11&gt;&lt;OBX.11.1&gt;P&lt;/OBX.11.1&gt;&lt;/OBX.11&gt;
			&lt;/OBX&gt;;


	var id = obj.resource.Observation.id.value.toString();
	obx[&apos;OBX.1&apos;][&apos;OBX.1.1&apos;] = id.substring(&quot;OBX-observation-&quot;.length, id.length);

	// Contains a value that reports the results for an AOE
	if (obj.resource.Observation.code) {
		// local code
		var code = obj.resource.Observation.code.coding.code.value.toString();		
		obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;] = code;
		
		// Local description
		var description = obj.resource.Observation.code.coding.display.value.toString();
		obx[&apos;OBX.3&apos;][&apos;OBX.3.5&apos;] = description;

		// Code system - Optional
		if (obj.resource.Observation.code.coding.system != undefined) {
			var codeSystem = obj.resource.Observation.code.coding.system.value.toString();
			if (codeSystem.toLowerCase().indexOf(&quot;snomed&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;SCT&quot;;
			else if (codeSystem.toLowerCase().indexOf(&quot;loinc&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;LN&quot;;
			else 
				delete obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;];
		}
		
	}


	// If valueString is used, expected that the answer is always a string, therefore OBX.2 [Value Type] is hard-coded to &quot;ST&quot;
	if (obj.resource.Observation.valueString) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;ST&quot;;

		var aoe = obj.resource.Observation.valueString.value.toString();
		if (aoe) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = aoe;		

	// If valueQuantity is used the OBX.2 [Value Type] is hard-coded to &quot;NM&quot;	
	} else if (obj.resource.Observation.valueQuantity) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;NM&quot;;		
		var quantity = obj.resource.Observation.valueQuantity.value.value.toString();
		if (quantity) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = quantity;
	}
	

	// Observation Result Status - not required by Quest
	// Hard-coded to &quot;P&quot; - Preliminary


	// OBX level comments (Issue #17)
	var observationComments = [];

	// Iterate over all possible comment entries in /text/div/p  (also see Issue #17)
	if (obj.resource.Observation.text &amp;&amp; obj.resource.Observation.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;,&quot;&quot;]; // Optional source of comment

		if (obj.resource.Observation.text.div.p.length != undefined &amp;&amp; obj.resource.Observation.text.div.p.length &gt; 0) {
			// Several comments from any acceptable sources
			obj.resource.Observation.text.div.p.forEach(function(item){
				if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					observationComments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.Observation.text.div.p) {
			// A single comment from any acceptable source
			if (sourceOfComment.indexOf(obj.resource.Observation.text.div.p.class.toString()) &gt; -1) {
				observationComments.push(getNTESegment(obj.resource.Observation.text.div.p, countNTE++));
			}			
		}
	}

	observationMap.put(id, obx.toString());
	observationCommentsMap.put(id, observationComments);
	
	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates OBX [Observation/Result] segment from the Observation resource
	@param {Object} obj - Observation object resource
	@return {String} obx - OBX segment serialized to string
*/
function processObservation(obj) {

	var obx =	&lt;OBX&gt;
				&lt;OBX.1&gt;&lt;OBX.1.1/&gt;&lt;/OBX.1&gt;
				&lt;OBX.2&gt;&lt;OBX.2.1/&gt;&lt;/OBX.2&gt;
				&lt;OBX.3&gt;&lt;OBX.3.1/&gt;&lt;OBX.3.2/&gt;&lt;OBX.3.3/&gt;&lt;OBX.3.4/&gt;&lt;OBX.3.5/&gt;&lt;OBX.3.6/&gt;&lt;/OBX.3&gt;
				&lt;OBX.4/&gt;
				&lt;OBX.5&gt;&lt;OBX.5.1/&gt;&lt;/OBX.5&gt;
				&lt;OBX.11&gt;&lt;OBX.11.1&gt;P&lt;/OBX.11.1&gt;&lt;/OBX.11&gt;
			&lt;/OBX&gt;;


	var id = obj.resource.Observation.id.value.toString();
	obx[&apos;OBX.1&apos;][&apos;OBX.1.1&apos;] = id.substring(&quot;OBX-observation-&quot;.length, id.length);

	// Contains a value that reports the results for an AOE
	if (obj.resource.Observation.code) {
		// local code
		var code = obj.resource.Observation.code.coding.code.value.toString();		
		obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;] = code;
		
		// Local description
		var description = obj.resource.Observation.code.coding.display.value.toString();
		obx[&apos;OBX.3&apos;][&apos;OBX.3.5&apos;] = description;

		// Code system - Optional
		if (obj.resource.Observation.code.coding.system != undefined) {
			var codeSystem = obj.resource.Observation.code.coding.system.value.toString();
			if (codeSystem.toLowerCase().indexOf(&quot;snomed&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;SCT&quot;;
			else if (codeSystem.toLowerCase().indexOf(&quot;loinc&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;LN&quot;;
			else 
				delete obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;];
		}
		
	}


	// If valueString is used, expected that the answer is always a string, therefore OBX.2 [Value Type] is hard-coded to &quot;ST&quot;
	if (obj.resource.Observation.valueString) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;ST&quot;;

		var aoe = obj.resource.Observation.valueString.value.toString();
		if (aoe) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = aoe;		

	// If valueQuantity is used the OBX.2 [Value Type] is hard-coded to &quot;NM&quot;	
	} else if (obj.resource.Observation.valueQuantity) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;NM&quot;;		
		var quantity = obj.resource.Observation.valueQuantity.value.value.toString();
		if (quantity) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = quantity;
	}
	

	// Observation Result Status - not required by Quest
	// Hard-coded to &quot;P&quot; - Preliminary


	// OBX level comments (Issue #17)
	var observationComments = [];

	// Iterate over all possible comment entries in /text/div/p  (also see Issue #17)
	if (obj.resource.Observation.text &amp;&amp; obj.resource.Observation.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;,&quot;&quot;]; // Optional source of comment

		if (obj.resource.Observation.text.div.p.length != undefined &amp;&amp; obj.resource.Observation.text.div.p.length &gt; 0) {
			// Several comments from any acceptable sources
			obj.resource.Observation.text.div.p.forEach(function(item){
				if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					observationComments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.Observation.text.div.p) {
			// A single comment from any acceptable source
			if (sourceOfComment.indexOf(obj.resource.Observation.text.div.p.class.toString()) &gt; -1) {
				observationComments.push(getNTESegment(obj.resource.Observation.text.div.p, countNTE++));
			}			
		}
	}

	observationMap.put(id, obx.toString());
	observationCommentsMap.put(id, observationComments);
	
	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>11</sequenceNumber>
                <name>Check for issues</name>
                <script>// Use fixHL7NodeOrder() to fix a possible node order issue 
// see http://www.mirthcorp.com/community/issues/browse/MIRTH-625

var messages = {request: &quot;&quot;, resp: &quot;&quot;};
messages.request = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(fixHL7NodeOrder(oml));

channelMap.put(&quot;omlHL7&quot;, messages.request); // testing
channelMap.put(&quot;error&quot;, error); // testing

logger.debug(&quot;SubmitOrder: Destination - &quot; + messages.request);


// Verify for errors 
if (error.length &gt; 0) {

	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));

	// To be sent to original feed submitter
	responseMap.put(&quot;Outcome&quot;, outcome);

	// Nothing to send to DEX
	channelMap.put(&quot;RequestMessage&quot;, null);
	
} else {

	// Temporary save the OML_O21 message for the next destination to process

//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!	
	channelMap.put(&quot;RequestMessage&quot;, null);
	//var info = {severity: &quot;Information&quot;, code: &quot;Information&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	//(AM) operation outcome mapping expects lowercase; code is &apos;informational&apos; not &apos;information&apos;
	var info = {severity: &quot;information&quot;, code: &quot;informational&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	outcome = getOperationOutcome(error, info, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));	
	responseMap.put(&quot;Outcome&quot;, outcome);

	logger.info(&quot;sent done&quot;);
//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!

	// (SN) Enable this line to actually submit the SubmitOrder request
	channelMap.put(&quot;RequestMessage&quot;, messages.request);
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Use fixHL7NodeOrder() to fix a possible node order issue 
// see http://www.mirthcorp.com/community/issues/browse/MIRTH-625

var messages = {request: &quot;&quot;, resp: &quot;&quot;};
messages.request = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(fixHL7NodeOrder(oml));

channelMap.put(&quot;omlHL7&quot;, messages.request); // testing
channelMap.put(&quot;error&quot;, error); // testing

logger.debug(&quot;SubmitOrder: Destination - &quot; + messages.request);


// Verify for errors 
if (error.length &gt; 0) {

	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));

	// To be sent to original feed submitter
	responseMap.put(&quot;Outcome&quot;, outcome);

	// Nothing to send to DEX
	channelMap.put(&quot;RequestMessage&quot;, null);
	
} else {

	// Temporary save the OML_O21 message for the next destination to process

//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!	
	channelMap.put(&quot;RequestMessage&quot;, null);
	//var info = {severity: &quot;Information&quot;, code: &quot;Information&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	//(AM) operation outcome mapping expects lowercase; code is &apos;informational&apos; not &apos;information&apos;
	var info = {severity: &quot;information&quot;, code: &quot;informational&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	outcome = getOperationOutcome(error, info, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));	
	responseMap.put(&quot;Outcome&quot;, outcome);

	logger.info(&quot;sent done&quot;);
//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!

	// (SN) Enable this line to actually submit the SubmitOrder request
	channelMap.put(&quot;RequestMessage&quot;, messages.request);
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>HL7V2</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>JavaScript Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Submit Order WS</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>SOAP query</name>
                <script>var 	submitOrderSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
				   &lt;soapenv:Header/&gt;
				   &lt;soapenv:Body&gt;
				      &lt;ord:submitOrder&gt;
				         &lt;ord:SubmitOrderRequest&gt;
				            &lt;hl7Order&gt;OML_O21&lt;/hl7Order&gt;
				         &lt;/ord:SubmitOrderRequest&gt;
				      &lt;/ord:submitOrder&gt;
				   &lt;/soapenv:Body&gt;
				&lt;/soapenv:Envelope&gt;;

var oml = channelMap.get(&quot;RequestMessage&quot;);
if (oml != null &amp;&amp; oml.toString().length() &gt; 0) {
		
	var bytes = new java.lang.String(oml.toString()).getBytes();
	submitOrderSoap.*::Body.*::submitOrder.*::SubmitOrderRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

} else {
	submitOrderSoap = &quot;&quot;;
	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var 	submitOrderSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
				   &lt;soapenv:Header/&gt;
				   &lt;soapenv:Body&gt;
				      &lt;ord:submitOrder&gt;
				         &lt;ord:SubmitOrderRequest&gt;
				            &lt;hl7Order&gt;OML_O21&lt;/hl7Order&gt;
				         &lt;/ord:SubmitOrderRequest&gt;
				      &lt;/ord:submitOrder&gt;
				   &lt;/soapenv:Body&gt;
				&lt;/soapenv:Envelope&gt;;

var oml = channelMap.get(&quot;RequestMessage&quot;);
if (oml != null &amp;&amp; oml.toString().length() &gt; 0) {
		
	var bytes = new java.lang.String(oml.toString()).getBytes();
	submitOrderSoap.*::Body.*::submitOrder.*::SubmitOrderRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

} else {
	submitOrderSoap = &quot;&quot;;
	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>POST request</name>
                <script>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null &amp;&amp; submitOrderSoap.toString().length &gt; 0) try {
	var error = [];
	var messages = {request: submitOrderSoap.toString(), resp: &quot;&quot;};
	var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};
	sslClient.setURL( $cfg(&quot;submitOrderURL&quot;) );
	sslClient.setSOAPRequest(submitOrderSoap);
	// Submit the request
	var httpCode = sslClient.doPost();

logger.debug (&quot;httpCode is &quot; + httpCode);
	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));
logger.debug (&quot;soapResp is &quot; + soapResp);
	if (200 == httpCode) {

		var orderACK = soapResp.*::Body.*::submitOrderResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String(FileUtil.decode(orderACK));
		messages.resp = ackHL7;
		
		var ack = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(ackHL7));
		channelMap.put(&quot;HL7ACK&quot;, ackHL7);
		// Check Acknowledgment Code: AA - Accept, AE - Error
		if (ack[&apos;MSA&apos;][&apos;MSA.1&apos;][&apos;MSA.1.1&apos;].toString() == &quot;AA&quot;) {
			issue.severity = &quot;information&quot;;
			issue.code = &quot;informational&quot;;
			issue.details = &quot;SUCCESS&quot;;			
		} else {
			// Acknowledgment Code == AE or anything else 
			issue.severity = &quot;error&quot;;
			issue.code = &quot;processing&quot;;
			issue.details = &quot;Order was not successfully processed&quot;;		
			error = ack[&apos;MSA&apos;][&apos;MSA.6&apos;][&apos;MSA.6.2&apos;].toString().split(&quot;,&quot;);	
		} 
		 
	} else {
		// HTTP code is not 200 OK
		issue.severity = &quot;error&quot;;
		issue.code = &quot;processing&quot;;
		issue.details = &quot;HTTP Code: &quot; + httpCode;
	}	
	
} catch(ex) {
	
	issue.severity = &quot;fatal&quot;;
	issue.code = &quot;exception&quot;;
	issue.details = &quot;SubmitOrder WS Transformer: &quot; + ex;
		
} finally {

	// Return submission results
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	responseMap.put(&quot;Outcome&quot;, outcome);
//	logger.debug(&quot;Outcome (Submit Order WS): &quot; + outcome);
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null &amp;&amp; submitOrderSoap.toString().length &gt; 0) try {
	var error = [];
	var messages = {request: submitOrderSoap.toString(), resp: &quot;&quot;};
	var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};
	sslClient.setURL( $cfg(&quot;submitOrderURL&quot;) );
	sslClient.setSOAPRequest(submitOrderSoap);
	// Submit the request
	var httpCode = sslClient.doPost();

logger.debug (&quot;httpCode is &quot; + httpCode);
	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));
logger.debug (&quot;soapResp is &quot; + soapResp);
	if (200 == httpCode) {

		var orderACK = soapResp.*::Body.*::submitOrderResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String(FileUtil.decode(orderACK));
		messages.resp = ackHL7;
		
		var ack = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(ackHL7));
		channelMap.put(&quot;HL7ACK&quot;, ackHL7);
		// Check Acknowledgment Code: AA - Accept, AE - Error
		if (ack[&apos;MSA&apos;][&apos;MSA.1&apos;][&apos;MSA.1.1&apos;].toString() == &quot;AA&quot;) {
			issue.severity = &quot;information&quot;;
			issue.code = &quot;informational&quot;;
			issue.details = &quot;SUCCESS&quot;;			
		} else {
			// Acknowledgment Code == AE or anything else 
			issue.severity = &quot;error&quot;;
			issue.code = &quot;processing&quot;;
			issue.details = &quot;Order was not successfully processed&quot;;		
			error = ack[&apos;MSA&apos;][&apos;MSA.6&apos;][&apos;MSA.6.2&apos;].toString().split(&quot;,&quot;);	
		} 
		 
	} else {
		// HTTP code is not 200 OK
		issue.severity = &quot;error&quot;;
		issue.code = &quot;processing&quot;;
		issue.details = &quot;HTTP Code: &quot; + httpCode;
	}	
	
} catch(ex) {
	
	issue.severity = &quot;fatal&quot;;
	issue.code = &quot;exception&quot;;
	issue.details = &quot;SubmitOrder WS Transformer: &quot; + ex;
		
} finally {

	// Return submission results
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	responseMap.put(&quot;Outcome&quot;, outcome);
//	logger.debug(&quot;Outcome (Submit Order WS): &quot; + outcome);
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>false</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>4</metaDataId>
          <name>Call GetOrderDocs</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>e0f422e1-0550-40f1-8a37-e148e0b5f636</channelId>
            <channelTemplate>${RequestMessage}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>false</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data

// Delete some characters that may break JSON to XML parsing
message = message.replace(/null/g,&apos;&quot;&quot;&apos;);
message = message.replace(/&amp;/g,&quot;&amp;amp;&quot;); // ampersand
message = message.replace(/&lt;/g,&quot;&amp;lt;&quot;);  // less than
message = message.replace(/&gt;/g,&quot;&amp;gt;&quot;);  // greater than
message = message.replace(/&quot;&quot;&quot;&quot;/g,&apos;&quot;&quot;&apos;); // quotes around quotes

return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

// Format of the OperationOutcome. Supported: &quot;XML&quot; or &quot;JSON&quot;
globalChannelMap.put(&quot;outcomeFormat&quot;, &quot;XML&quot;);

// Prepare SSL Client to access submitOrder Conformance Environment
if (globalMap.containsKey(&quot;sslClient&quot;) &amp;&amp; globalMap.get(&quot;sslClient&quot;)) 
	try {

		var sslClient = new Packages.org.safemovement.DEXSSLClient();		
		sslClient.setAuthorizationType(org.safemovement.DEXSSLClient.Authorization.BASIC);
		sslClient.setContentType(&quot;text/xml;charset=UTF-8&quot;);
		sslClient.setUserName($(&quot;username&quot;));
		sslClient.setUserPassword($(&quot;userpsw&quot;));		
		sslClient.setConnectionType(&quot;Close&quot;);
		
		globalChannelMap.put(&quot;sslClientClass&quot;, sslClient);
		
	} catch(ex) {
		logger.error(&quot;SubmitOrder: Deploy - cannot initialize SSLClient - &quot; + ex);
		
		// Stop this channel to resolve the problem
		ChannelUtil.stopChannel(channelId);
		throw (&quot;SubmitOrder: Deploy - cannot initialize SSLClient - &quot; + ex);		
	}



return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data

if (globalChannelMap.containsKey(&quot;sslClientClass&quot;)){
	globalChannelMap.remove(&quot;sslClientClass&quot;);
}


return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>e37e8a4a-f586-4ce6-9b4d-fbda18225fb2</id>
      <nextMetaDataId>4</nextMetaDataId>
      <name>Submit Order - OLD</name>
      <description>Submits a new lab order, including both Basic Lab Orders and Patient Service Center (PSC) Hold Orders.&#xd;
The Order object contains the inbound lab order message (HL7v2.5.1 OML_O21).&#xd;
&#xd;
This channel expects JSON feed with all data filled to build the outbound OML_O21 message.&#xd;
&#xd;
Last updated: March 12, 2017</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1494018886015</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>2</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>Outcome</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Validate JSON feed</name>
              <script>var error = [];				// A list of possible incoming JSON feed validation errors
var hasPatient = false;			// PID
var hasDiagnosticReport = false;	// ORC
var hasDiagnosticOrder = false;	// OBR
var hasCoverage = false;			// IN1
var hasPerson = false;			// GT1
var hasPractitioner = false;		// OBR.16
var conditionCount = 0;

// Feed UUID ~~ RKW The placement of static text in an ID value is pointless, and usually requires stripping out later - such as here. How about not putting it there in the first place?
var uuid = msg.Bundle.id.value.toString().toLowerCase().replace(&quot;oml-o21&quot;,&quot;&quot;);

// TODO: Define min length for UUID
if (uuid)
	channelMap.put(&quot;FeedUUID&quot;, uuid);
else 
	error.push(&quot;Feed Bundle id/@value should contain UUID in format OML-O21-xxxxxxxx-...&quot;);	


// The Data Exchange verifies that fields are populated depending on the coverage type
var billType = [&apos;T&apos;,&apos;P&apos;,&apos;C&apos;];
var coverageType;
msg.Bundle.entry.forEach(function(obj){
	if (obj.resource.Coverage) {
		coverageType = obj.resource.Coverage.type.code.value.toString();
		if (billType.indexOf(coverageType) &lt; 0) error.push(&quot;resource.Coverage.type.code.value for IN1.47[Coverage Type] is required and must be T, P or C&quot;);
	}
});

// Store IN1.47 [Coverage Type] value for future use
channelMap.put(&quot;CoverageType&quot;, coverageType);


// Validate incoming JSON field for required resources (aka segments)
msg.Bundle.entry.forEach(function(objRes){

	// Need to set the hasSomeResource only once
	if (objRes.resource.Patient != null &amp;&amp; objRes.resource.Patient != undefined) hasPatient = true;
	if (objRes.resource.DiagnosticReport != null &amp;&amp; objRes.resource.DiagnosticReport != undefined) hasDiagnosticReport = true;
	if (objRes.resource.DiagnosticOrder != null &amp;&amp; objRes.resource.DiagnosticOrder != undefined) hasDiagnosticOrder = true;
	if (objRes.resource.Coverage != null &amp;&amp; objRes.resource.Coverage != undefined) hasCoverage = true;
	if (objRes.resource.Person != null &amp;&amp; objRes.resource.Person != undefined) hasPerson = true;
	if (objRes.resource.Practitioner != null &amp;&amp; objRes.resource.Practitioner != undefined) hasPractitioner = true;
	if (objRes.resource.Condition != null &amp;&amp; objRes.resource.Condition != undefined) {
		conditionCount ++;
	}
});


// Validate for required segments
if (!hasPatient) error.push(&quot;resource.Patient for PID segment is Required&quot;);
if (!hasCoverage) error.push(&quot;resource.Coverage for IN1 segment is Required&quot;);
if (!hasDiagnosticReport) error.push(&quot;resource.DiagnosticReport for ORC segment is Required&quot;); // ~~ RKW - Expecting a diagnostic report - a result observation artifact - in an order? Why? 
if (!hasDiagnosticOrder) error.push(&quot;resource.DiagnosticOrder for OBR segment is Required&quot;);
if (!hasPractitioner) error.push(&quot;resource.Practitioner for OBR.16 [Ordering Provider] field is Required&quot;);
if (coverageType == &quot;T&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Third-Party Bill type&quot;);

// Updated to comply with CS12 Billing certification criteria
if (coverageType == &quot;P&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Patient Bill type&quot;);
if (conditionCount &gt; 12) error.push(&quot;Maximum of 12 resource.Condition with unique ICD-10 codes are permitted. You sent &quot; + conditionCount);  // ~~ RKW - Conditions? Not going to happen, and not in requirements

// Verify for errors 
if (error.length &gt; 0) {
	
	// OML_O21 message will not be created ~~ RKW. There is this thing called a filter. Manipulation of the destinationSet is hacking, as it makes the channel more opaque.
	destinationSet.removeAll();

	var messages = {request:&quot;&quot;, resp:&quot;&quot;};
	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	
	// To be sent to the upstream channel
	responseMap.put(&quot;Outcome&quot;, outcome);
	//logger.debug(&quot;SubmitOrder (Source): &quot; + outcome);
}</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>var error = [];				// A list of possible incoming JSON feed validation errors
var hasPatient = false;			// PID
var hasDiagnosticReport = false;	// ORC
var hasDiagnosticOrder = false;	// OBR
var hasCoverage = false;			// IN1
var hasPerson = false;			// GT1
var hasPractitioner = false;		// OBR.16
var conditionCount = 0;

// Feed UUID ~~ RKW The placement of static text in an ID value is pointless, and usually requires stripping out later - such as here. How about not putting it there in the first place?
var uuid = msg.Bundle.id.value.toString().toLowerCase().replace(&quot;oml-o21&quot;,&quot;&quot;);

// TODO: Define min length for UUID
if (uuid)
	channelMap.put(&quot;FeedUUID&quot;, uuid);
else 
	error.push(&quot;Feed Bundle id/@value should contain UUID in format OML-O21-xxxxxxxx-...&quot;);	


// The Data Exchange verifies that fields are populated depending on the coverage type
var billType = [&apos;T&apos;,&apos;P&apos;,&apos;C&apos;];
var coverageType;
msg.Bundle.entry.forEach(function(obj){
	if (obj.resource.Coverage) {
		coverageType = obj.resource.Coverage.type.code.value.toString();
		if (billType.indexOf(coverageType) &lt; 0) error.push(&quot;resource.Coverage.type.code.value for IN1.47[Coverage Type] is required and must be T, P or C&quot;);
	}
});

// Store IN1.47 [Coverage Type] value for future use
channelMap.put(&quot;CoverageType&quot;, coverageType);


// Validate incoming JSON field for required resources (aka segments)
msg.Bundle.entry.forEach(function(objRes){

	// Need to set the hasSomeResource only once
	if (objRes.resource.Patient != null &amp;&amp; objRes.resource.Patient != undefined) hasPatient = true;
	if (objRes.resource.DiagnosticReport != null &amp;&amp; objRes.resource.DiagnosticReport != undefined) hasDiagnosticReport = true;
	if (objRes.resource.DiagnosticOrder != null &amp;&amp; objRes.resource.DiagnosticOrder != undefined) hasDiagnosticOrder = true;
	if (objRes.resource.Coverage != null &amp;&amp; objRes.resource.Coverage != undefined) hasCoverage = true;
	if (objRes.resource.Person != null &amp;&amp; objRes.resource.Person != undefined) hasPerson = true;
	if (objRes.resource.Practitioner != null &amp;&amp; objRes.resource.Practitioner != undefined) hasPractitioner = true;
	if (objRes.resource.Condition != null &amp;&amp; objRes.resource.Condition != undefined) {
		conditionCount ++;
	}
});


// Validate for required segments
if (!hasPatient) error.push(&quot;resource.Patient for PID segment is Required&quot;);
if (!hasCoverage) error.push(&quot;resource.Coverage for IN1 segment is Required&quot;);
if (!hasDiagnosticReport) error.push(&quot;resource.DiagnosticReport for ORC segment is Required&quot;); // ~~ RKW - Expecting a diagnostic report - a result observation artifact - in an order? Why? 
if (!hasDiagnosticOrder) error.push(&quot;resource.DiagnosticOrder for OBR segment is Required&quot;);
if (!hasPractitioner) error.push(&quot;resource.Practitioner for OBR.16 [Ordering Provider] field is Required&quot;);
if (coverageType == &quot;T&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Third-Party Bill type&quot;);

// Updated to comply with CS12 Billing certification criteria
if (coverageType == &quot;P&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Patient Bill type&quot;);
if (conditionCount &gt; 12) error.push(&quot;Maximum of 12 resource.Condition with unique ICD-10 codes are permitted. You sent &quot; + conditionCount);  // ~~ RKW - Conditions? Not going to happen, and not in requirements

// Verify for errors 
if (error.length &gt; 0) {
	
	// OML_O21 message will not be created ~~ RKW. There is this thing called a filter. Manipulation of the destinationSet is hacking, as it makes the channel more opaque.
	destinationSet.removeAll();

	var messages = {request:&quot;&quot;, resp:&quot;&quot;};
	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	
	// To be sent to the upstream channel
	responseMap.put(&quot;Outcome&quot;, outcome);
	//logger.debug(&quot;SubmitOrder (Source): &quot; + outcome);
}</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">eyJCdW5kbGUiOiB7CiAgImVudHJ5IjogWwogICAgeyJyZXNvdXJjZSI6IHsiUGF0aWVudCI6IHsK
ICAgICAgImlkZW50aWZpZXIiOiBbCiAgICAgICAgewogICAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAic2Vjb25kYXJ5In0sCiAgICAgICAgICAidHlwZSI6IHsiY29kaW5nIjogeyJjb2RlIjogeyJ2
YWx1ZSI6ICJQVCJ9fX0sCiAgICAgICAgICAidmFsdWUiOiB7InZhbHVlIjogMjA1MjY2MTl9CiAg
ICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJvZmZpY2lhbCJ9
LAogICAgICAgICAgImFzc2lnbmVyIjogeyJkaXNwbGF5IjogeyJ2YWx1ZSI6ICJNUk4ifX0sCiAg
ICAgICAgICAidHlwZSI6IHsiY29kaW5nIjogeyJjb2RlIjogeyJ2YWx1ZSI6ICJQVCJ9fX0sCiAg
ICAgICAgICAidmFsdWUiOiB7InZhbHVlIjogMjA1MjY2MTl9CiAgICAgICAgfQogICAgICBdLAog
ICAgICAiYWRkcmVzcyI6IHsKICAgICAgICAiY291bnRyeSI6IHsidmFsdWUiOiAiVVNBIn0sCiAg
ICAgICAgImNpdHkiOiB7InZhbHVlIjogIk1hc29uIn0sCiAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAiaG9tZSJ9LAogICAgICAgICJsaW5lIjogeyJ2YWx1ZSI6ICI0NjkwIFBhcmt3YXkgRHIuIn0s
CiAgICAgICAgInBvc3RhbENvZGUiOiB7InZhbHVlIjogNDUwNDB9LAogICAgICAgICJzdGF0ZSI6
IHsidmFsdWUiOiAiT0gifQogICAgICB9LAogICAgICAiZ2VuZGVyIjogeyJ2YWx1ZSI6ICJtYWxl
In0sCiAgICAgICJuYW1lIjogewogICAgICAgICJnaXZlbiI6IFsKICAgICAgICAgIHsidmFsdWUi
OiAiUGF0aWVudF9GaXJzdG5hbWUifSwKICAgICAgICAgIHsidmFsdWUiOiAiTWlkZGxlIn0KICAg
ICAgICBdLAogICAgICAgICJ1c2UiOiB7InZhbHVlIjogIm9mZmljaWFsIn0sCiAgICAgICAgImZh
bWlseSI6IHsidmFsdWUiOiAiUGF0aWVudF9MYXN0bmFtZSJ9CiAgICAgIH0sCiAgICAgICJ0ZWxl
Y29tIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0sCiAgICAgICAgInVz
ZSI6IHsidmFsdWUiOiAiaG9tZSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFsdWUiOiAiMV4zMzNe
NDQ0NTU1NSJ9CiAgICAgIH0sCiAgICAgICJpZCI6IHsidmFsdWUiOiAiUElELXBhdGllbnQtaWRl
bnRpZmljYXRpb24ifSwKICAgICAgInRleHQiOiB7CiAgICAgICAgImRpdiI6IHsKICAgICAgICAg
ICJwIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIkZpcnN0IFBhdGllbnQgcmVsYXRlZCBpbnRlcm5hbCBjb21tZW50
IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiY2xhc3Mi
OiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiU2Vjb25kIFBhdGllbnQgcmVsYXRlZCBp
bnRlcm5hbCBjb21tZW50IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAg
ICAgICAgICAiY2xhc3MiOiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiVGhpcmQgUGF0
aWVudCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAg
ICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6ICJJIiwKICAgICAgICAgICAgICAiY29udGVu
dCI6ICJGb3J0aCBQYXRpZW50IHJlbGF0ZWQgaW50ZXJuYWwgY29tbWVudCBsaW5lIgogICAgICAg
ICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIlIiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIkZpcnN0IFBhdGllbnQgcmVsYXRlZCByZXBvcnQgY29tbWVudCBs
aW5lIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjog
IlIiLAogICAgICAgICAgICAgICJjb250ZW50IjogIlNlY29uZCBQYXRpZW50IHJlbGF0ZWQgcmVw
b3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAg
ICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJUaGlyZCBQYXRpZW50
IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAg
ewogICAgICAgICAgICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJG
b3J0aCBQYXRpZW50IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfQog
ICAgICAgICAgXSwKICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3ho
dG1sIgogICAgICAgIH0sCiAgICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAiZ2VuZXJhdGVkIn0K
ICAgICAgfSwKICAgICAgImJpcnRoRGF0ZSI6IHsidmFsdWUiOiAiMTk2OC0wMS0wMSJ9CiAgICB9
fX0sCiAgICB7InJlc291cmNlIjogeyJEaWFnbm9zdGljUmVwb3J0IjogewogICAgICAicmVzdWx0
IjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIk9ic2VydmF0aW9uIn19LAogICAgICAiaWRlbnRp
ZmllciI6IHsKICAgICAgICAic3lzdGVtIjogeyJ2YWx1ZSI6ICJRVUVTVF9TS0JfNzE4NjEyMSJ9
LAogICAgICAgICJ0eXBlIjogeyJpZCI6ICI5OVFESSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFs
dWUiOiA5ODc2NTQzMjF9CiAgICAgIH0sCiAgICAgICJyZXF1ZXN0IjogeyJyZWZlcmVuY2UiOiB7
InZhbHVlIjogIkRpYWdub3N0aWNPcmRlci9vYnItb2JzZXJ2YXRpb24tcmVxdWVzdCJ9fSwKICAg
ICAgImNvbnRhaW5lZCI6IHsiUHJhY3RpdGlvbmVyIjogewogICAgICAgICJpZGVudGlmaWVyIjog
eyJ2YWx1ZSI6IHsidmFsdWUiOiAiTlBQX0lEIn19LAogICAgICAgICJuYW1lIjogeyJmYW1pbHki
OiB7InZhbHVlIjogIk5QUF9OYW1lIn19LAogICAgICAgICJpZCI6IHsidmFsdWUiOiAiT1JDMTEt
dmVyaWZpZWQtYnkifQogICAgICB9fSwKICAgICAgImNvZGUiOiB7ImlkIjogMTAxMjR9LAogICAg
ICAicGVyZm9ybWVyIjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIlByYWN0aXRpb25lci9PUkMx
MS12ZXJpZmllZC1ieSJ9fSwKICAgICAgImVmZmVjdGl2ZURhdGVUaW1lIjogeyJleHRlbnNpb24i
OiB7InVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YzL051bGxGbGF2b3IvTkkifX0sCiAgICAg
ICJzdWJqZWN0IjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIlBhdGllbnQifX0sCiAgICAgICJp
ZCI6IHsidmFsdWUiOiAiT1JDLWNvbW1vbi1vcmRlciJ9LAogICAgICAiaXNzdWVkIjogeyJleHRl
bnNpb24iOiB7InVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YzL051bGxGbGF2b3IvTkkifX0s
CiAgICAgICJzdGF0dXMiOiB7InZhbHVlIjogImZpbmFsIn0KICAgIH19fSwKICAgIHsicmVzb3Vy
Y2UiOiB7IkRpYWdub3N0aWNPcmRlciI6IHsKICAgICAgIml0ZW0iOiB7CiAgICAgICAgImNvZGUi
OiB7ImNvZGluZyI6IHsKICAgICAgICAgICJjb2RlIjogeyJ2YWx1ZSI6IDg0NzJ9LAogICAgICAg
ICAgImRpc3BsYXkiOiB7InZhbHVlIjogIkhFUEFUSVRJUyBDIFZJUlVTIEFCIn0KICAgICAgICB9
fSwKICAgICAgICAic3BlY2ltZW4iOiB7ImRpc3BsYXkiOiB7InZhbHVlIjogIkcifX0KICAgICAg
fSwKICAgICAgInN1YmplY3QiOiB7ImlkIjogIlBhdGllbnQifSwKICAgICAgImlkIjogeyJ2YWx1
ZSI6ICJPQlItb2JzZXJ2YXRpb24tcmVxdWVzdCJ9LAogICAgICAidGV4dCI6IHsKICAgICAgICAi
ZGl2IjogewogICAgICAgICAgInAiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiY2xh
c3MiOiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiRmlyc3QgT2JzZXJ2YXRpb24gUmVx
dWVzdCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAg
ICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6ICJJIiwKICAgICAgICAgICAgICAiY29udGVu
dCI6ICJTZWNvbmQgT2JzZXJ2YXRpb24gUmVxdWVzdCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQg
bGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6
ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJGaXJzdCBPYnNlcnZhdGlvbiBSZXF1ZXN0
IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAg
ewogICAgICAgICAgICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJT
ZWNvbmQgT2JzZXJ2YXRpb24gUmVxdWVzdCByZWxhdGVkIHJlcG9ydCBjb21tZW50IGxpbmUiCiAg
ICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAieG1sbnMiOiAiaHR0cDovL3d3dy53
My5vcmcvMTk5OS94aHRtbCIKICAgICAgICB9LAogICAgICAgICJzdGF0dXMiOiB7InZhbHVlIjog
ImdlbmVyYXRlZCJ9CiAgICAgIH0sCiAgICAgICJldmVudCI6IHsKICAgICAgICAiZGF0ZVRpbWUi
OiB7InZhbHVlIjogIjIwMTYtMTEtMThUMjA6NTE6NTUrMDA6MDAifSwKICAgICAgICAiYWN0b3Ii
OiB7InJlZmVyZW5jZSI6IHsidmFsdWUiOiAiUHJhY3RpdGlvbmVyL29yZGVyaW5nLXByb3ZpZGVy
In19LAogICAgICAgICJzdGF0dXMiOiB7InZhbHVlIjogImNvbXBsZXRlZCJ9CiAgICAgIH0KICAg
IH19fSwKICAgIHsicmVzb3VyY2UiOiB7Ik9ic2VydmF0aW9uIjogewogICAgICAiY29kZSI6IHsi
Y29kaW5nIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogImh0dHA6Ly9zbm9tZWQuaW5m
by9zY3QifSwKICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAzNjU5ODEwMDd9LAogICAgICAgICJk
aXNwbGF5IjogeyJ2YWx1ZSI6ICJGaW5kaW5nIG9mIHRvYmFjY28gc21va2luZyBiZWhhdmlvciJ9
CiAgICAgIH19LAogICAgICAidmFsdWVTdHJpbmciOiB7InZhbHVlIjogIlNtb2tlIHR3byBjaWdh
cnMgZGFpbHkifSwKICAgICAgImlkIjogeyJ2YWx1ZSI6ICJPQlgtb2JzZXJ2YXRpb24ifSwKICAg
ICAgInRleHQiOiB7CiAgICAgICAgImRpdiI6IHsKICAgICAgICAgICJwIjogWwogICAgICAgICAg
ICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAgICAgICAgICJjb250ZW50Ijog
IkZpcnN0IG9ic2VydmF0aW9uIHJlbGF0ZWQgaW50ZXJuYWwgY29tbWVudCBsaW5lIgogICAgICAg
ICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIlNlY29uZCBvYnNlcnZhdGlvbiByZWxhdGVkIGludGVybmFsIGNv
bW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICJj
bGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJGaXJzdCBvYnNlcnZhdGlvbiBy
ZWxhdGVkIHJlcG9ydCBjb21tZW50IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsK
ICAgICAgICAgICAgICAiY2xhc3MiOiAiUiIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiU2Vj
b25kIG9ic2VydmF0aW9uIHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAg
fQogICAgICAgICAgXSwKICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8xOTk5
L3hodG1sIgogICAgICAgIH0sCiAgICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAiZ2VuZXJhdGVk
In0KICAgICAgfSwKICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAicHJlbGltaW5hcnkifQogICAg
fX19LAogICAgeyJyZXNvdXJjZSI6IHsiQ29uZGl0aW9uIjogewogICAgICAiY29kZSI6IHsiY29k
aW5nIjogWwogICAgICAgIHsKICAgICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogImh0dHA6Ly9o
bDcub3JnL2ZoaXIvVmFsdWVTZXQvaWNkLTEwIn0sCiAgICAgICAgICAiY29kZSI6IHsidmFsdWUi
OiAiSTI1NzAwIn0sCiAgICAgICAgICAiZGlzcGxheSI6IHsidmFsdWUiOiAiQXRoZXJvc2NsZXJv
c2lzIG9mIENBQkcifQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgInN5c3RlbSI6IHsi
dmFsdWUiOiAiaHR0cDovL2hsNy5vcmcvZmhpci9zaWQvaWNkLTkifSwKICAgICAgICAgICJjb2Rl
IjogeyJ2YWx1ZSI6IDQxNC4zfQogICAgICAgIH0KICAgICAgXX0sCiAgICAgICJ2ZXJpZmljYXRp
b25TdGF0dXMiOiB7InZhbHVlIjogImNvbmZpcm1lZCJ9LAogICAgICAicGF0aWVudCI6IHsicmVm
ZXJlbmNlIjogeyJ2YWx1ZSI6ICJQYXRpZW50In19LAogICAgICAiaWQiOiB7InZhbHVlIjogIkRH
MS1kaWFnbm9zaXMifQogICAgfX19LAogICAgeyJyZXNvdXJjZSI6IHsiQ292ZXJhZ2UiOiB7CiAg
ICAgICJpZGVudGlmaWVyIjogeyJ2YWx1ZSI6IHsidmFsdWUiOiAxMjM0NTY3ODl9fSwKICAgICAg
ImNvbnRhaW5lZCI6IFsKICAgICAgICB7Ik9yZ2FuaXphdGlvbiI6IHsKICAgICAgICAgICJpZGVu
dGlmaWVyIjogeyJ2YWx1ZSI6IHsidmFsdWUiOiAiQVVIU0MifX0sCiAgICAgICAgICAiYWRkcmVz
cyI6IHsKICAgICAgICAgICAgImNvdW50cnkiOiB7InZhbHVlIjogIlVTQSJ9LAogICAgICAgICAg
ICAiY2l0eSI6IHsidmFsdWUiOiAiTWFzb24ifSwKICAgICAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAid29yayJ9LAogICAgICAgICAgICAibGluZSI6IHsidmFsdWUiOiAiNDY5MCBQYXJrd2F5IERy
LiJ9LAogICAgICAgICAgICAicG9zdGFsQ29kZSI6IHsidmFsdWUiOiA0NTA0MH0sCiAgICAgICAg
ICAgICJzdGF0ZSI6IHsidmFsdWUiOiAiT0gifQogICAgICAgICAgfSwKICAgICAgICAgICJuYW1l
IjogeyJ2YWx1ZSI6ICJBRVROQSJ9LAogICAgICAgICAgInRlbGVjb20iOiB7CiAgICAgICAgICAg
ICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0sCiAgICAgICAgICAgICJ1c2UiOiB7InZhbHVl
IjogIndvcmsifSwKICAgICAgICAgICAgInZhbHVlIjogeyJ2YWx1ZSI6ICIxXjMzM140NDQ1NTU1
In0KICAgICAgICAgIH0sCiAgICAgICAgICAiaWQiOiB7InZhbHVlIjogImluc3VyYW5jZS1jb21w
YW55In0KICAgICAgICB9fSwKICAgICAgICB7IlBlcnNvbiI6IHsKICAgICAgICAgICJhZGRyZXNz
IjogewogICAgICAgICAgICAiY291bnRyeSI6IHsidmFsdWUiOiAiVVNBIn0sCiAgICAgICAgICAg
ICJjaXR5IjogeyJ2YWx1ZSI6ICJNYXNvbiJ9LAogICAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6
ICJob21lIn0sCiAgICAgICAgICAgICJsaW5lIjogeyJ2YWx1ZSI6ICIxMjMgTWFpbiBSb2FkIn0s
CiAgICAgICAgICAgICJwb3N0YWxDb2RlIjogeyJ2YWx1ZSI6IDQ1MDc3fSwKICAgICAgICAgICAg
InN0YXRlIjogeyJ2YWx1ZSI6ICJPSCJ9CiAgICAgICAgICB9LAogICAgICAgICAgIm5hbWUiOiB7
CiAgICAgICAgICAgICJnaXZlbiI6IFsKICAgICAgICAgICAgICB7InZhbHVlIjogIkluc3VyZWRf
Rmlyc3RuYW1lIn0sCiAgICAgICAgICAgICAgeyJ2YWx1ZSI6ICJNaWRkbGUifQogICAgICAgICAg
ICBdLAogICAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJvZmZpY2lhbCJ9LAogICAgICAgICAg
ICAiZmFtaWx5IjogeyJ2YWx1ZSI6ICJJbnN1cmVkX0xhc3RuYW1lIn0KICAgICAgICAgIH0sCiAg
ICAgICAgICAiaWQiOiB7InZhbHVlIjogImluc3VyZWQtcGVyc29uIn0KICAgICAgICB9fQogICAg
ICBdLAogICAgICAiZXh0ZW5zaW9uIjogWwogICAgICAgIHsKICAgICAgICAgICJ2YWx1ZUlkZW50
aWZpZXIiOiB7InZhbHVlIjogeyJ2YWx1ZSI6ICJBRVROQSJ9fSwKICAgICAgICAgICJ1cmwiOiAi
aHR0cDovL3d3dy5xdWVzdGRpYWdub3N0aWNzLmNvbSIKICAgICAgICB9LAogICAgICAgIHsKICAg
ICAgICAgICJ2YWx1ZVRpbWluZyI6IHsKICAgICAgICAgICAgImNvZGUiOiB7ImNvZGluZyI6IHsK
ICAgICAgICAgICAgICAic3lzdGVtIjogeyJ2YWx1ZSI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3Yy
LzA0ODUifSwKICAgICAgICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAiUyJ9LAogICAgICAgICAg
ICAgICJkaXNwbGF5IjogeyJ2YWx1ZSI6ICJTdGF0In0KICAgICAgICAgICAgfX0sCiAgICAgICAg
ICAgICJldmVudCI6IHsidmFsdWUiOiAiMjAxNi0wMS0wN1QwOTowMDowMC0wNTowMCJ9CiAgICAg
ICAgICB9LAogICAgICAgICAgInVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YyL3RxMSIKICAg
ICAgICB9CiAgICAgIF0sCiAgICAgICJwbGFuaG9sZGVyUmVmZXJlbmNlIjogeyJyZWZlcmVuY2Ui
OiB7InZhbHVlIjogIlBhdGllbnQvUElELXBhdGllbnQtaWRlbnRpZmljYXRpb24ifX0sCiAgICAg
ICJzdWJQbGFuIjogeyJ2YWx1ZSI6ICJDMTIzNDU2In0sCiAgICAgICJpc3N1ZXJSZWZlcmVuY2Ui
OiB7InJlZmVyZW5jZSI6IHsidmFsdWUiOiAiT3JnYW5pemF0aW9uL2luc3VyYW5jZS1jb21wYW55
In19LAogICAgICAiYmVuZWZpY2lhcnlJZGVudGlmaWVyIjogIiIsCiAgICAgICJpZCI6IHsidmFs
dWUiOiAiSU4xLWluc3VyYW5jZSJ9LAogICAgICAidHlwZSI6IHsiY29kZSI6IHsidmFsdWUiOiAi
UCJ9fSwKICAgICAgInJlbGF0aW9uc2hpcCI6IHsKICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAx
fSwKICAgICAgICAiZGlzcGxheSI6IHsidmFsdWUiOiAiU2VsZiJ9CiAgICAgIH0sCiAgICAgICJw
bGFuIjogeyJ2YWx1ZSI6ICJQMTIzNDU2UiJ9LAogICAgICAiZ3JvdXAiOiB7InZhbHVlIjogIkEx
MjM0NSJ9CiAgICB9fX0sCiAgICB7InJlc291cmNlIjogeyJQZXJzb24iOiB7CiAgICAgICJhZGRy
ZXNzIjogewogICAgICAgICJjb3VudHJ5IjogeyJ2YWx1ZSI6ICJVU0EifSwKICAgICAgICAiY2l0
eSI6IHsidmFsdWUiOiAiTWFzb24ifSwKICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJob21lIn0s
CiAgICAgICAgImxpbmUiOiB7InZhbHVlIjogIjQ2OTAgUGFya3dheSBEci4ifSwKICAgICAgICAi
cG9zdGFsQ29kZSI6IHsidmFsdWUiOiA0NTA0MH0sCiAgICAgICAgInN0YXRlIjogeyJ2YWx1ZSI6
ICJPSCJ9CiAgICAgIH0sCiAgICAgICJuYW1lIjogewogICAgICAgICJnaXZlbiI6IFsKICAgICAg
ICAgIHsidmFsdWUiOiAiSW5zdXJlZF9GaXJzdG5hbWUifSwKICAgICAgICAgIHsidmFsdWUiOiAi
TWlkZGxlIn0KICAgICAgICBdLAogICAgICAgICJ1c2UiOiB7InZhbHVlIjogIm9mZmljaWFsIn0s
CiAgICAgICAgImZhbWlseSI6IHsidmFsdWUiOiAiSW5zdXJlZF9MYXN0bmFtZSJ9CiAgICAgIH0s
CiAgICAgICJ0ZWxlY29tIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0s
CiAgICAgICAgInVzZSI6IHsidmFsdWUiOiAiaG9tZSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFs
dWUiOiAiMV4zMzNeNDQ0NTU1NSJ9CiAgICAgIH0sCiAgICAgICJpZCI6IHsidmFsdWUiOiAiR1Qx
LWd1YXJhbnRvciJ9CiAgICB9fX0sCiAgICB7InJlc291cmNlIjogeyJQcmFjdGl0aW9uZXIiOiB7
CiAgICAgICJpZGVudGlmaWVyIjogewogICAgICAgICJhc3NpZ25lciI6IHsiZGlzcGxheSI6IHsi
dmFsdWUiOiAiTlBJIn19LAogICAgICAgICJ2YWx1ZSI6IHsidmFsdWUiOiAxMzY2NDcyNTU3fQog
ICAgICB9LAogICAgICAibmFtZSI6IHsKICAgICAgICAiZ2l2ZW4iOiBbCiAgICAgICAgICB7InZh
bHVlIjogIkphc29uIn0sCiAgICAgICAgICB7InZhbHVlIjogIlMuIn0KICAgICAgICBdLAogICAg
ICAgICJmYW1pbHkiOiB7InZhbHVlIjogIkphdmlsbG8ifQogICAgICB9LAogICAgICAiaWQiOiB7
InZhbHVlIjogIm9yZGVyaW5nLXByb3ZpZGVyIn0KICAgIH19fQogIF0sCiAgImlkIjogeyJ2YWx1
ZSI6ICJPTUwtTzIxLWIxYTE3Y2QyLTg2NWYtNDg2YS05NjBkLThlYTc3NjRlYzAwZCJ9LAogICJ0
eXBlIjogeyJ2YWx1ZSI6ICJzZWFyY2hzZXQifQp9fQ==</inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>2</metaDataId>
          <name>Create OML_O21</name>
          <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <script>return true;
</script>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>OML templates</name>
                <script>// OML_O21 template with placeholders for required fields only
var oml_template = &quot;MSH|^~\&amp;|||||||OML^O21^OML_O21|||2.5.1\r&quot; + &quot;PID|1|||||||\r&quot;;
var oml = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(oml_template));

// MSH segment required fields (may be overwritten by MessageHeader resource)
oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = $(&quot;application&quot;);
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = $(&quot;account&quot;);
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = $(&quot;receivingFacility&quot;);

// Overrides
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = &quot;MET&quot;;
oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = &quot;PSC&quot;;
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = &quot;90046003&quot;;

// (Quest) Note: All date timestamps are set to Coordinated Universal Time (UTC).
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmssZ&quot;);
oml[&apos;MSH&apos;][&apos;MSH.7&apos;] = currentDate;

// Message Control ID is calculated based on date of submission
oml[&apos;MSH&apos;][&apos;MSH.10&apos;] = currentDate.toString().substring(0,14) + UUIDGenerator.getUUID().toString().substring(0,6);
oml[&apos;MSH&apos;][&apos;MSH.11&apos;] = $(&quot;processingID&quot;);


// A list of possible incoming JSON feed validation errors based on IN1.47 [Coverage Type] value
var error = [];</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// OML_O21 template with placeholders for required fields only
var oml_template = &quot;MSH|^~\&amp;|||||||OML^O21^OML_O21|||2.5.1\r&quot; + &quot;PID|1|||||||\r&quot;;
var oml = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(oml_template));

// MSH segment required fields (may be overwritten by MessageHeader resource)
oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = $(&quot;application&quot;);
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = $(&quot;account&quot;);
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = $(&quot;receivingFacility&quot;);

// Overrides
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = &quot;MET&quot;;
oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = &quot;PSC&quot;;
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = &quot;90046003&quot;;

// (Quest) Note: All date timestamps are set to Coordinated Universal Time (UTC).
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmssZ&quot;);
oml[&apos;MSH&apos;][&apos;MSH.7&apos;] = currentDate;

// Message Control ID is calculated based on date of submission
oml[&apos;MSH&apos;][&apos;MSH.10&apos;] = currentDate.toString().substring(0,14) + UUIDGenerator.getUUID().toString().substring(0,6);
oml[&apos;MSH&apos;][&apos;MSH.11&apos;] = $(&quot;processingID&quot;);


// A list of possible incoming JSON feed validation errors based on IN1.47 [Coverage Type] value
var error = [];</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Iterate JSON resources</name>
                <script>// Global NTE Set ID value
var countNTE = 1; 

// Insurance list to retain primary and secondary
var coverageMap = new Packages.java.util.HashMap(2);

// Guarantor
var guarantorMap = new Packages.java.util.HashMap(1);

// Common Order
var commonOrderMap = new Packages.java.util.HashMap(4);
var placedOrderNumberMap = new Packages.java.util.HashMap(4);

// Timing/Quantity
var timingQuantityMap = new Packages.java.util.HashMap(4);

// Observation Request
var observationRequestMap = new Packages.java.util.HashMap(4);
var observationRequestCommentsMap = new Packages.java.util.HashMap(4);

// Diagnosis
var diagnosisMap = new Packages.java.util.HashMap(12);

// Observation/Result aka AOEs
var observationMap = new Packages.java.util.HashMap(4);
var observationCommentsMap = new Packages.java.util.HashMap(4);
var observationReferencesMap = new Packages.java.util.HashMap(4);

// ORC.12 Ordering Provider
// OBX.16 Ordering Provider
var practitionerMap = new Packages.java.util.HashMap(4);



// Preliminary store referenced resources
for each (obj in msg.Bundle.entry) {

	if (obj.resource.Practitioner != null &amp;&amp; obj.resource.Practitioner != undefined) {
logger.error( &quot;Found Practitioner&quot; );	

		
		// Practitioner is required to complete ORC and OBR segments
		var id = ((obj.resource.Practitioner.id != undefined) ? obj.resource.Practitioner.id.value.toString() : &quot;&quot;);
		if (id.length &gt; 0)
			practitionerMap.put(id.toString(), obj);
	}
}

logger.error( &quot;About to iterate: &quot; + obj.resource.toString() );	
// Iterate over all inbound feed resource
for each (obj in msg.Bundle.entry) {

logger.error( &quot;Resource: \n&quot; + JSON.stringify( obj.resource ) );	

	if (obj.resource.MessageHeader != null &amp;&amp; obj.resource.MessageHeader != undefined) {
logger.error( &quot;Found MessagerHeader&quot; );			
		// Update MessageHeader segment
		processMessageHeader(obj);

	} else if (obj.resource.Patient != null &amp;&amp; obj.resource.Patient != undefined) {
		// Populate PID segment
		processPatient(obj);
		
	} else if (obj.resource.DiagnosticReport != null &amp;&amp; obj.resource.DiagnosticReport != undefined) {
logger.error( &quot;Found Report&quot;);	
		// Populate ORC segment
		processCommonOrder(obj);
		
	} else if (obj.resource.DiagnosticOrder != null &amp;&amp; obj.resource.DiagnosticOrder != undefined) {
logger.error( &quot;Found Order&quot;);	
		// Populate OBR segment
		processObservationRequest(obj);

	} else if (obj.resource.Coverage != null &amp;&amp; obj.resource.Coverage != undefined) {
		// Populate IN1 segment
		processCoverage(obj);
		
	} else if (obj.resource.Person != null &amp;&amp; obj.resource.Person != undefined) {
		// Populate GT1 segment
		processGuarantor(obj);
		
	} else if (obj.resource.Observation != null &amp;&amp; obj.resource.Observation != undefined) {
		// Store Observation resource for OBX segment
		processObservation(obj);
	}

}


// ==================== COMPILE THE OML MESSAGE ====================

// Required primary insurance segment
var segInsurancePrimary = coverageMap.get(1);
if (segInsurancePrimary != null) try {
	oml.appendChild(new XML(segInsurancePrimary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding primary insurance segment - &quot; + ex);
}
// Optional secondary insurance segment
var segInsuranceSecondary = coverageMap.get(2);
if (segInsuranceSecondary != null) try {
	oml.appendChild(new XML(segInsuranceSecondary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding secondary insurance segment - &quot; + ex);
} 



// Optional Guarantor segment
var segGuarantor = guarantorMap.get(1);
if (segGuarantor != null) try {
	oml.appendChild(new XML(segGuarantor));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding Guarantor segment - &quot; + ex);	
}



// Required ORDER group
for (var i = 0; i &lt; commonOrderMap.size(); i++) {

	// ORC [Common Order] segment
	var segCommonOrder = commonOrderMap.get((i+1).toString());
	if (segCommonOrder != null) try {
		oml.appendChild(new XML(segCommonOrder));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding CommonOrder segment - &quot; + ex);
	}

	// TQ1 [Timing/Quantity] segment
	var segTimingQuantity = timingQuantityMap.get((i+1).toString());
	if (segTimingQuantity != null) try {
		oml.appendChild(new XML(segTimingQuantity));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Timing/Quantity segment - &quot; + ex);
	}

	// OBR [Observation Request] segment
	var segObservation = observationRequestMap.get((i+1).toString());
	if (segObservation != null) try {
		oml.appendChild(new XML(segObservation));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Observation Request segment - &quot; + ex);
	}
		

	// Observation level NTE [Comments] segments
	var obsComments = observationRequestCommentsMap.get((i+1).toString());
	if (obsComments != null &amp;&amp; Array.isArray(obsComments)) {
		for (var kk = 0; kk &lt; obsComments.length; kk++) {
			var nte = obsComments[kk];
			if (nte.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(nte.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Observation Comment segment - &quot; + ex);
			}
		}
		obsComments.length = 0;
	}
	
	// DG1 [Diagnosis] segments
	var conditions = diagnosisMap.get((i+1).toString());
	if (conditions != null &amp;&amp; Array.isArray(conditions)) {
		for (var dd = 0; dd &lt; conditions.length; dd++) {
			var dg1 = conditions[dd];
			if (dg1.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(dg1.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Diagnosis segment - &quot; + ex);
			}
		}
		conditions.length = 0;		
	}

	// OBX [Observation] segments
	// Get the list of OBX segment references
	var obsReference = observationReferencesMap.get((i+1).toString());
	if (obsReference != null &amp;&amp; Array.isArray(obsReference)) {
		for (var rr = 0; rr &lt; obsReference.length; rr++) {
			// Get the actual OBX segments
			var obx = observationMap.get(obsReference[rr]);
			if (obx != null &amp;&amp; obx.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(obx.toString()));

				// OBX level NTE [Comment] segments
				var observationComments = observationCommentsMap.get(obsReference[rr]);
				if (observationComments != null &amp;&amp; Array.isArray(observationComments)) {
					for (var oc = 0; oc &lt; observationComments.length; oc++) {
						var obxNTE = observationComments[oc];
						if (obxNTE != null &amp;&amp; obxNTE.length &gt; 0)
							oml.appendChild(new XML(obxNTE.toString()));
					}
				}
				observationComments.length = 0;
				
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding OBX segment - &quot; + ex);
			}		
		}		
		obsReference.length = 0;		
	}

}


// Clear all temporary maps
coverageMap.clear();
guarantorMap.clear();
commonOrderMap.clear();
placedOrderNumberMap.clear();
timingQuantityMap.clear();
observationRequestMap.clear();
observationRequestCommentsMap.clear();
diagnosisMap.clear();
observationMap.clear();
observationCommentsMap.clear(); 
observationReferencesMap.clear();
practitionerMap.clear();</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Global NTE Set ID value
var countNTE = 1; 

// Insurance list to retain primary and secondary
var coverageMap = new Packages.java.util.HashMap(2);

// Guarantor
var guarantorMap = new Packages.java.util.HashMap(1);

// Common Order
var commonOrderMap = new Packages.java.util.HashMap(4);
var placedOrderNumberMap = new Packages.java.util.HashMap(4);

// Timing/Quantity
var timingQuantityMap = new Packages.java.util.HashMap(4);

// Observation Request
var observationRequestMap = new Packages.java.util.HashMap(4);
var observationRequestCommentsMap = new Packages.java.util.HashMap(4);

// Diagnosis
var diagnosisMap = new Packages.java.util.HashMap(12);

// Observation/Result aka AOEs
var observationMap = new Packages.java.util.HashMap(4);
var observationCommentsMap = new Packages.java.util.HashMap(4);
var observationReferencesMap = new Packages.java.util.HashMap(4);

// ORC.12 Ordering Provider
// OBX.16 Ordering Provider
var practitionerMap = new Packages.java.util.HashMap(4);



// Preliminary store referenced resources
for each (obj in msg.Bundle.entry) {

	if (obj.resource.Practitioner != null &amp;&amp; obj.resource.Practitioner != undefined) {
logger.error( &quot;Found Practitioner&quot; );	

		
		// Practitioner is required to complete ORC and OBR segments
		var id = ((obj.resource.Practitioner.id != undefined) ? obj.resource.Practitioner.id.value.toString() : &quot;&quot;);
		if (id.length &gt; 0)
			practitionerMap.put(id.toString(), obj);
	}
}

logger.error( &quot;About to iterate: &quot; + obj.resource.toString() );	
// Iterate over all inbound feed resource
for each (obj in msg.Bundle.entry) {

logger.error( &quot;Resource: \n&quot; + JSON.stringify( obj.resource ) );	

	if (obj.resource.MessageHeader != null &amp;&amp; obj.resource.MessageHeader != undefined) {
logger.error( &quot;Found MessagerHeader&quot; );			
		// Update MessageHeader segment
		processMessageHeader(obj);

	} else if (obj.resource.Patient != null &amp;&amp; obj.resource.Patient != undefined) {
		// Populate PID segment
		processPatient(obj);
		
	} else if (obj.resource.DiagnosticReport != null &amp;&amp; obj.resource.DiagnosticReport != undefined) {
logger.error( &quot;Found Report&quot;);	
		// Populate ORC segment
		processCommonOrder(obj);
		
	} else if (obj.resource.DiagnosticOrder != null &amp;&amp; obj.resource.DiagnosticOrder != undefined) {
logger.error( &quot;Found Order&quot;);	
		// Populate OBR segment
		processObservationRequest(obj);

	} else if (obj.resource.Coverage != null &amp;&amp; obj.resource.Coverage != undefined) {
		// Populate IN1 segment
		processCoverage(obj);
		
	} else if (obj.resource.Person != null &amp;&amp; obj.resource.Person != undefined) {
		// Populate GT1 segment
		processGuarantor(obj);
		
	} else if (obj.resource.Observation != null &amp;&amp; obj.resource.Observation != undefined) {
		// Store Observation resource for OBX segment
		processObservation(obj);
	}

}


// ==================== COMPILE THE OML MESSAGE ====================

// Required primary insurance segment
var segInsurancePrimary = coverageMap.get(1);
if (segInsurancePrimary != null) try {
	oml.appendChild(new XML(segInsurancePrimary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding primary insurance segment - &quot; + ex);
}
// Optional secondary insurance segment
var segInsuranceSecondary = coverageMap.get(2);
if (segInsuranceSecondary != null) try {
	oml.appendChild(new XML(segInsuranceSecondary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding secondary insurance segment - &quot; + ex);
} 



// Optional Guarantor segment
var segGuarantor = guarantorMap.get(1);
if (segGuarantor != null) try {
	oml.appendChild(new XML(segGuarantor));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding Guarantor segment - &quot; + ex);	
}



// Required ORDER group
for (var i = 0; i &lt; commonOrderMap.size(); i++) {

	// ORC [Common Order] segment
	var segCommonOrder = commonOrderMap.get((i+1).toString());
	if (segCommonOrder != null) try {
		oml.appendChild(new XML(segCommonOrder));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding CommonOrder segment - &quot; + ex);
	}

	// TQ1 [Timing/Quantity] segment
	var segTimingQuantity = timingQuantityMap.get((i+1).toString());
	if (segTimingQuantity != null) try {
		oml.appendChild(new XML(segTimingQuantity));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Timing/Quantity segment - &quot; + ex);
	}

	// OBR [Observation Request] segment
	var segObservation = observationRequestMap.get((i+1).toString());
	if (segObservation != null) try {
		oml.appendChild(new XML(segObservation));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Observation Request segment - &quot; + ex);
	}
		

	// Observation level NTE [Comments] segments
	var obsComments = observationRequestCommentsMap.get((i+1).toString());
	if (obsComments != null &amp;&amp; Array.isArray(obsComments)) {
		for (var kk = 0; kk &lt; obsComments.length; kk++) {
			var nte = obsComments[kk];
			if (nte.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(nte.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Observation Comment segment - &quot; + ex);
			}
		}
		obsComments.length = 0;
	}
	
	// DG1 [Diagnosis] segments
	var conditions = diagnosisMap.get((i+1).toString());
	if (conditions != null &amp;&amp; Array.isArray(conditions)) {
		for (var dd = 0; dd &lt; conditions.length; dd++) {
			var dg1 = conditions[dd];
			if (dg1.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(dg1.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Diagnosis segment - &quot; + ex);
			}
		}
		conditions.length = 0;		
	}

	// OBX [Observation] segments
	// Get the list of OBX segment references
	var obsReference = observationReferencesMap.get((i+1).toString());
	if (obsReference != null &amp;&amp; Array.isArray(obsReference)) {
		for (var rr = 0; rr &lt; obsReference.length; rr++) {
			// Get the actual OBX segments
			var obx = observationMap.get(obsReference[rr]);
			if (obx != null &amp;&amp; obx.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(obx.toString()));

				// OBX level NTE [Comment] segments
				var observationComments = observationCommentsMap.get(obsReference[rr]);
				if (observationComments != null &amp;&amp; Array.isArray(observationComments)) {
					for (var oc = 0; oc &lt; observationComments.length; oc++) {
						var obxNTE = observationComments[oc];
						if (obxNTE != null &amp;&amp; obxNTE.length &gt; 0)
							oml.appendChild(new XML(obxNTE.toString()));
					}
				}
				observationComments.length = 0;
				
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding OBX segment - &quot; + ex);
			}		
		}		
		obsReference.length = 0;		
	}

}


// Clear all temporary maps
coverageMap.clear();
guarantorMap.clear();
commonOrderMap.clear();
placedOrderNumberMap.clear();
timingQuantityMap.clear();
observationRequestMap.clear();
observationRequestCommentsMap.clear();
diagnosisMap.clear();
observationMap.clear();
observationCommentsMap.clear(); 
observationReferencesMap.clear();
practitionerMap.clear();</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>MSH segment</name>
                <script>/**
	Populates MSG segment with data from the MessageHeader resource
	@param {Object} obj - MessageHeader object resource
	@return - nothing, uses global HL7v2 message object
*/
function processMessageHeader(obj) {

	if (obj.resource.MessageHeader.source) {
		
		// The name of the sending application
		var sendingApplication = ((obj.resource.MessageHeader.source.name) ? obj.resource.MessageHeader.source.name.value.toString() : &quot;&quot;);
		if (sendingApplication) oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = sendingApplication;
		
		// Primary or secondary account number(s) defined for the placer. ~~ RKW - And the actual account number was less important?
		var sendingFacility = ((obj.resource.MessageHeader.source.endpoint) ? obj.resource.MessageHeader.source.endpoint.value.toString() : &quot;&quot;);
		if (sendingFacility) oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = sendingFacility;
			
	} 

	if (obj.resource.MessageHeader.destination) {
		
		// If provided must be hard-coded to &quot;PSC&quot; for PSC hold orders. If the &lt;name&gt; element is not provided or value is other than &quot;PSC&quot; the order is considered to be a basic lab order.
		var receivingApplication = ((obj.resource.MessageHeader.destination.name) ? obj.resource.MessageHeader.destination.name.value.toString() : &quot;&quot;);
		if (receivingApplication) oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = receivingApplication;


		// The receiving facility. The three-letter ID of the facility that performs the test.
		var receivingFacility = ((obj.resource.MessageHeader.destination.endpoint) ? obj.resource.MessageHeader.destination.endpoint.value.toString() : &quot;&quot;);
		if (receivingFacility) oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = receivingFacility;			
	}

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates MSG segment with data from the MessageHeader resource
	@param {Object} obj - MessageHeader object resource
	@return - nothing, uses global HL7v2 message object
*/
function processMessageHeader(obj) {

	if (obj.resource.MessageHeader.source) {
		
		// The name of the sending application
		var sendingApplication = ((obj.resource.MessageHeader.source.name) ? obj.resource.MessageHeader.source.name.value.toString() : &quot;&quot;);
		if (sendingApplication) oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = sendingApplication;
		
		// Primary or secondary account number(s) defined for the placer. ~~ RKW - And the actual account number was less important?
		var sendingFacility = ((obj.resource.MessageHeader.source.endpoint) ? obj.resource.MessageHeader.source.endpoint.value.toString() : &quot;&quot;);
		if (sendingFacility) oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = sendingFacility;
			
	} 

	if (obj.resource.MessageHeader.destination) {
		
		// If provided must be hard-coded to &quot;PSC&quot; for PSC hold orders. If the &lt;name&gt; element is not provided or value is other than &quot;PSC&quot; the order is considered to be a basic lab order.
		var receivingApplication = ((obj.resource.MessageHeader.destination.name) ? obj.resource.MessageHeader.destination.name.value.toString() : &quot;&quot;);
		if (receivingApplication) oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = receivingApplication;


		// The receiving facility. The three-letter ID of the facility that performs the test.
		var receivingFacility = ((obj.resource.MessageHeader.destination.endpoint) ? obj.resource.MessageHeader.destination.endpoint.value.toString() : &quot;&quot;);
		if (receivingFacility) oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = receivingFacility;			
	}

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>3</sequenceNumber>
                <name>PID segment</name>
                <script>/**
	Populates PID segment with data from the Patient resource
	@param {Object} obj - Patient object resource
	@return - nothing, uses global HL7v2 message object
*/
function processPatient(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var comments = [];

	// Iterate over all patient identifiers
	obj.resource.Patient.identifier.forEach(function(item){

		// PID.3 [Patient Identifier List]
		if (item.use.value.toString() == &quot;official&quot;) {
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = id;

			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.5&apos;] = type;

			var assigner = ((item.assigner) ? item.assigner.display.value.toString() : &quot;&quot;);
			if (assigner)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = assigner;								

		// PID.2 [Patient ID]	
		} else if (item.use.value.toString() == &quot;secondary&quot;) {
		
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.1&apos;] = id;
				
			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.5&apos;] = type;			
						
		}
		
	});


	// Parse patient&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Patient.name, true);
	oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = nameParts.family;
	if (nameParts.given1) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = nameParts.given1;
	if (nameParts.given2) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = nameParts.given2;


	// Patient&apos;s DOB
	if (obj.resource.Patient.birthDate) {
		var dob = obj.resource.Patient.birthDate.value.toString();
		oml[&apos;PID&apos;][&apos;PID.7&apos;] = dob.replace(/-/g,&quot;&quot;);
	} else {
		error.push(&quot;resource.Patient.birthDate for PID.7[DateTime of Birth] is required&quot;);
	}

	// Administrative Gender 
	if (obj.resource.Patient.gender) {
		var gender = obj.resource.Patient.gender.value;
		oml[&apos;PID&apos;][&apos;PID.8&apos;] = convertTable(&quot;0001&quot;, gender);
	} else {
		error.push(&quot;resource.Patient.gender for PID.8[Administrative Sex] is required&quot;);		
	}




	// Patient Address
	if (obj.resource.Patient.address) {

		var street = ((obj.resource.Patient.address.line) ? obj.resource.Patient.address.line.value.toString() : &quot;&quot;);
		if (street)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = street;
		
		var city = ((obj.resource.Patient.address.city) ? obj.resource.Patient.address.city.value.toString() : &quot;&quot;);
		if (city)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = city;	
		
		var state = ((obj.resource.Patient.address.state) ? obj.resource.Patient.address.state.value.toString() : &quot;&quot;);
		if (state)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.4&apos;] = state;
	
		var postal = ((obj.resource.Patient.address.postalCode) ? obj.resource.Patient.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;] = postal;
	
		var country = ((obj.resource.Patient.address.country) ? obj.resource.Patient.address.country.value.toString() : &quot;&quot;);
		if (country)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.6&apos;] = country;

		// There might be a better definition what is required &quot;patient’s address&quot;.
		hasAddress = (street || city || state || postal);	
	}

	// Patient Phone Number (Home)	
	var phone = ((obj.resource.Patient.telecom) ? obj.resource.Patient.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		oml[&apos;PID&apos;][&apos;PID.13&apos;] = convertPhoneXTN(phone);
	}


	// Validate conditional fields
	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (!hasAddress) error.push(&quot;resource.Patient.address for PID.11[Patient Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Patient.telecom for PID.13[Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);
	}


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.Patient.text &amp;&amp; obj.resource.Patient.text.div) {	
		
		var internalCommentsCount = 0; //  only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.Patient.text.div.p.length &amp;&amp; obj.resource.Patient.text.div.p.length &gt; 0) {
			obj.resource.Patient.text.div.p.forEach(function(item){
				// For internal (I) or report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					// If the comment is not internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				} 		
			});	
		} else if (obj.resource.Patient.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.Patient.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.Patient.text.div.p, countNTE++));
		}

		for (var i = comments.length - 1; i &gt;= 0; i--) {
			var nte = comments[i];
			if (nte.toString() != &quot;&quot;)
				oml[&apos;PID&apos;] += new XML(nte.toString());
		}

		comments.length = 0;
	}

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates PID segment with data from the Patient resource
	@param {Object} obj - Patient object resource
	@return - nothing, uses global HL7v2 message object
*/
function processPatient(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var comments = [];

	// Iterate over all patient identifiers
	obj.resource.Patient.identifier.forEach(function(item){

		// PID.3 [Patient Identifier List]
		if (item.use.value.toString() == &quot;official&quot;) {
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = id;

			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.5&apos;] = type;

			var assigner = ((item.assigner) ? item.assigner.display.value.toString() : &quot;&quot;);
			if (assigner)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = assigner;								

		// PID.2 [Patient ID]	
		} else if (item.use.value.toString() == &quot;secondary&quot;) {
		
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.1&apos;] = id;
				
			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.5&apos;] = type;			
						
		}
		
	});


	// Parse patient&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Patient.name, true);
	oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = nameParts.family;
	if (nameParts.given1) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = nameParts.given1;
	if (nameParts.given2) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = nameParts.given2;


	// Patient&apos;s DOB
	if (obj.resource.Patient.birthDate) {
		var dob = obj.resource.Patient.birthDate.value.toString();
		oml[&apos;PID&apos;][&apos;PID.7&apos;] = dob.replace(/-/g,&quot;&quot;);
	} else {
		error.push(&quot;resource.Patient.birthDate for PID.7[DateTime of Birth] is required&quot;);
	}

	// Administrative Gender 
	if (obj.resource.Patient.gender) {
		var gender = obj.resource.Patient.gender.value;
		oml[&apos;PID&apos;][&apos;PID.8&apos;] = convertTable(&quot;0001&quot;, gender);
	} else {
		error.push(&quot;resource.Patient.gender for PID.8[Administrative Sex] is required&quot;);		
	}




	// Patient Address
	if (obj.resource.Patient.address) {

		var street = ((obj.resource.Patient.address.line) ? obj.resource.Patient.address.line.value.toString() : &quot;&quot;);
		if (street)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = street;
		
		var city = ((obj.resource.Patient.address.city) ? obj.resource.Patient.address.city.value.toString() : &quot;&quot;);
		if (city)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = city;	
		
		var state = ((obj.resource.Patient.address.state) ? obj.resource.Patient.address.state.value.toString() : &quot;&quot;);
		if (state)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.4&apos;] = state;
	
		var postal = ((obj.resource.Patient.address.postalCode) ? obj.resource.Patient.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;] = postal;
	
		var country = ((obj.resource.Patient.address.country) ? obj.resource.Patient.address.country.value.toString() : &quot;&quot;);
		if (country)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.6&apos;] = country;

		// There might be a better definition what is required &quot;patient’s address&quot;.
		hasAddress = (street || city || state || postal);	
	}

	// Patient Phone Number (Home)	
	var phone = ((obj.resource.Patient.telecom) ? obj.resource.Patient.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		oml[&apos;PID&apos;][&apos;PID.13&apos;] = convertPhoneXTN(phone);
	}


	// Validate conditional fields
	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (!hasAddress) error.push(&quot;resource.Patient.address for PID.11[Patient Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Patient.telecom for PID.13[Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);
	}


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.Patient.text &amp;&amp; obj.resource.Patient.text.div) {	
		
		var internalCommentsCount = 0; //  only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.Patient.text.div.p.length &amp;&amp; obj.resource.Patient.text.div.p.length &gt; 0) {
			obj.resource.Patient.text.div.p.forEach(function(item){
				// For internal (I) or report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					// If the comment is not internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				} 		
			});	
		} else if (obj.resource.Patient.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.Patient.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.Patient.text.div.p, countNTE++));
		}

		for (var i = comments.length - 1; i &gt;= 0; i--) {
			var nte = comments[i];
			if (nte.toString() != &quot;&quot;)
				oml[&apos;PID&apos;] += new XML(nte.toString());
		}

		comments.length = 0;
	}

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>4</sequenceNumber>
                <name>IN1 primary and secondary segments</name>
                <script>/**
	Populates IN1 [Insurance] segments with data from the primary and secondary Coverage resources	
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCoverage(obj) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var isContainedPerson = hasPersonAddress = false;
	var isContainedOrganization = hasOrganizationAddress = false;

	var segIns = &lt;IN1&gt;
				&lt;IN1.1&gt;
					&lt;IN1.1.1&gt;1&lt;/IN1.1.1&gt;
				&lt;/IN1.1&gt;
				&lt;IN1.2/&gt;&lt;IN1.3/&gt;&lt;IN1.4/&gt;&lt;IN1.5/&gt;&lt;IN1.6/&gt;&lt;IN1.7/&gt;&lt;IN1.8/&gt;&lt;IN1.9/&gt;
				&lt;IN1.10/&gt;&lt;IN1.11/&gt;&lt;IN1.12/&gt;&lt;IN1.13/&gt;&lt;IN1.14/&gt;&lt;IN1.15/&gt;&lt;IN1.16/&gt;&lt;IN1.17/&gt;&lt;IN1.18/&gt;&lt;IN1.19/&gt;
				&lt;IN1.20/&gt;&lt;IN1.21/&gt;&lt;IN1.22/&gt;&lt;IN1.23/&gt;&lt;IN1.24/&gt;&lt;IN1.25/&gt;&lt;IN1.26/&gt;&lt;IN1.27/&gt;&lt;IN1.28/&gt;&lt;IN1.29/&gt;
				&lt;IN1.30/&gt;&lt;IN1.31/&gt;&lt;IN1.32/&gt;&lt;IN1.33/&gt;&lt;IN1.34/&gt;&lt;IN1.35/&gt;&lt;IN1.36/&gt;&lt;IN1.37/&gt;&lt;IN1.38/&gt;&lt;IN1.39/&gt;
				&lt;IN1.40/&gt;&lt;IN1.41/&gt;&lt;IN1.42/&gt;&lt;IN1.43/&gt;&lt;IN1.44/&gt;&lt;IN1.45/&gt;&lt;IN1.46/&gt;&lt;IN1.47/&gt;
			&lt;/IN1&gt;;

	// Insurance Set ID
	var coverageType = 1; 
	var setID = obj.resource.Coverage.id.value.toString();
	if (setID.indexOf(&quot;2&quot;) &gt; -1) {
		segIns[&apos;IN1.1&apos;] = &quot;2&quot;;
		coverageType = 2; // secondary - &quot;IN1-insurance-2&quot;
	} else {
		segIns[&apos;IN1.1&apos;] = &quot;1&quot;;
		coverageType = 1; // primary - &quot;IN1-insurance-1&quot;		
	}


	// Insurance Plan ID
	var planID = obj.resource.Coverage.identifier.value.value.toString();
	if (planID)
		segIns[&apos;IN1.2&apos;] = planID;


	if (obj.resource.Coverage.contained.length &amp;&amp; obj.resource.Coverage.contained.length &gt; 0) {

		// Loop through contained resources
		obj.resource.Coverage.contained.forEach(function(item){

			// Process contained insurance company
			processInsuranceOrganization(segIns, item);

			if (item.Person != null &amp;&amp; item.Person != undefined) {

				isContainedPerson = true;
				
				// Process insured person name with DEX name length limitation applied
				nameParts = processPersonName(item.Person.name, true);
	
				// Insured&apos;s Address
				if (item.Person.address) {
					var street = item.Person.address.line.value.toString();
					if (street)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.1&apos;] = street;
					
					var city = ((item.Person.address.city) ? item.Person.address.city.value.toString() : &quot;&quot;);
					if (city)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.3&apos;] = city;	
					
					var state = ((item.Person.address.state) ? item.Person.address.state.value.toString() : &quot;&quot;);
					if (state)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.4&apos;] = state;
				
					var postal = ((item.Person.address.postalCode) ? item.Person.address.postalCode.value.toString() : &quot;&quot;);
					if (postal)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.5&apos;] = postal;
				
					var country = ((item.Person.address.country) ? item.Person.address.country.value.toString() : &quot;&quot;);
					if (country)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.6&apos;] = country;
						
					// There might be a better definition what is required &quot;insured’s Address&quot;.
					hasPersonAddress = (street || city || state || postal);	
				}
			}
		});

	} else {
		// When only contained  insurance company is present
		processInsuranceOrganization(segIns, obj.resource.Coverage.contained);
	}

	// Insured&apos;s Group Employer Name 
	if (obj.resource.Coverage.extension) {
		var emplName = ((obj.resource.Coverage.extension.valueIdentifier) ? obj.resource.Coverage.extension.valueIdentifier.value.value.toString() : &quot;&quot;);
		if (emplName)
			segIns[&apos;IN1.11&apos;] = emplName;
	}


	// Group Number
	var groupNumber = ((obj.resource.Coverage.group) ? obj.resource.Coverage.group.value.toString() : &quot;&quot;);
	if (groupNumber)
		segIns[&apos;IN1.8&apos;] = groupNumber;



	

	// Name Of Insured
	// (SN) March 11, 2017: Fix to downgrade to DSTU3 Coverage resource. Previously checked only planholderReference.
/*	
	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
*/

	// Name Of Insured
	// (SN) March 13 2017: Disabled
	//var insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();

	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
	
	if (insuredRef == &quot;Patient/PID-patient-identification&quot;) {
		// Same as the PID segment
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString();
		
	} else if (insuredRef == &quot;Person/insured-person&quot;) {
		// Taken from the contained Person resource
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = nameParts.family;
		if (nameParts.given1.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = nameParts.given1;
		if (nameParts.given2.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = nameParts.given2;		
	}

	// Insured&apos;s Relationship To Patient
	if ( obj.resource.Coverage.relationship) {
		var relationship = ((obj.resource.Coverage.relationship.code) ? obj.resource.Coverage.relationship.code.value.toString() : &quot;&quot;);
		if (relationship)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;] = relationship;
		
		var relationshipDesc = ((obj.resource.Coverage.relationship.display) ? obj.resource.Coverage.relationship.display.value.toString() : &quot;&quot;);
		if (relationshipDesc)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.2&apos;] = relationshipDesc;
	}

	// Company Plan Code
	var planCode = (( obj.resource.Coverage.subPlan) ? obj.resource.Coverage.subPlan.value.toString() : &quot;&quot;);
	if (planCode)
		segIns[&apos;IN1.35&apos;] = planCode;

	// Policy Number
	var policyNumber = ((obj.resource.Coverage.plan) ? obj.resource.Coverage.plan.value.toString() : &quot;&quot;);
	if (policyNumber)
		segIns[&apos;IN1.36&apos;] = policyNumber;

	// Coverage Type
	segIns[&apos;IN1.47&apos;] = channelMap.get(&quot;CoverageType&quot;);


	if (coverage == &quot;T&quot;) {
		if (segIns[&apos;IN1.4&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Organization.name for IN1.4[Insurance Company Name] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.8&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.group for IN1.8[Group Number] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Person.name for IN1.16[Name Of Insured] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.relationship.code for IN1.17[Insured Relationship To Patient] is required if IN1.47[Coverage Type] is T&quot;);
		if (isContainedPerson &amp;&amp; !hasPersonAddress) error.push(&quot;resource.Coverage.contained.Person.address for IN1.19[Insured Address] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.36&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.plan for IN1.36[Policy Number] is required if IN1.47[Coverage Type] is T&quot;);		
	}


	// Store the segment to be later compiled into a message
	coverageMap.put(coverageType, segIns.toString());

	return;
}


/**
	Populates IN1.3 [Insurance Company ID] field with data from the contained Organization resource
	@param {Object} obj - Organization object resource
	@return - nothing, uses global HL7v2 message object
*/
function processInsuranceOrganization(segIns, item) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;

	if (item.Organization != null &amp;&amp; item.Organization != undefined) {

		isContainedOrganization = true;
		
		// Insurance Company ID
		var companyID = ((item.Organization.identifier) ? item.Organization.identifier.value.value.toString() : &quot;&quot;);
		if (companyID) 
			segIns[&apos;IN1.3&apos;] = companyID;
	
		// Insurance Company Name
		var companyName = ((item.Organization.name) ? item.Organization.name.value.toString() : &quot;&quot;);
		if (companyName)
			segIns[&apos;IN1.4&apos;] = companyName;

		// Insurance Company Address
		if (item.Organization.address) {
			var street = ((item.Organization.address.line) ? item.Organization.address.line.value.toString() : &quot;&quot;);
			if (street)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.1&apos;] = street;
				
			var city = ((item.Organization.address.city) ? item.Organization.address.city.value.toString() : &quot;&quot;);
			if (city)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.3&apos;] = city;
			
			var state = ((item.Organization.address.state) ? item.Organization.address.state.value.toString() : &quot;&quot;);
			if (state)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.4&apos;] = state;
		
			var postal = ((item.Organization.address.postalCode) ? item.Organization.address.postalCode.value.toString() : &quot;&quot;);
			if (postal)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.5&apos;] = postal;
		
			var country = ((item.Organization.address.country) ? item.Organization.address.country.value.toString() : &quot;&quot;);
			if (country)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.6&apos;] = country;

			// There might be a better definition what is required &quot;Insurance Company Address&quot;
			hasOrganizationAddress = (street || city || state || postal);						
		}		

		// Insurance Co Phone Number
		var phone = ((item.Organization.telecom) ? item.Organization.telecom.value.value.toString() : &quot;&quot;);
		if (phone) {
			hasPhone = true;
			segIns[&apos;IN1.7&apos;] = convertPhoneXTN(phone);
		}
	}

	// Validate conditional fields
	if (coverage == &quot;T&quot;) {		
		if (isContainedOrganization &amp;&amp; !hasOrganizationAddress) error.push(&quot;resource.Coverage.contained.Organization.address for IN1.5[Insurance Company Address] is required if IN1.47[Coverage Type] is T&quot;);
	}


	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates IN1 [Insurance] segments with data from the primary and secondary Coverage resources	
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCoverage(obj) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var isContainedPerson = hasPersonAddress = false;
	var isContainedOrganization = hasOrganizationAddress = false;

	var segIns = &lt;IN1&gt;
				&lt;IN1.1&gt;
					&lt;IN1.1.1&gt;1&lt;/IN1.1.1&gt;
				&lt;/IN1.1&gt;
				&lt;IN1.2/&gt;&lt;IN1.3/&gt;&lt;IN1.4/&gt;&lt;IN1.5/&gt;&lt;IN1.6/&gt;&lt;IN1.7/&gt;&lt;IN1.8/&gt;&lt;IN1.9/&gt;
				&lt;IN1.10/&gt;&lt;IN1.11/&gt;&lt;IN1.12/&gt;&lt;IN1.13/&gt;&lt;IN1.14/&gt;&lt;IN1.15/&gt;&lt;IN1.16/&gt;&lt;IN1.17/&gt;&lt;IN1.18/&gt;&lt;IN1.19/&gt;
				&lt;IN1.20/&gt;&lt;IN1.21/&gt;&lt;IN1.22/&gt;&lt;IN1.23/&gt;&lt;IN1.24/&gt;&lt;IN1.25/&gt;&lt;IN1.26/&gt;&lt;IN1.27/&gt;&lt;IN1.28/&gt;&lt;IN1.29/&gt;
				&lt;IN1.30/&gt;&lt;IN1.31/&gt;&lt;IN1.32/&gt;&lt;IN1.33/&gt;&lt;IN1.34/&gt;&lt;IN1.35/&gt;&lt;IN1.36/&gt;&lt;IN1.37/&gt;&lt;IN1.38/&gt;&lt;IN1.39/&gt;
				&lt;IN1.40/&gt;&lt;IN1.41/&gt;&lt;IN1.42/&gt;&lt;IN1.43/&gt;&lt;IN1.44/&gt;&lt;IN1.45/&gt;&lt;IN1.46/&gt;&lt;IN1.47/&gt;
			&lt;/IN1&gt;;

	// Insurance Set ID
	var coverageType = 1; 
	var setID = obj.resource.Coverage.id.value.toString();
	if (setID.indexOf(&quot;2&quot;) &gt; -1) {
		segIns[&apos;IN1.1&apos;] = &quot;2&quot;;
		coverageType = 2; // secondary - &quot;IN1-insurance-2&quot;
	} else {
		segIns[&apos;IN1.1&apos;] = &quot;1&quot;;
		coverageType = 1; // primary - &quot;IN1-insurance-1&quot;		
	}


	// Insurance Plan ID
	var planID = obj.resource.Coverage.identifier.value.value.toString();
	if (planID)
		segIns[&apos;IN1.2&apos;] = planID;


	if (obj.resource.Coverage.contained.length &amp;&amp; obj.resource.Coverage.contained.length &gt; 0) {

		// Loop through contained resources
		obj.resource.Coverage.contained.forEach(function(item){

			// Process contained insurance company
			processInsuranceOrganization(segIns, item);

			if (item.Person != null &amp;&amp; item.Person != undefined) {

				isContainedPerson = true;
				
				// Process insured person name with DEX name length limitation applied
				nameParts = processPersonName(item.Person.name, true);
	
				// Insured&apos;s Address
				if (item.Person.address) {
					var street = item.Person.address.line.value.toString();
					if (street)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.1&apos;] = street;
					
					var city = ((item.Person.address.city) ? item.Person.address.city.value.toString() : &quot;&quot;);
					if (city)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.3&apos;] = city;	
					
					var state = ((item.Person.address.state) ? item.Person.address.state.value.toString() : &quot;&quot;);
					if (state)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.4&apos;] = state;
				
					var postal = ((item.Person.address.postalCode) ? item.Person.address.postalCode.value.toString() : &quot;&quot;);
					if (postal)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.5&apos;] = postal;
				
					var country = ((item.Person.address.country) ? item.Person.address.country.value.toString() : &quot;&quot;);
					if (country)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.6&apos;] = country;
						
					// There might be a better definition what is required &quot;insured’s Address&quot;.
					hasPersonAddress = (street || city || state || postal);	
				}
			}
		});

	} else {
		// When only contained  insurance company is present
		processInsuranceOrganization(segIns, obj.resource.Coverage.contained);
	}

	// Insured&apos;s Group Employer Name 
	if (obj.resource.Coverage.extension) {
		var emplName = ((obj.resource.Coverage.extension.valueIdentifier) ? obj.resource.Coverage.extension.valueIdentifier.value.value.toString() : &quot;&quot;);
		if (emplName)
			segIns[&apos;IN1.11&apos;] = emplName;
	}


	// Group Number
	var groupNumber = ((obj.resource.Coverage.group) ? obj.resource.Coverage.group.value.toString() : &quot;&quot;);
	if (groupNumber)
		segIns[&apos;IN1.8&apos;] = groupNumber;



	

	// Name Of Insured
	// (SN) March 11, 2017: Fix to downgrade to DSTU3 Coverage resource. Previously checked only planholderReference.
/*	
	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
*/

	// Name Of Insured
	// (SN) March 13 2017: Disabled
	//var insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();

	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
	
	if (insuredRef == &quot;Patient/PID-patient-identification&quot;) {
		// Same as the PID segment
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString();
		
	} else if (insuredRef == &quot;Person/insured-person&quot;) {
		// Taken from the contained Person resource
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = nameParts.family;
		if (nameParts.given1.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = nameParts.given1;
		if (nameParts.given2.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = nameParts.given2;		
	}

	// Insured&apos;s Relationship To Patient
	if ( obj.resource.Coverage.relationship) {
		var relationship = ((obj.resource.Coverage.relationship.code) ? obj.resource.Coverage.relationship.code.value.toString() : &quot;&quot;);
		if (relationship)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;] = relationship;
		
		var relationshipDesc = ((obj.resource.Coverage.relationship.display) ? obj.resource.Coverage.relationship.display.value.toString() : &quot;&quot;);
		if (relationshipDesc)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.2&apos;] = relationshipDesc;
	}

	// Company Plan Code
	var planCode = (( obj.resource.Coverage.subPlan) ? obj.resource.Coverage.subPlan.value.toString() : &quot;&quot;);
	if (planCode)
		segIns[&apos;IN1.35&apos;] = planCode;

	// Policy Number
	var policyNumber = ((obj.resource.Coverage.plan) ? obj.resource.Coverage.plan.value.toString() : &quot;&quot;);
	if (policyNumber)
		segIns[&apos;IN1.36&apos;] = policyNumber;

	// Coverage Type
	segIns[&apos;IN1.47&apos;] = channelMap.get(&quot;CoverageType&quot;);


	if (coverage == &quot;T&quot;) {
		if (segIns[&apos;IN1.4&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Organization.name for IN1.4[Insurance Company Name] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.8&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.group for IN1.8[Group Number] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Person.name for IN1.16[Name Of Insured] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.relationship.code for IN1.17[Insured Relationship To Patient] is required if IN1.47[Coverage Type] is T&quot;);
		if (isContainedPerson &amp;&amp; !hasPersonAddress) error.push(&quot;resource.Coverage.contained.Person.address for IN1.19[Insured Address] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.36&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.plan for IN1.36[Policy Number] is required if IN1.47[Coverage Type] is T&quot;);		
	}


	// Store the segment to be later compiled into a message
	coverageMap.put(coverageType, segIns.toString());

	return;
}


/**
	Populates IN1.3 [Insurance Company ID] field with data from the contained Organization resource
	@param {Object} obj - Organization object resource
	@return - nothing, uses global HL7v2 message object
*/
function processInsuranceOrganization(segIns, item) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;

	if (item.Organization != null &amp;&amp; item.Organization != undefined) {

		isContainedOrganization = true;
		
		// Insurance Company ID
		var companyID = ((item.Organization.identifier) ? item.Organization.identifier.value.value.toString() : &quot;&quot;);
		if (companyID) 
			segIns[&apos;IN1.3&apos;] = companyID;
	
		// Insurance Company Name
		var companyName = ((item.Organization.name) ? item.Organization.name.value.toString() : &quot;&quot;);
		if (companyName)
			segIns[&apos;IN1.4&apos;] = companyName;

		// Insurance Company Address
		if (item.Organization.address) {
			var street = ((item.Organization.address.line) ? item.Organization.address.line.value.toString() : &quot;&quot;);
			if (street)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.1&apos;] = street;
				
			var city = ((item.Organization.address.city) ? item.Organization.address.city.value.toString() : &quot;&quot;);
			if (city)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.3&apos;] = city;
			
			var state = ((item.Organization.address.state) ? item.Organization.address.state.value.toString() : &quot;&quot;);
			if (state)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.4&apos;] = state;
		
			var postal = ((item.Organization.address.postalCode) ? item.Organization.address.postalCode.value.toString() : &quot;&quot;);
			if (postal)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.5&apos;] = postal;
		
			var country = ((item.Organization.address.country) ? item.Organization.address.country.value.toString() : &quot;&quot;);
			if (country)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.6&apos;] = country;

			// There might be a better definition what is required &quot;Insurance Company Address&quot;
			hasOrganizationAddress = (street || city || state || postal);						
		}		

		// Insurance Co Phone Number
		var phone = ((item.Organization.telecom) ? item.Organization.telecom.value.value.toString() : &quot;&quot;);
		if (phone) {
			hasPhone = true;
			segIns[&apos;IN1.7&apos;] = convertPhoneXTN(phone);
		}
	}

	// Validate conditional fields
	if (coverage == &quot;T&quot;) {		
		if (isContainedOrganization &amp;&amp; !hasOrganizationAddress) error.push(&quot;resource.Coverage.contained.Organization.address for IN1.5[Insurance Company Address] is required if IN1.47[Coverage Type] is T&quot;);
	}


	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>5</sequenceNumber>
                <name>GT1 segment</name>
                <script>/**
	Creates and populates GT1 [Guarantor] segment from the Person resource
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processGuarantor(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var gt1 = &lt;GT1&gt;
				&lt;GT1.1&gt;&lt;GT1.1.1&gt;1&lt;/GT1.1.1&gt;&lt;/GT1.1&gt;
				&lt;GT1.2/&gt;
				&lt;GT1.3&gt;&lt;GT1.3.1/&gt;&lt;GT1.3.2/&gt;&lt;/GT1.3&gt;
			&lt;/GT1&gt;;

	// Parse guarantor&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Person.name, true);
	gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;] = nameParts.family;
	if (nameParts.given1.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.2&apos;] = nameParts.given1;
	if (nameParts.given2.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.3&apos;] = nameParts.given2;	


	// Guarantor Address
	if (obj.resource.Person.address) {
		var street = ((obj.resource.Person.address.line) ? obj.resource.Person.address.line.value.toString() : &quot;&quot;);
		if (street)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.1&apos;] = street;
		
		var city = ((obj.resource.Person.address.city) ? obj.resource.Person.address.city.value.toString() : &quot;&quot;);
		if (city)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.3&apos;] = city;	
		
		var state = ((obj.resource.Person.address.state) ? obj.resource.Person.address.state.value.toString() : &quot;&quot;);
		if (state)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.4&apos;] = state;
	
		var postal = ((obj.resource.Person.address.postalCode) ? obj.resource.Person.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.5&apos;] = postal;
	
		var country = ((obj.resource.Person.address.country) ? obj.resource.Person.address.country.value.toString() : &quot;&quot;);
		if (country)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.6&apos;] = country;

		// There might be a better definition what is required &quot;guarantor address&quot;.
		hasAddress = (street || city || state || postal);			
	}


	// Guarantor Phon Number - Home
	var phone = ((obj.resource.Person.telecom) ? obj.resource.Person.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		gt1[&apos;GT1.6&apos;] = convertPhoneXTN(phone);
	}


	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Person.name for GT1.3[Guarantor Name] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasAddress) error.push(&quot;resource.Person.address for GT1.5[Guarantor Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Person.telecom for GT1.6[Guarantor Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);		
	}

	// Store the segment to be later compiled into a message
	guarantorMap.put(1, gt1.toString());

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates and populates GT1 [Guarantor] segment from the Person resource
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processGuarantor(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var gt1 = &lt;GT1&gt;
				&lt;GT1.1&gt;&lt;GT1.1.1&gt;1&lt;/GT1.1.1&gt;&lt;/GT1.1&gt;
				&lt;GT1.2/&gt;
				&lt;GT1.3&gt;&lt;GT1.3.1/&gt;&lt;GT1.3.2/&gt;&lt;/GT1.3&gt;
			&lt;/GT1&gt;;

	// Parse guarantor&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Person.name, true);
	gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;] = nameParts.family;
	if (nameParts.given1.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.2&apos;] = nameParts.given1;
	if (nameParts.given2.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.3&apos;] = nameParts.given2;	


	// Guarantor Address
	if (obj.resource.Person.address) {
		var street = ((obj.resource.Person.address.line) ? obj.resource.Person.address.line.value.toString() : &quot;&quot;);
		if (street)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.1&apos;] = street;
		
		var city = ((obj.resource.Person.address.city) ? obj.resource.Person.address.city.value.toString() : &quot;&quot;);
		if (city)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.3&apos;] = city;	
		
		var state = ((obj.resource.Person.address.state) ? obj.resource.Person.address.state.value.toString() : &quot;&quot;);
		if (state)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.4&apos;] = state;
	
		var postal = ((obj.resource.Person.address.postalCode) ? obj.resource.Person.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.5&apos;] = postal;
	
		var country = ((obj.resource.Person.address.country) ? obj.resource.Person.address.country.value.toString() : &quot;&quot;);
		if (country)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.6&apos;] = country;

		// There might be a better definition what is required &quot;guarantor address&quot;.
		hasAddress = (street || city || state || postal);			
	}


	// Guarantor Phon Number - Home
	var phone = ((obj.resource.Person.telecom) ? obj.resource.Person.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		gt1[&apos;GT1.6&apos;] = convertPhoneXTN(phone);
	}


	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Person.name for GT1.3[Guarantor Name] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasAddress) error.push(&quot;resource.Person.address for GT1.5[Guarantor Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Person.telecom for GT1.6[Guarantor Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);		
	}

	// Store the segment to be later compiled into a message
	guarantorMap.put(1, gt1.toString());

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>6</sequenceNumber>
                <name>ORC segment</name>
                <script>/**
	Populates ORC [Common Order] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticReport object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCommonOrder(obj) {


	var orc = &lt;ORC&gt;&lt;ORC.1&gt;&lt;ORC.1.1&gt;NW&lt;/ORC.1.1&gt;&lt;/ORC.1&gt;&lt;/ORC&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticReport.id) ? obj.resource.DiagnosticReport.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);

	logger.error( &quot;Group Count: &quot; + groupCount );
	logger.error( &quot;Group ID: &quot; + groupID );
			
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticReport.id element is undefined or not properly formatted, expected: ORC-common-order-n, where n identifies the order group&quot;);
	}


	// Placer Order Number
	// The value in ORC.02.01 (Entity Identifier) is the same as the value in OBR.02.01 (Entity Identifier)
	// All values for this field in all ORC and OBR segments are identical.
	// March 12: Moved into DiagnosticReport.identifier verified block 
	//var id = obj.resource.DiagnosticReport.identifier.value.value.toString();
	//if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;

	if (obj.resource.DiagnosticReport.identifier) {

		var id = ((obj.resource.DiagnosticReport.identifier.value.value) ? obj.resource.DiagnosticReport.identifier.value.value.toString():&quot;&quot;);
		if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;
		
		var namespaceID = ((obj.resource.DiagnosticReport.identifier.system) ? obj.resource.DiagnosticReport.identifier.system.value.toString() : &quot;&quot;);
		if (namespaceID) orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;] = namespaceID;
	
		var universalID = ((obj.resource.DiagnosticReport.identifier.type) ? obj.resource.DiagnosticReport.identifier.type.id.toString() : &quot;&quot;);
		if (universalID) orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;] = universalID;
	}
	else
	{
		logger.error( &quot;Missing identifier in in Diagnostic Report:&quot; + groupID )
	}


	// Store the Placer Order Number for the OBR segment
	var diagnosticOrderID = ((obj.resource.DiagnosticReport.request) ? obj.resource.DiagnosticReport.request.reference.value.toString() : &quot;&quot;);
	if (diagnosticOrderID.indexOf(&quot;DiagnosticOrder/&quot;) &gt; -1) {
		diagnosticOrderID = diagnosticOrderID.substring(&quot;DiagnosticOrder/&quot;.length, diagnosticOrderID.length);
		
		var placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};

		placedOrderNumber.id = orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;].toString();
		placedOrderNumber.namespaceID = orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;].toString();
		placedOrderNumber.universalID = orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;].toString();
		placedOrderNumberMap.put(diagnosticOrderID, placedOrderNumber);		
	}
	else
	{
		logger.error( &quot;No Diagnostic Order Found&quot; );
	}


	// Verified By Practitioner
	if (obj.resource.DiagnosticReport.contained != null &amp;&amp; obj.resource.DiagnosticReport.contained != undefined) {
		var verifiedByID = obj.resource.DiagnosticReport.contained.Practitioner.identifier.value.value.toString();
		if (verifiedByID)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.1&apos;] = verifiedByID;
			
		var familyName = ((obj.resource.DiagnosticReport.contained.Practitioner.name) ? obj.resource.DiagnosticReport.contained.Practitioner.name.family.value.toString() : &quot;&quot;);
		if (familyName)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.2&apos;] = familyName;		
	}

	// Process extension for TQ1 [Timing/Quantity] segment
	if (obj.resource.DiagnosticReport.extension.valueTiming != null &amp;&amp; obj.resource.DiagnosticReport.extension.valueTiming != undefined) {
		processTimingQuantity(groupCount, obj.resource.DiagnosticReport.extension.valueTiming);
	}

	// Process zero or many DiagnosticReport/codedDiagnosis elements for DG1 [Diagnosis] segment
	var conditions = [];
	if (obj.resource.DiagnosticReport.codedDiagnosis) {

		if (obj.resource.DiagnosticReport.codedDiagnosis.length &gt; 0) {
			var setID = 1;
			obj.resource.DiagnosticReport.codedDiagnosis.forEach(function(item){
				// A maximum of 12 unique ICD-10 codes are permitted per entire OML message
				// (SN) This code checks only codedDiagnosis in a single DiagnosticReport
				if (setID &lt;= 12) conditions.push(processCondition(item, setID++));				 
			});
		} else {
			conditions.push(processCondition(obj.resource.DiagnosticReport.codedDiagnosis, 1)); 
		}
	}

	// Process zero or many result/reference elements for OBX [Observation] segment
	var observationReferences = [];
	if (obj.resource.DiagnosticReport.result) {
		var ref;
		if (obj.resource.DiagnosticReport.result.length &gt; 0) {
			obj.resource.DiagnosticReport.result.forEach(function(item){
				ref = item.reference.value.toString();
				if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
			});
		} else {
			ref = ((obj.resource.DiagnosticReport.result.reference != undefined) ? obj.resource.DiagnosticReport.result.reference.value.toString() : &quot;&quot;);
			if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
		}		
	}


	// ORC.12 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticReport.performer != undefined) ? obj.resource.DiagnosticReport.performer.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(&quot;Practitioner/&quot;.length, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) orc[&apos;ORC.12&apos;][&apos;ORC.12.1&apos;] = id;
	
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) orc[&apos;ORC.12&apos;][&apos;ORC.12.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			orc[&apos;ORC.12&apos;][&apos;ORC.12.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.4&apos;] = nameParts.given2;				
		}
	}
	

	// Store the segment to be later compiled into a message
	commonOrderMap.put(groupCount.toString(), orc.toString());

	// Store the array of diagnosis to be later compiled into a message
	if (conditions.length &gt; 0) diagnosisMap.put(groupCount.toString(), conditions);

	// Store the array of Observations to be later compiled into a message
	if (observationReferences.length &gt; 0) observationReferencesMap.put(groupCount.toString(), observationReferences);


	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates ORC [Common Order] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticReport object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCommonOrder(obj) {


	var orc = &lt;ORC&gt;&lt;ORC.1&gt;&lt;ORC.1.1&gt;NW&lt;/ORC.1.1&gt;&lt;/ORC.1&gt;&lt;/ORC&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticReport.id) ? obj.resource.DiagnosticReport.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);

	logger.error( &quot;Group Count: &quot; + groupCount );
	logger.error( &quot;Group ID: &quot; + groupID );
			
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticReport.id element is undefined or not properly formatted, expected: ORC-common-order-n, where n identifies the order group&quot;);
	}


	// Placer Order Number
	// The value in ORC.02.01 (Entity Identifier) is the same as the value in OBR.02.01 (Entity Identifier)
	// All values for this field in all ORC and OBR segments are identical.
	// March 12: Moved into DiagnosticReport.identifier verified block 
	//var id = obj.resource.DiagnosticReport.identifier.value.value.toString();
	//if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;

	if (obj.resource.DiagnosticReport.identifier) {

		var id = ((obj.resource.DiagnosticReport.identifier.value.value) ? obj.resource.DiagnosticReport.identifier.value.value.toString():&quot;&quot;);
		if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;
		
		var namespaceID = ((obj.resource.DiagnosticReport.identifier.system) ? obj.resource.DiagnosticReport.identifier.system.value.toString() : &quot;&quot;);
		if (namespaceID) orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;] = namespaceID;
	
		var universalID = ((obj.resource.DiagnosticReport.identifier.type) ? obj.resource.DiagnosticReport.identifier.type.id.toString() : &quot;&quot;);
		if (universalID) orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;] = universalID;
	}
	else
	{
		logger.error( &quot;Missing identifier in in Diagnostic Report:&quot; + groupID )
	}


	// Store the Placer Order Number for the OBR segment
	var diagnosticOrderID = ((obj.resource.DiagnosticReport.request) ? obj.resource.DiagnosticReport.request.reference.value.toString() : &quot;&quot;);
	if (diagnosticOrderID.indexOf(&quot;DiagnosticOrder/&quot;) &gt; -1) {
		diagnosticOrderID = diagnosticOrderID.substring(&quot;DiagnosticOrder/&quot;.length, diagnosticOrderID.length);
		
		var placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};

		placedOrderNumber.id = orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;].toString();
		placedOrderNumber.namespaceID = orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;].toString();
		placedOrderNumber.universalID = orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;].toString();
		placedOrderNumberMap.put(diagnosticOrderID, placedOrderNumber);		
	}
	else
	{
		logger.error( &quot;No Diagnostic Order Found&quot; );
	}


	// Verified By Practitioner
	if (obj.resource.DiagnosticReport.contained != null &amp;&amp; obj.resource.DiagnosticReport.contained != undefined) {
		var verifiedByID = obj.resource.DiagnosticReport.contained.Practitioner.identifier.value.value.toString();
		if (verifiedByID)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.1&apos;] = verifiedByID;
			
		var familyName = ((obj.resource.DiagnosticReport.contained.Practitioner.name) ? obj.resource.DiagnosticReport.contained.Practitioner.name.family.value.toString() : &quot;&quot;);
		if (familyName)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.2&apos;] = familyName;		
	}

	// Process extension for TQ1 [Timing/Quantity] segment
	if (obj.resource.DiagnosticReport.extension.valueTiming != null &amp;&amp; obj.resource.DiagnosticReport.extension.valueTiming != undefined) {
		processTimingQuantity(groupCount, obj.resource.DiagnosticReport.extension.valueTiming);
	}

	// Process zero or many DiagnosticReport/codedDiagnosis elements for DG1 [Diagnosis] segment
	var conditions = [];
	if (obj.resource.DiagnosticReport.codedDiagnosis) {

		if (obj.resource.DiagnosticReport.codedDiagnosis.length &gt; 0) {
			var setID = 1;
			obj.resource.DiagnosticReport.codedDiagnosis.forEach(function(item){
				// A maximum of 12 unique ICD-10 codes are permitted per entire OML message
				// (SN) This code checks only codedDiagnosis in a single DiagnosticReport
				if (setID &lt;= 12) conditions.push(processCondition(item, setID++));				 
			});
		} else {
			conditions.push(processCondition(obj.resource.DiagnosticReport.codedDiagnosis, 1)); 
		}
	}

	// Process zero or many result/reference elements for OBX [Observation] segment
	var observationReferences = [];
	if (obj.resource.DiagnosticReport.result) {
		var ref;
		if (obj.resource.DiagnosticReport.result.length &gt; 0) {
			obj.resource.DiagnosticReport.result.forEach(function(item){
				ref = item.reference.value.toString();
				if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
			});
		} else {
			ref = ((obj.resource.DiagnosticReport.result.reference != undefined) ? obj.resource.DiagnosticReport.result.reference.value.toString() : &quot;&quot;);
			if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
		}		
	}


	// ORC.12 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticReport.performer != undefined) ? obj.resource.DiagnosticReport.performer.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(&quot;Practitioner/&quot;.length, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) orc[&apos;ORC.12&apos;][&apos;ORC.12.1&apos;] = id;
	
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) orc[&apos;ORC.12&apos;][&apos;ORC.12.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			orc[&apos;ORC.12&apos;][&apos;ORC.12.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.4&apos;] = nameParts.given2;				
		}
	}
	

	// Store the segment to be later compiled into a message
	commonOrderMap.put(groupCount.toString(), orc.toString());

	// Store the array of diagnosis to be later compiled into a message
	if (conditions.length &gt; 0) diagnosisMap.put(groupCount.toString(), conditions);

	// Store the array of Observations to be later compiled into a message
	if (observationReferences.length &gt; 0) observationReferencesMap.put(groupCount.toString(), observationReferences);


	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>7</sequenceNumber>
                <name>TQ1 segment</name>
                <script>/**
	Populates TQ1 [Timing/Quantity] segment with data from the DiagnosticReport extension
	@param {Integer} count - Common Order group count
	@param {Object} valueTiming - valueTiming extension
	@return - nothing, uses global map
*/
function processTimingQuantity(count, valueTiming) {
	
	// TQ1 [Timing/Quantity] segment
	if (valueTiming != null &amp;&amp; valueTiming != undefined) {

		var tq1 = &lt;TQ1&gt;&lt;TQ1.1&gt;&lt;TQ1.1.1&gt;1&lt;/TQ1.1.1&gt;&lt;/TQ1.1&gt;&lt;/TQ1&gt;;

		tq1[&apos;TQ1.1&apos;][&apos;TQ1.1.1&apos;] = count;
			
		var startDateTime = ((valueTiming.event) ? valueTiming.event.value.toString() : &quot;&quot;);
		if (startDateTime)
			tq1[&apos;TQ1.7&apos;] = convertJSONDateTime(startDateTime);

		var priorityCode = ((valueTiming.code) ? valueTiming.code.coding.code.value.toString() : &quot;&quot;);
		if (priorityCode)
			tq1[&apos;TQ1.9&apos;][&apos;TQ1.9.1&apos;] = priorityCode;
	}

	// Store the segment to be later compiled into a message
	timingQuantityMap.put(count.toString(), tq1.toString());

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates TQ1 [Timing/Quantity] segment with data from the DiagnosticReport extension
	@param {Integer} count - Common Order group count
	@param {Object} valueTiming - valueTiming extension
	@return - nothing, uses global map
*/
function processTimingQuantity(count, valueTiming) {
	
	// TQ1 [Timing/Quantity] segment
	if (valueTiming != null &amp;&amp; valueTiming != undefined) {

		var tq1 = &lt;TQ1&gt;&lt;TQ1.1&gt;&lt;TQ1.1.1&gt;1&lt;/TQ1.1.1&gt;&lt;/TQ1.1&gt;&lt;/TQ1&gt;;

		tq1[&apos;TQ1.1&apos;][&apos;TQ1.1.1&apos;] = count;
			
		var startDateTime = ((valueTiming.event) ? valueTiming.event.value.toString() : &quot;&quot;);
		if (startDateTime)
			tq1[&apos;TQ1.7&apos;] = convertJSONDateTime(startDateTime);

		var priorityCode = ((valueTiming.code) ? valueTiming.code.coding.code.value.toString() : &quot;&quot;);
		if (priorityCode)
			tq1[&apos;TQ1.9&apos;][&apos;TQ1.9.1&apos;] = priorityCode;
	}

	// Store the segment to be later compiled into a message
	timingQuantityMap.put(count.toString(), tq1.toString());

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>8</sequenceNumber>
                <name>OBR segment</name>
                <script>/**
	Populates OBR [Observation Request] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticOrder object resource
	@return - nothing, uses global HL7v2 message object
*/
function processObservationRequest(obj) {

	var comments = [];

	var obr = &lt;OBR&gt;&lt;OBR.1&gt;&lt;OBR.1.1&gt;1&lt;/OBR.1.1&gt;&lt;/OBR.1&gt;
				&lt;OBR.2/&gt;&lt;OBR.3/&gt;
				&lt;OBR.4&gt;&lt;OBR.4.1/&gt;&lt;OBR.4.2/&gt;&lt;OBR.4.3/&gt;&lt;OBR.4.4/&gt;&lt;OBR.4.5/&gt;&lt;/OBR.4&gt;
				&lt;OBR.5/&gt;&lt;OBR.6/&gt;&lt;OBR.7/&gt;&lt;OBR.8/&gt;&lt;OBR.9/&gt;
				&lt;OBR.10/&gt;&lt;OBR.11/&gt;&lt;OBR.12/&gt;&lt;OBR.13/&gt;&lt;OBR.14/&gt;&lt;OBR.15/&gt;
				&lt;OBR.16&gt;&lt;OBR.16.1/&gt;&lt;OBR.16.2/&gt;&lt;OBR.16.3/&gt;&lt;OBR.16.4/&gt;&lt;OBR.16.5/&gt;&lt;OBR.16.6/&gt;&lt;OBR.16.7/&gt;&lt;OBR.16.8/&gt;&lt;/OBR.16&gt;
			&lt;/OBR&gt;;


	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticOrder.id) ? obj.resource.DiagnosticOrder.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);
		
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticOrder.id element is undefined or not properly formatted, expected: OBR-observation-request-n, where n identifies the order group&quot;);
	}


	// OBR.2 [Placer Order Number] is stored during the DiagnosticReport resource processing	
	var resourceID = obj.resource.DiagnosticOrder.id.value.toString();
	// Extracts the following object - placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};
	var placedOrderNumber = placedOrderNumberMap.get(resourceID);
	if (placedOrderNumber) {
		if (placedOrderNumber.id) obr[&apos;OBR.2&apos;][&apos;OBR.2.1&apos;] = placedOrderNumber.id.toString();
		if (placedOrderNumber.namespaceID) obr[&apos;OBR.2&apos;][&apos;OBR.2.2&apos;] = placedOrderNumber.namespaceID.toString();
		if (placedOrderNumber.universalID) obr[&apos;OBR.2&apos;][&apos;OBR.2.3&apos;] = placedOrderNumber.universalID.toString();
	}
	

	// Universal Service Identifier	
	var alternateID = obj.resource.DiagnosticOrder.item.code.coding.code.value.toString();
	if (alternateID)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.4&apos;] = alternateID;

	var alternateText = obj.resource.DiagnosticOrder.item.code.coding.display.value.toString();
	if (alternateText)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.5&apos;] = alternateText;

	// Observation Date/Time	
	var observationDateTime = obj.resource.DiagnosticOrder.event.dateTime.value.toString();
	if (observationDateTime) {
		// Format : yyyymmddhhmm
		var specimenCollectionDate = convertJSONDateTime(observationDateTime);
		obr[&apos;OBR.7&apos;] = specimenCollectionDate.substring(0, 12);
	}

	// Specimen Action Code
	var actionCode = ((obj.resource.DiagnosticOrder.item.specimen) ? obj.resource.DiagnosticOrder.item.specimen.display.value.toString() : &quot;&quot;);
	if (actionCode)
		obr[&apos;OBR.11&apos;] = actionCode;

	// OBR.16 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticOrder.event.actor.reference != undefined) ? obj.resource.DiagnosticOrder.event.actor.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(13, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) obr[&apos;OBR.16&apos;][&apos;OBR.16.1&apos;] = id;
				
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) obr[&apos;OBR.16&apos;][&apos;OBR.16.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			obr[&apos;OBR.16&apos;][&apos;OBR.16.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.4&apos;] = nameParts.given2;			
		}
	}

	// Store the segment to be later compiled into a message
	observationRequestMap.put(groupCount.toString(), obr.toString());




	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.DiagnosticOrder.text &amp;&amp; obj.resource.DiagnosticOrder.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.DiagnosticOrder.text.div.p.length &amp;&amp; obj.resource.DiagnosticOrder.text.div.p.length &gt; 0) {
			obj.resource.DiagnosticOrder.text.div.p.forEach(function(item){
				// For internal (I) and report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
						
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
						// If the comment is other than internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.DiagnosticOrder.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.DiagnosticOrder.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.DiagnosticOrder.text.div.p, countNTE++));			
		}

		// Store the comments array to be later compiled into a message
		observationRequestCommentsMap.put(groupCount.toString(), comments);

	}


	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates OBR [Observation Request] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticOrder object resource
	@return - nothing, uses global HL7v2 message object
*/
function processObservationRequest(obj) {

	var comments = [];

	var obr = &lt;OBR&gt;&lt;OBR.1&gt;&lt;OBR.1.1&gt;1&lt;/OBR.1.1&gt;&lt;/OBR.1&gt;
				&lt;OBR.2/&gt;&lt;OBR.3/&gt;
				&lt;OBR.4&gt;&lt;OBR.4.1/&gt;&lt;OBR.4.2/&gt;&lt;OBR.4.3/&gt;&lt;OBR.4.4/&gt;&lt;OBR.4.5/&gt;&lt;/OBR.4&gt;
				&lt;OBR.5/&gt;&lt;OBR.6/&gt;&lt;OBR.7/&gt;&lt;OBR.8/&gt;&lt;OBR.9/&gt;
				&lt;OBR.10/&gt;&lt;OBR.11/&gt;&lt;OBR.12/&gt;&lt;OBR.13/&gt;&lt;OBR.14/&gt;&lt;OBR.15/&gt;
				&lt;OBR.16&gt;&lt;OBR.16.1/&gt;&lt;OBR.16.2/&gt;&lt;OBR.16.3/&gt;&lt;OBR.16.4/&gt;&lt;OBR.16.5/&gt;&lt;OBR.16.6/&gt;&lt;OBR.16.7/&gt;&lt;OBR.16.8/&gt;&lt;/OBR.16&gt;
			&lt;/OBR&gt;;


	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticOrder.id) ? obj.resource.DiagnosticOrder.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);
		
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticOrder.id element is undefined or not properly formatted, expected: OBR-observation-request-n, where n identifies the order group&quot;);
	}


	// OBR.2 [Placer Order Number] is stored during the DiagnosticReport resource processing	
	var resourceID = obj.resource.DiagnosticOrder.id.value.toString();
	// Extracts the following object - placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};
	var placedOrderNumber = placedOrderNumberMap.get(resourceID);
	if (placedOrderNumber) {
		if (placedOrderNumber.id) obr[&apos;OBR.2&apos;][&apos;OBR.2.1&apos;] = placedOrderNumber.id.toString();
		if (placedOrderNumber.namespaceID) obr[&apos;OBR.2&apos;][&apos;OBR.2.2&apos;] = placedOrderNumber.namespaceID.toString();
		if (placedOrderNumber.universalID) obr[&apos;OBR.2&apos;][&apos;OBR.2.3&apos;] = placedOrderNumber.universalID.toString();
	}
	

	// Universal Service Identifier	
	var alternateID = obj.resource.DiagnosticOrder.item.code.coding.code.value.toString();
	if (alternateID)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.4&apos;] = alternateID;

	var alternateText = obj.resource.DiagnosticOrder.item.code.coding.display.value.toString();
	if (alternateText)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.5&apos;] = alternateText;

	// Observation Date/Time	
	var observationDateTime = obj.resource.DiagnosticOrder.event.dateTime.value.toString();
	if (observationDateTime) {
		// Format : yyyymmddhhmm
		var specimenCollectionDate = convertJSONDateTime(observationDateTime);
		obr[&apos;OBR.7&apos;] = specimenCollectionDate.substring(0, 12);
	}

	// Specimen Action Code
	var actionCode = ((obj.resource.DiagnosticOrder.item.specimen) ? obj.resource.DiagnosticOrder.item.specimen.display.value.toString() : &quot;&quot;);
	if (actionCode)
		obr[&apos;OBR.11&apos;] = actionCode;

	// OBR.16 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticOrder.event.actor.reference != undefined) ? obj.resource.DiagnosticOrder.event.actor.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(13, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) obr[&apos;OBR.16&apos;][&apos;OBR.16.1&apos;] = id;
				
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) obr[&apos;OBR.16&apos;][&apos;OBR.16.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			obr[&apos;OBR.16&apos;][&apos;OBR.16.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.4&apos;] = nameParts.given2;			
		}
	}

	// Store the segment to be later compiled into a message
	observationRequestMap.put(groupCount.toString(), obr.toString());




	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.DiagnosticOrder.text &amp;&amp; obj.resource.DiagnosticOrder.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.DiagnosticOrder.text.div.p.length &amp;&amp; obj.resource.DiagnosticOrder.text.div.p.length &gt; 0) {
			obj.resource.DiagnosticOrder.text.div.p.forEach(function(item){
				// For internal (I) and report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
						
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
						// If the comment is other than internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.DiagnosticOrder.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.DiagnosticOrder.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.DiagnosticOrder.text.div.p, countNTE++));			
		}

		// Store the comments array to be later compiled into a message
		observationRequestCommentsMap.put(groupCount.toString(), comments);

	}


	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>9</sequenceNumber>
                <name>DG1 segment</name>
                <script>/**
	Populates DG1 [Diagnosis] segment from the Condition resource
	@param {Object} obj - Condition object resource
	@return {String} dg1 - DG1 segment serialized to string
*/
function processCondition(obj, setID) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);

	var dg1 = &lt;DG1&gt;
				&lt;DG1.1&gt;&lt;DG1.1.1&gt;1&lt;/DG1.1.1&gt;&lt;/DG1.1&gt;
				&lt;DG1.3&gt;&lt;DG1.3.1/&gt;&lt;DG1.3.2/&gt;&lt;DG1.3.3/&gt;&lt;DG1.3.4/&gt;&lt;/DG1.3&gt;
				&lt;DG1.6&gt;&lt;DG1.6.1&gt;F&lt;/DG1.6.1&gt;&lt;/DG1.6&gt;
			&lt;/DG1&gt;;

	dg1[&apos;DG1.1&apos;][&apos;DG1.1.1&apos;] = setID;

	// Diagnosis Code
	if (obj.coding) {
		if (obj.coding.length &gt; 0) {
			obj.coding.forEach(function(item){
	
				var code = ((item.code) ? item.code.value.toString() : &quot;&quot;);
				var system = item.system.value.toString().toLowerCase();
			
				if (system)
					if (system.indexOf(&quot;icd-10&quot;) &gt; -1) {
	
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
	
					var text = ((item.display) ? item.display.value.toString() : &quot;&quot;);
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
									
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
				} else {
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;] = code;
				}
			});
		} else {
			var code = ((obj.coding.code) ? obj.coding.code.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
			var text = ((obj.coding.display) ? obj.coding.display.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
		}
	}

	
	// DG1.6 [Diagnosis Type] - hard-coded, required by HL7v2.5.1, F - Final
	//dg1[&apos;DG1.6&apos;][&apos;DG1.6.1&apos;] = &quot;F&quot;;

	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;].toString() == &quot;&quot;) 
			error.push(&quot;resource.Condition.code for DG1.3[Diagnosis Code] is required if IN1.47[Coverage Type] is P or T&quot;);
	}

	return dg1.toString();
	
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates DG1 [Diagnosis] segment from the Condition resource
	@param {Object} obj - Condition object resource
	@return {String} dg1 - DG1 segment serialized to string
*/
function processCondition(obj, setID) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);

	var dg1 = &lt;DG1&gt;
				&lt;DG1.1&gt;&lt;DG1.1.1&gt;1&lt;/DG1.1.1&gt;&lt;/DG1.1&gt;
				&lt;DG1.3&gt;&lt;DG1.3.1/&gt;&lt;DG1.3.2/&gt;&lt;DG1.3.3/&gt;&lt;DG1.3.4/&gt;&lt;/DG1.3&gt;
				&lt;DG1.6&gt;&lt;DG1.6.1&gt;F&lt;/DG1.6.1&gt;&lt;/DG1.6&gt;
			&lt;/DG1&gt;;

	dg1[&apos;DG1.1&apos;][&apos;DG1.1.1&apos;] = setID;

	// Diagnosis Code
	if (obj.coding) {
		if (obj.coding.length &gt; 0) {
			obj.coding.forEach(function(item){
	
				var code = ((item.code) ? item.code.value.toString() : &quot;&quot;);
				var system = item.system.value.toString().toLowerCase();
			
				if (system)
					if (system.indexOf(&quot;icd-10&quot;) &gt; -1) {
	
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
	
					var text = ((item.display) ? item.display.value.toString() : &quot;&quot;);
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
									
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
				} else {
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;] = code;
				}
			});
		} else {
			var code = ((obj.coding.code) ? obj.coding.code.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
			var text = ((obj.coding.display) ? obj.coding.display.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
		}
	}

	
	// DG1.6 [Diagnosis Type] - hard-coded, required by HL7v2.5.1, F - Final
	//dg1[&apos;DG1.6&apos;][&apos;DG1.6.1&apos;] = &quot;F&quot;;

	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;].toString() == &quot;&quot;) 
			error.push(&quot;resource.Condition.code for DG1.3[Diagnosis Code] is required if IN1.47[Coverage Type] is P or T&quot;);
	}

	return dg1.toString();
	
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>10</sequenceNumber>
                <name>OBX segment</name>
                <script>/**
	Populates OBX [Observation/Result] segment from the Observation resource
	@param {Object} obj - Observation object resource
	@return {String} obx - OBX segment serialized to string
*/
function processObservation(obj) {

	var obx =	&lt;OBX&gt;
				&lt;OBX.1&gt;&lt;OBX.1.1/&gt;&lt;/OBX.1&gt;
				&lt;OBX.2&gt;&lt;OBX.2.1/&gt;&lt;/OBX.2&gt;
				&lt;OBX.3&gt;&lt;OBX.3.1/&gt;&lt;OBX.3.2/&gt;&lt;OBX.3.3/&gt;&lt;OBX.3.4/&gt;&lt;OBX.3.5/&gt;&lt;OBX.3.6/&gt;&lt;/OBX.3&gt;
				&lt;OBX.4/&gt;
				&lt;OBX.5&gt;&lt;OBX.5.1/&gt;&lt;/OBX.5&gt;
				&lt;OBX.11&gt;&lt;OBX.11.1&gt;P&lt;/OBX.11.1&gt;&lt;/OBX.11&gt;
			&lt;/OBX&gt;;


	var id = obj.resource.Observation.id.value.toString();
	obx[&apos;OBX.1&apos;][&apos;OBX.1.1&apos;] = id.substring(&quot;OBX-observation-&quot;.length, id.length);

	// Contains a value that reports the results for an AOE
	if (obj.resource.Observation.code) {
		// local code
		var code = obj.resource.Observation.code.coding.code.value.toString();		
		obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;] = code;
		
		// Local description
		var description = obj.resource.Observation.code.coding.display.value.toString();
		obx[&apos;OBX.3&apos;][&apos;OBX.3.5&apos;] = description;

		// Code system - Optional
		if (obj.resource.Observation.code.coding.system != undefined) {
			var codeSystem = obj.resource.Observation.code.coding.system.value.toString();
			if (codeSystem.toLowerCase().indexOf(&quot;snomed&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;SCT&quot;;
			else if (codeSystem.toLowerCase().indexOf(&quot;loinc&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;LN&quot;;
			else 
				delete obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;];
		}
		
	}


	// If valueString is used, expected that the answer is always a string, therefore OBX.2 [Value Type] is hard-coded to &quot;ST&quot;
	if (obj.resource.Observation.valueString) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;ST&quot;;

		var aoe = obj.resource.Observation.valueString.value.toString();
		if (aoe) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = aoe;		

	// If valueQuantity is used the OBX.2 [Value Type] is hard-coded to &quot;NM&quot;	
	} else if (obj.resource.Observation.valueQuantity) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;NM&quot;;		
		var quantity = obj.resource.Observation.valueQuantity.value.value.toString();
		if (quantity) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = quantity;
	}
	

	// Observation Result Status - not required by Quest
	// Hard-coded to &quot;P&quot; - Preliminary


	// OBX level comments (Issue #17)
	var observationComments = [];

	// Iterate over all possible comment entries in /text/div/p  (also see Issue #17)
	if (obj.resource.Observation.text &amp;&amp; obj.resource.Observation.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;,&quot;&quot;]; // Optional source of comment

		if (obj.resource.Observation.text.div.p.length != undefined &amp;&amp; obj.resource.Observation.text.div.p.length &gt; 0) {
			// Several comments from any acceptable sources
			obj.resource.Observation.text.div.p.forEach(function(item){
				if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					observationComments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.Observation.text.div.p) {
			// A single comment from any acceptable source
			if (sourceOfComment.indexOf(obj.resource.Observation.text.div.p.class.toString()) &gt; -1) {
				observationComments.push(getNTESegment(obj.resource.Observation.text.div.p, countNTE++));
			}			
		}
	}

	observationMap.put(id, obx.toString());
	observationCommentsMap.put(id, observationComments);
	
	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates OBX [Observation/Result] segment from the Observation resource
	@param {Object} obj - Observation object resource
	@return {String} obx - OBX segment serialized to string
*/
function processObservation(obj) {

	var obx =	&lt;OBX&gt;
				&lt;OBX.1&gt;&lt;OBX.1.1/&gt;&lt;/OBX.1&gt;
				&lt;OBX.2&gt;&lt;OBX.2.1/&gt;&lt;/OBX.2&gt;
				&lt;OBX.3&gt;&lt;OBX.3.1/&gt;&lt;OBX.3.2/&gt;&lt;OBX.3.3/&gt;&lt;OBX.3.4/&gt;&lt;OBX.3.5/&gt;&lt;OBX.3.6/&gt;&lt;/OBX.3&gt;
				&lt;OBX.4/&gt;
				&lt;OBX.5&gt;&lt;OBX.5.1/&gt;&lt;/OBX.5&gt;
				&lt;OBX.11&gt;&lt;OBX.11.1&gt;P&lt;/OBX.11.1&gt;&lt;/OBX.11&gt;
			&lt;/OBX&gt;;


	var id = obj.resource.Observation.id.value.toString();
	obx[&apos;OBX.1&apos;][&apos;OBX.1.1&apos;] = id.substring(&quot;OBX-observation-&quot;.length, id.length);

	// Contains a value that reports the results for an AOE
	if (obj.resource.Observation.code) {
		// local code
		var code = obj.resource.Observation.code.coding.code.value.toString();		
		obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;] = code;
		
		// Local description
		var description = obj.resource.Observation.code.coding.display.value.toString();
		obx[&apos;OBX.3&apos;][&apos;OBX.3.5&apos;] = description;

		// Code system - Optional
		if (obj.resource.Observation.code.coding.system != undefined) {
			var codeSystem = obj.resource.Observation.code.coding.system.value.toString();
			if (codeSystem.toLowerCase().indexOf(&quot;snomed&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;SCT&quot;;
			else if (codeSystem.toLowerCase().indexOf(&quot;loinc&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;LN&quot;;
			else 
				delete obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;];
		}
		
	}


	// If valueString is used, expected that the answer is always a string, therefore OBX.2 [Value Type] is hard-coded to &quot;ST&quot;
	if (obj.resource.Observation.valueString) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;ST&quot;;

		var aoe = obj.resource.Observation.valueString.value.toString();
		if (aoe) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = aoe;		

	// If valueQuantity is used the OBX.2 [Value Type] is hard-coded to &quot;NM&quot;	
	} else if (obj.resource.Observation.valueQuantity) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;NM&quot;;		
		var quantity = obj.resource.Observation.valueQuantity.value.value.toString();
		if (quantity) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = quantity;
	}
	

	// Observation Result Status - not required by Quest
	// Hard-coded to &quot;P&quot; - Preliminary


	// OBX level comments (Issue #17)
	var observationComments = [];

	// Iterate over all possible comment entries in /text/div/p  (also see Issue #17)
	if (obj.resource.Observation.text &amp;&amp; obj.resource.Observation.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;,&quot;&quot;]; // Optional source of comment

		if (obj.resource.Observation.text.div.p.length != undefined &amp;&amp; obj.resource.Observation.text.div.p.length &gt; 0) {
			// Several comments from any acceptable sources
			obj.resource.Observation.text.div.p.forEach(function(item){
				if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					observationComments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.Observation.text.div.p) {
			// A single comment from any acceptable source
			if (sourceOfComment.indexOf(obj.resource.Observation.text.div.p.class.toString()) &gt; -1) {
				observationComments.push(getNTESegment(obj.resource.Observation.text.div.p, countNTE++));
			}			
		}
	}

	observationMap.put(id, obx.toString());
	observationCommentsMap.put(id, observationComments);
	
	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>11</sequenceNumber>
                <name>Check for issues</name>
                <script>// Use fixHL7NodeOrder() to fix a possible node order issue 
// see http://www.mirthcorp.com/community/issues/browse/MIRTH-625

var messages = {request: &quot;&quot;, resp: &quot;&quot;};
messages.request = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(fixHL7NodeOrder(oml));

channelMap.put(&quot;omlHL7&quot;, messages.request); // testing
channelMap.put(&quot;error&quot;, error); // testing

logger.debug(&quot;SubmitOrder: Destination - &quot; + messages.request);


// Verify for errors 
if (error.length &gt; 0) {

	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));

	// To be sent to original feed submitter
	responseMap.put(&quot;Outcome&quot;, outcome);

	// Nothing to send to DEX
	channelMap.put(&quot;RequestMessage&quot;, null);
	
} else {

	// Temporary save the OML_O21 message for the next destination to process

//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!	
	channelMap.put(&quot;RequestMessage&quot;, null);
	//var info = {severity: &quot;Information&quot;, code: &quot;Information&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	//(AM) operation outcome mapping expects lowercase; code is &apos;informational&apos; not &apos;information&apos;
	var info = {severity: &quot;information&quot;, code: &quot;informational&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	outcome = getOperationOutcome(error, info, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));	
	responseMap.put(&quot;Outcome&quot;, outcome);

	logger.info(&quot;sent done&quot;);
//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!

	// (SN) Enable this line to actually submit the SubmitOrder request
	channelMap.put(&quot;RequestMessage&quot;, messages.request);
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Use fixHL7NodeOrder() to fix a possible node order issue 
// see http://www.mirthcorp.com/community/issues/browse/MIRTH-625

var messages = {request: &quot;&quot;, resp: &quot;&quot;};
messages.request = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(fixHL7NodeOrder(oml));

channelMap.put(&quot;omlHL7&quot;, messages.request); // testing
channelMap.put(&quot;error&quot;, error); // testing

logger.debug(&quot;SubmitOrder: Destination - &quot; + messages.request);


// Verify for errors 
if (error.length &gt; 0) {

	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));

	// To be sent to original feed submitter
	responseMap.put(&quot;Outcome&quot;, outcome);

	// Nothing to send to DEX
	channelMap.put(&quot;RequestMessage&quot;, null);
	
} else {

	// Temporary save the OML_O21 message for the next destination to process

//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!	
	channelMap.put(&quot;RequestMessage&quot;, null);
	//var info = {severity: &quot;Information&quot;, code: &quot;Information&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	//(AM) operation outcome mapping expects lowercase; code is &apos;informational&apos; not &apos;information&apos;
	var info = {severity: &quot;information&quot;, code: &quot;informational&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	outcome = getOperationOutcome(error, info, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));	
	responseMap.put(&quot;Outcome&quot;, outcome);

	logger.info(&quot;sent done&quot;);
//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!

	// (SN) Enable this line to actually submit the SubmitOrder request
	channelMap.put(&quot;RequestMessage&quot;, messages.request);
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>HL7V2</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>JavaScript Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Submit Order WS</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>SOAP query</name>
                <script>var 	submitOrderSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
				   &lt;soapenv:Header/&gt;
				   &lt;soapenv:Body&gt;
				      &lt;ord:submitOrder&gt;
				         &lt;ord:SubmitOrderRequest&gt;
				            &lt;hl7Order&gt;OML_O21&lt;/hl7Order&gt;
				         &lt;/ord:SubmitOrderRequest&gt;
				      &lt;/ord:submitOrder&gt;
				   &lt;/soapenv:Body&gt;
				&lt;/soapenv:Envelope&gt;;

var oml = channelMap.get(&quot;RequestMessage&quot;);
if (oml != null &amp;&amp; oml.toString().length() &gt; 0) {
		
	var bytes = new java.lang.String(oml.toString()).getBytes();
	submitOrderSoap.*::Body.*::submitOrder.*::SubmitOrderRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

} else {
	submitOrderSoap = &quot;&quot;;
	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var 	submitOrderSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
				   &lt;soapenv:Header/&gt;
				   &lt;soapenv:Body&gt;
				      &lt;ord:submitOrder&gt;
				         &lt;ord:SubmitOrderRequest&gt;
				            &lt;hl7Order&gt;OML_O21&lt;/hl7Order&gt;
				         &lt;/ord:SubmitOrderRequest&gt;
				      &lt;/ord:submitOrder&gt;
				   &lt;/soapenv:Body&gt;
				&lt;/soapenv:Envelope&gt;;

var oml = channelMap.get(&quot;RequestMessage&quot;);
if (oml != null &amp;&amp; oml.toString().length() &gt; 0) {
		
	var bytes = new java.lang.String(oml.toString()).getBytes();
	submitOrderSoap.*::Body.*::submitOrder.*::SubmitOrderRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

} else {
	submitOrderSoap = &quot;&quot;;
	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>POST request</name>
                <script>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null &amp;&amp; submitOrderSoap.toString().length &gt; 0) try {
	var error = [];
	var messages = {request: submitOrderSoap.toString(), resp: &quot;&quot;};
	var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};
	sslClient.setURL( $cfg(&quot;submitOrderURL&quot;) );
	sslClient.setSOAPRequest(submitOrderSoap);
	// Submit the request
	var httpCode = sslClient.doPost();

logger.debug (&quot;httpCode is &quot; + httpCode);
	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));
logger.debug (&quot;soapResp is &quot; + soapResp);
	if (200 == httpCode) {

		var orderACK = soapResp.*::Body.*::submitOrderResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String(FileUtil.decode(orderACK));
		messages.resp = ackHL7;
		
		var ack = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(ackHL7));
		channelMap.put(&quot;HL7ACK&quot;, ackHL7);
		// Check Acknowledgment Code: AA - Accept, AE - Error
		if (ack[&apos;MSA&apos;][&apos;MSA.1&apos;][&apos;MSA.1.1&apos;].toString() == &quot;AA&quot;) {
			issue.severity = &quot;information&quot;;
			issue.code = &quot;informational&quot;;
			issue.details = &quot;SUCCESS&quot;;			
		} else {
			// Acknowledgment Code == AE or anything else 
			issue.severity = &quot;error&quot;;
			issue.code = &quot;processing&quot;;
			issue.details = &quot;Order was not successfully processed&quot;;		
			error = ack[&apos;MSA&apos;][&apos;MSA.6&apos;][&apos;MSA.6.2&apos;].toString().split(&quot;,&quot;);	
		} 
		 
	} else {
		// HTTP code is not 200 OK
		issue.severity = &quot;error&quot;;
		issue.code = &quot;processing&quot;;
		issue.details = &quot;HTTP Code: &quot; + httpCode;
	}	
	
} catch(ex) {
	
	issue.severity = &quot;fatal&quot;;
	issue.code = &quot;exception&quot;;
	issue.details = &quot;SubmitOrder WS Transformer: &quot; + ex;
		
} finally {

	// Return submission results
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	responseMap.put(&quot;Outcome&quot;, outcome);
//	logger.debug(&quot;Outcome (Submit Order WS): &quot; + outcome);
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null &amp;&amp; submitOrderSoap.toString().length &gt; 0) try {
	var error = [];
	var messages = {request: submitOrderSoap.toString(), resp: &quot;&quot;};
	var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};
	sslClient.setURL( $cfg(&quot;submitOrderURL&quot;) );
	sslClient.setSOAPRequest(submitOrderSoap);
	// Submit the request
	var httpCode = sslClient.doPost();

logger.debug (&quot;httpCode is &quot; + httpCode);
	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));
logger.debug (&quot;soapResp is &quot; + soapResp);
	if (200 == httpCode) {

		var orderACK = soapResp.*::Body.*::submitOrderResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String(FileUtil.decode(orderACK));
		messages.resp = ackHL7;
		
		var ack = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(ackHL7));
		channelMap.put(&quot;HL7ACK&quot;, ackHL7);
		// Check Acknowledgment Code: AA - Accept, AE - Error
		if (ack[&apos;MSA&apos;][&apos;MSA.1&apos;][&apos;MSA.1.1&apos;].toString() == &quot;AA&quot;) {
			issue.severity = &quot;information&quot;;
			issue.code = &quot;informational&quot;;
			issue.details = &quot;SUCCESS&quot;;			
		} else {
			// Acknowledgment Code == AE or anything else 
			issue.severity = &quot;error&quot;;
			issue.code = &quot;processing&quot;;
			issue.details = &quot;Order was not successfully processed&quot;;		
			error = ack[&apos;MSA&apos;][&apos;MSA.6&apos;][&apos;MSA.6.2&apos;].toString().split(&quot;,&quot;);	
		} 
		 
	} else {
		// HTTP code is not 200 OK
		issue.severity = &quot;error&quot;;
		issue.code = &quot;processing&quot;;
		issue.details = &quot;HTTP Code: &quot; + httpCode;
	}	
	
} catch(ex) {
	
	issue.severity = &quot;fatal&quot;;
	issue.code = &quot;exception&quot;;
	issue.details = &quot;SubmitOrder WS Transformer: &quot; + ex;
		
} finally {

	// Return submission results
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	responseMap.put(&quot;Outcome&quot;, outcome);
//	logger.debug(&quot;Outcome (Submit Order WS): &quot; + outcome);
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data

// Delete some characters that may break JSON to XML parsing
message = message.replace(/null/g,&apos;&quot;&quot;&apos;);
message = message.replace(/&amp;/g,&quot;&amp;amp;&quot;); // ampersand
message = message.replace(/&lt;/g,&quot;&amp;lt;&quot;);  // less than
message = message.replace(/&gt;/g,&quot;&amp;gt;&quot;);  // greater than
message = message.replace(/&quot;&quot;&quot;&quot;/g,&apos;&quot;&quot;&apos;); // quotes around quotes

return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

// Format of the OperationOutcome. Supported: &quot;XML&quot; or &quot;JSON&quot;
globalChannelMap.put(&quot;outcomeFormat&quot;, &quot;XML&quot;);

// Prepare SSL Client to access submitOrder Conformance Environment
if (globalMap.containsKey(&quot;sslClient&quot;) &amp;&amp; globalMap.get(&quot;sslClient&quot;)) 
	try {

		var sslClient = new Packages.org.safemovement.DEXSSLClient();		
		sslClient.setAuthorizationType(org.safemovement.DEXSSLClient.Authorization.BASIC);
		sslClient.setContentType(&quot;text/xml;charset=UTF-8&quot;);
		sslClient.setUserName($(&quot;username&quot;));
		sslClient.setUserPassword($(&quot;userpsw&quot;));		
		sslClient.setConnectionType(&quot;Close&quot;);
		
		globalChannelMap.put(&quot;sslClientClass&quot;, sslClient);
		
	} catch(ex) {
		logger.error(&quot;SubmitOrder: Deploy - cannot initialize SSLClient - &quot; + ex);
		
		// Stop this channel to resolve the problem
		ChannelUtil.stopChannel(channelId);
		throw (&quot;SubmitOrder: Deploy - cannot initialize SSLClient - &quot; + ex);		
	}



return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data

if (globalChannelMap.containsKey(&quot;sslClientClass&quot;)){
	globalChannelMap.remove(&quot;sslClientClass&quot;);
}


return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>e38ce6d8-cdfc-4a8a-877a-6688edb368ee</id>
      <nextMetaDataId>4</nextMetaDataId>
      <name>Test Exercise</name>
      <description>LRI ORU_R01 processing downstream channel.
The channel receives ORU_R01 messages routed from the LRI getResults channel.

(SN) This channel should use Strict Parser for incoming HL7v2 ORU messages.

Last updated: March 25, 2017</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1497207049534</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>16</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps/>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>HL7V2</inboundDataType>
          <outboundDataType>HL7V2</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>false</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
              <handleRepetitions>true</handleRepetitions>
              <handleSubcomponents>true</handleSubcomponents>
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <stripNamespaces>true</stripNamespaces>
              <segmentDelimiter>\r</segmentDelimiter>
              <convertLineBreaks>true</convertLineBreaks>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
              <useStrictParser>true</useStrictParser>
              <useStrictValidation>false</useStrictValidation>
              <segmentDelimiter>\r</segmentDelimiter>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
              <splitType>MSH_Segment</splitType>
              <batchScript></batchScript>
            </batchProperties>
            <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
              <segmentDelimiter>\r</segmentDelimiter>
              <successfulACKCode>AA</successfulACKCode>
              <successfulACKMessage></successfulACKMessage>
              <errorACKCode>AE</errorACKCode>
              <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
              <rejectedACKCode>AR</rejectedACKCode>
              <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
              <msh15ACKAccept>false</msh15ACKAccept>
              <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
            </responseGenerationProperties>
            <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
              <successfulACKCode>AA,CA</successfulACKCode>
              <errorACKCode>AE,CE</errorACKCode>
              <rejectedACKCode>AR,CR</rejectedACKCode>
              <validateMessageControlId>true</validateMessageControlId>
              <originalMessageControlId>Destination_Encoded</originalMessageControlId>
              <originalIdMapVariable></originalIdMapVariable>
            </responseValidationProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules>
            <rule>
              <sequenceNumber>0</sequenceNumber>
              <name>Check for ORU messages</name>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Continue processing only if the incoming message is ORU_R01
if(&quot;ORU&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.1&apos;].toString() &amp;&amp; &quot;R01&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.2&apos;].toString()) {
	return true;
} else {
	logger.error(&quot;ORU Processing: non-ORU message is rejected &quot; + msg.toString());
	return false;
}</string>
                </entry>
              </data>
              <type>JavaScript</type>
              <script>// Continue processing only if the incoming message is ORU_R01
if(&quot;ORU&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.1&apos;].toString() &amp;&amp; &quot;R01&quot; == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSG.2&apos;].toString()) {
	return true;
} else {
	logger.error(&quot;ORU Processing: non-ORU message is rejected &quot; + msg.toString());
	return false;
}</script>
              <operator>NONE</operator>
            </rule>
          </rules>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>ORU_R01_2.5.1</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${DR}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>DiagnosticReport resource</name>
                <script>var arrDiagnosticReport = [];
var arrOrderingProvider = [];
var arrProviderID = [];

/*
* (SN) Practitioner resource for Performing Organization or Medical Doctor is not mapped (see comments below)
*
*/ 

//logger.error( msg.toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;].toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0].toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0].toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0][&apos;OBX&apos;][0].toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0][&apos;OBX&apos;][0].toString() );

for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	var resDiagnosticReport = &lt;DiagnosticReport&gt;&lt;text&gt;&lt;status value=&quot;generated&quot;/&gt;&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;&lt;/text&gt;&lt;/DiagnosticReport&gt;;
	
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		var containedObservation = &lt;contained&gt;&lt;/contained&gt;;		
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			containedObservation.appendChild( getObservationResourcePopulated( obs ) );
			resDiagnosticReport.appendChild(containedObservation);	
		}
	}

	logger.error( resDiagnosticReport.toString() );
}

/*
for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	// Process only ORC-OBR-OBX group
	if (observation[&apos;ORC&apos;][&apos;ORC.1&apos;].toString() != &quot;RE&quot;) { continue; }

	// Ignore &quot;comment&quot; or PDF results
	var invokeContinue = false;
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; ( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;ClinicalPDFReport1&quot; || obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;EnhancedPDFReport1&quot; ))
		{
			invokeContinue = true;
		}
	}	
	
	if( invokeContinue ){ continue; }; 
	
// logger.error( &quot;Processing Observation&quot; );

	var PlacerOrderNumber = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString();
	var PlacerNamespace   = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.2&apos;].toString();
	var FillerOrderNumber = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();
	var FillerNamespace   = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.2&apos;].toString();

	var StatusCode = observation[&apos;ORC&apos;][&apos;ORC.5&apos;].toString();
	
	var TestCode    = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	var TestHasParent     = false;

	// Does result have a parent?
	if( TestCode.indexOf( &quot;%&quot; ) &gt; -1 )
	{
		TestCode = TestCode.replace( &apos;%&apos;, &apos;&apos; );
		TestHasParent = true;	
	}
	
	var resDiagnosticReport = &lt;DiagnosticReport&gt;&lt;text&gt;&lt;status value=&quot;generated&quot;/&gt;&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;&lt;/text&gt;&lt;/DiagnosticReport&gt;;

	var contained = 0;
	
//msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0][&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;CE.1&apos;].toString()

	var resultReference = &lt;contained&gt;&lt;/contained&gt;;
	// Reference to contained observations
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			resultReference.appendChild( getObservationResourcePopulated( obs ) );
			logger.error( &quot;Observation: &quot; + getObservationResourcePopulated( obs ).toString() );			
		}
	}	
	
	resDiagnosticReport.appendChild(resultReference);

		
	// Order Status - Indicates whether the result is partial or final.
	if (StatusCode){
		var statusXML = &lt;status value=&quot;final&quot;&gt;&lt;/status&gt;;
		resDiagnosticReport.appendChild(statusXML);
	}

	resDiagnosticReport.code.@id = TestCode;

	// Hard-coded, required by FHIR
	var subXML = &lt;subject&gt;&lt;reference value=&quot;Patient&quot;/&gt;&lt;/subject&gt;;
	subXML.reference.@value = &quot;Patient/&quot; + $(&apos;PatientResourceID&apos;);
	resDiagnosticReport.appendChild(subXML);
	

	var resultReference = &lt;result&gt;&lt;/result&gt;;

	// Reference to observation this report is based on
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;) 
		{
			var obsReference = &lt;reference value=&quot;&quot;/&gt;;
			obsReference.@value =  &quot;#&quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			resultReference.appendChild(obsReference);	
		}	
	}

	resDiagnosticReport.appendChild(resultReference);	

	logger.error( resDiagnosticReport.toString() );
	
//	arrDiagnosticReport.push(resDiagnosticReport.toString());


}
*/

function getObservationResourcePopulated(obs) {

	importPackage( Packages.java.util );
	importPackage( Packages.org.hl7.fhir.instance.model );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.resource );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.valueset );
	importPackage( Packages.ca.uhn.fhir.model.primitive );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.composite );
	importPackage( Packages.java.text );

	var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();	

	var HL7DateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);

	var obsResource = new Observation();

	obsResource.setId( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());				
		
	obsResource.addIdentifier().setValue(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());

	switch( obs[&apos;OBX.11&apos;].toString() + &apos;&apos; )
	{
		case &quot;F&quot;:
			obsResource.setStatus(ObservationStatusEnum.FINAL);				
		break;

		case &quot;P&quot;:
			obsResource.setStatus(ObservationStatusEnum.PRELIMINARY);			
		break;

		case &quot;S&quot;:
			obsResource.setStatus(ObservationStatusEnum.AMENDED);	
		break;

		case &quot;C&quot;:
			obsResource.setStatus(ObservationStatusEnum.CANCELLED);
		break;

		case &quot;X&quot;:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
		break;
					
		default:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
			logger.error( &quot;Unrecognized Status Code: &quot; + obs[&apos;OBX.11&apos;].toString() );	
	}

	var theCodeableConcept = new CodeableConceptDt();
	var theLoincCoding = new CodingDt();
	var theQuestCoding = new CodingDt();
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) 
	{
		// LOINC coding
		theLoincCoding.setSystem(&quot;http://loinc.org&quot;);
		theLoincCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString());
		theLoincCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString());
		theCodeableConcept.addCoding(theLoincCoding );		
	}

	theQuestCoding.setSystem(obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString());
	theQuestCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());
	theQuestCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString());
	theCodeableConcept.addCoding(theQuestCoding );				

	obsResource.setCode(theCodeableConcept );

	var HL7TimestampFormatWithTZ = new SimpleDateFormat( &quot;yyyyMMddHHmmss.SSSZ&quot;);

	if( obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString() )
	{
		obsResource.setIssuedWithMillisPrecision(HL7TimestampFormatWithTZ.parse(obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString()));
	}
	obsResource.setValue( new StringDt( obs[&apos;OBX.5&apos;][&apos;SN.1&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.2&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.3&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.4&apos;].toString() ) );

	var theInterpretation = new CodeableConceptDt();
	theInterpretation.setText(obs[&apos;OBX.8&apos;].toString());	
	obsResource.setInterpretation(theInterpretation );	

	var theReferenceRange = new Observation.ReferenceRange();
	var theMeaningCoding = new CodeableConceptDt();
	var theReferenceRangeMeaningCoding = new CodingDt();	

	theReferenceRangeMeaningCoding.setCode(obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString());
	theReferenceRangeMeaningCoding.setSystem(obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString());
	theReferenceRangeMeaningCoding.setDisplay(obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString());

	theMeaningCoding.addCoding(theReferenceRangeMeaningCoding );
	theReferenceRange.setText(obs[&apos;OBX.7&apos;].toString());
		
	theReferenceRange.setMeaning(theMeaningCoding );
	obsResource.addReferenceRange(theReferenceRange);	

//	logger.error( &quot;Contained Observation: \n&quot; + obsResource.toString() );
	return new XML( ctx.newXmlParser().encodeResourceToString(obsResource) );
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var arrDiagnosticReport = [];
var arrOrderingProvider = [];
var arrProviderID = [];

/*
* (SN) Practitioner resource for Performing Organization or Medical Doctor is not mapped (see comments below)
*
*/ 

//logger.error( msg.toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;].toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0].toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0].toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0][&apos;OBX&apos;][0].toString() );
//logger.error( msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0][&apos;OBX&apos;][0].toString() );

for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	var resDiagnosticReport = &lt;DiagnosticReport&gt;&lt;text&gt;&lt;status value=&quot;generated&quot;/&gt;&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;&lt;/text&gt;&lt;/DiagnosticReport&gt;;
	
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		var containedObservation = &lt;contained&gt;&lt;/contained&gt;;		
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			containedObservation.appendChild( getObservationResourcePopulated( obs ) );
			resDiagnosticReport.appendChild(containedObservation);	
		}
	}

	logger.error( resDiagnosticReport.toString() );
}

/*
for each (var observation in msg[&apos;ORU_R01.PATIENT_RESULT&apos;].children()) {

	// Process only ORC-OBR-OBX group
	if (observation[&apos;ORC&apos;][&apos;ORC.1&apos;].toString() != &quot;RE&quot;) { continue; }

	// Ignore &quot;comment&quot; or PDF results
	var invokeContinue = false;
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; ( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;ClinicalPDFReport1&quot; || obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() == &quot;EnhancedPDFReport1&quot; ))
		{
			invokeContinue = true;
		}
	}	
	
	if( invokeContinue ){ continue; }; 
	
// logger.error( &quot;Processing Observation&quot; );

	var PlacerOrderNumber = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.1&apos;].toString();
	var PlacerNamespace   = observation[&apos;ORC&apos;][&apos;ORC.2&apos;][&apos;EI.2&apos;].toString();
	var FillerOrderNumber = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.1&apos;].toString();
	var FillerNamespace   = observation[&apos;ORC&apos;][&apos;ORC.3&apos;][&apos;EI.2&apos;].toString();

	var StatusCode = observation[&apos;ORC&apos;][&apos;ORC.5&apos;].toString();
	
	var TestCode    = observation[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;CE.1&apos;].toString();
	var TestHasParent     = false;

	// Does result have a parent?
	if( TestCode.indexOf( &quot;%&quot; ) &gt; -1 )
	{
		TestCode = TestCode.replace( &apos;%&apos;, &apos;&apos; );
		TestHasParent = true;	
	}
	
	var resDiagnosticReport = &lt;DiagnosticReport&gt;&lt;text&gt;&lt;status value=&quot;generated&quot;/&gt;&lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;/&gt;&lt;/text&gt;&lt;/DiagnosticReport&gt;;

	var contained = 0;
	
//msg[&apos;ORU_R01.PATIENT_RESULT&apos;][&apos;ORU_R01.ORDER_OBSERVATION&apos;][0][&apos;ORU_R01.OBSERVATION&apos;][0][&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;CE.1&apos;].toString()

	var resultReference = &lt;contained&gt;&lt;/contained&gt;;
	// Reference to contained observations
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;)
		{
			resultReference.appendChild( getObservationResourcePopulated( obs ) );
			logger.error( &quot;Observation: &quot; + getObservationResourcePopulated( obs ).toString() );			
		}
	}	
	
	resDiagnosticReport.appendChild(resultReference);

		
	// Order Status - Indicates whether the result is partial or final.
	if (StatusCode){
		var statusXML = &lt;status value=&quot;final&quot;&gt;&lt;/status&gt;;
		resDiagnosticReport.appendChild(statusXML);
	}

	resDiagnosticReport.code.@id = TestCode;

	// Hard-coded, required by FHIR
	var subXML = &lt;subject&gt;&lt;reference value=&quot;Patient&quot;/&gt;&lt;/subject&gt;;
	subXML.reference.@value = &quot;Patient/&quot; + $(&apos;PatientResourceID&apos;);
	resDiagnosticReport.appendChild(subXML);
	

	var resultReference = &lt;result&gt;&lt;/result&gt;;

	// Reference to observation this report is based on
	for each (var obs in observation[&apos;ORU_R01.OBSERVATION&apos;].children()) 
	{
		if (&quot;OBX&quot; == obs.name().toString() &amp;&amp; obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString() != &quot;&quot;) 
		{
			var obsReference = &lt;reference value=&quot;&quot;/&gt;;
			obsReference.@value =  &quot;#&quot; + obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString();
			resultReference.appendChild(obsReference);	
		}	
	}

	resDiagnosticReport.appendChild(resultReference);	

	logger.error( resDiagnosticReport.toString() );
	
//	arrDiagnosticReport.push(resDiagnosticReport.toString());


}
*/

function getObservationResourcePopulated(obs) {

	importPackage( Packages.java.util );
	importPackage( Packages.org.hl7.fhir.instance.model );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.resource );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.valueset );
	importPackage( Packages.ca.uhn.fhir.model.primitive );
	importPackage( Packages.ca.uhn.fhir.model.dstu2.composite );
	importPackage( Packages.java.text );

	var ctx = Packages.ca.uhn.fhir.context.FhirContext.forDstu2();	

	var HL7DateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);

	var obsResource = new Observation();

	obsResource.setId( obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());				
		
	obsResource.addIdentifier().setValue(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());

	switch( obs[&apos;OBX.11&apos;].toString() + &apos;&apos; )
	{
		case &quot;F&quot;:
			obsResource.setStatus(ObservationStatusEnum.FINAL);				
		break;

		case &quot;P&quot;:
			obsResource.setStatus(ObservationStatusEnum.PRELIMINARY);			
		break;

		case &quot;S&quot;:
			obsResource.setStatus(ObservationStatusEnum.AMENDED);	
		break;

		case &quot;C&quot;:
			obsResource.setStatus(ObservationStatusEnum.CANCELLED);
		break;

		case &quot;X&quot;:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
		break;
					
		default:
			obsResource.setStatus(ObservationStatusEnum.UNKNOWN_STATUS);
			logger.error( &quot;Unrecognized Status Code: &quot; + obs[&apos;OBX.11&apos;].toString() );	
	}

	var theCodeableConcept = new CodeableConceptDt();
	var theLoincCoding = new CodingDt();
	var theQuestCoding = new CodingDt();
	
	if (obs[&apos;OBX.3&apos;][&apos;CE.6&apos;].toString() == &quot;LN&quot;) 
	{
		// LOINC coding
		theLoincCoding.setSystem(&quot;http://loinc.org&quot;);
		theLoincCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.4&apos;].toString());
		theLoincCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.5&apos;].toString());
		theCodeableConcept.addCoding(theLoincCoding );		
	}

	theQuestCoding.setSystem(obs[&apos;OBX.3&apos;][&apos;CE.3&apos;].toString());
	theQuestCoding.setCode(obs[&apos;OBX.3&apos;][&apos;CE.1&apos;].toString());
	theQuestCoding.setDisplay(obs[&apos;OBX.3&apos;][&apos;CE.2&apos;].toString());
	theCodeableConcept.addCoding(theQuestCoding );				

	obsResource.setCode(theCodeableConcept );

	var HL7TimestampFormatWithTZ = new SimpleDateFormat( &quot;yyyyMMddHHmmss.SSSZ&quot;);

	if( obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString() )
	{
		obsResource.setIssuedWithMillisPrecision(HL7TimestampFormatWithTZ.parse(obs[&apos;OBX.19&apos;][&apos;TS.1&apos;].toString()));
	}
	obsResource.setValue( new StringDt( obs[&apos;OBX.5&apos;][&apos;SN.1&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.2&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.3&apos;].toString() +  obs[&apos;OBX.5&apos;][&apos;SN.4&apos;].toString() ) );

	var theInterpretation = new CodeableConceptDt();
	theInterpretation.setText(obs[&apos;OBX.8&apos;].toString());	
	obsResource.setInterpretation(theInterpretation );	

	var theReferenceRange = new Observation.ReferenceRange();
	var theMeaningCoding = new CodeableConceptDt();
	var theReferenceRangeMeaningCoding = new CodingDt();	

	theReferenceRangeMeaningCoding.setCode(obs[&apos;OBX.6&apos;][&apos;CE.1&apos;].toString());
	theReferenceRangeMeaningCoding.setSystem(obs[&apos;OBX.6&apos;][&apos;CE.3&apos;].toString());
	theReferenceRangeMeaningCoding.setDisplay(obs[&apos;OBX.6&apos;][&apos;CE.2&apos;].toString());

	theMeaningCoding.addCoding(theReferenceRangeMeaningCoding );
	theReferenceRange.setText(obs[&apos;OBX.7&apos;].toString());
		
	theReferenceRange.setMeaning(theMeaningCoding );
	obsResource.addReferenceRange(theReferenceRange);	

//	logger.error( &quot;Contained Observation: \n&quot; + obsResource.toString() );
	return new XML( ctx.newXmlParser().encodeResourceToString(obsResource) );
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64">TVNIfF5+XCZ8UUxTfFRNRV4wNUQwNjQyODI3XkNMSUF8fDkwMDQ2MDAzfDIwMTcwNTExMTEyODM1
LjAwMC0wNzAwfHxPUlVeUjAxXk9SVV9SMDF8ODAwMDAwMDAwMDAwMDEwMzMyMDB8UHwyLjUuMXwx
fHxBTHxORXx8fHx8TFJJX05HX1JOX1Byb2ZpbGVeXjIuMTYuODQwLjEuMTEzODgzLjkuMjBeSVNP
ClBJRHwxfHxTQUZFLjExMTExMTExXl5eXlBUfjg1NjcxMDA5NjAyODQ0NjdeXl5eQU58fFNNSVRI
XkpJTExeXl5eXkx8fDE5NTgxMjI4fE18fHwxMTExIE1JTEwgU1ReXlJPU1dFTExeR0FeMzAwNzZe
VVNBCk5URXwxfEx8RkFTVElORzpOTwpPUkN8UkV8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5
NTFUXlFVRVNUX1RNRXx8Q018fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5e
TlBJfHx8fHx8fHx8U0FGRSBJUEMsQSBQUk9GRVNTSU9OQUwgQ09SUC5eXl5eXl5eXl45MDA0NjAw
M3w3OTA0IFNBTlRBIE1PTklDQSBCTFZEIFNURSAzMDBeTUFJTDAwMF5XRVNUIEhPTExZV09PRF5D
QV45MDA0Ni01MTcwXl5PXl5VU0F8Xl5eXl4zMTBeNTc5Mjc3OApPQlJ8MXw5XlFVRVNUX1RNRV85
MDA0NjAwM3xXSDM1MDk1MVReUVVFU1RfVE1FfDQ5OF5IQlNBRyBXL1JGTCBDT05GXjk5UURJfHx8
MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8fHx8fHx8fHwxNDk3ODc1MDI1XktBV0VTQ0heR0FSWV5e
Xl5eXl5eXl5OUEl8fHx8fHwyMDE3MDUxMTExMjgzNS4wMDAtMDcwMHx8fEYKT0JYfDF8U1R8NTUw
MTkzMDBeSEVQQVRJVElTIEIgU1VSRkFDRSBBTlRJR0VOXjk5UURJXjUxOTYtMV5IQlYgc3VyZmFj
ZSBBZyBTZXJQbCBRbCBJQV5MTnwxfFJFQUNUSVZFfHxOT04tUkVBQ1RJVkV8QXx8fEZ8fHwyMDE3
MDUxMTExMjgzNS4wMDAtMDcwMHx8fHx8MjAxNzA1MTEwODMzMTQuMDAwLTA3MDB8fHx8UVVFU1Qg
RElBR05PU1RJQ1MtV0VTVCBISUxMU15eXl5eXkZJXkNMSUFeXjA1RDA2NDI4Mjd8ODQwMSBGQUxM
QlJPT0sgQVZFTlVFXl5XRVNUIEhJTExTXkNBXjkxMzA0LTMyMjZ8MTM2NjQ3OTA5OV5URVJSQVpB
U15FTlJJUVVFXl5NRF5eXl5eXl5eTlBJXkVOCk9CWHwyfFNUfDU1MDE5NjAwXkNPTkZJUk1BVElP
Tl45OVFESV43OTA1LTNeSEJWIHN1cmZhY2UgQWcgU2VyUGwgUWwgTnReTE58MXxETlJ8fHxOfHx8
WHx8fDIwMTcwNTExMTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4MzMxNC4wMDAtMDcwMHx8
fHxRVUVTVCBESUFHTk9TVElDUy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4
NDAxIEZBTExCUk9PSyBBVkVOVUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5
XlRFUlJBWkFTXkVOUklRVUVeXk1EXl5eXl5eXl5OUEleRU4KU1BNfDF8MDNeMDN8fFVTUEVDXlNv
dXJjZSwgVW5zcGVjaWZpZWReSEw3MDQ4N3x8fHx8fHx8fHx8fHwyMDE3MDUxMDEzMzYwMC4wMDAt
MDcwMHwyMDE3MDUxMTA4MDExOC4wMDAtMDcwMApPUkN8UkV8OV5RVUVTVF9UTUVfOTAwNDYwMDN8
V0gzNTA5NTFUXlFVRVNUX1RNRXx8Q018fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5e
Xl5eXl5eTlBJfHx8fHx8fHx8U0FGRSBJUEMsQSBQUk9GRVNTSU9OQUwgQ09SUC5eXl5eXl5eXl45
MDA0NjAwM3w3OTA0IFNBTlRBIE1PTklDQSBCTFZEIFNURSAzMDBeTUFJTDAwMF5XRVNUIEhPTExZ
V09PRF5DQV45MDA0Ni01MTcwXl5PXl5VU0F8Xl5eXl4zMTBeNTc5Mjc3OApPQlJ8Mnw5XlFVRVNU
X1RNRV85MDA0NjAwM3xXSDM1MDk1MVReUVVFU1RfVE1FfDg0NzJeSEVQIEMgQUIgVy9SRUZMIEhD
Vl45OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfHx8fHx8fHx8MTQ5Nzg3NTAyNV5LQVdF
U0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHxGCk9C
WHwxfFNUfDU1MDcxNjAwXkhFUEFUSVRJUyBDIEFOVElCT0RZXjk5UURJXjEzOTU1LTBeSENWIEFi
IFNlclBsIFFsIElBXkxOfDF8UkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxBfHx8Rnx8fDIwMTcwNTEx
MTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4MzM0NC4wMDAtMDcwMHx8fHxRVUVTVCBESUFH
Tk9TVElDUy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9P
SyBBVkVOVUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVO
UklRVUVeXk1EXl5eXl5eXl5OUEleRU4KT0JYfDJ8Tk18NTUwNzE3MDVeU0lHTkFMIFRPIENVVC1P
RkZeOTlRREleNDgxNTktOF5IQ1YgQWIgcy9jbyBTZXJQbCBJQV5MTnwxfDEwLjAwfHw8MS4wMHxI
fHx8Rnx8fDIwMTcwNTExMTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4MzM0NC4wMDAtMDcw
MHx8fHxRVUVTVCBESUFHTk9TVElDUy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0Mjgy
N3w4NDAxIEZBTExCUk9PSyBBVkVOVUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5
MDk5XlRFUlJBWkFTXkVOUklRVUVeXk1EXl5eXl5eXl5OUEleRU4KTlRFfDF8THwgCk5URXwyfEx8
Rm9sbG93aW5nIENEQyByZWNvbW1lbmRhdGlvbnMgKE1NV1IgTm8uIDYyLCAyMDEzKSwgdGhpcwpO
VEV8M3xMfHBhdGllbnQncyBIQ1YgQW50aWJvZHkgUmVhY3RpdmUgc2FtcGxlIHdpbGwgYmUgdGVz
dGVkIGZvcgpOVEV8NHxMfHRoZSBwcmVzZW5jZSBvZiBIQ1YgUk5BIGJ5IGEgTnVjbGVpYyBBY2lk
IEFtcGxpZmljYXRpb24KTlRFfDV8THxUZXN0IChOQUFUKSB0byBkZXRlcm1pbmUgaWYgdGhlIHBh
dGllbnQgaGFzIGFuIGFjdGl2ZSBIQ1YKTlRFfDZ8THxpbmZlY3Rpb24uCk5URXw3fEx8IApTUE18
MXwwM14wM3x8VVNQRUNeU291cmNlLCBVbnNwZWNpZmllZF5ITDcwNDg3fHx8fHx8fHx8fHx8fDIw
MTcwNTEwMTMzNjAwLjAwMC0wNzAwfDIwMTcwNTExMDgwMTE4LjAwMC0wNzAwCk9SQ3xSRXw5XlFV
RVNUX1RNRV85MDA0NjAwM3xXSDM1MDk1MVReUVVFU1RfVE1FfHxDTXx8fHx8fHwxNDk3ODc1MDI1
XktBV0VTQ0heR0FSWV5eXl5eXl5eXl5OUEl8fHx8fHx8fHxTQUZFIElQQyxBIFBST0ZFU1NJT05B
TCBDT1JQLl5eXl5eXl5eXjkwMDQ2MDAzfDc5MDQgU0FOVEEgTU9OSUNBIEJMVkQgU1RFIDMwMF5N
QUlMMDAwXldFU1QgSE9MTFlXT09EXkNBXjkwMDQ2LTUxNzBeXk9eXlVTQXxeXl5eXjMxMF41Nzky
Nzc4fHx8fHx8fHw4NDcyXkhFUCBDIEFCIFcvUkVGTCBIQ1ZeOTlRREleNTYwMDAwODQ3Ml5eVU5J
VENPREUKT0JSfDN8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXwlMzU2
NDVeSENWIFJOQSwgUU4gUENSXjk5UURJfHx8MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8fHx8R3x8
fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTExMTI4
MzUuMDAwLTA3MDB8fHxGfDU1MDcxNjAwJkhFUEFUSVRJUyBDIEFOVElCT0RZJjk5UURJJjEzOTU1
LTAmSENWIEFiIFNlclBsIFFsIElBJkxOfHx8OSZRVUVTVF9UTUVfOTAwNDYwMDNeV0gzNTA5NTFU
JlFVRVNUX1RNRXx8fHx8fHx8fHx8fHx8fHx8fHx8fDg0NzJeSEVQIEMgQUIgVy9SRUZMIEhDVl45
OVFESV41NjAwMDA4NDcyXl5VTklUQ09ERQpOVEV8MXxMfFRoZSBhbmFseXRpY2FsIHBlcmZvcm1h
bmNlIGNoYXJhY3RlcmlzdGljcyBvZiB0aGlzCk5URXwyfEx8YXNzYXkgaGF2ZSBiZWVuIGRldGVy
bWluZWQgYnkgUXVlc3QgRGlhZ25vc3RpY3MuIApOVEV8M3xMfFRoZSBtb2RpZmljYXRpb25zIGhh
dmUgbm90IGJlZW4gY2xlYXJlZCBvciBhcHByb3ZlZCBieQpOVEV8NHxMfHRoZSBGREEuIFRoaXMg
YXNzYXkgaGFzIGJlZW4gdmFsaWRhdGVkIHB1cnN1YW50IHRvIHRoZSAKTlRFfDV8THxDTElBIHJl
Z3VsYXRpb25zIGFuZCBpcyB1c2VkIGZvciBjbGluaWNhbCBwdXJwb3Nlcy4gIApOVEV8NnxMfCAK
TlRFfDd8THxUaGlzIHRlc3Qgd2FzIHBlcmZvcm1lZCB1c2luZyB0aGUgQ09CQVMoUilBbXBsaVBy
ZXAvCk5URXw4fEx8Q09CQVMoUilUYXFNYW4oUilIQ1YgVGVzdCx2Mi4wLgpOVEV8OXxMfCAKTlRF
fDEwfEx8Rm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhpcyB0ZXN0LCBnbyB0bzoKTlRFfDExfEx8
aHR0cDovL2VkdWNhdGlvbi5xdWVzdGRpYWdub3N0aWNzLmNvbS9mYXEvRkFRMjJ2MQpOVEV8MTJ8
THwoVGhpcyBsaW5rIGlzIGJlaW5nIHByb3ZpZGVkIGZvciBpbmZvcm1hdGlvbmFsLwpOVEV8MTN8
THxlZHVjYXRpb25hbCBwdXJwb3NlcyBvbmx5LikKTlRFfDE0fEx8IApPQlh8MXxOTXw1NTE5NDI1
NV5IQ1YgUk5BLCBRVUFOVElUQVRJVkUgUkVBTCBUSU1FIFBDUl45OVFESV4xMTAxMS00XkhDViBS
TkEgU2VyUGwgUENSLWFDbmNeTE58MXwxNXxJVS9tTF5eOTlRREl8PDE1fEh8fHxGfHx8MjAxNzA1
MTExMTI4MzUuMDAwLTA3MDB8fHx8fDIwMTcwNTExMDgzNDE1LjAwMC0wNzAwfHx8fFFVRVNUIERJ
QUdOT1NUSUNTLVdFU1QgSElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3fDg0MDEgRkFMTEJS
T09LIEFWRU5VRV5eV0VTVCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0NzkwOTleVEVSUkFaQVNe
RU5SSVFVRV5eTUReXl5eXl5eXk5QSV5FTgpPQlh8MnxOTXw1NTE5NDI2NV5IQ1YgUk5BLCBRVUFO
VElUQVRJVkUgUkVBTCBUSU1FIFBDUl45OVFESV4zODE4MC02XkhDViBSTkEgU2VyUGwgUENSLUxv
ZyBJVV5MTnwxfDEuMTh8TG9nIElVL21MXkxvZyBJVS9tTF45OVFESXw8MS4xOHxIfHx8Rnx8fDIw
MTcwNTExMTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4MzQxNS4wMDAtMDcwMHx8fHxRVUVT
VCBESUFHTk9TVElDUy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZB
TExCUk9PSyBBVkVOVUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJB
WkFTXkVOUklRVUVeXk1EXl5eXl5eXl5OUEleRU4KTlRFfDF8THwgCk5URXwyfEx8UGxlYXNlIG5v
dGU6IFBhdGllbnRzIHdpdGggY2lyY3VsYXRpbmcgYW50aS1IQ1YKTlRFfDN8THxhbnRpYm9kaWVz
IHRoYXQgaGF2ZSBkZXRlY3RhYmxlIEhDViBSTkEgYXMgZGV0ZXJtaW5lZApOVEV8NHxMfGJ5IE5B
VCwgc2hvdWxkIGJlIGNvbnNpZGVyZWQgdG8gaGF2ZSBhbiBhY3RpdmUgSENWCk5URXw1fEx8aW5m
ZWN0aW9uLiBQbGVhc2UgY29ycmVsYXRlIHRoZXNlIGZpbmRpbmdzIHdpdGggdGhlCk5URXw2fEx8
cGF0aWVudCdzIGNsaW5pY2FsIGhpc3RvcnkgYW5kIGFueSBvdGhlciBkaWFnbm9zdGljcwpOVEV8
N3xMfGZpbmRpbmdzLCBpbmNsdWRpbmcgYW55IGV2aWRlbmNlIG9mIGxpdmVyIGR5c2Z1bmN0aW9u
LgpOVEV8OHxMfFBsZWFzZSBjb25zaWRlciB0aGUgY3VycmVudCBUcmVhdG1lbnQgR3VpZGVsaW5l
cyBmb3IKTlRFfDl8THx0aGUgbWFuYWdlbWVudCBvZiB0aGVzZSBwYXRpZW50cyAoSiBIZXBhdG9s
LCAxNDMzLTE0NDQsCk5URXwxMHxMfE9jdDIwMTEpLgpOVEV8MTF8THwgClNQTXwxfDAzXjAzfHxV
U1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8MjAxNzA1MTAxMzM2
MDAuMDAwLTA3MDB8MjAxNzA1MTEwODAxMDAuMDAwLTA3MDAKT1JDfFJFfDleUVVFU1RfVE1FXzkw
MDQ2MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8fDE0OTc4NzUwMjVeS0FXRVNDSF5H
QVJZXl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEgUFJPRkVTU0lPTkFMIENPUlAuXl5e
Xl5eXl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxWRCBTVEUgMzAwXk1BSUwwMDBeV0VT
VCBIT0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5eXl5eMzEwXjU3OTI3NzgKT0JSfDR8
OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXwzNjQwXkhTViAyIElHR145
OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfHx8fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NI
XkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHxGCk9CWHwx
fE5NfDcwMDIwNjAwXkhTViAyIElHRywgVFlQRSBTUEVDSUZJQyBBQl45OVFESV41MjA5LTJeSFNW
MiBJZ0cgU2VyIElBLWFDbmNeTE58MXwxMi4wMHxpbmRleF5eOTlRREl8fEh8fHxGfHx8MjAxNzA1
MTExMTI4MzUuMDAwLTA3MDB8fHx8fDIwMTcwNTExMDg0MDAyLjAwMC0wNzAwfHx8fFFVRVNUIERJ
QUdOT1NUSUNTLVdFU1QgSElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3fDg0MDEgRkFMTEJS
T09LIEFWRU5VRV5eV0VTVCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0NzkwOTleVEVSUkFaQVNe
RU5SSVFVRV5eTUReXl5eXl5eXk5QSV5FTgpOVEV8MXxMfCAgICAgICAgICAgICAgICAgICAgICAg
ICAgSW5kZXggICAgICAgICAgSW50ZXJwcmV0YXRpb24KTlRFfDJ8THwgICAgICAgICAgICAgICAg
ICAgICAgICAgIC0tLS0tICAgICAgICAgIC0tLS0tLS0tLS0tLS0tCk5URXwzfEx8ICAgICAgICAg
ICAgICAgICAgICAgICAgICA8MC45MCAgICAgICAgICBOZWdhdGl2ZQpOVEV8NHxMfCAgICAgICAg
ICAgICAgICAgICAgICAgICAgMC45MC0xLjA5ICAgICAgRXF1aXZvY2FsCk5URXw1fEx8ICAgICAg
ICAgICAgICAgICAgICAgICAgICA+MS4wOSAgICAgICAgICBQb3NpdGl2ZQpOVEV8NnxMfCAKTlRF
fDd8THxUaGlzIGFzc2F5IHV0aWxpemVzIHJlY29tYmluYW50IHR5cGUtc3BlY2lmaWMgYW50aWdl
bnMKTlRFfDh8THx0byBkaWZmZXJlbnRpYXRlIEhTVi0xIGZyb20gSFNWLTIgaW5mZWN0aW9ucy4g
QQpOVEV8OXxMfHBvc2l0aXZlIHJlc3VsdCBjYW5ub3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiByZWNl
bnQgYW5kCk5URXwxMHxMfHBhc3QgaW5mZWN0aW9uLiBJZiByZWNlbnQgSFNWIGluZmVjdGlvbiBp
cyBzdXNwZWN0ZWQKTlRFfDExfEx8YnV0IHRoZSByZXN1bHRzIGFyZSBuZWdhdGl2ZSBvciBlcXVp
dm9jYWwsIHRoZSBhc3NheQpOVEV8MTJ8THxzaG91bGQgYmUgcmVwZWF0ZWQgaW4gNC02IHdlZWtz
LiBUaGUgcGVyZm9ybWFuY2UKTlRFfDEzfEx8Y2hhcmFjdGVyaXN0aWNzIG9mIHRoZSBhc3NheSBo
YXZlIG5vdCBiZWVuIGVzdGFibGlzaGVkCk5URXwxNHxMfGZvciBwZWRpYXRyaWMgcG9wdWxhdGlv
bnMsIGltbXVub2NvbXByb21pc2VkIHBhdGllbnRzLApOVEV8MTV8THxvciBuZW9uYXRhbCBzY3Jl
ZW5pbmcuClNQTXwxfDAyXjAyfHxVU1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8
fHx8fHx8fHx8MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8MjAxNzA1MTEwODAxMTguMDAwLTA3MDAK
T1JDfFJFfDleUVVFU1RfVE1FXzkwMDQ2MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8
fDE0OTc4NzUwMjVeS0FXRVNDSF5HQVJZXl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEg
UFJPRkVTU0lPTkFMIENPUlAuXl5eXl5eXl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxW
RCBTVEUgMzAwXk1BSUwwMDBeV0VTVCBIT0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5e
Xl5eMzEwXjU3OTI3NzgKT0JSfDV8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNU
X1RNRXw5MTQzMV5ISVYxLzIgQUcvQUIsNCBXL1JGTF45OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAw
MC0wNzAwfHx8fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8
MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHxGCk9CWHwxfFNUfDg2MDA5MDUyXkhJViBBRy9BQiwg
NFRIIEdFTl45OVFESV41Njg4OC0xXkhJViAxKzIgQWIrSElWMSBwMjQgQWcgU2VyUGwgUWwgSUFe
TE58MXxOT04tUkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxOfHx8Rnx8fDIwMTcwNTExMTEyODM1LjAw
MC0wNzAwfHx8fHwyMDE3MDUxMTA4NDEzOC4wMDAtMDcwMHx8fHxRVUVTVCBESUFHTk9TVElDUy1X
RVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9PSyBBVkVOVUVe
XldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVOUklRVUVeXk1E
Xl5eXl5eXl5OUEleRU4KTlRFfDF8THxUaGUgcmVwZWF0ZWRseSByZWFjdGl2ZSBzY3JlZW5pbmcg
YXNzYXkgcmVzdWx0IGlzCk5URXwyfEx8Y29uZmlybWVkIGJ5IGR1cGxpY2F0ZSByZXBlYXQgdGVz
dGluZywgYW5kIGluZGljYXRlcwpOVEV8M3xMfGEgUE9TU0lCTEUgcHJlc2VuY2Ugb2YgSElWLTEg
YW50aWJvZGllcyBvciBISVYtMiAKTlRFfDR8THxhbnRpYm9kaWVzLCBhbmQvb3IgSElWLTEgcDI0
IGFudGlnZW4uIEFkZGl0aW9uYWwKTlRFfDV8THx0ZXN0aW5nIGlzIHJlcXVpcmVkIGZvciBkaWFn
bm9zaXMuIApOVEV8NnxMfCAKTlRFfDd8THxUaGVyZWZvcmUsIHRoZXNlIHNjcmVlbmluZyByZXN1
bHRzIG11c3QgYmUgY29ycmVsYXRlZCAKTlRFfDh8THx3aXRoIHJlc3VsdHMgb2YgcmVmbGV4IGNv
bmZpcm1hdG9yeSB0ZXN0cywgaW5jbHVkaW5nCk5URXw5fEx8dGhlIEhJVi0xL0hJVi0yIGFudGli
b2R5IGRpZmZlcmVudGlhdGlvbiBhc3NheSBhbmQsIGlmIApOVEV8MTB8THxuZWNlc3NhcnksIHRo
ZSBISVYtMSBSTkEgcXVhbGl0YXRpdmUgVE1BLgpOVEV8MTF8THwgCk5URXwxMnxMfFRoZSA0dGgg
Z2VuZXJhdGlvbiBISVYtMS8yIEFudGlnZW4vQW50aWJvZHkKTlRFfDEzfEx8Y29tYmluYXRpb24g
aW1tdW5vYXNzYXkgaXMgYSBzY3JlZW5pbmcgdGVzdCBhbmQKTlRFfDE0fEx8c2hvdWxkIG5vdCBi
ZSB1c2VkIGFsb25lIGZvciBkaWFnbm9zaXMuICBSZXBlYXRlZGx5Ck5URXwxNXxMfHJlYWN0aXZl
IHJlc3VsdHMgZnJvbSB0aGUgNHRoIGdlbmVyYXRpb24gc2NyZWVuaW5nCk5URXwxNnxMfHRlc3Qg
YXJlIG9ubHkgaW5kaWNhdGl2ZSBvZiBISVYgaW5mZWN0aW9uIHdoZW4gdGhvc2UKTlRFfDE3fEx8
c2NyZWVuaW5nIHJlc3VsdHMgYXJlIGNvbmZpcm1lZCB0byBiZSBwb3NpdGl2ZSBieQpOVEV8MTh8
THxlaXRoZXIgdGhlIEhJVi0xLzIgQW50aWJvZHkgRGlmZmVyZW50aWF0aW9uIEFzc2F5IG9yCk5U
RXwxOXxMfHRoZSBISVYtMSBSTkEgdGVzdCBieSBUTUEuCk5URXwyMHxMfCAKTlRFfDIxfEx8UExF
QVNFIE5PVEU6IFRoaXMgaW5mb3JtYXRpb24gaGFzIGJlZW4gZGlzY2xvc2VkIHRvCk5URXwyMnxM
fHlvdSBmcm9tIHJlY29yZHMgd2hvc2UgY29uZmlkZW50aWFsaXR5IG1heSBiZQpOVEV8MjN8THxw
cm90ZWN0ZWQgYnkgc3RhdGUgbGF3LiAgSWYgeW91ciBzdGF0ZSByZXF1aXJlcyBzdWNoCk5URXwy
NHxMfHByb3RlY3Rpb24sIHRoZW4gdGhlIHN0YXRlIGxhdyBwcm9oaWJpdHMgeW91IGZyb20KTlRF
fDI1fEx8bWFraW5nIGFueSBmdXJ0aGVyIGRpc2Nsb3N1cmUgb2YgdGhlIGluZm9ybWF0aW9uCk5U
RXwyNnxMfHdpdGhvdXQgdGhlIHNwZWNpZmljIHdyaXR0ZW4gY29uc2VudCBvZiB0aGUgcGVyc29u
Ck5URXwyN3xMfHRvIHdob20gaXQgcGVydGFpbnMsIG9yIGFzIG90aGVyd2lzZSBwZXJtaXR0ZWQg
YnkgbGF3LgpOVEV8Mjh8THxBIGdlbmVyYWwgYXV0aG9yaXphdGlvbiBmb3IgdGhlIHJlbGVhc2Ug
b2YgbWVkaWNhbCBvcgpOVEV8Mjl8THxvdGhlciBpbmZvcm1hdGlvbiBpcyBOT1Qgc3VmZmljaWVu
dCBmb3IgdGhpcyBwdXJwb3NlLgpOVEV8MzB8THwgCk5URXwzMXxMfFRoZSBwZXJmb3JtYW5jZSBv
ZiB0aGlzIGFzc2F5IGhhcyBub3QgYmVlbiBjbGluaWNhbGx5Ck5URXwzMnxMfHZhbGlkYXRlZCBp
biBwYXRpZW50cyBsZXNzIHRoYW4gMiB5ZWFycyBvbGQuCk5URXwzM3xMfCAKU1BNfDF8fHxVU1BF
Q15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8MjAxNzA1MTAxMzM2MDAu
MDAwLTA3MDB8MjAxNzA1MTEwODAxMTguMDAwLTA3MDAKT1JDfFJFfDleUVVFU1RfVE1FXzkwMDQ2
MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8fDE0OTc4NzUwMjVeS0FXRVNDSF5HQVJZ
Xl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEgUFJPRkVTU0lPTkFMIENPUlAuXl5eXl5e
Xl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxWRCBTVEUgMzAwXk1BSUwwMDBeV0VTVCBI
T0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5eXl5eMzEwXjU3OTI3Nzh8fHx8fHx8fCVT
QkhJVjIzXkhJViA0VEggR0VOIFNDUiAyLDNeOTlRREleNzAwOTk5MTQzMV5eVU5JVENPREUKT0JS
fDZ8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXwlOTE0MzJeSElWIDEv
MiBBQiBESUZGXjk5UURJfHx8MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8fHx8R3x8fHx8MTQ5Nzg3
NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3
MDB8fHxGfDg2MDExNjEyJkhJViBSRVBFQVQgQSY5OVFESXx8fDkmUVVFU1RfVE1FXzkwMDQ2MDAz
XldIMzUwOTUxVCZRVUVTVF9UTUV8fHx8fHx8fHx8fHx8fHx8fHx8fHwlU0JISVYyM15ISVYgNFRI
IEdFTiBTQ1IgMiwzXjk5UURJXjcwMDk5OTE0MzFeXlVOSVRDT0RFCk9CWHwxfFNUfDg2MDA5MDU2
XkhJViAxIEFOVElCT0RZXjk5UURJXjI5ODkzLTVeSElWMSBBYiBTZXJQbCBRbCBJQV5MTnwxfFBP
U0lUSVZFfHxORUdBVElWRXxBfHx8Rnx8fDIwMTcwNTExMTEyODM1LjAwMC0wNzAwfHx8fHwyMDE3
MDUxMTA4NDEzNy4wMDAtMDcwMHx8fHxRVUVTVCBESUFHTk9TVElDUy1XRVNUIEhJTExTXl5eXl5e
RkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9PSyBBVkVOVUVeXldFU1QgSElMTFNeQ0Fe
OTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVOUklRVUVeXk1EXl5eXl5eXl5OUEleRU4K
T0JYfDJ8U1R8ODYwMDkwNTdeSElWIDIgQU5USUJPRFleOTlRREleMzAzNjEtMF5ISVYgMiBBYiBT
ZXJQbCBRbCBJQV5MTnwxfE5FR0FUSVZFfHxORUdBVElWRXxOfHx8Rnx8fDIwMTcwNTExMTEyODM1
LjAwMC0wNzAwfHx8fHwyMDE3MDUxMTA4NDEzNy4wMDAtMDcwMHx8fHxRVUVTVCBESUFHTk9TVElD
Uy1XRVNUIEhJTExTXl5eXl5eRkleQ0xJQV5eMDVEMDY0MjgyN3w4NDAxIEZBTExCUk9PSyBBVkVO
VUVeXldFU1QgSElMTFNeQ0FeOTEzMDQtMzIyNnwxMzY2NDc5MDk5XlRFUlJBWkFTXkVOUklRVUVe
Xk1EXl5eXl5eXl5OUEleRU4KTlRFfDF8THwgCk5URXwyfEx8UG9zaXRpdmUgZm9yIEhJVi0xIGFu
dGlib2RpZXMuCk5URXwzfEx8IApOVEV8NHxMfExhYm9yYXRvcnkgZXZpZGVuY2Ugb2YgSElWLTEg
aW5mZWN0aW9uIGlzIHByZXNlbnQgaW4gCk5URXw1fEx8cGF0aWVudHMgZ3JlYXRlciB0aGFuIDI0
IG1vbnRocyBvZiBhZ2UuIApOVEV8NnxMfCAKTlRFfDd8THxJbiBwYXRpZW50cyBsZXNzIHRoYW4g
MjQgbW9udGhzIG9mIGFnZSwgYSBwb3NpdGl2ZSBISVYtMQpOVEV8OHxMfEFudGlib2R5IERpZmZl
cmVudGlhdGlvbiBhc3NheSByZXN1bHQgbWF5IHJlcHJlc2VudCAKTlRFfDl8THxwYXNzaXZlIHRy
YW5zZmVyIG9mIG1hdGVybmFsIGFudGlib2R5LiBJbiBwYXRpZW50cyBsZXNzCk5URXwxMHxMfHRo
YW4gMjQgbW9udGhzIG9mIGFnZSwgdGVzdGluZyB0aGUgcGF0aWVudCdzIHNwZWNpbWVuCk5URXwx
MXxMfHdpdGggdGhlIEhJVi0xIFJOQSBRdWFsaXRhdGl2ZSBUTUEgYXNzYXkgKHRlc3QgY29kZSAK
TlRFfDEyfEx8MTYxODUpIG9yIHRoZSBISVYtMSBETkEsIFF1YWxpdGF0aXZlLCBQQ1IgYXNzYXkg
KHRlc3QgCk5URXwxM3xMfGNvZGUgODQwMSkgaXMgcmVjb21tZW5kZWQgdG8gY29uZmlybSBISVYt
MSBpbmZlY3Rpb24uCk5URXwxNHxMfCAKTlRFfDE1fEx8UExFQVNFIE5PVEU6IFRoaXMgaW5mb3Jt
YXRpb24gaGFzIGJlZW4gZGlzY2xvc2VkIHRvCk5URXwxNnxMfHlvdSBmcm9tIHJlY29yZHMgd2hv
c2UgY29uZmlkZW50aWFsaXR5IG1heSBiZQpOVEV8MTd8THxwcm90ZWN0ZWQgYnkgc3RhdGUgbGF3
LiAgSWYgeW91ciBzdGF0ZSByZXF1aXJlcyBzdWNoCk5URXwxOHxMfHByb3RlY3Rpb24sIHRoZW4g
dGhlIHN0YXRlIGxhdyBwcm9oaWJpdHMgeW91IGZyb20gCk5URXwxOXxMfG1ha2luZyBhbnkgZnVy
dGhlciBkaXNjbG9zdXJlIG9mIHRoZSBpbmZvcm1hdGlvbgpOVEV8MjB8THx3aXRob3V0IHRoZSBz
cGVjaWZpYyB3cml0dGVuIGNvbnNlbnQgb2YgdGhlIHBlcnNvbgpOVEV8MjF8THx0byB3aG9tIGl0
IHBlcnRhaW5zLCBvciBhcyBvdGhlcndpc2UgcGVybWl0dGVkIGJ5IGxhdy4KTlRFfDIyfEx8QSBn
ZW5lcmFsIGF1dGhvcml6YXRpb24gZm9yIHRoZSByZWxlYXNlIG9mIG1lZGljYWwgb3IKTlRFfDIz
fEx8b3RoZXIgaW5mb3JtYXRpb24gaXMgTk9UIHN1ZmZpY2llbnQgZm9yIHRoaXMgcHVycG9zZS4K
TlRFfDI0fEx8IApOVEV8MjV8THxGb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBwbGVhc2UgcmVm
ZXIgdG8KTlRFfDI2fEx8aHR0cDovL2VkdWNhdGlvbi5xdWVzdGRpYWdub3N0aWNzLmNvbS9mYXEv
RkFRMTA2Ck5URXwyN3xMfChUaGlzIGxpbmsgaXMgYmVpbmcgcHJvdmlkZWQgZm9yIGluZm9ybWF0
aW9uYWwvCk5URXwyOHxMfGVkdWNhdGlvbmFsIHB1cnBvc2VzIG9ubHkuKQpOVEV8Mjl8THwgClNQ
TXwxfDA0XjA0fHxVU1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8
MjAxNzA1MTAxMzM2MDAuMDAwLTA3MDB8MjAxNzA1MTEwODAxMDAuMDAwLTA3MDAKT1JDfFJFfDle
UVVFU1RfVE1FXzkwMDQ2MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8fDE0OTc4NzUw
MjVeS0FXRVNDSF5HQVJZXl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEgUFJPRkVTU0lP
TkFMIENPUlAuXl5eXl5eXl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxWRCBTVEUgMzAw
Xk1BSUwwMDBeV0VTVCBIT0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5eXl5eMzEwXjU3
OTI3NzgKT0JSfDd8OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXwxNzEz
NF5TUEVDIElEIE5PVElGSUNBVElPTl45OVFESXx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfHx8
fHx8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJfHx8fHx8MjAxNzA1MTEx
MTI4MzUuMDAwLTA3MDB8fHxGCk9CWHwxfHw4NjAwNjU1Nl5DT01NRU5UOl45OVFESV44MjUxLTFe
U2VydmljZSBDbW50IFhYWC1JbXBeTE58MXx8fHx8fHxGfHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3
MDB8fHx8fDIwMTcwNTExMDgwMTE4LjAwMC0wNzAwfHx8fFFVRVNUIERJQUdOT1NUSUNTLVdFU1Qg
SElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3fDg0MDEgRkFMTEJST09LIEFWRU5VRV5eV0VT
VCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0NzkwOTleVEVSUkFaQVNeRU5SSVFVRV5eTUReXl5e
Xl5eXk5QSV5FTgpOVEV8MXxMfFNwZWNpbWVuIGxhYmVscyBtdXN0IGluY2x1ZGUgdHdvIGZvcm1z
IG9mIHBhdGllbnQgCk5URXwyfEx8SUQuIE9ubHkgb25lIHVuaXF1ZSBpZGVudGlmaWVyIHdhcyBw
cmVzZW50IG9uIHRoZSAKTlRFfDN8THxzYW1wbGUocykuIFRoZSB0ZXN0aW5nIHlvdSByZXF1ZXN0
ZWQgd2lsbCBiZSAKTlRFfDR8THxwcm9jZXNzZWQ7IGhvd2V2ZXIsIGdvaW5nIGZvcndhcmQgcGxl
YXNlIHByb3ZpZGUgCk5URXw1fEx8dHdvIGlkZW50aWZpZXJzIGFzIHJlcXVpcmVkIGJ5IHRoZSBD
b2xsZWdlIG9mIApOVEV8NnxMfEFtZXJpY2FuIFBhdGhvbG9naXN0cyAoQ0FQKS4KU1BNfDF8fHxV
U1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8MjAxNzA1MTAxMzM2
MDAuMDAwLTA3MDB8MjAxNzA1MTEwODAxMTguMDAwLTA3MDAKT1JDfFJFfDleUVVFU1RfVE1FXzkw
MDQ2MDAzfFdIMzUwOTUxVF5RVUVTVF9UTUV8fENNfHx8fHx8fDE0OTc4NzUwMjVeS0FXRVNDSF5H
QVJZXl5eXl5eXl5eXk5QSXx8fHx8fHx8fFNBRkUgSVBDLEEgUFJPRkVTU0lPTkFMIENPUlAuXl5e
Xl5eXl5eOTAwNDYwMDN8NzkwNCBTQU5UQSBNT05JQ0EgQkxWRCBTVEUgMzAwXk1BSUwwMDBeV0VT
VCBIT0xMWVdPT0ReQ0FeOTAwNDYtNTE3MF5eT15eVVNBfF5eXl5eMzEwXjU3OTI3NzgKT0JSfDh8
OV5RVUVTVF9UTUVfOTAwNDYwMDN8V0gzNTA5NTFUXlFVRVNUX1RNRXw3OTleUlBSIChNT05JVE9S
KSBXL1JFRkxeOTlRREl8fHwyMDE3MDUxMDEzMzYwMC4wMDAtMDcwMHx8fHx8fHx8fDE0OTc4NzUw
MjVeS0FXRVNDSF5HQVJZXl5eXl5eXl5eXk5QSXx8fHx8fDIwMTcwNTExMTEyODM1LjAwMC0wNzAw
fHx8RgpPQlh8MXxTVHw0MDAxMDEwMF5SUFIgKE1PTklUT1IpIFcvUkVGTCBUSVRFUl45OVFESV4y
MDUwNy0wXlJQUiBTZXIgUWxeTE58MXxSRUFDVElWRXx8Tk9OLVJFQUNUSVZFfEF8fHxGfHx8MjAx
NzA1MTExMTI4MzUuMDAwLTA3MDB8fHx8fDIwMTcwNTExMDg0MDE1LjAwMC0wNzAwfHx8fFFVRVNU
IERJQUdOT1NUSUNTLVdFU1QgSElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3fDg0MDEgRkFM
TEJST09LIEFWRU5VRV5eV0VTVCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0NzkwOTleVEVSUkFa
QVNeRU5SSVFVRV5eTUReXl5eXl5eXk5QSV5FTgpOVEV8MXxMfFRoZSBSUFIgaXMgYSBub24tdHJl
cG9uZW1hbC1zcGVjaWZpYyB0ZXN0OyB0aGVyZWZvcmUsIApOVEV8MnxMfGEgdHJlcG9uZW1hbC1z
cGVjaWZpYyBjb25maXJtYXRvcnkgdGVzdCBzaG91bGQgYmUgCk5URXwzfEx8cGVyZm9ybWVkIHVu
bGVzcyBwcmlvciBzeXBoaWxpcyBpbmZlY3Rpb24gaGFzIGJlZW4gCk5URXw0fEx8ZG9jdW1lbnRl
ZCBmb3IgdGhpcyBwYXRpZW50LgpTUE18MXwwMV4wMXx8VVNQRUNeU291cmNlLCBVbnNwZWNpZmll
ZF5ITDcwNDg3fHx8fHx8fHx8fHx8fDIwMTcwNTEwMTMzNjAwLjAwMC0wNzAwfDIwMTcwNTExMDgw
MTE4LjAwMC0wNzAwCk9SQ3xSRXw5XlFVRVNUX1RNRV85MDA0NjAwM3xXSDM1MDk1MVReUVVFU1Rf
VE1FfHxDTXx8fHx8fHwxNDk3ODc1MDI1XktBV0VTQ0heR0FSWV5eXl5eXl5eXl5OUEl8fHx8fHx8
fHxTQUZFIElQQyxBIFBST0ZFU1NJT05BTCBDT1JQLl5eXl5eXl5eXjkwMDQ2MDAzfDc5MDQgU0FO
VEEgTU9OSUNBIEJMVkQgU1RFIDMwMF5NQUlMMDAwXldFU1QgSE9MTFlXT09EXkNBXjkwMDQ2LTUx
NzBeXk9eXlVTQXxeXl5eXjMxMF41NzkyNzc4fHx8fHx8fHw3OTleUlBSIChNT05JVE9SKSBXL1JF
RkxeOTlRREleNDEwMDAwMDc5OV5eVU5JVENPREUKT0JSfDl8OV5RVUVTVF9UTUVfOTAwNDYwMDN8
V0gzNTA5NTFUXlFVRVNUX1RNRXwlMzYyMDNeUlBSIFRJVEVSXjk5UURJfHx8MjAxNzA1MTAxMzM2
MDAuMDAwLTA3MDB8fHx8R3x8fHx8MTQ5Nzg3NTAyNV5LQVdFU0NIXkdBUlleXl5eXl5eXl5eTlBJ
fHx8fHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHxGfDQwMDEwMTAwJlJQUiAoTU9OSVRPUikg
Vy9SRUZMIFRJVEVSJjk5UURJJjIwNTA3LTAmUlBSIFNlciBRbCZMTnx8fDkmUVVFU1RfVE1FXzkw
MDQ2MDAzXldIMzUwOTUxVCZRVUVTVF9UTUV8fHx8fHx8fHx8fHx8fHx8fHx8fHw3OTleUlBSIChN
T05JVE9SKSBXL1JFRkxeOTlRREleNDEwMDAwMDc5OV5eVU5JVENPREUKT0JYfDF8U058ODYwMDc0
MDheUlBSIFRJVEVSXjk5UURJXjMxMTQ3LTJeUlBSIFNlci1UaXRyXkxOfDF8XjFeOl4xNnx8fEh8
fHxGfHx8MjAxNzA1MTExMTI4MzUuMDAwLTA3MDB8fHx8fDIwMTcwNTExMDg0MDM0LjAwMC0wNzAw
fHx8fFFVRVNUIERJQUdOT1NUSUNTLVdFU1QgSElMTFNeXl5eXl5GSV5DTElBXl4wNUQwNjQyODI3
fDg0MDEgRkFMTEJST09LIEFWRU5VRV5eV0VTVCBISUxMU15DQV45MTMwNC0zMjI2fDEzNjY0Nzkw
OTleVEVSUkFaQVNeRU5SSVFVRV5eTUReXl5eXl5eXk5QSV5FTgpTUE18MXwwMV4wMXx8VVNQRUNe
U291cmNlLCBVbnNwZWNpZmllZF5ITDcwNDg3fHx8fHx8fHx8fHx8fDIwMTcwNTEwMTMzNjAwLjAw
MC0wNzAwfDIwMTcwNTExMDgwMTAwLjAwMC0wNzAwCk9SQ3xSRXw5XlFVRVNUX1RNRV85MDA0NjAw
M3xXSDM1MDk1MVReUVVFU1RfVE1FfHxDTXx8fHx8fHwxNDk3ODc1MDI1XktBV0VTQ0heR0FSWV5e
Xl5eXl5eXl5OUEl8fHx8fHx8fHxTQUZFIElQQyxBIFBST0ZFU1NJT05BTCBDT1JQLl5eXl5eXl5e
XjkwMDQ2MDAzfDc5MDQgU0FOVEEgTU9OSUNBIEJMVkQgU1RFIDMwMF5NQUlMMDAwXldFU1QgSE9M
TFlXT09EXkNBXjkwMDQ2LTUxNzBeXk9eXlVTQXxeXl5eXjMxMF41NzkyNzc4Ck9CUnwxMHw5XlFV
RVNUX1RNRV85MDA0NjAwM3xXSDM1MDk1MVReUVVFU1RfVE1FfEVuaGFuY2VkUERGUmVwb3J0MV5F
bmhhbmNlZCBQREYgUmVwb3J0IFdIMzUwOTUxVC0xXjk5UURJfHx8MjAxNzA1MTAxMzM2MDAuMDAw
LTA3MDB8fHx8fHx8fHwxNDk3ODc1MDI1XktBV0VTQ0heR0FSWV5eXl5eXl5eXl5OUEl8fHx8fHwy
MDE3MDUxMTExMjgzNS4wMDAtMDcwMHx8fEYKT0JYfDF8RUR8RW5oYW5jZWRQREZSZXBvcnQxXkVu
aGFuY2VkIFBERiBSZXBvcnQgV0gzNTA5NTFULTFeOTlRREl8fFRNRV5JTV5eQmFzZTY0XkpWQkVS
aTB4TGpVS0plTGp6OU1LTXlBd0lHOWlhZ284UEM5TVpXNW5kR2dnTVRBdlJtbHNkR1Z5TDBac1lY
UmxSR1ZqYjJSbFBqNXpkSEpsWVcwS2VKd3I1QUlBQU80QWZBcGxibVJ6ZEhKbFlXMEtaVzVrYjJK
cUNqUWdNQ0J2WW1vS1BEd3ZUR1Z1WjNSb0lEWXpMMFpwYkhSbGNpOUdiR0YwWlVSbFkyOWtaVDQr
YzNSeVpXRnRDbmljVXdqa0t1UnlDdUhTajhnMFViQlVDRW5qTWxRd0FFSkRCVk5qSXdWakE0V1FY
QzZOQUVkM1Z3VlRCWDgzQlZQTmtDd3UxeEN1UUM0QVZra0wxUXBsYm1SemRISmxZVzBLWlc1a2Iy
SnFDalVnTUNCdlltb0tQRHd2VEdWdVozUm9JREV3TDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlQ0
K2MzUnlaV0Z0Q25pY0srUUNBQUR1QUh3S1pXNWtjM1J5WldGdENtVnVaRzlpYWdvMklEQWdiMkpx
Q2p3OEwweGxibWQwYUNBMk15OUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVStQbk4wY21WaGJRcDRu
Rk1JNUNya2Nncmgwby9JTkZLd1ZBaEo0ekpVTUFCQ1F3VlRZeU1GWXdPRmtGd3VqUUJIZDFjRll3
Vi9Od1ZUelpBc0x0Y1Fya0F1QUZYUEM5RUtaVzVrYzNSeVpXRnRDbVZ1Wkc5aWFnbzNJREFnYjJK
cUNqdzhMMHhsYm1kMGFDQXhNQzlHYVd4MFpYSXZSbXhoZEdWRVpXTnZaR1UrUG5OMGNtVmhiUXA0
bkN2a0FnQUE3Z0I4Q21WdVpITjBjbVZoYlFwbGJtUnZZbW9LT0NBd0lHOWlhZ284UEM5TVpXNW5k
R2dnTmpNdlJtbHNkR1Z5TDBac1lYUmxSR1ZqYjJSbFBqNXpkSEpsWVcwS2VKeFRDT1FxNUhJSzRk
S1B5RFJVc0ZRSVNlTXlWREFBUWtNRlUyTWpCV01EaFpCY0xvMEFSM2RYQlNNRmZ6Y0ZVODJRTEM3
WEVLNUFMZ0JWa2d2UENtVnVaSE4wY21WaGJRcGxibVJ2WW1vS09TQXdJRzlpYWdvOFBDOU1aVzVu
ZEdnZ01UQXZSbWxzZEdWeUwwWnNZWFJsUkdWamIyUmxQajV6ZEhKbFlXMEtlSndyNUFJQUFPNEFm
QXBsYm1SemRISmxZVzBLWlc1a2IySnFDakV3SURBZ2IySnFDanc4TDB4bGJtZDBhQ0EyTXk5R2FX
eDBaWEl2Um14aGRHVkVaV052WkdVK1BuTjBjbVZoYlFwNG5GTUk1Q3JrY2dyaDBvL0lORmF3VkFo
SjR6SlVNQUJDUXdWVFl5TUZZd09Ga0Z3dWpRQkhkMWNGRXdWL053VlR6WkFzTHRjUXJrQXVBRllN
QzlNS1pXNWtjM1J5WldGdENtVnVaRzlpYWdveE1TQXdJRzlpYWdvOFBDOU1aVzVuZEdnZ01UQXZS
bWxzZEdWeUwwWnNZWFJsUkdWamIyUmxQajV6ZEhKbFlXMEtlSndyNUFJQUFPNEFmQXBsYm1SemRI
SmxZVzBLWlc1a2IySnFDakV5SURBZ2IySnFDanc4TDB4bGJtZDBhQ0EyTWk5R2FXeDBaWEl2Um14
aGRHVkVaV052WkdVK1BuTjBjbVZoYlFwNG5GTUk1Q3JrY2dyaDBvL0lORkN3VkFoSjR6SlVNQUJD
UXdWVFl5TUZZd09Ga0Z3dWpRQkhkMWVnaUwrYmdxbG1TQmFYYXdoWElCY0FWVlVMelFwbGJtUnpk
SEpsWVcwS1pXNWtiMkpxQ2pFMUlEQWdiMkpxQ2p3OEwweGxibWQwYUNBeU5qUTJMMFpwYkhSbGNp
OUdiR0YwWlVSbFkyOWtaVDQrYzNSeVpXRnRDbmljdlZwdGI5czRFdjZlWHlGZ3YyeUJXaUVwNmkx
M09NQjFuTlI3aVozYVJvTmlkejhvanB3SWEwdXVMWGV2OSt0dktKRVVSVXF5MHVUcTFxMUV6WkRQ
ekhEZUtHTUx3WjhCaG4vOGtGaXI3ZG5YTTF5TVlRc0g3Rzh4NUFkMkVJUWxyWU50Ri81M0hCdTdD
S0dDNlh5eXhkWmxkdmJwN01QeTdQekt0YWkxWFBPSllITHNVSXRTbTJEUFdtNnQzMysxM2xsL1dz
dmZnQktla1RxcEY5cU9ReENDUzJRVHorRHdMWXhySERSQU5uSURoS2tWMmpnczZlZnhMdHZuN3l6
RytPc2lqL0xqNFlMZlhTVnB0SkhUNlZCZDN3VU10dXVRa3d1N0NLRDZKQXc4aS9pd01tS2dDNmJG
N1dUNThUMWY3N2ZKelEyZlpMd0VYU0tMdXJZWFVLYTZyVFZBdHVPeEVZZFF4cit4Q1BKdHhPWnlP
NFk1UHh2MmJJK1d3NTZOS0Z3Nk1Gek9xZ3c4Vy9kbjZSbG9GUGtCZGVBNTlha0xvdGpZb3o3eXJQ
bjEyZTkvZ2x5UE1PU1RRcFMvenlRNENiY0Z4UUlzLy9XczhXR054L1h0QUVtQkpISVlwcFMyUy9O
RDRGK0d4cENnZXJpRm1WWFNRaWxOa09YWUQrRkZ0U1U3WWRaSkJ3S1FwREkzRmFxWnk5Z2RkWkZl
QnIrQVhxMmxhMnNoZ29JUDd1bldITWl4Q2JWY3h3NERGSWJjY2UraVBJbFQ0Ym1UZEozdHR6Q1Vw
YW9MQVREZHBqVnBLWEtiN3FYOEZGSGJjOEl3b0RVdE1KMDdYbUdPdDloOU5ZZzZoTktROWRHU1Ns
V2VBbFJhcHdYOEQ2RTh0WDZGVXR1Ym1pZEx2VFdoZkoxYjFCZHJnNmhUMWRYZmF0b201RzlpYmwx
RkhWNUFXSjRETWlaWDNSY1d1M2lWYk9PMDJ4bVlwb0VsOUVMTmxPcXdkQVhYOTJ6SEJidTQrbkJO
WDVBR213SXhLRjl5djM3dk5lS3VBOVQ4cFE1VEoyNFNValVDNDY3ZnUwYm9iaEg4UlJMaU1QU1po
Qnl0REl6NitwVk05UTB1OVZJUEJhNGlrd0gyZGR1M2NjMDJ3QzNFamZaczNUSk40dnpmUWxpTDUx
RVUyTVJoN3FZNTNtaHpPZ2NaNmRvc2J0alVNSGZBOEt1bGd6THdOcFZDejRDSVBTaHNpVm80bGdq
WnVFVFVndnhOWXJjQm9zS3FERmQwUWNCM1MxblExSVpRZlNaSjBDUkliZndWbFhBalNFMFlWS2Rx
UUc3V2EwMzFwYjVyWGlHRHNXVlFIUkMzQW9DMlBCZm9DNWZBWVFDcHlRWVhaVHo3dUZoUnRJWVZM
V1h0SC9jdnJUOHFscTVhc282bVNIb29SbWFCR0VKdmhYMklLK1UwbDdNUG9wUEQ1SndFNXpoMEF6
NlZaQXlCMHdrZ3V1amN3K3V4NEpaY3JBbHNXaGhEZnhkZ0J5RmE4bDdINldPOHY5RFhjcUg5cEto
c1dPc010K1ZLYmRCMGNvTzBSRUVJNjBZaHBmQUMrVGxMNHk0UUd2MzB1Z2xGT2JYajJzUUZBRjVq
N1gzWnRZckd1aGhlalVIUjVhZDlRZXJib1E5Y0hOdkhPTnJrejczVzB6Z0QxL014UXFHSFNFQ3A1
eXRMeWc2aHEycFV5OU5BalJsVlBmald3YTlmYmMzdWExRkZRVm9MQVMwUy9IQU83UVJSWWEwRk56
RWdJNGtSdUJ2U2p0Undteml2ajlaR1Fta1JxREh4dEhVMnpkdmtiY0NlVEpMOFdFMExVMHJyNElX
Mjc5RHFCSXEzRG9aTEVZL3lta2ZqdVAvb3VDaDA4ZExncUJZSmlFM2RBaFUvWlB0NlRBNEpxNHc2
MXRHWVVQRnhPMVlKWFJ2N1ZJYkZtK2lCUjRoNXZPWlh2M1NzcDdHSHJVZDl5cElZRVR1QVlLS0g0
bTZkWSt6WUZGY3FIR1diVGJ6SzQ4Y09kRG9QY3M4eE9pY0krMGJFeEZRVTl6clR1VWlBem9Yajhl
dTd5eTdMWVFMYjFDbWNrcHR1RlNmZnVwRnFMQXdwUG9sVVl4SklVWENCY0Qra1RtQUhibVcvOGlT
M0c2bkcwZytweGlSMWlpOUlZQ0RWTysydUxrbnR5Z0kxd2xVZHorc0Q5Z3Y2TmIzQmJPK094WEF0
aERQMldqeFM1S3RGdnhhNWY3aDExaVZycUZrMWJOdFdJUlNGZFkwcldkZFY1Mm1TOGZXUnYzbHhR
d2dqQ3pkejlUZzNhTjZOYnlGSWovcWhPWVZWUGJpV2oybzkrQytpYUlkbWhFS1lkc3hLTVN4TFJa
Z0hKZ3dkMmN2ZkRpYzNNSzR6Vk90cStlbmZ3L3Z4WWlRYmxldmgvRXM3cjVacldCVXNxdG03MGZ1
aENDUHoyZFY0c1pqTXBzTWJQalNhemUvczlua3hGQmdCRTRLWHUzNklxSGlaTlp3dXhjUzNzK2xr
Skc0KzNIeStGRFJMQWNQcGtod1RaSHVZRlYyOEJCZ3ZscHp2NCt6bTVzdjliSFlwOUNDWEtTd3dj
TEdQcXRENHFmN1cwSWU2SFJvdTBSZ2FOZ2N5YkljOFE0eHVKdU9wV0hZeG5uK2VqTVlMWWU0QU5w
RUhMVnpnK0VhUFJ4eUkvNjQ2MWVKdVBKcmNqcWVDV3k5cFdJY1pNQ1R0MjN2L3BNSWtiaGtwK0pi
OGRJd1B1VkJJY2NPdkw1UG9LYzBPZWJJNmlNZjVjOHl2b3NNaFd5VVJwREErc01tZU12RXNGWVBS
WnRORzM3SVNIOWxHKzcvRWRiU1BqZVh6ZmZRWXEwVFp1bnRldTlXdU9BalZibDgzYWdBQnhlVkdu
ZDJDSFphTEM2V09DbXZrSWJKOEc0bjlmVFZjTENmVDY0dnBySDdFaG9tSS9VUmtJc0pPRllyakgz
N0ZJNVpsSG5rQUJhL1N4U1RpWG9sSXhodG80UE50TnpCZlZXTmRaQ2hhQWxpS09MYlBBOEN5MHVn
MDJzYkdsaVZZSEs4b1RCTnh3RCtQMGlmQlV5cGQzWTZFK1FFSldONVNtR2RIc2VCczNUaU5Nb01U
VUlqUlR2SEN1cG9CcXVwNEg2ZXJ1SUc5aXE4dWk1S1FMNmpLV3BUbVhEMmh1U0Vjb0hTeGpNUU5x
alNsNURvRjFnRHppUHh4OFpsREl5SzRYbDhMUDF0K3VST3hybkQvcThuSWdGUlRnaUtKaG04ODdR
TVFUT2hCaVVJVmdNTVBocUVyVzZtRXNBRlpQQzRqYkRkTXhWYTBEak5KSCtQL2ROaUhObXRkc1l0
N2dnSm1JRDdtNStJYTVVLzVUa29SWDBDZngvdmRQczdWVTNwRllLKzN3Q2JsVC9rTzJPZWw5UEpq
Q3V6M0Z0aWsvQ25mZjBLRmdGNUFQNDJmd0xiZmpMZ0VXYWUzcUNibFQva3lTUWNZY2wwSHpmanJN
Zm1XcmVUdmtoVDV3dDd5bVpRLzVmdXZFN0xwMzd1TUhSazFtUktqM3JLZUpFWEZvVW5mMlRUUzVY
TWlTNnJESWZyT3I0OTVza24rRzR0SCszaVZiUitTTkpKdFN2NTlGdzhPN09odG5hekVCR21lUE1Y
cG9RRWc2UTlRSTgxRkFmbVlySXZzbmJPQ2tZOUJ2aHlJczViMVB0c3F3eUtCSnVrNlhyRll5YXE5
WW1UWWdLOGxmemZoMDBoMzBzWmNVNGZqUmlocEZhVnBsa3Y4VUhPbVQ4ZmtJRjREUE1UNTM3SDh6
UVBvdU9vQ2kyclpRSGtxM3lrb05kSmRKS3MxcVJDaGo4bTZDVUZWaWtnR2NTOTJ4ZUhJTmtCUnZS
dFEreWRlbmZSQmxubFZaVjlxMWF6OVV4a3JpOXRzenk5aUVXUWFleFMyeXczQS9ST25UbnA0em80
YjBjRThWSkIzc2RMWkpFSjdkQ0NPTWNIMmY4bE51WlFBZC9HK2VBdGZsS2tHelA3cFRpZGRQVWY3
Q0t5MVQ5U2VTclpJaG9hSzYrZElLcmZheVEvVnBvVW1JSHJZd0padTNBVDlFNVpPdXBhbTNNV1A0
UEI3R1dSMjJlNjRLWW9mMllBbTIrMHh6U0JDN1NBRUpBZXA4MTM1a28vUkdkRDY1eHFkVkNKTDR5
eU44a2cwczRmVkh2UUNIbTRjZGtCMzNSTEQrL1FIakRmQVdMN1huZC9OK1lwL0ZLY2l5OW44ajNl
OUd3RWR5WXM2QVlMclVPN1A1K01yY2M2em5Dekg4NDd1UUdlZWo0ZWo1ZVR6dUhkelFMVFVOWjFO
QjlVa3BnbFZxVThsU0RCUi94U2xrMWErVzltbXlxclNmZEpCRGtFaFMrTnR0TkZUWnc2TzlJL0tF
L2N4T0VEOHZra3FRTm8vV2Vta0FrdzdrRldXcmhQMkc2QnMvMTNCSnZaNFU2Z3o4UFZQVXpvcGoz
M1NnNC9wSmo0SVRlNzJpZlM5dy9mZE0xUW80cEdlb3A2and6czlWaGt3KzZjb25mUXhXeDIzRUZr
a3ppcGM1VlU5eGNOUFV6Z29NZ2hoditOL2VUandpaTRiaVVhNzJuSW5IVkRqeEJkWXBLTCtIWG9i
OUVhdjAyaGxyQ25PMi80SFFjQlJxd3BsYm1SemRISmxZVzBLWlc1a2IySnFDakUySURBZ2IySnFD
anc4TDFSNWNHVXZXRTlpYW1WamRDOURiMnh2Y2xOd1lXTmxXeTlKUTBOQ1lYTmxaQ0F5TkNBd0lG
SmRMMU4xWW5SNWNHVXZTVzFoWjJVdlRtRnRaUzlKYlRFdlFtbDBjMUJsY2tOdmJYQnZibVZ1ZENB
NEwxZHBaSFJvSURJNE15OU1aVzVuZEdnZ016UXhPQzlJWldsbmFIUWdNVEV6TDBacGJIUmxjaTlH
YkdGMFpVUmxZMjlrWlQ0K2MzUnlaV0Z0Q25pYzdaMi9ydXU0RWNiZko5VW1nSkhITU5MdFE5eGky
MjFUcExoSWxTcDVnVlJCbWdCYnUwaVhLbFg2dkloWHVJTXo0SjEvbktGSVNmYjVQaENHajQ5RVVU
Si9tdUZ3S0QrZkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFS
QkVBUkJFQVJCUitoLy8vL1BQLy85VnlwLy9QdFBiZUhQdDdKdGRuWkxJZWh5MnJnZ2dqWmU3bi82
NGZiemIvSmwyMzRyeEJyNGdqNjV4aUNLQzFteHM4OE1nbzdUWmtxMmJ2L2xiNy96ak02QWtlTENX
TUZtUVc4dlFvbTdQYjNScng1VzVOMTFCMURzUTJLY0JiMnJZcFRNUHdWRVFBT0NTQUlsWFV5czRM
TkJrTkJHQkkrVlBIekU1N0JIRUdScVF5T3dTcnJBSkVHUUtUWk1RQW1DZG1wejJMUTdCNVFnYUVB
YlRVbVVOaE9HR1ZnSUNoVFR0QkhFcnpCTXBoNy8vV1VyWC8veGh4Ly8vSHNxMi9Yazk5dm4yMy9Q
YmlOMGtDZ0VFYURFYjJDWXRJaWpaSElJeU1yb3BTOFJqWnU2aG1sN2hXRVMycjUzc2tUVkFxeUV0
cXVoTDlIWmpScVJGNFVRS0cwbTdPeVdYazU1cStRVk1NWFNRRzEzcXJNYlZkWm1jVXhQanptaXNv
Z21zbmVVdk1kL3ZvcjIwd1NtV3IwQlVQRjhFek0xZDlCRWFZR1V6blQvUHFXV1czTDlvRWRNRTRj
ZzJqQUZtSXIxQmtDWmdRaTJTbk5wR2xnOFJRR1FDNUtsdi9yTXlDZ2ViWUdwVndlcUd5U2ZRaFBa
bzUxTzBhWGlpaDVOeVJHMHQvdHJkWjRWZW1tZ3RuNnVBeEh0dUdsL2VGeXMrTmhacmhNU01hMU1L
UjdsbVNxdkVuWWR1V1FPVWQzbCtSSDhGMlhNZExLdjI5WVRWMlVDVldyL2lUS0hUaTFRZTJneXJk
Szl0eXhSajZjMFU2ZTdmNlo5R1lqdWVuYks3RG5WKy9aQS9Mazd5c3VUMVoxSElFenkxK1Q2MWlw
dzl2YmJwdjBvQldTZGJxZk1yakpXVlo3TnBVQ1Y1dEc2VE1WUXhGaDE5NzNzdEZSc25vWTdiYnQ0
S2srUWVPM2FyQlBIVTdQTUUwdjNaQk9XZFVEbCszL21mS3Z6Q09KRU1vMjVvSjJLemRNd1RWUnR3
SkVZc29rMmRGbHJ5MW1Pbi9tTjczSHZreFV1QW1xQXB1Q1VCMnFyV3FndTBhZEk5L1A3dnN3aVBX
SWFRRWtYcjU1YnhmR2JHM1hYZCtEOVgrNkpRSG1CRVc1QU1JT21HMmxlbkxhcU50M1JIRWFaUUhG
cWNWdXVFNk9JemRPQU42WFh5QWR2dWtXVDdnMnZrczJiKzVRLzNiWDJmN01aU0ZjQVpicG4zdW5v
RTljVmltMENKOU9MYjd4aTJGdy9JSUxMR0UyNnE1Y0l5dkJsd3BWczdiYlpkc3IxNjJSb3VyL25W
YXQ3MFFxZ1NqY0g4OXpqQ2dldXpNc0IxYWJ0aWI0NjBPdW90cHZsbU0wdCtoQzNpdGUzYlQvRjY4
dDBxaW5WSGdEVVFGeGQ3eUtRRVVBTnNQQnlRSEhjWUwrenh3bnFHcVZGV09uNmswMjlmOHNNckY4
dHFYY0NTdnQ3R1lNUzEybEdMRXQyNnJXQWFsTWpSSit2OWplUlplRlpQYStJNVlyaXozeEoycDBT
ZllIZXllVWJzeVlhbWZhL1hzdzh2MVQ1dFlBU1llMjJlNWM4b2paQnZXU014T29xRXlYeGVXQ2hi
dW5nT1VVZzk0Y21GZ0YxU2xCQ0E5VXUyemVMR2U1clQ3OGI5TzZTOVZwQXRZbmxMUWpWbnRhR05i
cEFlUkNKVjVPdnJzRkt0cHhPZklyWGx3bDJyYWh6T2xCeHo4K1hzWW1rZk9yUmxZSHlRQ2laSnow
Szg1Z3k2UkNMRmx1VTlDZGRza3BBVFluMWFXdXk4eHMvWldKM2VENDMwOVI4SWxObUh1cXlRSG54
N1pKNUVqUjVLSm1tUnhmeHVXZXdnaEZXQ2FqYm1nQ0MyVEh5TXNjZGVyTzVRT2tLSndMRkRjaWtJ
WFZqajFjR3FtMG45OGxTRGZkRWVGeFRFR1BWTFMxaW91U0RFblRXVTRMbnVsZGt2dlIyL2NLaldj
YmI3V1BtUVJlTm9RWktKbGMydjFUNWhZQnFqUXUvbHN4VDhKQXhiOFMwc3dUV3FnUVVXNmdwS1JP
bEJJTjRyL3c5WDI4V0gyNVJsRytQTWplUUZ3S3F6YlZqcHZKM2JFNVl5bHVvNlVVRFc3VlE2MmFq
TWt6dFNhV3VIcTRiT1J5Ymg5cXZHSmtYQXVxTCt2bk9mTzhpWjYvTDBVN1hic0JhSmRzL0Y2aW5i
MjUyK2ovQk5HZ3B1cGhaWXpMY2RhZFBFN3dvVVB2TlUyQ2JXazhzNXVJdi8vcXRmdFVmZHVIS1J5
VGF3V09ld2E0OExycTVBWUdkQ2pwUE10ODcyRGlUeTVmTVBvcFp6aXdOZm5XZ1JFU2kycldtK0ho
TWlvbVA0TWpEcXJWVHlSdUNtTTRldllSU3NmK21uNTlBZjNianlWNXY5R3lpQ0FzRWg5QTFlNGJN
bXlGcTJ4Q3ZyZ29tY0hVTHUvRjh2UWJrOUxVYkdxalNlcUxBTm1VQ0VhWlZNaTBVbHdBclBrbzFJ
akVYcU9mVTJaenVQVG1UaERDQWFqZFpLRmdQMWZVaFJUMWVVQ0xPc0RWUDhJSkE1ZU5kWDhLZlhl
dWFKODh3dGV3SXIwK2daR0tWdnlGOCtYN3dPSG9KYmVVbk1hdE02VDVUV2wyZWQrZUcyOS9OakUy
MmMrQTByd1pVL2thZEhEMlpXQVVvZWViSmZHTWFxZndOWWV6RVM2bytTS0h0VHNHK3V0c2tPeTBa
aFNSUVkrM2ZreURSUmVPTmdZcm5ucExtU1Z1bHVIampyTFlrL1QxdG1uZGN4VWdEM1ltSEJvRTdw
OTJxcEd0WFhlNlVaeXFPdW5TZlJaYXBwK3ZmWGcybzB0SzhtMk9lNHFHVGlWSUpxeUQ2VngwQUR0
eEp4aFNNT0xnWG1hTjFJaVg1OEFRUHEzWmpYV0Z5OVVRd2hDazlsOCs3RHNuR2VEVlVGMWd0a2dD
cUZIRDJ6Rk5nbTdTek4xQUNPNVVQK09zbkJPNjRpalU5aWc5TjNYT0lkVFh2ci85UmYzcXR0L3R3
RzZaTEFKWGNpLzI5cW5tS0kzZzd5YXJPUng5cG9hQlBvaGFvZktjYWkrK05qWnZ5THQvQWZEU0Fn
cWFybW40VDU1WWZZNXRNckFaT2VXRHdDRUd4ZURTUjdGVGVqNFFLbWdSV1UwWlBBVk41OHlTZTd3
U2dvTGthQU1velQza0xOUmVvNm1LVDFzS1dvakVRMUJVUEtLcEFMUm85YmZXTE4xM3psRC9aTmox
K0lMd0pRVjF4WEtLMGJIekFRbzBacVM1VzFRZGZpQWJmaWduMkVOVFZHRkFERmlybUlsL29PZi9W
cC8yTDFWdnJRbng3Rm9hM05jeHQxWHVMcHA0dk1pZDFyeXg3SDdOUUdhOXY5V255ajhzTHBxWkhK
THgwaVB5MFBtVUN6RzNWUzZ2TEM2VklyYjRMOFYyUjc0M21UWktHUmFlUG9aWU9aT2dobk5yWld6
R0F1dm5MM3g3Zi8yNkxWOFBWRWdCT0YyWHhCZGZrbUt3SjVwb1NwWjdmdnV0WlFDMks4czIvQ3Qr
a3pSTmJxT2tEcUJnV0VtRjF6V1duRjFRWHFNT2FRVjlaTnhueW5uNk11VGNQbFVFcEdlV2Izc04x
TEdLZHYvZk1BZlg4NkNSZ0txT3JBVVcrWDVBWXZIVzVVcWFFWjZGbVRVWE52UTQ4MTZ5Wld1Rm41
akVaOXZ3SFBKeURNMUdydThRYmQ1OVpNYjFKTzMxSSt1M08wdUx4dVZHK2RlT3AxdGtUNW1sNmZJ
OVVzanRtL0lIdWZ1TEQ0WlVMNXVJTDNzczhGdmZlZHNTWFBGeitLWjNlOW5UbkY2ZWd0OUViZUEz
TE44bGNqejhXUDh3RGxjdysycDk2VkQwRnM2bmNCczNVb295akVsRDA5WW52eSt6a1BPd3luOFlR
UDhXbGRVN2F2Zmk5UGdWZTNpdWVoVUpreFE5ak1YY3hyd25iNkxadCtoRHNIbnR6RUI1UTdkSE5K
b2xkK05EbXRUS3ZzQ2VhNGtsdUdUdDcrMTIrS2VNcGl1eDV6dDY2K2R6cXlFajNUeE9vcC8vc08r
b0crcit4Uy9uMTQzZHFUS0NDWG1RZWpta3lkekVIaklGWk1TdVBvM3ptQnQ2VmVWcHVaTDQ5MDhV
WmdJdENFMVBzMU5iSWx2Rmp6Tk96RGhUSFlGa2VVSjdNSVVZbTZPRUZHK043c25tNG9PdDZlOUVu
UWZQRWxsV2dNazFxLzJzYTYyT2twM1dxUVlra1ZudU1DTG1tWGp2WHBSc05BSFZUUC9sWGpmN3BY
VXhuVXV0bXJTM3Rub0s0Q1NTREJ1Sk04N0c3QWFBRzRoakpLN1pJd1VKNHpSU1BvZkpHYWtxSDU0
QjVpOVZTOC9SY0R4U1BudG9WOUhvWGJmaVNSMzlhWHFpUXVKa251NkxlckJ1eUlBMEFOVUJIN0xV
ZUlKMDFFWmduN2ZWNVdNMmRpaklub1pabXc2NXorWUlubk9pREpwc1JCQ1h5ZXlWenBVeXZqeHNm
UEdGakdLaHVrM1E5b2ozVkduYks3SzVkc2dLZ1ZuUjEwY2pWaXpWS1FKbWVpUW1VQ0VEeDdvK1Bo
em1mQzFSK0xsdlhMSUxWT3ZnMkFOU2VmRWd4MFhCd29qS0Zwc2RDRS96aElwVGFSaDdnN0pGV2hN
MjdEb3pwOG1WNjFCU1hiOWhDNlEzTU1QVXhMcCt1TXdpd0x4VXRwdEJNeFVhS1VGcVJhMlNLWm5n
UE9GWWVLQzhRcCtuSXhPdEtjNTF4QXc0YlF5VmJkUXBRUVh1T0VXSFZCcXROVTdWQnRHMURIQjI4
c3UrWXcrVXZmakIvcElHS2U3anBkTVZ4NDlheDBhZFFBbW9zeWxldGYzV1VMOURwQzJyMFNzQlRD
RHBGR2FEaWdGTFZRbm0zMEllZjJNQnp2bFBHVU0raGVhaDgvUmxmMGZTY1MvTlFnVTRINmpPcjIv
bTcyU3lsTWRRanpPMTVOajhsUUpFci9yUE4xdE9uVUFYcUdVNEhtOGgvOVJjbVYyTXN3NWtTYlow
Nmg3RGQ4dURReFBFcUpmUWVLZTZ1b25DZVQ2YTdldjRialk3YjRON3RJeVd2Uy9HUEgwdDQybENo
NlN1T0FkVWF4RWVUYmVqeHpqZVc5cVM4dXczM2Y5NHNFN1V3dy9KZWsvalFYMVcyNVBFRHFJUEZl
WHFydzRNRE1xZUtiaC9QdzgvYzZJSjVLRjJuTjdHYmIrMHNvTHFOMUhwVXNydkZsdmt3b0Q1RTE5
eUw5Z1NYNHRWRnc3RTJoL3lhZG1xZEhzV2xSbkZWaTV5WmFpUHoydytmZUtsSnM2N3d4VVZ1bmdn
YmZrS21rdXAyaVc0a0FYcFh0U2pwcFNKZ3lwUVlkclgvaXNPTTBIc3JScW1kVFFaVFFtSlFJTjZE
cGs4bEhpNlpDeGpOWllQYjUyZTMrb3A2ZlA5RGFhZWtmVUluaWgwOHZmZ2lLUEQ2SUtnVnBWSzBL
T25rd0lDbXM1c1BRVmNSSlFHeTU1YXhSekJNMEh1cmxLM0h4bWlNSTlxWWtteFhueGNFbmFMV3lo
QXB1ckRuSmlhajc4M0R4c1dyZ0loUmdsV0NQb1BJN3BpNU41bWlhV3IvZGNCNld3aTZwb2dzYll3
Q2pyeC84ZnFwczg4SmdpNGhFWE9JYlJQRjlNaEZCRVFRMUZYN1c0UlVQdFVLUkFpQ0lBaUNJQWlD
SUFpQ0lBaUNJQWlDb1BmV3IyNlgzWGdLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ295TkNBd0lHOWlh
Z284UEM5TVpXNW5kR2dnTWpVNU5pOU9JRE12Um1sc2RHVnlMMFpzWVhSbFJHVmpiMlJsUGo1emRI
SmxZVzBLZUp5ZGxuZFVVOWtXaDgrOU43MVFraENLbE5CcmFGSUNTQTI5U0pFdUtqRUpFRXJBa0FB
aU5rUlVjRVJSa2FZSU1pamdnS05Ea2JFaWlvVUJVYkhyQkJsRTFIRndGQnVXU1dTdEdkKzhlZS9O
bTk4ZjkzNXJuNzNQM1dmdmZkYTZBSkQ4Z3dYQ1RGZ0pnQXloV0JUaDU4V0lqWXRuWUFjQkRQQUFB
MndBNEhDenMwSVcrRVlDbVFKODJJeHNtUlA0RjcyNkRpRDUreXJUUDR6QkFQK2ZsTGxaSWpFQVVK
aU01L0w0MlZ3WkY4azRQVmVjSmJkUHlaaTJORTNPTUVyT0lsbUNNbGFUYy9Jc1czejJtV1VQT2ZN
eWhEd1p5M1BPNG1YdzVOd240NDA1RXI2TWtXQVpGK2NJK0xreXZpWmpnM1JKaGtER2IrU3hHWHhP
TmdBb2t0d3U1bk5UWkd3dFk1SW9Nb0l0NDNrQTRFakpYL0RTTDFqTXp4UExEOFhPekZvdUVpU25p
QmttWEZPR2paTVRpK0hQejAzbmk4WE1NQTQzalNQaU1kaVpHVmtjNFhJQVpzLzhXUlI1YlJteUlq
dllPRGs0TUcwdGJiNG8xSDlkL0p1UzkzYVdYb1IvN2hsRUgvakQ5bGQrbVEwQXNLWmx0ZG42aDIx
cEZRQmQ2d0ZRdS8ySHpXQXZBSXF5dm5VT2ZYRWV1bnhlVXNUaUxHY3JxOXpjWEVzQm4yc3BMK2p2
K3A4T2YwTmZmTTlTdnQzdjVXRjQ4NU00a25ReFExNDNibVo2cGtURXlNN2ljUGtNNXArSCtCOEgv
blVlRmhIOEpMNklMNVJGUk11bVRDQk1sclZieUJPSUJabENoa0Q0bjVyNEQ4UCtwTm01bG9uYStC
SFFsbGdDcFNFYVFINGVBQ2dxRVNBSmUyUXIwTzk5QzhaSEEvbk5pOUdabUozN3o0TCtmVmU0VFA3
SUZpUi9qbU5IUkRLNEVsSE83SnI4V2dJMElBQkZRQVBxUUJ2b0F4UEFCTGJBRWJnQUQrQURBa0Vv
aUFSeFlESGdnaFNRQVVRZ0Z4U0F0YUFZbElLdFlDZW9CbldnRVRTRE5uQVlkSUZqNERRNEJ5NkJ5
MkFFM0FGU01BNmVnQ253Q3N4QUVJU0Z5QkFWVW9kMElFUElITEtGV0pBYjVBTUZReEZRSEpRSUpV
TkNTQUlWUU91Z1VxZ2Nxb2Jxb1dib1crZ29kQnE2QUExRHQ2QlJhQkw2RlhvSEl6QUpwc0Zhc0JG
c0JiTmdUemdJam9RWHdjbndNamdmTG9LM3dKVndBM3dRN29SUHc1ZmdFVmdLUDRHbkVZQVFFVHFp
aXpBUkZzSkdRcEY0SkFrUklhdVFFcVFDYVVEYWtCNmtIN21LU0pHbnlGc1VCa1ZGTVZCTWxBdktI
eFdGNHFLV29WYWhOcU9xVVFkUW5hZysxRlhVS0dvSzlSRk5SbXVpemRITzZBQjBMRG9abllzdVJs
ZWdtOUFkNkxQb0VmUTQraFVHZzZGampER09HSDlNSENZVnN3S3pHYk1iMDQ0NWhSbkdqR0dtc1Zp
c090WWM2NG9OeFhLd1ltd3h0Z3A3RUhzU2V3VTdqbjJESStKMGNMWTRYMXc4VG9ncnhGWGdXbkFu
Y0Zkd0U3Z1p2QkxlRU8rTUQ4WHo4TXZ4WmZoR2ZBOStDRCtPbnlFb0U0d0pyb1JJUWlwaExhR1Mw
RVk0UzdoTGVFRWtFdldJVHNSd29vQzRobGhKUEVROFR4d2x2aVZSU0dZa05pbUJKQ0Z0SWUwbm5T
TGRJcjBnazhsR1pBOXlQRmxNM2tKdUpwOGgzeWUvVWFBcVdDb0VLUEFVVml2VUtIUXFYRkY0cG9o
WE5GVDBWRnlzbUs5WW9YaEVjVWp4cVJKZXlVaUpyY1JSV3FWVW8zUlU2WWJTdERKVjJVWTVWRGxE
ZWJOeWkvSUY1VWNVTE1XSTRrUGhVWW9vK3lobktHTlVoS3BQWlZPNTFIWFVSdXBaNmpnTlF6T21C
ZEJTYWFXMGIyaUR0Q2tWaW9xZFNyUktua3FOeW5FVktSMmhHOUVENk9uME12cGgrblg2TzFVdFZV
OVZ2dW9tMVRiVks2cXYxZWFvZWFqeDFVclUydFZHMU42cE05UjkxTlBVdDZsM3FkL1RRR21ZYVlS
cjVHcnMwVGlyOFhRT2JZN0xITzZja2ptSDU5eldoRFhOTkNNMFYyanUweHpRbk5iUzF2TFR5dEtx
MGpxajlWU2JydTJobmFxOVEvdUU5cVFPVmNkTlI2Q3pRK2Vrem1PR0NzT1RrYzZvWlBReHBuUTFk
ZjExSmJyMXVvTzZNM3JHZWxGNmhYcnRldmYwQ2Zvcy9TVDlIZnE5K2xNR09nWWhCZ1VHclFhM0Rm
R0dMTU1VdzEyRy9ZYXZqWXlOWW93MkdIVVpQVEpXTXc0d3pqZHVOYjVyUWpaeE4xbG0wbUJ5elJS
anlqSk5NOTF0ZXRrTU5yTTNTekdyTVJzeWg4MGR6QVhtdTgySExkQVdUaFpDaXdhTEcwd1MwNU9a
dzJ4bGpsclNMWU10Q3kyN0xKOVpHVmpGVzIyejZyZjZhRzF2blc3ZGFIM0hobUlUYUZObzAyUHpx
NjJaTGRlMnh2YmFYUEpjMzdtcjUzYlBmVzVuYnNlMzIyTjMwNTVxSDJLL3diN1gvb09EbzRQSW9j
MWgwdEhBTWRHeDF2RUdpOFlLWTIxbW5YZENPM2s1clhZNjV2VFcyY0ZaN0h6WStSY1hwa3VhUzR2
TG8zbkc4L2p6R3VlTnVlcTVjbHpyWGFWdURMZEV0NzF1VW5kZGQ0NTdnL3NERDMwUG5rZVR4NFNu
cVdlcTUwSFBaMTdXWGlLdkRxL1hiR2YyU3ZZcGI4VGJ6N3ZFZTlDSDRoUGxVKzF6MzFmUE45bTMx
WGZLejk1dmhkOHBmN1Iva1A4Mi94c0JXZ0hjZ09hQXFVREh3SldCZlVHa29BVkIxVUVQZ3MyQ1Jj
RTlJWEJJWU1qMmtMdnpEZWNMNTNlRmd0Q0EwTzJoOThLTXc1YUZmUitPQ1E4THJ3bC9HR0VUVVJE
UnY0QzZZTW1DbGdXdklyMGl5eUx2UkpsRVNhSjZveFdqRTZLYm8xL0hlTWVVeDBoanJXSlh4bDZL
MDRnVHhIWEhZK09qNDV2aXB4ZjZMTnk1Y0R6QlBxRTQ0Zm9pNDBWNWl5NHMxbGljdnZqNEVzVWxu
Q1ZIRXRHSk1Za3RpZTg1b1p3R3p2VFNnS1cxUzZlNGJPNHU3aE9lQjI4SGI1THZ5aS9uVHlTNUpw
VW5QVXAyVGQ2ZVBKbmlubEtSOGxUQUZsUUxucWY2cDlhbHZrNExUZHVmOWlrOUpyMDlBNWVSbUhG
VVNCR21DZnN5dFRQek1vZXp6TE9LczZUTG5KZnRYRFlsQ2hJMVpVUFppN0s3eFRUWno5U0F4RVN5
WGpLYTQ1WlRrL01tTnpyM1NKNXluakJ2WUxuWjhrM0xKL0o5ODc5ZWdWckJYZEZib0Z1d3RtQjBw
ZWZLK2xYUXFxV3JlbGZycnk1YVBiN0diODJCdFlTMWFXdC9LTFF1TEM5OHVTNW1YVStSVnRHYW9y
SDFmdXRiaXhXS1JjVTNOcmhzcU51STJpallPTGhwN3FhcVRSOUxlQ1VYUzYxTEswcmZiK1p1dnZp
VnpWZVZYMzNha3JSbHNNeWhiTTlXekZiaDF1dmIzTGNkS0ZjdXp5OGYyeDZ5dlhNSFkwZkpqcGM3
bCt5OFVHRlhVYmVMc0V1eVMxb1pYTmxkWlZDMXRlcDlkVXIxU0kxWFRYdXRadTJtMnRlN2VidXY3
UEhZMDFhblZWZGE5MjZ2WU8vTmVyLzZ6Z2FqaG9wOW1IMDUreDQyUmpmMmY4MzZ1cmxKbzZtMDZj
Tis0WDdwZ1lnRGZjMk96YzB0bWkxbHJYQ3JwSFh5WU1MQnk5OTRmOVBkeG15cmI2ZTNseDRDaHlT
SEhuK2IrTzMxdzBHSGU0K3dqclI5Wi9oZGJRZTFvNlFUNmx6ZU9kV1YwaVh0anVzZVBocDR0TGZI
cGFmamU4dnY5eC9UUFZaelhPVjQyUW5DaWFJVG4wN21uNXcrbFhYcTZlbmswMk85UzNydm5Jazlj
NjB2dkcvd2JORFo4K2Q4ejUzcDkrdy9lZDcxL0xFTHpoZU9YbVJkN0xya2NLbHp3SDZnNHdmN0h6
b0dIUVk3aHh5SHVpODdYZTRabmpkODRvcjdsZE5YdmErZXV4Wnc3ZExJL0pIaDYxSFhiOTVJdUNH
OXlidjU2RmI2cmVlM2MyN1AzRmx6RjMyMzVKN1N2WXI3bXZjYmZqVDlzVjNxSUQwKzZqMDY4R0RC
Z3p0ajNMRW5QMlgvOUg2ODZDSDVZY1dFemtUekk5dEh4eVo5Snk4L1h2aDQvRW5XazVtbnhUOHIv
MXo3ek9UWmQ3OTQvREl3RlRzMS9sejAvTk92bTErb3Y5ai8wdTVsNzNUWTlQMVhHYTltWHBlOFVY
OXo0QzNyYmYrN21IY1RNN252c2U4clA1aCs2UGtZOVBIdXA0eFBuMzREOTRUeit3cGxibVJ6ZEhK
bFlXMEtaVzVrYjJKcUNqSTVJREFnYjJKcUNqdzhMMHhsYm1kMGFDQTFOalE1TDBacGJIUmxjaTlH
YkdGMFpVUmxZMjlrWlQ0K2MzUnlaV0Z0Q25pY3ZWMWJjeHMzc243WHIyRFZlVGgyMVhvMHdOejlK
dHUwclYxWmRpUWxxVlN5RHhRMXNxYVdGNFdrNHMzNTlRZVlHUURkUUdNNEltanZiallraU12M2RU
ZlEzVE1BeENheCtPOHJKdjZ2cVBoa3ZqejU4NFMxWld6Q1N2bS90cWdvbzdLc3Vyb0ppekx4N3lT
SldCYkhjZHZvOUh6Skp1L1dKeitkdkxrNU9YMmZUZExKelgzZmtlaWNKZWtrVFNQTzhzbk5jdkw3
aThuTHliOG5OLzhVTmNWdkhGZk5xeWhKZUJ5TGozSEVjNmRGTVdFTXRVakxPSXF6TW1icHBJcFkx
ZFcvcWgvWG05M0xpV3o0NG5vMzJ6MXRYL2ZmM2plcjJVSjNaMFBOaWt4Z2lMS0U3eDA0aXdYVWds
ZGxQdUdGR0RtV29OdEcxNS9PYno3K294L3ZuK2NYRjMwbjB4c2h5M2lTWmxGZXBsSjB5OG1yT0Vw
eVdaTHdWTFpmVEhoY1JMSHNLeHNvN3R2TDRqekswNjQ0aitKVWZFeEVjZGNyS0hpWS9IcXlPaEVT
allzeVRjVHZhWkZtZ2tyRThyU0k4OG5WaDVQZi95MTQzWW1pZ3JkVXZwMW9jQnF1QjhXMTBQeWZK
K1NQcUUxV1JHV3NDV25rb2poTlV6K2JnOEEvRDQzRHdQeTRGRDNEcXExUUtNaTY3Q0M4TVJweUVD
YXUra29CMHJWY280cVJ1aHpyd0pTZUI3K0Zic2F5cFhXdEZvVkNUTThNVGFBazR1a2tTNktxakt1
cW43aGZacnVtWHFtWmU3NjZYMitXb21pOWdsTklBTE4xaXRpbWNVWjkxL3pUT0kzeXBLcktGRWxC
eWp6SlczVWN3L29RUkJ0Q3AwaGMydFdDd2dOQXRYWTg0QTlDdVc5OGc5S3lUV3NtYTdsUktNT21C
UjdNQjlHdWhjWHZWUzJGL0NqcXRrVTBNQXU0OUhPaW11U0Y1OEwxWXoxdmx2VnFlREpJU1lzbVZW
NVpxb1RGZWlwa1JSNGxtZEJMWmhjamVRazNTQzNFUXZpNmRianRrYmd4UUd1K1lKaDJaWW9rVklK
c2piOW56dEx0SWY0c2hxeXFDc213UjZzWFJudDh3d2tidUpZTFhnb3l3TWtCRzJhKzVKZyt3SjdL
cEQ2OUprUFIrVzVMbUdmbXBYRVo4VVJPTjJ2aXZWM3M5MEdPdTNhREc5bTE2THVVK0dIb0FBcU9F
eW1NWEJCWnlvU2tlVlVsR0tFc2owdTNQQmpvWGhBR0t5ZzI5Y3BZRktRNm9FRkZNZTVKVjZDSW9Q
S0FTSmdFYVpHSmNTMEN1UnV2VWZHbGJUVUJIQnlUaVRHZ1hndFJ4aWQ1SnVxM1U0SlZwWEJOa1pp
aXNzMm1ia2RVcWFHcG04cjByNTlmVm43VURtMVNzb0drU005UUZyc0JZaVZ5SzFhSWRhWHI1dDNu
TnlxVFkveVVsNmVzeXNxK0s5MndFaTJUVXF3dWR1dXpEMVBWV3JlU1NTQTFNQlA1WGNtU09FNjd0
aC9xMVYyOWVXMlBsWW4wTTQyN2hCVTMrTlNONUlObVYzZXFkaWc0bDltb2NDbGtnUHh1Q0kvVjlQ
cnMvVlJJby9zUGhhMGJNTWtpbmdsWXZjZysxclBGN21IVWVGYkxNc3NMRnNkVkh2TXlUZk1DREtu
RCtLSFFEc2FRWURyQW9PM1lLOVM0QUZoK1IxTWZJRVh6MU1QZ1lFYzNDTUpnUlN1UUt0RFQzVmxk
Q2QrZ0pleWpFNzZrT3F1K2h4RHBIWHpwQjIwbXh3RzcxNVAxejc2c3RRVEU5M2tWRlVscUhoUDE4
YjB6cFhpZTlvR0oxZUxYajBrV1Z4bTdjVnFZUVVvZXBWa2JESFd4ekhxeHFPZTcrbTVnRkt0Sm5K
MnkrSlRIckhBV0NKYXFnTk5xYzZyVzVPUjFrdmVmdjd3YndsbGxFU3RTdmZwZDFmTzYrV3NRcHRW
Q3dtVDdZRnB0Rk15NGZCMnpVVENaTUtPeVN2UWkyajFaSE1ScE54a0YxRzZrQmNwZTg5SkJhbWQr
UTFFN3pCTEEvSUFSZVBqYTlJejh3VTU0L05tYUtrYXJsV3lPcGg3Z2h5YTZoL2ZCcVp6TmpJaWhM
R3hMTHdrZ3NLRnk0R0F5MkEvRk1YeVJvd2QzU0RnT2gyNDFJbytscmZFWVJFYTRTbnExTmptaHRm
U2luUEIvVkJBcGd1TlUrSmpFbnRpbUcydWQvTmZacjlQcnR6b08vbkIyOVJ1TWc5SGJsMEtFVmlK
d1ZRRzJnMVZVWTVIZzArRzdPSjllM3FnM0h0T3JYODdmVHE4VnpESVh1WkFJaGN1a2NHSmxub2gx
SzROZFhYK1p2ajMvTkwxVXJXMnZJeVAxVWlMeHEyWHpGY0xrV1ZTV1JwUS9QZFhiblpKQSs2WC8v
SzZaZlYydHQ3dG12bFUvN3g3cS90TnN1MTNQbTVsWWV2dUN4ZnJyV3YyMlVvV3p4Y0pYM3pOU1g3
S2NiZjZqUHM4MnRUUDhiak83cTJHbDlmMXd2NUZYcnl4dlg1cUp0STVYS2VPdDVXWnBKZjdOUzU1
a2laU2VyRnhFWEFRYVFxUXkvYnFYcitGa0FaTkIrckw3a1lzdTJ2d1JmR3AvYnorMVRSZWdHeldk
MkVUUEdpN0xaWDZJK3UzNzBOTkVwQzJ0dmlkSXJZeUxHVkxoNUVXd0hlUWx1eGN0eGRSdlUvTVVF
MlFpcDh4a09kTjRZRkZQRWxLSGNDRlIyR3dQZHloVkJ3QVFRdElKZ1VFaHBHbVV5S1dxUXNJNFg5
MkxrS3RaUDIyMVdXenIyYmJlamhTU1JDRWpWekdSQ0N0Z0JSZExXeXlmbzJuWW9LZ1hET2lES3Vy
SndTSWxPZERYSHNrNUhXSWtZNndJZEVHWkUvV0cySXhBdlNFMjYxcWFSRXlxc2lEcjdkT0JtaEdj
NjI2QUZyd0dVWmFSV0JEbGNwOGtVVlgwZEc3TUNuRTVXOVlqSWNDaFdmZEVvaHdGZ3VlSjhIV0Zm
TWdBVVZ6VjI2ZkZidVRnU1NLR2xQNVVUUTdPOGtoOGplTnhna2lTWExYSEdPN3JUYjJhcTJYMWFy
YjZPbFllV1ZySUxxdXkwcERVODZreGlFQnppT2hpZGp0Mi9MeU1oRkNyc3V6SHQ2YW0xOGhCUXpn
eU1zVXFFUU5tRTJsNE1sS0oyNjBWYlR6SkxBK1E4U2pyOHRyMlhhditwcDRjOGxidWJVRmZYWDlY
MFpTUHBPOXhNeGdSSXdCdnBFR2RWd3FJcnRXL2tkYkUyamZTOEp2enMwM2xlZEM3bDlLNlAxdFEv
Wk1GTTcrR0dOcEN4TTNDWkd2cms0U2s4SUlwT2FLTkJ5YnVKQXk5UjRBa1RwMGl0Yk9ReVFoOWZ4
TVBXTlJIR0FXUFRDbVUrK0toMW9TclNDNHdsWm5oTHo2ZS82SlMrVlBlZnpxN3ZEbi9NTDA4bGY5
KzgvbmRieXJhVmYrOC8venoxYzFIbFNOTUw2ZFhaemZubnk5VlBINTY5ZjdDMURZUEJNQTY0NUpw
Rno3SUJoY2I0YUpPd3FSTGpyeWNrRGpSTzE0d2MrRTdYckJBd0tjR2tGU1JXOS9OUXdCSUVyem1C
WjAraXlSNnpZc0JlMmlOa0lGSCtoNGFoeW5GWXlVRWJHanNsQisxekgxNmFheVJ0YTdNZE5pN3Nv
d3JWemJzVnZydkZiZjhnUzc0YnE1TWx1WnBGSmZhYzVodlBRNFJYdlZkZGtEaDl3Tnh3UkV4QXVO
aVlaM09vY0phcnRPbGd3TXMwc09oTytLTUNkQWovUnNYS1VvcEUwS00wRGFDNys5aVBSNE5GRU9P
QURhVW80Zk5NVjJzQjVCRFlzaXNiTXYxc0RsWTZIRHNBYnhlaDFwSkk4dmpLR2RtaFRITzlPekQ2
ZGtiNVRkVDZDeWQxNHpQaWxLU0pLYVVKenZKNUpPQjhydnBkREJzOHNRcG9CaktGWkNBcXZSd08y
Ymc1QUhra0JoaEhFRGtIaExCWnVxWktZTWtQRzBHb25EQ2JqemNmdEFTUWJyMTdubEorOURBbW5T
WG55OWZYVTNQM3Q2Yy96S0ZFMHVLU1k1UVVySHpubkJUUzBKMmNxeUo5VHhBTUI5cGY3Uk5vTzhL
VHl4RzZRMTJFcXBPY21SRWdwNVlSQnRTSGw2UmU3ajlzTlhoZWNrQ0x0WWtQRmIyNDdJWDgrTUk3
WG5zQm5ZU3FnbVBmWk00Q1JKREdRSk9Tb3dLYU0xODcxeUZTTEc4S2FJcVJyb29jdXU3Wm9kMFE1
TStPSE8wYVJIYVFLVmUxWG1NeGtNalZCc0lFQUdiZERIeW1iQmFZY2E1bU9IRXFQOHU5eFNEakFZ
VWZMZGtUSlltVmRtK2lCQWR5dVFIZk8yUnlKSjJ2M1BTWTBVRkIySkRvMW93VEtxSWFyM1NhSFE5
TjMyazBseGJ0QUg0SGJuR0ZQQ1JhUU11MWhodGMvamVtUXVLQllmMTRtamZhaGxtRlk0MTByajJS
TERlWEFJV2ErRjZkUEREd25EdzR5anFQb0ZiL1lRcHdtY1BOTmc5YVpGNUJ1MkdESDJwRnJ0SFNh
R3gyMzQ0OWtQOVViUjlNc2ZkaEtuQ1p4OGsxRDNKd0FpUEM0U09Pd25UUldEMFJqRHYzbjlDNmxh
NTBRYnVKMHdkOU9CTGV4QmJIK01DRGhqalFFWFErdm5lb1E4UnNYa2pUbFdNRlZMa2RvSG1oelZF
OHo0NEZyV1pVUnJCeFg0Ritxekh4eVZVS3hnVUJUNk9xcTdQcnlkZGVKTXJrVWxNWE5UbGN1OHVl
SmRmRVU4bHhiS1M4RW1SaUtpOVBjclc3ZS9RMjhRMjlXTXQ5NXd0L3RZRnMvbXUrVXY5dnAxdjZu
clZyTDZhWFdvelU3WGJuOUYrYWRCbUlZeThDRUJlWXVUejllcSsyU3oxSnJsYkJlYnU2WEhSekFV
VlJFeHRocXUzTzhGQlBYNDEyKythMVYzYmFBQjhHUUMrd3VCbmFsLzA1K3ZyOHpjWDAvN3JveEFr
MkdLaU4rcDlQUC9sRmRPUWQ4M3QrcTZwOVhhK0RhakY4VE5rbTBJVlFJSEZGZ2NOQkVqekZLRlJt
Qjk1Q3RCL3JWZVJlaForZDlmSTg0bjZYZ3NDTTR0RFFETU11dGMvTU5YZVJ2NThhamJhbHU0MWk3
dHVXMlN6allZRnkxZ0lTSTVCRG8zRFE4Wko1RGhKVldWNjhtOXF3YlVHZTFhM3Z2bmV6WEc5NmZS
Sjd3dTdWUzNtNjgybVhwaDlxMTRPU1FpSEZIUDQxdWdqWGhpaG5qeUM0cUwrcjhiWXJocXozWHFq
MWd0cEV0cUVtOVY4OFhUWHN2YkNUMFBnWnhpKzJhYmJ6cGRUTUlmVkJOUHJXblBmN2tEYk5mMlJY
bWNaRnZOUDg3amZvNE1zaEVTT1NhenFlUzFnYlA1Mjl6N0RWZURxOHF6LzlPZlRiTkhzWnNDNzNI
dzZpd2JRaG5nOFZtQzBRMUlKOFUrc2RHYVhlc21uVFZRc2ZmVUdxcS9UdXQ1ZDA2Mk9wMmRhODE2
a0ljNklWUmpwZkwyOGJWWVFWck5jUHEzVzBMYjBVcWxjbDcwKzdNeE8wZGFyZXBHSCtDQWVZK1Ri
aC9YVFFxM2FxN1d6SkQxdGE3Ty9mcjFTeGY3MXZUTlVFQXI1YVBBUXI4UVpwbUdGV25naHU5K3Ns
ODY4R2pBcG9CZ3YrQkJ2MWI0QmhFc1lVTHcrZnJCZTZUaXlqNndNUFJqVzZEcmR2blBGNGR1RHZq
eGs5N0RlMWdOVVFod2l0eHppc004ejdPelljNmVPYzJqRGV4UTJCU2pmRGxsU2lEdmtsanVzaFR1
c055OXRjM0dYR2VCWTNwR081UXhNZmpsZHZQQkQzQ0VmZG9lTzR3QzJwdVA5WWRmQlF4d2R6MGU3
RGg3aW9yamxvcjVjVE0rdVZWSncrZmxHSC8yL2VkRHJjQU52OTJoTEhtYnF0OXRhVDUrN1pqdGZy
TGZJVkwwY1F0d2Z0OXpmMytzbmR3SGIxQ0pJdkZNd3YzVlQyMHlwdTlZSVJXaWdkTHZVSm5nN3RB
YUVPRU51T2NQSHpYclhIanUyN1d5N016bmxZdllOT294enRhSUowaHVpZXA5ZUtON2JwL25EQUpz
UUI1bkVKQnRoSkNBMk0wdHJUWE5UaTlobS9kRGNObm9CdEZYcVk1Q0UrTWJFOG8zTDJYL0FRNGVW
MHNiOTB3YXNkTDJWUDIwY0gyTTROdFIxT0E3MEVNK1ljRGMzV1QvdFhHbkw0L1AzelZ4TmcwMnoy
Mm1saUltd05lYzFDUjZQOVdZN1NDSEVJeWFXUjlTZVRjeFZOWW1iblVHeW16VXJuVHpwcUVvdlJH
dXBvMi9ORm1CZlNyTE81T29tbEpkU2lJdE1MQmVwZkVrWE9PbERsMDlDVjV2bS8rQ0Nhc0xFSFho
TXRwQUg0bXoxaUZoQUJEa0xJQWd2bHhCL21WaitjZzNtZ09zUXRLOFFMa1F2UGZmQzhNQ0JZTWhS
MTM5ODJvZ0FwaDdTU0loYlRjYTcxU1RFclNhRkx5TVRkdGdLaTNqV0JzUUE4eC9qWEdHYVlXYnRv
bGxKQXhoS0daSVE5NXBZN3ZVdjRTYnZ3Qm5oUmlGNTdLN1pVV2dYSWpQWHpHYXFrb29FLzY1bkd6
MVhGM2REQ2cveHNVazFwSEJ6Zmt3KytWYWJadHhkOStCWDg2SzZMMUF2cXF1SXlUMHBxWG54RDBv
Q05pNzR4elh2LzFNbXVwWnZKWXAybHdENHFvNkp4VlZVWlZXVnErMzNxT0JBZEdxWU5PL1JnUUt6
clFKaFUyZmFBRDZ6MDBJVGk2MnZqamhkVGdmc3JFREN0WVNHZDZ6b1d0YTdhbzBRbFFPY2ptVUVi
VlhZQzhQWnFvQmtieGtLWVFld1piQjlXQWFCVUJPR1FuTnkzb2RycnFnY1NOaW5pbVBzVGRnTHl0
bWJnQlJBSzhZdmR0aFBzRHBvNlNNcWhGWm9vdmFPQU0wZkZnUForM1IxakUwSyt5RFpteTJRUm1o
TitTVVB1Z2xXQ0MxNHlNUFJ4NTV6bENMM0tiTXFqdmNkcEh6VGYzaDMvdjc5UzVOS3luLytlSEg5
ODVjdkY5TlAwOHViTTNWZThtZjlRT0R6NWNWdmY3dzA5Y0V4U3J4WHdXZ0Z2MjAybGdMTGdVbWdm
a0pONWJtZ25BMFV5RmpnR1Q1b0xMQWNHUXZvSjloYWlNRTdhM0hCZ3VsTEV6WHYrbzA2NEE0RHFB
NlBtbzZ4ODhDUEJtK2JnUFhnM2c4QUhweDJoWW9wY3J2QW5HQkZtdkt3UDNoVGlFT1BDQzZzWWxL
VkhXcVBIZm5ZaE9vRzJ4ZEFTYTVENUJGWGF5Vnl6N2kyWGNxeEN5cmNIaEcyaUlKYzRqVi91QUdX
aEFTMEhTb3dibGVBd20zTzJ1TlVlZDVGanVhckFpTks1RjBpbVlJTHZoK0tEWTVwZ1FEQk5xejFT
bVBSOVlqNG0wd1hYUEVlekFDbENpcEJjYkU3YVl3L1d0SkhMaEZNeHl6Q29sWmxCallNYkEyK1dC
dVdRNjRRUEpDb2o5T3hJcjFCVEM2VFFWT3o3ZGxENlhEcHc5R0hNTU5MYTdwN3d1QU5hdTFKMkpT
VlVWSzBOd2RiUjJIVkN4NTFtNFFkei9pRTZJOFlZMUtENE5EaThUV3JiTlFHaFczVWw0N0FjaWhi
U0FVbzFNZndXTUh2SUNhWHlSZ3JnY0wzTUFtMVdOKzBHU2JpYXpXVUlWSlc1Q0g0dzVZTmZHK1VP
aFFyL3pLQXZLNDdjK2JmbDgvWDU5MXhKVGVEQUFjdm54MTJRNW1BSTVuSHNWTUlTczA0R3hTZWNm
QlgyeWhVYjNqR01VcU5WamRCMnFXSFh0cGpFQk9PYWtYcnlpOTdEOEVmdUhUUVZqUXU2SVpNZkZa
M2xLUk9XNWNGeXJJdThPc1lWWHJNeU9vbVNDYytnNmVoN2syMGgvSTJwQXlQa282U0FXbGxLRFNX
RnB6MHpaK0Y2bktrbGlLM0N3eExxQ2NQK1lCN2wyeFpFNnJCeFg1TmVxekl3eVZZTVFnU0JkMzdp
QXljbzdXOTB1WDB3eGsrUkl1dkZ1ekhrRGVBRUxtcStSVUh5NVVKbHJsYW1IUXlCVXBDOGtGNVIz
SUJ4KzBLVUU2VkpNcjgyc3pMZkZWZ0VxN3VuTzd4d29KRDBjRlJMUmdnVzRXMSt0UVUxc01KYkN2
UTJQcnFpTlBsZEVpNkNwVWFVK0F0VFpOaFV1VmtmQUNuWXhsaENaT3lCQnNHTmdnYUpHNEZ1VUx3
VUtRK1VzY0tvUWRCdVZRR2pjMHhhUitwd3hVQXh4OUNQWHh0VThxcnFCUXV0Q3pzWkpVL0kxbUZF
aVJDb3NySjhJRDZVRHB4YkxVcUM3VkJZUXVsSWVOV1VLeVFDbFNtajJKd3lEa0dsRXRsaklWQTZm
dW9CTnVyYjlvTVUvRzE4aTk2dENINUtQNndkWU8reFNsTDFaODVzT2VnR3hxUVNWSGxpYjhySi80
R3drQkowVEZNRklKU3M4MEdoV2NiL05XMkJ0VWJubTJNMUIvcUoxU3Y5T0NZQ2ozYnFGYTB0dnpT
OTFIOGdRc0hiVWhrREY0NU1UaWc0ak84bzZSNDJzQXNVSmFCZ1YvSDZOSm5TS2lmVUszNHJKNEdP
NUIyVjNZYVVqbDVIRlNIUjAxSFNZcTBPaFFhU3c4WTVKTEtTbnZ3cGh3cHBzanRBc01TYWNyRC92
QjAxUkUyb1J0YzdGZWx6NDU4YklKMWcwQlI0UGRkK2pUR0krM0x0MVNCdnNsS3AxcWhWL0NPeWZQ
YXkyU0ZTR0w1RUtCTHFNQlhkY2x1WGlpMTkzZll3b0tEakNmR28xb3d3QzM4c0ZaL0l6Q3NSeVNt
ZEI1dEMvaHdDdHdWYmt5Qkg1MTlXT1hvSnVad08zaFdFb1F2bHgzVWtHTUhxR1dvZlRoMlNlUGFG
d1A3TXhOVURxNE1wbFh4QThONWVOUGtHQUg0eEk3NkNWV0h6eXBvc1B1U0xMQ0x6bzB2VkRHNEg1
ZldWWERRTndLUzh5Y2V4cEQzU1I1MkU2b1FuNVdRVVBkbEZLTWNNbjA3YkxoR2dnTStnbjkzeFNr
VUFDcUhPb0g5aENxRkhoeGZzRXBvWld4RWd1SWcrbmJWSTZqak9mRVJGZHo1WTFSOWR5bFNUSkhi
QmVZK1VxUXBEL3ZEWTFlYkhxVWJYT3hYcGMrT2ZHd09RKzB6ZWdxOGZWSW5UVElsdE9lZjFFbFRM
djhNbVB6N2R2dU9acVZweURnWkh1Y0xQaTkvVDE0alpHNGNHamlvbEdZaHNQTHg5UE9RY1FvOHpz
WHNkcjJCbDlMVWY4bkQwTU0zUWRtWEpwamplKzAxVXZvK3JoVitVdTBRS1VLSWxKaUlkZnJzNjBa
ZXBHRk9HSm9EYU9wQ3FPVjZ0WHR3N3V5WmZhMzNYTGlVbGlHb3EvRnFyZ0xHeVdJOHp2bnpEdW50
bFpHK2VFdDFpMmRSYnl3K2Fsa2NRbzFoYXFQdWxQRGVHYmNFeGNoNnZkaFpwcGJMQTdCejIyaTNX
eU8xM1dhMjJ0NXJvelZIZktVbHI4eUI0WjZ3dWdkZ1dMZGVIanlFUjRKNUhHUTcrRVkwY015OG8v
Ry8rdEtDL20rK0QzQkpRcmhZamdmYzY3WHZVcENmcU51a0NJdjdBMTRmTWwvZjFYdE1MQTJoWS9r
M2xyTXkwNGQyaUhQbGtOcTd5N04vdU54VTBaZTNWM3ZJZVJsbElZd3MxMmdFK0tKTVk2YTVnVHYx
NXV1bE1KZzc5NXFjL3Y0Y2dycjJhZWlQRVA4L01ZbmJxd3BsYm1SemRISmxZVzBLWlc1a2IySnFD
ak13SURBZ2IySnFDanc4TDFSNWNHVXZXRTlpYW1WamRDOURiMnh2Y2xOd1lXTmxXeTlKUTBOQ1lY
TmxaQ0F6T0NBd0lGSmRMMU4xWW5SNWNHVXZTVzFoWjJVdlRtRnRaUzlKYlRFdlFtbDBjMUJsY2tO
dmJYQnZibVZ1ZENBNEwxZHBaSFJvSURJNE15OU1aVzVuZEdnZ016UXhPQzlJWldsbmFIUWdNVEV6
TDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlQ0K2MzUnlaV0Z0Q25pYzdaMi9ydXU0RWNiZko5VW1n
SkhITU5MdFE5eGkyMjFUcExoSWxTcDVnVlJCbWdCYnUwaVhLbFg2dkloWHVJTXo0SjEvbktGSVNm
YjVQaENHajQ5RVVUSi9tdUZ3S0QrZkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFSQkVBUkJFQVJCRUFS
QkVBUkJFQVJCRUFSQkVBUkJFQVJCUitoLy8vL1BQLy85VnlwLy9QdFBiZUhQdDdKdGRuWkxJZWh5
MnJnZ2dqWmU3bi82NGZiemIvSmwyMzRyeEJyNGdqNjV4aUNLQzFteHM4OE1nbzdUWmtxMmJ2L2xi
Ny96ak02QWtlTENXTUZtUVc4dlFvbTdQYjNScng1VzVOMTFCMURzUTJLY0JiMnJZcFRNUHdWRVFB
T0NTQUlsWFV5czRMTkJrTkJHQkkrVlBIekU1N0JIRUdScVF5T3dTcnJBSkVHUUtUWk1RQW1DZG1w
ejJMUTdCNVFnYUVBYlRVbVVOaE9HR1ZnSUNoVFR0QkhFcnpCTXBoNy8vV1VyWC8veGh4Ly8vSHNx
Mi9Yazk5dm4yMy9QYmlOMGtDZ0VFYURFYjJDWXRJaWpaSElJeU1yb3BTOFJqWnU2aG1sN2hXRVMy
cjUzc2tUVkFxeUV0cXVoTDlIWmpScVJGNFVRS0cwbTdPeVdYazU1cStRVk1NWFNRRzEzcXJNYlZk
Wm1jVXhQanptaXNvZ21zbmVVdk1kL3ZvcjIwd1NtV3IwQlVQRjhFek0xZDlCRWFZR1V6blQvUHFX
V1czTDlvRWRNRTRjZzJqQUZtSXIxQmtDWmdRaTJTbk5wR2xnOFJRR1FDNUtsdi9yTXlDZ2ViWUdw
VndlcUd5U2ZRaFBabzUxTzBhWGlpaDVOeVJHMHQvdHJkWjRWZW1tZ3RuNnVBeEh0dUdsL2VGeXMr
TmhacmhNU01hMU1LUjdsbVNxdkVuWWR1V1FPVWQzbCtSSDhGMlhNZExLdjI5WVRWMlVDVldyL2lU
S0hUaTFRZTJneXJkSzl0eXhSajZjMFU2ZTdmNlo5R1lqdWVuYks3RG5WKy9aQS9Mazd5c3VUMVox
SElFenkxK1Q2MWlwdzl2YmJwdjBvQldTZGJxZk1yakpXVlo3TnBVQ1Y1dEc2VE1WUXhGaDE5NzNz
dEZSc25vWTdiYnQ0S2srUWVPM2FyQlBIVTdQTUUwdjNaQk9XZFVEbCszL21mS3Z6Q09KRU1vMjVv
SjJLemRNd1RWUnR3SkVZc29rMmRGbHJ5MW1Pbi9tTjczSHZreFV1QW1xQXB1Q1VCMnFyV3FndTBh
ZEk5L1A3dnN3aVBXSWFRRWtYcjU1YnhmR2JHM1hYZCtEOVgrNkpRSG1CRVc1QU1JT21HMmxlbkxh
cU50M1JIRWFaUUhGcWNWdXVFNk9JemRPQU42WFh5QWR2dWtXVDdnMnZrczJiKzVRLzNiWDJmN01a
U0ZjQVpicG4zdW5vRTljVmltMENKOU9MYjd4aTJGdy9JSUxMR0UyNnE1Y0l5dkJsd3BWczdiYlpk
c3IxNjJSb3VyL25WYXQ3MFFxZ1NqY0g4OXpqQ2dldXpNc0IxYWJ0aWI0NjBPdW90cHZsbU0wdCto
QzNpdGUzYlQvRjY4dDBxaW5WSGdEVVFGeGQ3eUtRRVVBTnNQQnlRSEhjWUwrenh3bnFHcVZGV09u
NmswMjlmOHNNckY4dHFYY0NTdnQ3R1lNUzEybEdMRXQyNnJXQWFsTWpSSit2OWplUlplRlpQYStJ
NVlyaXozeEoycDBTZllIZXllVWJzeVlhbWZhL1hzdzh2MVQ1dFlBU1llMjJlNWM4b2paQnZXU014
T29xRXlYeGVXQ2hidW5nT1VVZzk0Y21GZ0YxU2xCQ0E5VXUyemVMR2U1clQ3OGI5TzZTOVZwQXRZ
bmxMUWpWbnRhR05icEFlUkNKVjVPdnJzRkt0cHhPZklyWGx3bDJyYWh6T2xCeHo4K1hzWW1rZk9y
UmxZSHlRQ2laSnowSzg1Z3k2UkNMRmx1VTlDZGRza3BBVFluMWFXdXk4eHMvWldKM2VENDMwOVI4
SWxObUh1cXlRSG54N1pKNUVqUjVLSm1tUnhmeHVXZXdnaEZXQ2FqYm1nQ0MyVEh5TXNjZGVyTzVR
T2tLSndMRkRjaWtJWFZqajFjR3FtMG45OGxTRGZkRWVGeFRFR1BWTFMxaW91U0RFblRXVTRMbnVs
ZGt2dlIyL2NLaldjYmI3V1BtUVJlTm9RWktKbGMydjFUNWhZQnFqUXUvbHN4VDhKQXhiOFMwc3dU
V3FnUVVXNmdwS1JPbEJJTjRyL3c5WDI4V0gyNVJsRytQTWplUUZ3S3F6YlZqcHZKM2JFNVl5bHVv
NlVVRFc3VlE2MmFqTWt6dFNhV3VIcTRiT1J5Ymg5cXZHSmtYQXVxTCt2bk9mTzhpWjYvTDBVN1hi
c0JhSmRzL0Y2aW5iMjUyK2ovQk5HZ3B1cGhaWXpMY2RhZFBFN3dvVVB2TlUyQ2JXazhzNXVJdi8v
cXRmdFVmZHVIS1J5VGF3V09ld2E0OExycTVBWUdkQ2pwUE10ODcyRGlUeTVmTVBvcFp6aXdOZm5X
Z1JFU2kycldtK0hoTWlvbVA0TWpEcXJWVHlSdUNtTTRldllSU3NmK21uNTlBZjNianlWNXY5R3lp
Q0FzRWg5QTFlNGJNbXlGcTJ4Q3ZyZ29tY0hVTHUvRjh2UWJrOUxVYkdxalNlcUxBTm1VQ0VhWlZN
aTBVbHdBclBrbzFJakVYcU9mVTJaenVQVG1UaERDQWFqZFpLRmdQMWZVaFJUMWVVQ0xPc0RWUDhJ
SkE1ZU5kWDhLZlhldWFKODh3dGV3SXIwK2daR0tWdnlGOCtYN3dPSG9KYmVVbk1hdE02VDVUV2wy
ZWQrZUcyOS9OakUyMmMrQTByd1pVL2thZEhEMlpXQVVvZWViSmZHTWFxZndOWWV6RVM2bytTS0h0
VHNHK3V0c2tPeTBaaFNSUVkrM2ZreURSUmVPTmdZcm5ucExtU1Z1bHVIampyTFlrL1QxdG1uZGN4
VWdEM1ltSEJvRTdwOTJxcEd0WFhlNlVaeXFPdW5TZlJaYXBwK3ZmWGcybzB0SzhtMk9lNHFHVGlW
SUpxeUQ2VngwQUR0eEp4aFNNT0xnWG1hTjFJaVg1OEFRUHEzWmpYV0Z5OVVRd2hDazlsOCs3RHNu
R2VEVlVGMWd0a2dDcUZIRDJ6Rk5nbTdTek4xQUNPNVVQK09zbkJPNjRpalU5aWc5TjNYT0lkVFh2
ci85UmYzcXR0L3R3RzZaTEFKWGNpLzI5cW5tS0kzZzd5YXJPUng5cG9hQlBvaGFvZktjYWkrK05q
WnZ5THQvQWZEU0FncWFybW40VDU1WWZZNXRNckFaT2VXRHdDRUd4ZURTUjdGVGVqNFFLbWdSV1Uw
WlBBVk41OHlTZTd3U2dvTGthQU1velQza0xOUmVvNm1LVDFzS1dvakVRMUJVUEtLcEFMUm85YmZX
TE4xM3psRC9aTmoxK0lMd0pRVjF4WEtLMGJIekFRbzBacVM1VzFRZGZpQWJmaWduMkVOVFZHRkFE
RmlybUlsL29PZi9WcC8yTDFWdnJRbng3Rm9hM05jeHQxWHVMcHA0dk1pZDFyeXg3SDdOUUdhOXY5
V255ajhzTHBxWkhKTHgwaVB5MFBtVUN6RzNWUzZ2TEM2VklyYjRMOFYyUjc0M21UWktHUmFlUG9a
WU9aT2dobk5yWld6R0F1dm5MM3g3Zi8yNkxWOFBWRWdCT0YyWHhCZGZrbUt3SjVwb1NwWjdmdnV0
WlFDMks4czIvQ3Qra3pSTmJxT2tEcUJnV0VtRjF6V1duRjFRWHFNT2FRVjlaTnhueW5uNk11VGNQ
bFVFcEdlV2Izc04xTEdLZHYvZk1BZlg4NkNSZ0txT3JBVVcrWDVBWXZIVzVVcWFFWjZGbVRVWE52
UTQ4MTZ5Wld1Rm41akVaOXZ3SFBKeURNMUdydThRYmQ1OVpNYjFKTzMxSSt1M08wdUx4dVZHK2Rl
T3AxdGtUNW1sNmZJOVVzanRtL0lIdWZ1TEQ0WlVMNXVJTDNzczhGdmZlZHNTWFBGeitLWjNlOW5U
bkY2ZWd0OUViZUEzTE44bGNqejhXUDh3RGxjdysycDk2VkQwRnM2bmNCczNVb295akVsRDA5WW52
eSt6a1BPd3luOFlRUDhXbGRVN2F2Zmk5UGdWZTNpdWVoVUpreFE5ak1YY3hyd25iNkxadCtoRHNI
bnR6RUI1UTdkSE5Kb2xkK05EbXRUS3ZzQ2VhNGtsdUdUdDcrMTIrS2VNcGl1eDV6dDY2K2R6cXlF
ajNUeE9vcC8vc08rb0crcit4Uy9uMTQzZHFUS0NDWG1RZWpta3lkekVIaklGWk1TdVBvM3ptQnQ2
VmVWcHVaTDQ5MDhVWmdJdENFMVBzMU5iSWx2Rmp6Tk96RGhUSFlGa2VVSjdNSVVZbTZPRUZHK043
c25tNG9PdDZlOUVuUWZQRWxsV2dNazFxLzJzYTYyT2twM1dxUVlra1ZudU1DTG1tWGp2WHBSc05B
SFZUUC9sWGpmN3BYVXhuVXV0bXJTM3Rub0s0Q1NTREJ1Sk04N0c3QWFBRzRoakpLN1pJd1VKNHpS
U1BvZkpHYWtxSDU0QjVpOVZTOC9SY0R4U1BudG9WOUhvWGJmaVNSMzlhWHFpUXVKa251NkxlckJ1
eUlBMEFOVUJIN0xVZUlKMDFFWmduN2ZWNVdNMmRpaklub1pabXc2NXorWUlubk9pREpwc1JCQ1h5
ZXlWenBVeXZqeHNmUEdGakdLaHVrM1E5b2ozVkduYks3SzVkc2dLZ1ZuUjEwY2pWaXpWS1FKbWVp
UW1VQ0VEeDdvK1Boem1mQzFSK0xsdlhMSUxWT3ZnMkFOU2VmRWd4MFhCd29qS0Zwc2RDRS96aElw
VGFSaDdnN0pGV2hNMjdEb3pwOG1WNjFCU1hiOWhDNlEzTU1QVXhMcCt1TXdpd0x4VXRwdEJNeFVh
S1VGcVJhMlNLWm5nUE9GWWVLQzhRcCtuSXhPdEtjNTF4QXc0YlF5VmJkUXBRUVh1T0VXSFZCcXRO
VTdWQnRHMURIQjI4c3UrWXcrVXZmakIvcElHS2U3anBkTVZ4NDlheDBhZFFBbW9zeWxldGYzV1VM
OURwQzJyMFNzQlRDRHBGR2FEaWdGTFZRbm0zMEllZjJNQnp2bFBHVU0raGVhaDgvUmxmMGZTY1Mv
TlFnVTRINmpPcjIvbTcyU3lsTWRRanpPMTVOajhsUUpFci9yUE4xdE9uVUFYcUdVNEhtOGgvOVJj
bVYyTXN3NWtTYlowNmg3RGQ4dURReFBFcUpmUWVLZTZ1b25DZVQ2YTdldjRialk3YjRON3RJeVd2
Uy9HUEgwdDQybENoNlN1T0FkVWF4RWVUYmVqeHpqZVc5cVM4dXczM2Y5NHNFN1V3dy9KZWsvalFY
MVcyNVBFRHFJUEZlWHFydzRNRE1xZUtiaC9QdzgvYzZJSjVLRjJuTjdHYmIrMHNvTHFOMUhwVXNy
dkZsdmt3b0Q1RTE5eUw5Z1NYNHRWRnc3RTJoL3lhZG1xZEhzV2xSbkZWaTV5WmFpUHoydytmZUts
SnM2N3d4VVZ1bmdnYmZrS21rdXAyaVc0a0FYcFh0U2pwcFNKZ3lwUVlkclgvaXNPTTBIc3JScW1k
VFFaVFFtSlFJTjZEcGs4bEhpNlpDeGpOWllQYjUyZTMrb3A2ZlA5RGFhZWtmVUluaWgwOHZmZ2lL
UEQ2SUtnVnBWSzBLT25rd0lDbXM1c1BRVmNSSlFHeTU1YXhSekJNMEh1cmxLM0h4bWlNSTlxWWtt
eFhueGNFbmFMV3loQXB1ckRuSmlhajc4M0R4c1dyZ0loUmdsV0NQb1BJN3BpNU41bWlhV3IvZGNC
Nld3aTZwb2dzYll3Q2pyeC84ZnFwczg4SmdpNGhFWE9JYlJQRjlNaEZCRVFRMUZYN1c0UlVQdFVL
UkFpQ0lBaUNJQWlDSUFpQ0lBaUNJQWlDb1BmV3IyNlgzWGdLWlc1a2MzUnlaV0Z0Q21WdVpHOWlh
Z296T0NBd0lHOWlhZ284UEM5TVpXNW5kR2dnTWpVNU5pOU9JRE12Um1sc2RHVnlMMFpzWVhSbFJH
VmpiMlJsUGo1emRISmxZVzBLZUp5ZGxuZFVVOWtXaDgrOU43MVFraENLbE5CcmFGSUNTQTI5U0pF
dUtqRUpFRXJBa0FBaU5rUlVjRVJSa2FZSU1pamdnS05Ea2JFaWlvVUJVYkhyQkJsRTFIRndGQnVX
U1dTdEdkKzhlZS9ObTk4ZjkzNXJuNzNQM1dmdmZkYTZBSkQ4Z3dYQ1RGZ0pnQXloV0JUaDU4V0lq
WXRuWUFjQkRQQUFBMndBNEhDenMwSVcrRVlDbVFKODJJeHNtUlA0RjcyNkRpRDUreXJUUDR6QkFQ
K2ZsTGxaSWpFQVVKaU01L0w0MlZ3WkY4azRQVmVjSmJkUHlaaTJORTNPTUVyT0lsbUNNbGFUYy9J
c1czejJtV1VQT2ZNeWhEd1p5M1BPNG1YdzVOd240NDA1RXI2TWtXQVpGK2NJK0xreXZpWmpnM1JK
aGtER2IrU3hHWHhPTmdBb2t0d3U1bk5UWkd3dFk1SW9Nb0l0NDNrQTRFakpYL0RTTDFqTXp4UExE
OFhPekZvdUVpU25pQmttWEZPR2paTVRpK0hQejAzbmk4WE1NQTQzalNQaU1kaVpHVmtjNFhJQVpz
LzhXUlI1YlJteUlqdllPRGs0TUcwdGJiNG8xSDlkL0p1UzkzYVdYb1IvN2hsRUgvakQ5bGQrbVEw
QXNLWmx0ZG42aDIxcEZRQmQ2d0ZRdS8ySHpXQXZBSXF5dm5VT2ZYRWV1bnhlVXNUaUxHY3JxOXpj
WEVzQm4yc3BMK2p2K3A4T2YwTmZmTTlTdnQzdjVXRjQ4NU00a25ReFExNDNibVo2cGtURXlNN2lj
UGtNNXArSCtCOEgvblVlRmhIOEpMNklMNVJGUk11bVRDQk1sclZieUJPSUJabENoa0Q0bjVyNEQ4
UCtwTm01bG9uYStCSFFsbGdDcFNFYVFINGVBQ2dxRVNBSmUyUXIwTzk5QzhaSEEvbk5pOUdabUoz
N3o0TCtmVmU0VFA3SUZpUi9qbU5IUkRLNEVsSE83SnI4V2dJMElBQkZRQVBxUUJ2b0F4UEFCTGJB
RWJnQUQrQURBa0VvaUFSeFlESGdnaFNRQVVRZ0Z4U0F0YUFZbElLdFlDZW9CbldnRVRTRE5uQVlk
SUZqNERRNEJ5NkJ5MkFFM0FGU01BNmVnQ253Q3N4QUVJU0Z5QkFWVW9kMElFUElITEtGV0pBYjVB
TUZReEZRSEpRSUpVTkNTQUlWUU91Z1VxZ2Nxb2Jxb1dib1crZ29kQnE2QUExRHQ2QlJhQkw2Rlhv
SEl6QUpwc0Zhc0JGc0JiTmdUemdJam9RWHdjbndNamdmTG9LM3dKVndBM3dRN29SUHc1ZmdFVmdL
UDRHbkVZQVFFVHFpaXpBUkZzSkdRcEY0SkFrUklhdVFFcVFDYVVEYWtCNmtIN21LU0pHbnlGc1VC
a1ZGTVZCTWxBdktIeFdGNHFLV29WYWhOcU9xVVFkUW5hZysxRlhVS0dvSzlSRk5SbXVpemRITzZB
QjBMRG9abllzdVJsZWdtOUFkNkxQb0VmUTQraFVHZzZGampER09HSDlNSENZVnN3S3pHYk1iMDQ0
NWhSbkdqR0dtc1Zpc090WWM2NG9OeFhLd1ltd3h0Z3A3RUhzU2V3VTdqbjJESStKMGNMWTRYMXc4
VG9ncnhGWGdXbkFuY0Zkd0U3Z1p2QkxlRU8rTUQ4WHo4TXZ4WmZoR2ZBOStDRCtPbnlFb0U0d0py
b1JJUWlwaExhR1MwRVk0UzdoTGVFRWtFdldJVHNSd29vQzRobGhKUEVROFR4d2x2aVZSU0dZa05p
bUJKQ0Z0SWUwbm5TTGRJcjBnazhsR1pBOXlQRmxNM2tKdUpwOGgzeWUvVWFBcVdDb0VLUEFVVml2
VUtIUXFYRkY0cG9oWE5GVDBWRnlzbUs5WW9YaEVjVWp4cVJKZXlVaUpyY1JSV3FWVW8zUlU2WWJT
dERKVjJVWTVWRGxEZWJOeWkvSUY1VWNVTE1XSTRrUGhVWW9vK3lobktHTlVoS3BQWlZPNTFIWFVS
dXBaNmpnTlF6T21CZEJTYWFXMGIyaUR0Q2tWaW9xZFNyUktua3FOeW5FVktSMmhHOUVENk9uME12
cGgrblg2TzFVdFZVOVZ2dW9tMVRiVks2cXYxZWFvZWFqeDFVclUydFZHMU42cE05UjkxTlBVdDZs
M3FkL1RRR21ZYVlScjVHcnMwVGlyOFhRT2JZN0xITzZja2ptSDU5eldoRFhOTkNNMFYyanUweHpR
bk5iUzF2TFR5dEtxMGpxajlWU2JydTJobmFxOVEvdUU5cVFPVmNkTlI2Q3pRK2Vrem1PR0NzT1Rr
YzZvWlBReHBuUTFkZjExSmJyMXVvTzZNM3JHZWxGNmhYcnRldmYwQ2Zvcy9TVDlIZnE5K2xNR09n
WWhCZ1VHclFhM0RmR0dMTU1VdzEyRy9ZYXZqWXlOWW93MkdIVVpQVEpXTXc0d3pqZHVOYjVyUWpa
eE4xbG0wbUJ5elJSanlqSk5NOTF0ZXRrTU5yTTNTekdyTVJzeWg4MGR6QVhtdTgySExkQVdUaFpD
aXdhTEcwd1MwNU9adzJ4bGpsclNMWU10Q3kyN0xKOVpHVmpGVzIyejZyZjZhRzF2blc3ZGFIM0ho
bUlUYUZObzAyUHpxNjJaTGRlMnh2YmFYUEpjMzdtcjUzYlBmVzVuYnNlMzIyTjMwNTVxSDJLL3di
N1gvb09EbzRQSW9jMWgwdEhBTWRHeDF2RUdpOFlLWTIxbW5YZENPM2s1clhZNjV2VFcyY0ZaN0h6
WStSY1hwa3VhUzR2TG8zbkc4L2p6R3VlTnVlcTVjbHpyWGFWdURMZEV0NzF1VW5kZGQ0NTdnL3NE
RDMwUG5rZVR4NFNucVdlcTUwSFBaMTdXWGlLdkRxL1hiR2YyU3ZZcGI4VGJ6N3ZFZTlDSDRoUGxV
KzF6MzFmUE45bTMxWGZLejk1dmhkOHBmN1Iva1A4Mi94c0JXZ0hjZ09hQXFVREh3SldCZlVHa29B
VkIxVUVQZ3MyQ1JjRTlJWEJJWU1qMmtMdnpEZWNMNTNlRmd0Q0EwTzJoOThLTXc1YUZmUitPQ1E4
THJ3bC9HR0VUVVJEUnY0QzZZTW1DbGdXdklyMGl5eUx2UkpsRVNhSjZveFdqRTZLYm8xL0hlTWVV
eDBoanJXSlh4bDZLMDRnVHhIWEhZK09qNDV2aXB4ZjZMTnk1Y0R6QlBxRTQ0Zm9pNDBWNWl5NHMx
bGljdnZqNEVzVWxuQ1ZIRXRHSk1Za3RpZTg1b1p3R3p2VFNnS1cxUzZlNGJPNHU3aE9lQjI4SGI1
THZ5aS9uVHlTNUpwVW5QVXAyVGQ2ZVBKbmlubEtSOGxUQUZsUUxucWY2cDlhbHZrNExUZHVmOWlr
OUpyMDlBNWVSbUhGVVNCR21DZnN5dFRQek1vZXp6TE9LczZUTG5KZnRYRFlsQ2hJMVpVUFppN0s3
eFRUWno5U0F4RVN5WGpLYTQ1WlRrL01tTnpyM1NKNXluakJ2WUxuWjhrM0xKL0o5ODc5ZWdWckJY
ZEZib0Z1d3RtQjBwZWZLK2xYUXFxV3JlbGZycnk1YVBiN0diODJCdFlTMWFXdC9LTFF1TEM5OHVT
NW1YVStSVnRHYW9ySDFmdXRiaXhXS1JjVTNOcmhzcU51STJpallPTGhwN3FhcVRSOUxlQ1VYUzYx
TEswcmZiK1p1dnZpVnpWZVZYMzNha3JSbHNNeWhiTTlXekZiaDF1dmIzTGNkS0ZjdXp5OGYyeDZ5
dlhNSFkwZkpqcGM3bCt5OFVHRlhVYmVMc0V1eVMxb1pYTmxkWlZDMXRlcDlkVXIxU0kxWFRYdXRa
dTJtMnRlN2VidXY3UEhZMDFhblZWZGE5MjZ2WU8vTmVyLzZ6Z2FqaG9wOW1IMDUreDQyUmpmMmY4
MzZ1cmxKbzZtMDZjTis0WDdwZ1lnRGZjMk96YzB0bWkxbHJYQ3JwSFh5WU1MQnk5OTRmOVBkeG15
cmI2ZTNseDRDaHlTSEhuK2IrTzMxdzBHSGU0K3dqclI5Wi9oZGJRZTFvNlFUNmx6ZU9kV1YwaVh0
anVzZVBocDR0TGZIcGFmamU4dnY5eC9UUFZaelhPVjQyUW5DaWFJVG4wN21uNXcrbFhYcTZlbmsw
Mk85UzNydm5JazljNjB2dkcvd2JORFo4K2Q4ejUzcDkrdy9lZDcxL0xFTHpoZU9YbVJkN0xya2NL
bHp3SDZnNHdmN0h6b0dIUVk3aHh5SHVpODdYZTRabmpkODRvcjdsZE5YdmErZXV4Wnc3ZExJL0pI
aDYxSFhiOTVJdUNHOXlidjU2RmI2cmVlM2MyN1AzRmx6RjMyMzVKN1N2WXI3bXZjYmZqVDlzVjNx
SUQwKzZqMDY4R0RCZ3p0ajNMRW5QMlgvOUg2ODZDSDVZY1dFemtUekk5dEh4eVo5Snk4L1h2aDQv
RW5XazVtbnhUOHIvMXo3ek9UWmQ3OTQvREl3RlRzMS9sejAvTk92bTErb3Y5ai8wdTVsNzNUWTlQ
MVhHYTltWHBlOFVYOXo0QzNyYmYrN21IY1RNN252c2U4clA1aCs2UGtZOVBIdXA0eFBuMzREOTRU
eit3cGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqTTVJREFnYjJKcUNqdzhMMHhsYm1kMGFDQTNOREl6
TDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlQ0K2MzUnlaV0Z0Q25pY3hWMWJjOXcyc243M3I1aXE4
M0NTcWhYRis4V1ZGMFdXSGUzYXNpTXJtOXJhN01ONE5MS21kaTdPekNpdW5GOS9BSklBdXh2ZEhB
NHhjblkzRzdHSEFMNnZ1d0YwZ3dBWlRVTDEzN05JL1Y5UnhaUFo2c1h2TDZKYUZrMmlVdit2RmhW
bFVKWlZjMjhTQlpuNmQ1SUVVUmFHWVYzby9Ib1ZUVjV0WHZ6ODRzZTdGK2V2czBrNnVYdG9LMUtW
UjBrNlNkTWdqdkxKM1dyeTcrOG0zMC8rTTduN3U3cFQvUmJqVy9NcVNKSTRETldmWVJEblRvbGlF
a1dvUkZxR1FaaVZZWlJPcWlDcW12dHY1MTgyMi8zM0UxM3d1NC83NmY1cDk3SzllcjFZVDVlMk9n
bzFLektGSWNpUytHRERXYWlnRm5GVjVwTzRVQzJIR25SZDZPTzc2N3VmL3RhMjkvZnJ0Mi9iU3E3
dWxDN0RTWm9GZVpscTFhMG1aMkdRNUZxU3hLa3V2NXpFWVJHRXVxNnNSOXlXMStJOHlOTkduQWRo
cXY1TWxMaXBGUWdlSjcrK1dMOVFHZzJMTWszVTcybVJab3BLRU9WcEVlYVQyemN2L3YwZnhldGVp
WXE0cHZMMWhRVm40UW9vUGlyTC8vNkMvUkdWeVlxZ0RDMGhpMXlKMHpTVjJZd0NmeHdhaDBIMzQw
clZERyt0bGNKQnRySlJlRVBVWkM5TWZPdVpBV1R2Y3AwcVJPWnl2QU5UT2c1K0RiMXJpMnJyb3hr
VUN0VTlNOVNCa2lCT0oxa1NWR1ZZVlczSC9URGRMK1pyMDNPdjF3K2I3VXFKTm12WWhSUXdhbFBF
Tmcwejd0cnlUOE0weUpPcUtsT2tCYTN6SksvTmNRcnZReEFwaE1hUVdOcmNCWlVIZ0ZyckNPQkhv
VHpVZm9lUytDYnB5Vlp2SEVxL2JvRWJreURTdTdENlJkTnl5RTlpYnFxaW5sNFE2M2xPM2FaNTRi
N3c4Y3Q4dGxqTjEvMmRRV3RhRmFueWlwZ1NpbTFYeUlvOFNESmxsNHlLa2I3VU5NZ054RXI1dHJT
Lzc3RzRNVURTWHpCTWVqTkhFaHBCbDhiWG1UTjBDOFNQWWhoVlZhRVp0bWp0d0VqYjd6aGhCN2Q2
d1VOQkJqZzVZUDNjbDIxVEFpemN6TnBUZEJtT3pyTU5ZVUxQUzhNeWlCUGQzVWpIdTF3ZW5vT2M2
ZG9OYm5UVnF1NVM0NGVoQXhDY0psSVlPQ0JHYWFRMEhWZFZnaEZxZVZpNmNtK2dCMEYwV0lHNHU2
OE1sU0MxQVEwU2hiZ21ld05IQk1rOUltRVdKQ0VUNHJzWTVHNjh4c1dYMUdzOE9EZ3VFMkpBclJX
Q0xKN2ttYnEvN2hKUlZhcXBLVkJkVkpmWnp1c1dUV3JZM1p2cTlLL3RYeVEvcXB2dVVyS2VwTWoy
MENoMEE4Uks1VlpSb2NhVnBwcFg3MzgwbVZ3VW44ZmxlVlJsWlZ1VkxWaXBra21wUmhkYSt1TE5s
U2x0Uytra2tHczRVdmxkR1NWaG1EWmwzOHpYOS9QdFM5cFdwdExQTkd3U1ZsemdYZE9TQkkzZTd0
emFvSWhqblkycUtZVU5rRi8xNFNGRlAxNjh2bExhYVA3RFlXc2FUTElnemhTc1ZtVS96YWZML2VP
ZzlrakpNc3VMS0F5clBJekxOTTBMMEtRTjQvdENPeGhEZ3U0QWc3WlRqMUREQW1COWpibytRSXI2
cWNCZzlFVFhDNkxEaWtZZ0k3RGQzUmxkbWJuQmFsaWk0eitrT3FPK1FJaWRIYVQwZzNlVDA0QTlP
Sk8xYTE5a0xBSHhmVjRGUlpKMnkwUnRmTzkwcVRoUDI4Q0VsUGoxcHlRTHF5eTZjMHAwalpSeGtH
WjFNTlRFTXB2bGNqN2J6Kzk3V2lGRnd1dzhDcy9qTUNxY0FTSktUY0JKeXB5Yk1UbDVtZVR0M3g5
ZTllR3NzaUFxVWp2NjNjNW44OFVmdlRCSkNRMHpPZ1NUbERFd3cvSmxHQTJDR1NrM0txdkVEcUxO
eW1JdlRscGtFRkJheUNvMGVobVhEbEthK2ZWRjdUQkxBUDBEUnVEK1k5TVIrUU5OZU9Sc3pZalJh
S1dMbzY0SCtLR09MdkFlbmNwUlprd01SYkN0UkJKQVlYMXlNTUZrc0I2T28vOGd4emZ1a0hBbUhM
N1VnRHlXOThaVEVCa3dWZktqZFpjVGtxRVg1WVQvWTRKSUZSeW5hbzVKYU1mdXFpSGo1RDh1ZnIz
NmVHbmo0RGNYdC8rQ2NUQjYrbEtvMEVvRnJpYkFkckNxMjZKQThXbnd2YjIrdXJrelR6eXVidjk1
ZlhuMTBjQXNjNVVMcVZDNFRBb25WbzRUTlc1bHNLcVBINjR1cjk5ZDNaalNkTmJSa1hxcGtjaG0y
WDZHTU9Nc0tNdE9sVDgvelhkN280SDZvdjM3MVdMNmViM1o3UmV6bmZsNS96aHYvNXJ1ZHB2Wllx
cUczbGF3M0h6ZW1OL1dSamhkTHFYN2haWmF5V3E2L2EvNWU3cWRPODN2dDlQN09ieHA4OUJmYnlE
YU5jcnJoMllxcll1ck5JcHJ6ODNTU3YwN0x1TWtTN1QyOU0xRkVLdEFRNmxVcDE4UCtqR2NGa1E2
U0Y4MVA4YXFpanAvQkgvVnY5ZC8xVVdYb0JyVG5hS0o3VFd4bHV2OEVOWGIxbUc3aVVwYmFudFBr
Rm1qV1BXUUNpY3ZpbTB2TDEyOUtxbTZmcDJhcDVoZ3BITEtUTXNqaXdlS1dwS1FPb1FMaWNKaUI3
aERyVG9BZ0JLU1Jna1JWRUthQm9rZXFpcWtqT3YxZ3dxNUZwdW5uWFdMM1h5Nm0rOEdLa21qMEpH
cjZraU1GMFJGcklhMlVLK2pXZGhBMUNvRzFNR0pXbkpRWkRRSDZqcWdPYWRDakdTSUY0RXFPSGZp
bmhCM0xYQlBpTHR4TFUyQ1NKdXlZTzg3WkFQVEkrTFlWZ09zSURwRVdRWnFRTlREZlpJRVZkSFN1
ZXRHaUp2cGFqNFFBbXc2YWxZa3lrRWc0anhSYzEyaEZ4a2dpdHY1N21tNUg5aDRrcWdtOVh4cU9r
Y2M1WUc2RE1OaGlraVMzSlRIR0I3bTIvbDZab2JWMituNjgxQjlaR21ocTZ6S3lrSXk2MU5ERUlI
aUVOSGI2YWVoN2VkbG9KUmFsV1hiUHVtYW9wT0RnckJsdEJnU1RuU0FFb2JOS3JhdXVidGVtdXNp
RCtFVFhDQXdjWklFWDFoSTdtdXpDZThham5rUWFVL002c1ZEY05raWlWWDBWbVN0cENrQkJDT3hv
VllKakc2MUZkMTExcUlCOTUwWlZWbGVJYjZpbW5RSkhZZmYwV3ZJQWNmS1hzRmhCcUxEWW91UnVz
TW9EUStFMEs3Q3dHR3d6eTZPOVZGSlg2OXd2SkhIeGFDR1RNSFlCcGxpc1ZXdVlJTlIrSThEMUpD
QUkvRVE2cExDVVQyK2hwRDhnUWZMVUlIMG01RTUway95QUhza3RXb1hqRFNLeEZGdzJnemYvamFJ
dHFSeldJMnZLU1QvWUtGaUh2VmtpS2gzTXhVeUJSSmJwZU5LL0d4eEhLQ1dCSmlRWGVaTm9BQ3BJ
em0wQnF6SDF4eDg0NnNKRDVhaGd1Z1hlTzZDMnhPZ0lYajdqTU0vREFuWWtJSHZzay83RVd3cnhn
WXBjaXF3L0xDRmVONUhFVVRiTWdnenppSllMQnRROGg2Smk2OVZNQ2dPZktoaXpMck96eSthOENa
cFdpOXJUTEhLbm1LOVNnMmkxb3FKV3RXd290TEdMQXpLc2w3SmN0TW4zRXJtMFVxT1cvbnc5dXJp
NDVYSm1ON2YyWWUyZDQ4TGsxTXY0TDZNV3ZJNE5iOTltdHRkVS9lTDNXeTUyZGxWb1AxR1pwQjdN
Q2pDWm8yclhVUDdjL1BVTnZpdzNhemFQN2Z6MldaN2IwQitmVlN3MnI5bm0vWEQ0bjYrM2krbXk4
WCtUN3NtOWFjbEpLTXVFdE1oamtkZFl0UmZ0cHQ5L2JESU5HdmEzKzJuZTROMU9mMGF0SC9XajRU
Tk9waWl2R1Z1Mzg1L2YxcHM1NGIxN21uMktITXBQYmhVTEJmbEhtQXRjZjA5WGRjanpOcS9WT0hI
eGFmRmZ0ZHhjOHdwY2FnOE9LajBHcEZZVGYrN1dIKzJxNXpHSEE5UFc4WEFhTHQxOFNlN2FtbVhK
anVhQzI0WEUwVWVoVDdRSXd6OTYyTC91SG5hdXdyWFR6MGZGalBUQzdhTC9kN2FSZldEWGJmTXp2
RDRNdC91ZWlsRVBoUmlUR0Z2MXBkVlZ6VjllTEh2a095bmk3VmRxZDRZYzloUmFLTnQ5SFd4QTlo
WG1xelR1NW9lSlZLS2ZTZ2xtTkpGMitUbitYcStuZHExOGlkbHErM2kvK0JvK21BSmRkcmZ6cGQ2
SFpPYVp6Vy9YOHhzWmJxY3lDVkp6RVE0Z2t1S3VXeEFIM0JuQXp0UnFQbkRqajBQeXZIQWN4ekkw
ZDcvNVduN1JZM01mUlpKZlZoa21FWFBTQkpsUHUza3VKM1huWVBlM3krMG9xekZYT1Y5Z1hiZTZq
VzdBZE5ubFB2QUpSUG80MzcvNWVYNStmeithVllEQzM3WGoxbnV3Zk9WMldaMS9qRDkvZnoxeGM5
Um1QZkFLbnhna1JueU54aUNMQmZyLzFKdit6VHZCbXcxaS95aFp2Vjd4OXVBd3FmTDh4N29wUTkw
TWlGYVZWcTd0NTV1eDZ2MThzL2d0Kzk3NEZRZWNPSlE5SHRuSFU5WVZjb0R2YWhkNWQwcUhaQTg0
eXBqTGRiNzNIU0VtcGo3bEtCOWhtVldHWkVvaEVVTTRMUUs4cUtWMUpWQXdTZ0dYY3NPT3R1MlhT
dUZkekdRbWVWVGZyWFhNY1I0R3E0UlFneEtXSVlldFBvRmNEb2U5STNYSDVIdWlkeHlkZnpLTWFY
ak5MQXFiMmR5SEowbmNHaFJlTkJxR0RDRlpMTy9abVVTS1lESXJXRWtDMG9Lazh3RTYvYzJuK1J1
UExsRDY4dkMraUVXVzF0SnR2M1dTNXIxajVBOEZsdERTWWFWZENVWkNsVHZiVC9KQ1ZsbXpFcnU4
Y3RWd0ZDa0hqOERlaStDWXY1WWJtMEZXK21SVzRWQk9iSWhxTi9iaUh6akRnbHF4YUhyZTJoVkVa
cFBNT3Z6cnpaeVM2WHllcStWSTRNVk9iRVVZSWtzSmJBZnZSRHMwbk5qRDRKdUpkT1EvRlF3dmVS
M0VudHZXL2FRSVA1b3Rxc2xlZ2VpM2c0ZGxuWWpZbVEyVjNUdmpnaHl1M1Q3K09kTzVkaFRrMGxl
YmxZcmxYRHZYc0x0Y0lkMjNtU1p3Y1B2Z1ZQUVk4MnBNdEZ1VVJndWRjaEtMKzN0eldWV3o1S2wz
VDhHQmV4ZXAxQnZJSzhEMWJhcXZMUXRXOEhCL1hKeFhnUkZVVlpWZlB5ZU9hQ1NJWnZub0lLUUhD
akdVUnhSTGFNY1ZOVkFwUkV0RVR5Yzl2bzMybEV0bm5DelhaL2Z3WTF0U0x0UURwUUpxeFhsUU5k
SURsVU82eCtvY3FhTlJ2TXVoOE4rQ3lzVEhMaC9sMTZzS2tqQ0FkdjAyQnNIN05QcjFEaDZzMTVj
VmtFWVZUcnlPdEdHdlE3VWlGMTdGTTdvblh0QU5hTzM3N2xnVHJPRkQySWJ1WStQUWh1M2w2OERN
bUpESDRXQWwzTVQxWEkycWIyMFV1RksycTdpNitjVVpFNUx3c0owTTcwRUFpN2JOUll0YVk0VU5B
TXp2QjY1OXFXcjBDTnhrYmV6R1JCMHEwWUkyWm5GWXRHMXEwWWR2M3FTUlpmdURaVFJtRVdqcmtK
SFk4NzZCQ0pCOU8zcWt4VDBValBSNjRwV1R2UU5laS9DekhNUm9aSnF2Qmp3Z0ZlMERVS2tTMW9S
RDU2ZkNCalg0a1dEaDdzaVRTQVdjakRYK0c4YVJJa2F0MHJiOWIvNzZlckR4ZDMxM2ZYSGRuRDhz
ZjMzeDE5dVgxOWNtaTBONXArTG03dnJOMWMzN2RXdjU3ZFhyOSthdVBuOXpldnIyM2ZkemQxaU9k
eE9ERlVMTnpoRDFSSzVWUzJ1eGt1M3BJbE90N2dONmlKRmpuc3h6RW5nY0FIa21GbVJVNEhObkJC
VmtGREJlc2VualFRMU4vb1FzYU9NRGpSdkNJR0xieEtJN2ROaUZMMmUzVDFQL0Y0N3NQSE9xSjdz
QUwxMnNzdGlNOWtkbW5hTW9NcnFGQUhNRlZieWpOTmRMWTZxZWswZ2I1NUdnRXNESmlycjUyQ3Bu
WXVoWUN5NnRwbkVuTUlDQWpBWlEyenRaQXp4ZGZPekpSYVNTMGVkTHFjUnN6RlNMbEVhVU8yUWlU
Q09WZTZRMUNzN0NLZmpHZDlpUHBZbVB5aUhYQ0Y0cUZLSjFFbG5aQW1VU3dXNkVmRjV4cVVsVXVN
TkFKMmR3WlZ3SisrYUZTbDR0TFRTM3BkRWFwek1TbnR5ZnRnVWJLZGU4RDZTSStPY1JPK3RZVXlx
NjhtYWZZVFBaK3IrNEV1S2RhQWNXaHhTZ1FhV0tKNDBBSk5BdVZTZzE4b2RzTk8rUk1YYmgzbVha
YW1BNFZ2cWdQSkF5RHVTUlBHYmpTVTROemZyRjFrVVZLa3U3M1RKMjZ1THk3dnJmMTV4MGF4V1di
dXF4WVRsTktSMG9sbXJGRjNQeVhyZHNhQ2NSM0hJdnJBMjNPc2kxbzZvSGwvN01vM1hyc3FBQmE3
S1E4WlU4RmpJYTEraStBMEhrR056RXlLM1ZDVEgrNVlKRS9nVldvVjNQTm1SVUQyK1Z1RWRDVk54
SFd4d1JrTFNvTTRjZ3BtZVB6L3FVanQ0SDB4UUFmaE9qZ3hUNUZUUXNVU1dFdGlQemx4ZGVreVB3
V0xXbEhuVzQwY1NHMi9iSVA4Q0tKT0RMeHJRQzlwMklNS3owODM3bTdOdWhtSlhiMDA3OWM1SE42
SHRmc1hSZE5WRjAxV1Fsb29QeUxlQXhETmw1TnNGV1pjS2ZkcjN0dFc1V1hkcHdDaUpmUnBrU2xq
QldIUnRNNWxOYURzQlNHZ2h0ak9MeHVMRE9XNjdKeEZmT3VwME9ZMUphS0Z5aWRMY3RRSzZHUkFo
SkhLTDAvRU03M3lxRjRZYmhFTGRFMGRoL0lDVTlQTVA0aEFyV2p0eEZKNFRPL1hUcllaSXc1SXBU
cFVGOUlKeUV4cG9BTjR3c3RwSlBYN200TFcvb28wUXEvQkUwWkk2NUkvRlZ2ZVNyYnhqeEFHUW5H
Y1YwQ0s4cFdUTjQycjhETUlyZmpWeG9XWUg1NzVtUE5RZktTbEsvYmtTOFduRnBWa2MrWkY3SkhI
M25qeSsrT255bitZWjhNMkZmYUhYamZucncrVXQrL2pDalJmcDNrRHNOVmh1M1lQVTQrYzJ4NEp5
ZzFqb09PaFZNOEJ4aUx4ekhGeVBuK2N3aldjMEhuZTdNazhVUjFsMEF5STJoMkNtVThWOFBCbzNZ
S1ViRUFuNFRvNE1VK1JVMExGRWxoTFlqNC9ISFhwdW9FSEVyQ25MdE1lUEpEYmV0a0grQlZDeVl4
TDdMSW1NU3N5ekpGMWwreHBQSnZRZUVNS0FrTkFuMk81d2dKWWFBWW9JMHppSWxJc1ZTUk0zZHBj
R2hYNkRnVFo0WVJCQ3dWaDBzRlVDQXdUYjhLNDJzb2IzTWZFM255NUVMSmt4VVRaSlRWelVUZ0lq
eDBuZFE0b2tRdGIzaTFDTjBXbkQyUFpTWEEzbGtCMkVDNVhvMERoVlBOZUx4dVhRNjFDTzIwcHN4
bXNldHQrSGVzZ1RvcVRVRzVUMTY1elpKMFNYNEpuUWorOWYvWXRHTEpJeTVmZ3d4Q2FFQy9hbnM2
bnhTd29EKzZXVWJrQTUxQ2tFRHkzcGtEcFZXTnVMeHVVd3hDK2d2aVVPM2w0cWRaWitLbEtwdnV3
UHVZN0U3WnNORXdjZi9wRGVOdlRoejlFQk5IMis0T2VWRUlicFdSUUc3bG53VitvQXBqYmNzeUxX
Y3FnZVg0dnlqV01xZkFmalN2SDJZZFF1Y2Z1R2d3VHZNd09EWlpwUWp2Y2wzbWRjR01TWHdLOUR6
Q2I1REtySDF3NlNnL05nRHliRnZUa1dUU0U5RE1BcUdyUlBOTzhrVjNLT2FPWElGRVZPQlIwdlpC
dktkM3pTNk9pVk1RTVd5MWFUWEVhaTRXMFVCSW9EUCtnaERwbGxoanpFU2UwWkdTNlRIQkR3eGtH
bXpGQldYZllESk0rWXVkWGlMS2xQQXVidGR2ZnUwb0JSa2tTQlNlMHVTaWdZaTY1dEpqRnZDQVlD
a0ZkQ2JHY1dqY1hIcEpwOFp1d29lRHdGVjdsRWFVTEtQaWhmQXpnZHozaitsR2RZRkFtNVF2QlFw
Uktwa3diRUVpaVhDblFqNHZPTVMwdWt4aHNBT2p1RHkvcjhrSnd6VSsxRnBUNmwyWHhVNC9yTnpZ
V3prbjc1eTkzWis5ZXYreExPSWFrRnltdUFHVkd1OEZ6bUhaZTZRVG0wTXFRQ2pTcFI5QTR3aDRC
eXFVQlBsVHRkcDMySmlyZmY4bTdLVWtrT2Q3cEJDYlhnWUNlbE1uVDg0SlBSUEZRRjZ0TVp0QnZx
ayt3aGZJUWxaYU5IQitGQUt5Z1pPb1d2SHAvUXdWK2hnV0Z0dU50RnJDRkpQWDRHWmhwUFlrTEY5
VlVlOHNBMFc3REtTYWdjUDRJY20xQVJ1YVVpT2Q1ZmxPVkJxL0NPSnpzU3FjZlBLcndqcldnanhN
RUc1eVlvSTRMbUVNejAvSmtTbCtiSmFhcVZJOE1VT1JWMExKR2xCUGJqczFpSEh0TmpzSmcxWlI3
MytKSEV4dHMyeUw4QVNod2tIc3BpeWZUMFExUlBUL0RGaUtaZSsyby9JREJCY2RwOGdoZWtUVURp
bWZueDdZS3ZtTVQyZFNRNnhRS1g1dU1xU3FMZnFsR1l6WVZJTVBiRE5XMHp1VUVIQkYxZWlyQ2RX
VFFXSDA1VnF6WXZSWmVPT2wxT1kvSlNxRnlpTkRmbHA2L2lRd2lSSE9CMFBNTTdMZXFGNFg1d0Jl
cWVPQXJqQjZTa24zOFFoMWpSMm9tajhKell5WnkrQ3c1cFdETEZxUUw3WGxEdUYxYWdBWGpEeUdv
bjlmaVpnOWYraWpaQ3JNSVRSVHZnSUg4b0JycVhiT1VkOVEyQVJEY1hJb3Z3bHBJMWo2dnhNd2l2
K05YRWhacjNwaFQweFhiWUlGQU9OSS9xOGJYSXNhRGNyNjFBbThDUDBFQ2JFSGxuRTF5UG4xR1l4
bk5DaGJNS1N4U0hKUFNsY3RnY2dwbE9GU0R4YU56b2pyNlVqb0R2dml1RERGUGtWTkI5S0FaWlNt
QS9QbmlsOUpnNW5JaFpVOUlYQkVxb1QrQmZyQjloOE5heDZLdS9reXczU2p2KzFkOUpucGd2UFI5
NjVYMlMrN1JUNEhaZWI1Ykx6ZGZ1ZmV5WHI4eE9ILzBsRnYxZXd2djZoZWptelhHL2ZmZnUzYTlt
ei9MTnhuemxKSS9Oam1ZMU5pYS9mZDk5VDJTeDYyRlMrREFwTVpNdkN1ZDh2ZjlmZzdUYmVYMngz
aTgrYmU3TnB5UnU1OVBaZnZHSC9kakdkUFZsYVM2K0x1ekhrVC9aenhyUGQzdjhnbnFSVCtuRHA4
Sjh3QWM5dHZNZGVKbVkvYVlFMmx0dVVCdVdVMk9qcDlseWJqOGxjakZiR0NZWGlyYit5TWlCRDU0
a2xRZW5OTVNjd0R2amZ2dnU1dUxpVHI5SzMzNDBvZmxTeTN5dnZ3R3l0bDlsWVQ1dzBsaTZ2ZW8r
YVdSZnFJbnNXMnRKWXBlR1B1d2l6RzdSdm1aeDNmTmRqRFR5YVRBV0I0bG1JekFZTVpuSHQ4UFNE
ZjBkRmJ0M0ZRbzgwdEQ2TlVDdzFWYUFrdVNrQ2lxOVlOTG1lOTJsd2FJa2VrMGdONXVDa1dBc090
Z3FnUUdTWkhqWG1VVmo3MlB5WmluTngrb2R6d0NsK0daaHdjWHVMRDhNekhJTVRPb1ZYcm1tZFFQ
U0dQRUcrR3V2ZVJ3bklDWDluTU54U2g3WG9ieCtZQkpqRkN6WTRSUkpwVlUvYVpxb0gvNDZoTDZr
ZEZLUG56RWtuK0RCSGtyMTJYeVQ1bzlHOVlLaFRwRlZXb3ZnbG9sQndJOURxRXQ2eDlYNG1VUHlF
UmJxa0tOM2FaSUhhVmJwTUw0N2VzZWVuZnRGYjBHL3U4RGJaWnU3cnJyZEE5ZnZ6SytIajlpTnlU
K01GNUJxdkp5RDFOVTVCMjZhZWdmNDFUVkZVeHUwQlpGMzdvSHI4Zk1QdnZFVmJZUjBWM0hONFVB
S2E0M0IyK2dVcVdCbmpCWUx0WUtUeDhycHVKVWpzeFE1RlhRY2taMTQ3dU8vOCtwb21qRU1Gc3Qy
bEp4SUl1TnRHZ1NLQTMvb2RCMGRlT0RwT3JRMXNxNVpGWW9TTnJZK0hLaWtJWGpGZmozbVFja3p4
cSsxT0l1Q1ZLK05ORnNqd2FVQm95U2hBcE9aclpGSU1CWmQyMHdhR1hTZEFFVFhFTnVaUldQeE1R
RTNteCs0Q2g1UHdWVXVVWnFRdU1oQmt0MkloM0E2bnZHdFExV3BGT1FLd1VPVlNxUk9HdUZKb0Z3
cTBJMkl6ek11TFpFYWJ3RG83QXd1Ni9NRHRrYW1hb0NxaWtydncyNk80dzBNaFhwQ0lIYnI1TUNB
TW1UTkRIYTJQWi81aHdmNFVpbm9CWkFLTkxwRThhVEJzUVRLcFFJOVdlNlVuZllsS3Q1K3pic3hT
d1VNNlZLbjdNc2dPVWVTS0g2ejhVWFlPcWxmYkozcHowVFFiaHBsQS9aTkhoMmxRNVdBSFhxbmNk
UmpRRGtQT1pGMVlXMjR6MFdzRlVrOWZ0WmxHcThkbFFFTEhKV0hqS25RMUpyVHZrVHhHdzRmeDJa
Y1VBNnBTSTczRjZXQjBDcTg0OG1PUk9yeHN3cnZTQ3ZhQ0hHd3dha0tUSkNRT1FRelBYL2l4R1Y5
Y3U1cTVjZ3dSVTRGSFV0a0tZSDkrS1RXb2NmMEdDeG1UVm5FUFg0a3NmRzJEZkl2Z0JKSGtBZjJU
ZEs1NlFjN09WMy9jcjU2Nnp3NjBtMmdqKytnOUhaUWJOM2lCOW1YbGZna2tPWWpFclpkODIwS2tJ
UGxjZjNpenp4cU1yWHUwb0JSRXEyWDFMeHVFZ25Hb29PdEVoZ2d2WVYzblZrMDlqNG00NVVTZEtM
ZzhSUlFkbTdXQkZ6d3pzckJ3QXpSNG5ROHd5KzdNcDVBWVdDSEdCSitRcTRRUEZTcFJPcFVrWFF2
S0pkS3I3TTVMaTJSR204QTJINGY2aUhwYlZZRnFacEtxK1NaMDFzYTFBM0lDYTJaU2ZaeFd2TWJU
NmFnc0NkTE9TR1VRL1ZES3REb0VrWHYrSFFJS0pmS0VFK0MycGVvZVB1MTFMMzZxVWlsQm1icXJJ
T2RsTXJROFVWSWIrTWdWN0ZUbVR2ZFZDVkY1WkFFZDBUUWJwVkNVaWwvVjRXZzdPZW9DQ2pjNitD
djFDdE1iYmpYUmF3ZFNUMSs5dVViWDlGR21GN0hsUnFZcTdOV09RbVY0d2NRYWRsaFlOUnVxVWlP
ZDVLczBEb1lBVVVjRFB3NnhKYVNJNUY2L0t3aWVUMFA5bUN1ZmlEMTY4d2htT2trU1JUOC9CeG5C
eWNEbEJOWkswZUdLWElxNkZnaVN3bnN4eWU0anJJWjIyQ3hiRXJKanlRMjNyWkJvRGp3Z3hKY01q
djlBS2FudDV2UGZMSUxFN0tLUnRKVkYwa25pbHlvbDNodHJnVWtQdWxpcmh3d2h1MDJBcGh4Wlhr
QlQ3NkJ5eGFNbGxnd3BzUTRkTWFuUXR3cWdkRWxzK2l1TTR2RzNvZnoyK2JiZWVUU1VhZkxhVXd5
QzQwYWN1Q0pwZG5ReUg0N3lzb1RyR2wvUHlDR2QyRmdod0MvOWx2SThRTlMwczgvSEwva2NmV0V5
SlVRV050dklGbDV3bkx3MXp5dmFCY1VOZ0Q0ZFpBQ0pMV1RldnpNSVhrRkQ3WW5CNnU2dUtQZXRR
ZU5Bc1VKUzhUZkpyenVIVWpZSk4yUGc4aExtc2ZWK0JsRThoSVdhaytpVVFuek5QMmVFOUk4cXNm
WEloU1V0UWdCUlV6Uy9jcndyMnREQ2lEeWpncXV4ODhvZk9NcjJralB5VWRrbFlKTWJDZzhTbGdP
SnpBSHEzYUFodGdCZzF4eG9Xc0wzc3F4WVlxY0NpeExiQ21CL2ZpUWxpcWJzdzBXeTZhVS9FaGlN
dzYxNVBRY2VPY2tVSjZaNWtlY0JDcGlsY3lrQjg4S3BvVlBJeVZvNU1OeVB0MlpNMVhyelg3KzBx
eStOcWV4ekNHc3I0djlZL3ZuYkxHZFBTM1Z6L1owNFhTOVg1ejFIOGdxZlFCWEFQQzBPZlczbUJ0
ays4ZHBkMmJNSGcvVDU4MW0rK21uSlRvdlJrN1YyU05tOW5UYWZRK0Z5b05DRmdJSzlqRGZ6Y1dk
V1JYZlBXNmVsdVlNbnoyak9OdXNkNHY3K2RhZVU3VG42UURWRWVmanN0Q0hTNlM1Sk9ZYmN2QjRY
T001MEtWbW0rMTJycHpGbnJwOG5OdmZIaGJyZStWRWpJdlZod0pGOEpFUCtCaUJwNmRMWjh2RmVq
R2Jtc09pajR2ZGZyTzFaeS9YOS9Zdkk5c29xRnZqUll2cDUvVm10MS9NZWc3SFpyRVArZ1NoTndv
MFRyUll6NVpQOTdCZkdwanpQNVFiTVdkTmw4cGhMUHcvZHc5UDYwTW5IYlBFQjMrSzhCTlBhWHdk
dWtEenc1TnlJWHN1OUc0N24rNVgzZldiSjFWSVdjMk9CNzFIZWJQVUIzMkcwSGNJVjlQMTlQTWNn
TnFBMDYwN2NyNjFPM0w5ZDlOVjUrcW56ZEpZTVVxVDVDeFNvOFhmZW5oa1BqeHl4T1A5Yks5QzJl
aTM3NEhWZjM3eC8vOXNMazhLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ28wTUNBd0lHOWlhZ284UEM5
TVpXNW5kR2dnTXpFNU55OUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVStQbk4wY21WaGJRcDRuTFZi
VzNQYnRoSis5Ni9nekhsSlptb1lWeEwwbTJMTGpscGZFa2xKNXB5bUQ0eE0yNXJxNGtpeU8vbjNC
VWdDWElBZ0xacytiZE9RUzJEMzJ3c1dpNHRJaE5XL2gwVDlMMGxwTkZzZS9Ed2dCWTFFUk9yL0Ns
SWlrWlJwMlpZUkpOVGZqQ0VpTU1aRnA2UFJra1NuNjRQUEJ4K21CMGRuSXVMUjlMWmlwSmdUeGlQ
T0VTVnhORjFHZjc2TDNrZC9SZFBmVlV2MWpicE40eFF4UmpGV2p4alJ1TkVqaVFoeGVuQ0pFUllT
RXg2bGlLUmwrM0grc043czNrZTY0N3ZKTHRzOWJvK3J0N1A1S2x0WWRqNVVrUWlGQVFsR254VXNz
SUthMEZUR0VVMlVaS3hCRjUwbWw2UHB4OThxZWIrUExpNHFKc09wc2lXT3VFQ3g1TnAweStnUUl4
WnJDcU5jOTE5RUZDY0lhMTZpZzF6MTErUVl4YndreHdoejljZ1V1ZVFLQ1BmUnQ0UFZnYklvVGlS
bjZqdFB1RkNxSUJMekJNZlIrUHpnejcrVVhqZUtsTkJDbFg4T0xEZ0x0d1hGUkhuKzUwSHdvOU5I
SkVoaXE1QkZyc2ljODNadFhnWCtaV2dhR3RRZmw0b3piRm9ZSlFUWjBsNkZGenNpTzJHNlRROE5J
TnVxR1ZUWWNWY2pPbHlWWGdhL2dGN0w4cTAxTVVraFVjTlRPQU9JSWNvandWQXFjWnBXQS9kVHRw
dm5Lek55UjZ2YjlXYXBTT3NWSEVJS21POVRSMXVPUmVqZDZzOHhSekZMVThrZEsyaWJzN2h3eDF0
RW53UFJoMUE2MHFXV3JhRHhBRkRyblJid3IwTDVuUHdhcFJlYjNraTJkZ3VoN0Rjc1hHRnRFUDFX
cnZsYlhSdEMvaWJ1OWszVU1RcW9udWRVTTYyWE94WW1EL2xzdnN4WDNZTkJXMXAxU2VQVWN5VWsy
NkVna2hneG9md2lmTEpqTHpVTmhoS3hNcjd0M1QvMmdyaGRnTjU0Y1dINmpVTktRaWZvM3U2N2FL
VHVGc1ZmcENGSjAwUnJXS0cxaWRHWFgrdmtCcmkxaTVzS0JOQ3BBYlpmK0FabHRnRnVhUnowWjJ2
SWhOVDV2Nld3bHBISHNVU1U2ZUhtRGJ5VHhmTnpVR082YmhZM21yWGlMVFYrV0RvQXd0dFVDbnNt
Uk1LSnNqUk5VK1lpMUhRc20vVGVRSjhGVVdNRjVMcWR4SXJBYlVIamtMREx5VFlJS2VMUWUxVENR
WkNlTXRodEZVRGVyTmRDOWFVZk5UMTBhSVFNZGdGVlhrQ0NSckZRN1lzaFFWS3BwaWFraHFqdXM4
a0xpV1pwV0xmbGV2bFhqUzl2ZlZTSXJwZGtIWXNpTzBJSmJoYUlxVnBia1VUbGxaTE42ZlVIczVJ
ajlJaktJNUlLV2JHeUhWUFZrMG1WWGZ6ZWcvT2g2VzE3NlVWZ1NEQlI2enRKR01hODdIdWVyMjd5
emJFdlM2amxKOGZsZ3RYdGNGbEthb1BtTjI4MExWRlFxbGVqYWtvSkZzaW5YWGk4cnBQQjJWQlpv
L3duaEswVXlBU2lRc0dxVFBZeHp4YTcrNzNrZVQybGlCT0NjUnBqS2ptUEV5RFNsdkZkcFIyc0lj
RndnRVhiVzJlby9RcGcvZTRNZllEVUdhY3RHcng2b3VzRVVXTjFNcEFoMk9IZXlLNkJ1Y0ZhdUUy
ZC9pbTFrZlZiRkFyT0RtM0xqM0NZdkEzWVoyZXlhdS9MeXlXZ3ZvOVRsREJlYnhOVjlYMWpTTkdZ
VjRXSjErUGJSeVp3S3NpMDBhTVdJaW5pb2lpR3lscG12VmprczExKzB5SEY2NExGRWNGSEZKT2tr
U0FJTndXbjErZkk1R1Iyek9McStkTnBGODVVSUpKd20vM0crU3lmUDNYQzlIcG9tT1E1bUY0ZkF4
UExZMHoyZ2tsVUdNbVUyU1JhN2l4MjR2Uzc3QVhVNzJRTlNvNnBiQ0QxVjM1ZFZUdGNKWUR4QVN2
dy9ybnBCZXNIZjhIVHZsb3paQ2RiNmU3TzBBUDZPUU85UmU5WEwrVjh6UUkxbElkdDJhb0VNRmdY
SFV3d0F2SUo2ZGcveVlXRk41Um9URGpoWG51c1k4UFIrQmFLN0RGVmhyTjF2U2IwVXErekp2eVBL
U0pWY2N6VkhNUDhnVjJ6OGZMa0g0TnZ3OG1KcllQUEIrUC93anJZT1gxSlZHbWxDbGRUWURld3Ft
WUVLWDFLZkJlajRkWFVuSGdNeDE5SEo4T0pnU2xqdFJaU3BiQmtTYU5XcGt6bExRRlpUVDROVDBh
WHd5dlQyNTkxZEtVdU5aSjJ0Mnp1SUV3cWtKUzFLVDgvNXR1ZHNVRHhVajJmenJPNzFYcTdtOCsy
NXZQdVBxK2VzdTEyUFp0bkt2VldoTVg2Ym0yK3JRd3hXeXphMnJkSXFpakxiUE8zZWM0MmVVUDhi
cFBkNUxEUityYWJMMnIxSzRtTFF6TzFyS01wSjdTSVhNRlQ5VGVWbEFtbXJhY2JKNGlxUWtPWlZD
Ky9idlV4bkNZUVhhUXZ5NDlVc1NqV2orQ3ArRjQ4RlYwWGdJMFpUaVN5bzRacXVsNGZPbndySG5h
WXFHVkw0ZS9JY1N1aGFvU2s3dUpGYWR1cGwyYXZlcXFoWHl6TnVhc2dVV3RLb2VuRTRvR2tTa21v
T29RTEZZWGRudEVkV3JVQkFCaUJsVVlnMEFpY0k2WlRWZW9ZWTdTNlZTWFhmUDI0dFdHeHpiTnR2
dDNUU0JxRnJselZRQXBFQVVtb1NtMVk3Nk5aMklCVUdRYndDSkVxNVNESldBN3dlc1p5RFlZdWtu
MmlDTEFJaFZQb2hMaVdFRG9ocnZNYVo0aG9WeWJCZHMvNXdJd0lTaTBiNElYV2dKQVNxWVNvMHox
aktFMHFkYVoxaHJqS2x2bWVFS0JvVXU1SXlMMUEwSmlwdVM3Um13d1F4VGpmUGk1MmV3cG5USW5V
ODZrWkhKVEVTTDFpdko4aEdJdE5meGZEYmI3SlZ6T1RWc2ZaNm01ZmV3aWVhSmFwVEMwa3N6KzFE
eUxRSFNLNnlIN3NLeitXU0JrMWxiS1M3dzNOMWlBSEhhRmtaek1FUjdwQXdiamN4ZGFjNi9lRmVV
OWlERTl3QWNIVVNXM3dXemFTdTJTVzVaMm1paGdSV295NDRuVFh2cG05U2xIaktKcUwzcmlnUkJj
Qk9BTUhiYW85VmREcTBKakk2b1BkTjkrQ0RWVmVCcjFoVGh3QTdacDRDWk1MeE9hU0hkdjI5dm1l
RUtxOWwvcGpsMGQ4cDhOdWZXUEJqNzhncEFCZXFDUElaVkJIbHh4QzM5dmFMd05VS2dFKzdxRjRp
NjBoazc0dWFJbUNJTTZBRWxEeE1nY1RmV1lIOUhhb0lSVjYrK0ZGY0txMXZQMjJoOUl0NWdZOCtq
cWhKU3BDS0YwTmlnblBVYnFlalJ3bk9HUlBCY09rbnc0dkExUXBVWDlzNmwyd2dvcERNdlFEWU5M
WEVVSEpqaElCVDRRMExIZVJIQmVBeXdja2lMNi9DL1pEQXE1YnVLM3NXYjREdTk3QWc3NUlZdSs5
M28rRHZna3IvU0x0bkJzWG5sb0JiempVVnRlMUJFMkxHbjI5NFFBS3dNYXFiaXc0M2gyVXBRdERp
VjZweWdJUVZTc2lxbmVlUVNXYUJpcFJsVVRVVWxCZ0pDV3oxeDI4T2xSTEx0STltT25MOTRWNTU5
SVdUTlZManpxdlRWWmRNcWxGaHpsakxKdHBnZzIvNm9nZGtqRHNVaUZOVXhUTFNnWHovQ3JVdGJ3
R0ppdlIzZ1dBclFKQTY3clZhSTNkTjJoalI0MVhWS2ZRMk5qRjRkYjZwcEUzOFJ0UUxwbExMeTU2
bFhuUGlHNlVlWTZCUGJxemVnb1NyTDlnVUFBdXZlS2tFYmxoMkMyMXRqR0VOKzhiUTdoa0xzTnVl
WXR5N3hrZ2pYTFBVZG1qaDFZNFhYUnJvb0JQQU90ZWJtb0xwckJLTFVXNk1aSmJqaGtiT1ZRdXcr
NTdpNnF3RzRaZjF6cnF1dVRRR3FtTGJxMFQ4RXJOdVplZjJrSXNxRStnQkhiczQ4NjcxazhPbWRm
Z0RZUFhPK3BsUUJwVm82dXhTL2VXVVlXTUxybzFFYUJiWDlXc2V6a3JMTElCM2ZkV3lCcDFPV1Rk
QkNvdzQ2YW01OTZpSUd0RDROYVJvQldzZzJ1NDlmR3A0NVlrOXZ4UjYyWDkwVlQxMVlXeHIxQ2dB
UEFnTGR1eHQ0VmdpMzhEY1JYUXRxL0x1cUI3b1dhTzQ1ZytZWTNWWjJuUFdZblpPNjUvR29kaSsv
dVUrMS9iK1d5ZW1VdjVKK3ZsTWwvdHRzZnd0Qzk4bTFFZjF6TEVVbTd2ZUF6dHNlWFZlcGRiSHZx
bzE0VkE5R0ViUjRJbGVrRlFYc3M3K1dxMjBLOEc5akQxeStCcU9wb09wcU92dzRway9veUhnNHZx
Y1RxNk5GOC9uWXdiOS9sRWlvUytqMEFhTW9kWE5jTzI0eG1GbEVsRWNHeDcxWTFUVHkyUmxJZHRV
djlDVURtQzZ3czM1WUZKZmV5N3loYS9kdk5aWnM1MUgvSk5jU0c3UGtPWTNXZWJiTGJMTjNONG9H
dlBaM2YzODIxRHlWb3lkeVZuMjIzMnErcDVuejBaR1Q5eSt6dU1tMXlKV3M1WDltRDVoMm5mZmhM
Y1BKNENDRVNiN3N2MXpmeFdxYTd2bm0rYm1GYnJYUlBkYkpGbkd3dHR2VEZtZkhqWXJKOGN5SzE0
WWhkUGZRWitkanBBSm9ZS281cURkbUN4YlJQU1U3YVkzNENEK0lmSHpmWXhzNWNwZHVZVTN3cHFS
WmE0eUU0dVJvT3E3eWEvZTF3NGhxcnZCRmlrajF1TDRkWmFacmFZcjJCNFBXNGUxdHZjT08yWlVK
ZXZDSFhwdTl2aTI5WGg4NDgxWkJYdkZ2bmpkcjY2YTF4UE9MbitNSmg4ZnpmKy9uNndmRmpNUDIz
eWg2TU9RNmFlSVczdmFmYnpNbHNWajNXRzBjZVh2ejFSaEZHWE1TaCt1VEVvZG9HY1diY3MxL1lT
eGh6K0FxTU02NVUxZ0dNOGt3ZnR4WkRkdW5sZnVSWk9YT0gzdTkzRDhkRlJmdk5ZRGpuMFU0L25H
ekNRWit2bDBXMzI4K2hzOEpuU0o5TEJtcnFzdjBNM3E0RDcydy9OSDNudFZUMVM1emVCVUFXR3lC
WWQ3cVZlTnJVYU5hTGMyblB4QzMxL0R4eldtTHNvRjJhWjFQeGhkS094cmpWU29jK0t5MWx6T0Q2
N0hsK09yczRyZ1pQUmRBaW51OWo3YVk1aUVSZVh5YlU2ZHU3eER2Z3BJcW9vOEJ0Ky9qS2NtSHRR
cDZQQitkWDFaRG82bVJ4K3E4a2ZSeGNYRXhNcmt0dWJvR2VEaTRzUDQrdnJQNnIzd2RmaDFaZWhh
ZGpHNE1Ua29KUXd6QThacGVZQzdFWDJZNzNKZHV1TlNZK244MDArVSsvbVp0WHdhanhTZU0wd0c0
N0hnLzhOSnI5ZG5scmVLc09aeGxpYzRwaXJVaWlCdGNhL0ZRMUFvQXBsYm1SemRISmxZVzBLWlc1
a2IySnFDalF4SURBZ2IySnFDanc4TDB4bGJtZDBhQ0F4T1RrMEwwWnBiSFJsY2k5R2JHRjBaVVJs
WTI5a1pUNCtjM1J5WldGdENuaWN0VmxiYzV2SUVuN1hyNkRxdkNSVmF6eFhHSHllRkFrN2JHVEpr
YlNiT3J2WkJ5SmptenE2T0VpT2EvLzk5Z2htbUJsQWNpeXY0M0tnNmN2WFBkTTkzWUE5QlAvT01Q
d0pJK0l0VnIzdlBieW5ZUThMK2JzbmhjSVhJaXA1S2ZZNS9FK3BqemxDYUM5MG5xeXdOOXowUHZj
K3pIdm5sOXhqM3Z5dVVnVEtNV1VlWXo3QmdUZGZlWCsrODk1N2YzbnpYNEVUbmhHYk5ZaDhTZ2xD
Y0lsOEVqUWtRZzlqUzRJSjVDTXVFR1plNU9PbzVKOW1qNXRpOTk2VGd1OW11M1QzdEwybzdpN3pk
YnJVNmx5b1BPU0F3ZWVVSERYTUVVQU5TU1FDajRSZ0dVblFlNkhaZFRMLytFdGw3OWRrTktxVXhI
T0lKZklZOXdQQlpPaFczaG55YVNBcGxEQXB2L1FJQ24wa2RmRUQ1RXBla2dNL1lDVTU4QkdEU3dy
a1VxdEJlUEMrOU5ZOWlDZ0tCYVB3bklXTWd5cytEbGlJQW05NjFmdnpML0RyRmtnaDJidnkzTlBn
Tk53T0ZETlkrZSs5MW9lV0RBOTlnYlJER2ptUUdXUGQzcndLL00raGFYaFFQMXlCWnBOMUg1UTJ5
SnIyS3J6SU1ua1FwczE2cGdCcHJ1YW1RdFp5TlhhSDdkTFB3ZDlEcjIyNTBacXBvaEJDZW5Jcmdh
aFBtTWVwSHdrVVJWWGkzcVM3UEZ1cnpFM1dkNXRpQmFUTjJrd2hBT2F1cWVVdFE3enRYdnZQRVBN
REdrV0NXVkdRTWFmQmZqbmVZdmRaRUYwSTVVTGExSkxMREo0QlZLOU9CL2hYb1R4bXYwYnA3RTBu
azNYYzJsQ2VsaGEyc1M2SUxwY2QvczZsYlVQK0pzdnRodWhBRmhCNXpnR2I5TXZPaGRsanRzaFgy
ZnB3TXNoSWcwZ1VSTTVTbW1TZENqd01mTXBoWGJoTHR1SUZ4MkJiSVliZ2ErblQ5MTRyYmh1Z2t5
ODJUSmU1elVsekVhUzBmYzhicGJ2RDhaL3lFRWRSS0QyczBPckM2TnF2ZmJJM3VJNkxYUXE0NFZN
RDdHbmJ0OVZtRitBTzV0YjE3Tnd5YmU3OGF5V3NJL01ZRWo2aE10MmN4QnNzajU5QmplTzYyZHhJ
MWFCYlNQeG02MkFRM3FaVGVHRkJ4QXhEcEVrVVVSdWhwQ1BScEo4TTlDaUlHcXRCcnZrRUFnTFRE
WTFGUXJZbXpkRG1pRVUvb1JOdUJlazRnMnl1RnVUTmZxMnR2M1IzelFrK05MWU1zZ0ZWcStCejRn
VWMrUGNwZ1NNQlI1TVBLU3BsaW14dlVZMkdOUytUNDErVlg4NTh0RGRkajJRSGhpS2RvUmcxRzhR
SVppc2NRbDBwMVF3bkg5UWtoOGs1RWVjNDRxSlNwUVVqa0tRQ3Fvc3IzYitLbGJTV2trTmdtMkVN
ODUzQUZDRld5bDVsNjl1c3VIQnRjUmcvR1NvSFZsdmd1clRVQmMxbGI3Q1dLQWlSMHlnY0thME44
dkFRSGtkMDFyK01JUnJsVHh1MjBpRGxQdUVBcXdyWnh5eGQ3aDVlWk0rUkZEd0lNVUpSZ0loZ0xB
Z05rN3FOUDlUYW1UMmtrUTVtMC9iV0ZlcGxEYkM4dDFMZlFHcmxhWWNIcno3b0RvS29zVm9WU0JG
MHVqZXFhOHZab0NQYzVjN3BKYlZSOVRzY2FqMGR1c2FQOW0zeU5tQ1BubVRWdXkrbmxoajlmUkQ1
SVdYMWE2S3F2MitrRkFsWTFaZzRFbDgrVW80aWp1Y05pZHFJSUQ3aisyYW83R1UyeTJXMjJHVzNC
Nnc0SW9pZlkzUk9FQTRiQlFJejFYQTZNdWVxSnRNTEdsVFhOOE5ET0NQdTQ1RHA2amZORmxuKzR5
Qk1SMExDeE1kZ09qSUtKaElYQ0w4SUpvWnRKQ0txaTJqNVp2RWdUbGZrUlVCZElSMVFmRUZFQTZr
NytSM3EyczBwd2NnUHN3TS92VGI5eFB6Z0RqemQwNW9pVzlWS2lsdXBaL2huSlhxSDM2OGU1VnpQ
V25vb0I5dXEwd2tqWUlmb3hnSERUVDF0UHA1ZTVOcU5ONXhvSERqdFVpK1lZOXQzNDFzNDhvS2pz
cjFhMXpPaFUzcXRtZkEvcW9tRTVwakJHVVBkeEs3Vk9IWHlVLzlMUEJ2b1B2aXFQLzJmMlFkYlgx
OUNhSzJnY1ZVTmRnTXJzR0VmL0NueGpaSjRQRmRmUE9McDc4a2duaW1ZSW9CWkNGcGhRY05HcjB3
bzFDMXVxcHJkeElQa09oNHJhZmZVa1oyNmtFaTZsNlc0TjJFUzdndFJoL0x6VTdiZHFRanNiNnJy
WVo3ZXJ6ZmJYYjdZcXNlN2g2eTZTcmZielNKUG9mUldoT1htZnFPZXJSVXhYUzY3K0Rzc1ZaUlZX
dnhmWGFkRjFqQy9LOUxiekdUYTNCM1c2M2V1S3c2SVh0U291YWl5YldsOEo4TXVINXhRQXVhcjBH
ZlZ6cHJYS01icEttc3NNd3h6MVdoWHl5VHEzZUkwWGQ4cmtSS251WUpFYmgwaTVKdWJXbmJ5cE14
TjdscTFHQXFvWUpDTlZINHFxeFZNczd1c3lOYUxyRVc2bmk2NHpCOHVxMk10T1VxLzZjaEVIbldU
QXVaU0pOd0l0Z1NhNkFheGZmNnFRdXl3cWV6UUU1RUsrbVNlWENhRC9qeVpqQTk0NFdpTEc3eklv
eS9ENWJCZEo3TlpNcjdTRldBd0dROE5qSjJBamxsREhqdkNRVUdYSFBTd3krbTh3RjZtMzdLbHpy
Y252VjN6OVdMNWRLc1Q3VmxsdFh6djFzaTJSM1ArN2NMQmJSekowRmRiZGIzOFcybGNLNHRQNi96
N2s3ckpiMEY3ZnBkblJVVjRUaFdHeHlMYjFtZkFScm1sYTBRWG1zQkdzMDFYajh2czY3dnQxL2NL
MXJ3dU01REYrZnErdXZ0NzgxUmRGZGwzV1daME1Ydk9kYUg3ZHNSOGFKdC9MRGFMYkx2TmJ2OWJ5
VDlzbnJNZldhRXE3djJtdGc4cjhKd1d5aWFnVHJlWkRzYm1SMzU3eExTd1RkZExXMGRaMTl5dDRX
bGVhRWUvcWZXcVMvRitwTGxYZDJwbmRHR0liQXo5VlZia2kxUXQzazI2ZTlqQVNaSnZkd3JBMTNl
RC9zMStiZW92LzgyRE40SWM1TlVybVhoNk9abGVHOG1Yek9NTExRNXpuL1BpR2VTSmdPT1c2VmNs
elRKQWlJODViVEIrL2kyZXFWTittUFN2eHBQWlBCbk16cjdVNUkvSmFEU3JydUhVVldQT1pYODAr
akNkVEQ1VjkvM2Y0L0Z2Y1hYVElUN29WeGNScG9pZFVVTFViSGNkRDZIV2pUU1NhVHlZVDZhcVk0
akgwK1N6Vmo2UHA5UCtILzNaTDllcUlFR3pvalNQSjBvSThTRUtHQkVrTkUvT2Z3Q09va0NRQ21W
dVpITjBjbVZoYlFwbGJtUnZZbW9LTkRJZ01DQnZZbW9LUER3dlZIbHdaUzlZVDJKcVpXTjBMME52
Ykc5eVUzQmhZMlZiTDBsRFEwSmhjMlZrSURVd0lEQWdVbDB2VTNWaWRIbHdaUzlKYldGblpTOU9Z
VzFsTDBsdE1TOUNhWFJ6VUdWeVEyOXRjRzl1Wlc1MElEZ3ZWMmxrZEdnZ01qZ3pMMHhsYm1kMGFD
QXpOREU0TDBobGFXZG9kQ0F4TVRNdlJtbHNkR1Z5TDBac1lYUmxSR1ZqYjJSbFBqNXpkSEpsWVcw
S2VKenRuYit1NjdnUnh0OG4xU2FBa2NjdzB1MUQzR0xiYlZPa3VFaVZLbm1CVkVHYUFGdTdTSmNx
VmZxOGlGZTRnelBnblgrY29VaEo5dmsrRUlhUGowUlJNbithNFhBb1A1OFFCRUVRQkVFUUJFRVFC
RUVRQkVFUUJFRVFCRUVRQkVFUUJFRVFCRUVRQkVFUUJFRVFCRUVRQkVGSDZILy8vODgvLy8xWEtu
LzgrMDl0NGMrM3NtMTJka3NoNkhMYXVDQ0NObDd1Zi9yaDl2TnY4bVhiZml2RUd2aUNQcm5HSUlv
TFdiR3p6d3lDanRObVNyWnUvK1Z2di9PTXpvQ1I0c0pZd1daQmJ5OUNpYnM5dmRHdkhsYmszWFVI
VU94RFlwd0Z2YXRpbE13L0JVUkFBNEpJQWlWZFRLemdzMEdRMEVZRWo1VThmTVRuc0VjUVpHcERJ
N0JLdXNBa1FaQXBOa3hBQ1lKMmFuUFl0RHNIbENCb1FCdE5TWlEyRTRZWldBZ0tGTk8wRWNTdk1F
eW1Idi85WlN0Zi8vR0hILy84ZXlyYjllVDMyK2ZiZjg5dUkzU1FLQVFSb01SdllKaTBpS05rY2dq
SXl1aWxMeEdObTdxR2FYdUZZUkxhdm5leVJOVUNySVMycTZFdjBkbU5HcEVYaFJBb2JTYnM3Slpl
VG5tcjVCVXd4ZEpBYlhlcXN4dFYxbVp4VEUrUE9hS3lpQ2F5ZDVTOHgzKytpdmJUQktaYXZRRlE4
WHdUTXpWMzBFUnBnWlRPZFA4K3BaWmJjdjJnUjB3VGh5RGFNQVdZaXZVR1FKbUJDTFpLYzJrYVdE
eEZBWkFMa3FXLytzeklLQjV0Z2FsWEI2b2JKSjlDRTltam5VN1JwZUtLSGszSkViUzMrMnQxbmhW
NmFhQzJmcTRERWUyNGFYOTRYS3o0MkZtdUV4SXhyVXdwSHVXWktxOFNkaDI1WkE1UjNlWDVFZndY
WmN4MHNxL2IxaE5YWlFKVmF2K0pNb2RPTFZCN2FES3QwcjIzTEZHUHB6UlRwN3QvcG4wWmlPNTZk
c3JzT2RYNzlrRDh1VHZLeTVQVm5VY2dUUExYNVByV0tuRDI5dHVtL1NnRlpKMXVwOHl1TWxaVm5z
MmxRSlhtMGJwTXhWREVXSFgzdmV5MFZHeWVoanR0dTNncVQ1QjQ3ZHFzRThkVHM4d1RTL2RrRTVa
MVFPWDdmK1o4cS9NSTRrUXlqYm1nbllyTjB6Qk5WRzNBa1JpeWlUWjBXV3ZMV1k2ZitZM3ZjZStU
RlM0Q2FvQ200SlFIYXF0YXFDN1JwMGozOC91K3pDSTlZaHBBU1Jldm5sdkY4WnNiZGRkMzRQMWY3
b2xBZVlFUmJrQXdnNlliYVY2Y3RxbzIzZEVjUnBsQWNXcHhXNjRUbzRqTjA0QTNwZGZJQjIrNlJa
UHVEYStTelp2N2xEL2R0Zlovc3hsSVZ3Qmx1bWZlNmVnVDF4V0tiUUluMDR0dnZHTFlYRDhnZ3Nz
WVRicXJsd2pLOEdYQ2xXenR0dGwyeXZYclpHaTZ2K2RWcTN2UkNxQktOd2Z6M09NS0I2N015d0hW
cHUySnZqclE2NmkybStXWXpTMzZFTGVLMTdkdFA4WHJ5M1NxS2RVZUFOUkFYRjN2SXBBUlFBMnc4
SEpBY2R4Z3Y3UEhDZW9hcFVWWTZmcVRUYjEveXd5c1h5MnBkd0pLKzNzWmd4TFhhVVlzUzNicXRZ
QnFVeU5FbjYvMk41Rmw0Vms5cjRqbGl1TFBmRW5hblJKOWdkN0o1UnV6SmhxWjlyOWV6RHkvVlBt
MWdCSmg3Ylo3bHp5aU5rRzlaSXpFNmlvVEpmRjVZS0Z1NmVBNVJTRDNoeVlXQVhWS1VFSUQxUzdi
TjRzWjdtdFB2eHYwN3BMMVdrQzFpZVV0Q05XZTFvWTF1a0I1RUlsWGs2K3V3VXEybkU1OGl0ZVhD
WGF0cUhNNlVISFB6NWV4aWFSODZ0R1ZnZkpBS0prblBRcnptRExwRUlzV1c1VDBKMTJ5U2tCTmlm
VnBhN0x6R3o5bFluZDRQamZUMUh3aVUyWWU2ckpBZWZIdGtua1NOSGtvbWFaSEYvRzVaN0NDRVZZ
SnFOdWFBSUxaTWZJeXh4MTZzN2xBNlFvbkFzVU55S1FoZFdPUFZ3YXFiU2YzeVZJTjkwUjRYRk1R
WTlVdExXS2k1SU1TZE5aVGd1ZTZWMlMrOUhiOXdxTlp4dHZ0WStaQkY0MmhCa29tVnphL1ZQbUZn
R3FOQzcrV3pGUHdrREZ2eExTekJOYXFCQlJicUNrcEU2VUVnM2l2L0QxZmJ4WWZibEdVYjQ4eU41
QVhBcXJOdFdPbThuZHNUbGpLVzZqcFJRTmJ0VkRyWnFNeVRPMUpwYTRlcmhzNUhKdUgycThZbVJj
QzZvdjYrYzU4N3lKbnI4dlJUdGR1d0ZvbDJ6OFhxS2R2Ym5iNlA4RTBhQ202bUZsak10eDFwMDhU
dkNoUSs4MVRZSnRhVHl6bTRpLy8rcTErMVI5MjRjcEhKTnJCWTU3QnJqd3V1cmtCZ1owS09rOHkz
enZZT0pQTGw4dytpbG5PTEExK2RhQkVSS0xhdGFiNGVFeUtpWS9neU1PcXRWUEpHNEtZemg2OWhG
S3gvNmFmbjBCL2R1UEpYbS8wYktJSUN3U0gwRFY3aHN5YklXcmJFSyt1Q2lad2RRdTc4WHk5QnVU
MHRSc2FxTko2b3NBMlpRSVJwbFV5TFJTWEFDcytTalVpTVJlbzU5VFpuTzQ5T1pPRU1JQnFOMWtv
V0EvVjlTRkZQVjVRSXM2d05VL3dna0RsNDExZndwOWQ2NW9uenpDMTdBaXZUNkJrWXBXL0lYejVm
dkE0ZWdsdDVTY3hxMHpwUGxOYVhaNTM1NGJiMzgyTVRiWno0RFN2QmxUK1JwMGNQWmxZQlNoNTVz
bDhZeHFwL0ExaDdNUkxxajVJb2UxT3diNjYyeVE3TFJtRkpGQmo3ZCtUSU5GRjQ0MkJpdWVla3Va
Slc2VzRlT09zdGlUOVBXMmFkMXpGU0FQZGlZY0dnVHVuM2Fxa2ExZGQ3cFJuS282NmRKOUZscW1u
Njk5ZURhalMwcnliWTU3aW9aT0pVZ21ySVBwWEhRQU8zRW5HRkl3NHVCZVpvM1VpSmZud0JBK3Jk
bU5kWVhMMVJEQ0VLVDJYejdzT3ljWjROVlFYV0MyU0FLb1VjUGJNVTJDYnRMTTNVQUk3bFEvNDZ5
Y0U3cmlLTlQyS0QwM2RjNGgxTmUrdi8xRi9lcTIzKzNBYnBrc0FsZHlML2IycWVZb2plRHZKcXM1
SEgybWhvRStpRnFoOHB4cUw3NDJObS9JdTM4QjhOSUNDcHF1YWZoUG5saDlqbTB5c0JrNTVZUEFJ
UWJGNE5KSHNWTjZQaEFxYUJGWlRSazhCVTNuekpKN3ZCS0NndVJvQXlqTlBlUXMxRjZqcVlwUFd3
cGFpTVJEVUZROG9xa0F0R2oxdDlZczNYZk9VUDlrMlBYNGd2QWxCWFhGY29yUnNmTUJDalJtcExs
YlZCMStJQnQrS0NmWVExTlVZVUFNV0t1WWlYK2c1LzlXbi9ZdlZXK3RDZkhzV2hyYzF6RzNWZTR1
bW5pOHlKM1d2TEhzZnMxQVpyMi8xYWZLUHl3dW1wa2NrdkhTSS9MUStaUUxNYmRWTHE4c0xwVWl0
dmd2eFhaSHZqZVpOa29aRnA0K2hsZzVrNkNHYzJ0bGJNWUM2K2N2Zkh0Ly9ib3RYdzlVU0FFNFha
ZkVGMStTWXJBbm1taEtsbnQrKzYxbEFMWXJ5emI4SzM2VE5FMXVvNlFPb0dCWVNZWFhOWmFjWFZC
ZW93NXBCWDFrM0dmS2Vmb3k1TncrVlFTa1o1WnZldzNVc1lwMi85OHdCOWZ6b0pHQXFvNnNCUmI1
ZmtCaThkYmxTcG9Sbm9XWk5SYzI5RGp6WHJKbGE0V2ZtTVJuMi9BYzhuSU16VWF1N3hCdDNuMWt4
dlVrN2ZVajY3YzdTNHZHNVViNTE0Nm5XMlJQbWFYcDhqMVN5TzJiOGdlNSs0c1BobFF2bTRndmV5
endXOTk1MnhKYzhYUDRwbmQ3MmRPY1hwNkMzMFJ0NERjczN5VnlQUHhZL3pBT1Z6RDdhbjNwVVBR
V3pxZHdHemRTaWpLTVNVUFQxaWUvTDdPUTg3REtmeGhBL3hhVjFUdHE5K0wwK0JWN2VLNTZGUW1U
RkQyTXhkekd2Q2R2b3RtMzZFT3dlZTNNUUhsRHQwYzBtaVYzNDBPYTFNcSt3SjVyaVNXNFpPM3Y3
WGI0cDR5bUs3SG5PM3JyNTNPcklTUGRQRTZpbi8rdzc2Z2I2djdGTCtmWGpkMnBNb0lKZVpCNk9h
VEozTVFlTWdWa3hLNCtqZk9ZRzNwVjVXbTVrdmozVHhSbUFpMElUVSt6VTFzaVc4V1BNMDdNT0ZN
ZGdXUjVRbnN3aFJpYm80UVViNDN1eWViaWc2M3A3MFNkQjg4U1dWYUF5VFdyL2F4cnJZNlNuZGFw
QmlTUldlNHdJdWFaZU85ZWxHdzBBZFZNLytWZU4vdWxkVEdkUzYyYXRMZTJlZ3JnSkpJTUc0a3p6
c2JzQm9BYmlHTWtydGtqQlFuak5GSStoOGtacVNvZm5nSG1MMVZMejlGd1BGSStlMmhYMGVoZHQr
SkpIZjFwZXFKQzRtU2U3b3Q2c0c3SWdEUUExUUVmc3RSNGduVFVSbUNmdDlYbFl6WjJLTWllaGxt
YkRyblA1Z2llYzZJTW1teEVFSmZKN0pYT2xUSytQR3g4OFlXTVlxRzZUZEQyaVBkVWFkc3Jzcmwy
eUFxQldkSFhSeU5XTE5VcEFtWjZKQ1pRSVFQSHVqNCtIT1o4TFZINHVXOWNzZ3RVNitEWUExSjU4
U0RIUmNIQ2lNb1dteDBJVC9PRWlsTnBHSHVEc2tWYUV6YnNPak9ueVpYclVGSmR2MkVMcERjd3c5
VEV1bjY0ekNMQXZGUzJtMEV6RlJvcFFXcEZyWklwbWVBODRWaDRvTHhDbjZjakU2MHB6blhFRERo
dERKVnQxQ2xCQmU0NFJZZFVHcTAxVHRVRzBiVU1jSGJ5eTc1akQ1UzkrTUgra2dZcDd1T2wweFhI
ajFySFJwMUFDYWl6S1Y2MS9kWlF2ME9rTGF2Ukt3Rk1JT2tVWm9PS0FVdFZDZWJmUWg1L1l3SE8r
VThaUXo2RjVxSHo5R1YvUjlKeEw4MUNCVGdmcU02dmIrYnZaTEtVeDFDUE03WGsyUHlWQWtTditz
ODNXMDZkUUJlb1pUZ2VieUgvMUZ5WlhZeXpEbVJKdG5UcUhzTjN5NE5ERThTb2w5QjRwN3E2aWNK
NVBwcnQ2L2h1Tmp0dmczdTBqSmE5TDhZOGZTM2phVUtIcEs0NEIxUnJFUjVOdDZQSE9ONWIycEx5
N0RmZC8zaXdUdFRERDhsNlQrTkJmVmJiazhRT29nOFY1ZXF2RGd3TXlwNHB1SDgvRHo5em9nbmtv
WGFjM3NadHY3U3lndW8zVWVsU3l1OFdXK1RDZ1BrVFgzSXYyQkpmaTFVWERzVGFIL0pwMmFwMGV4
YVZHY1ZXTG5KbHFJL1BiRDU5NHFVbXpydkRGUlc2ZUNCdCtRcWFTNm5hSmJpUUJlbGUxS09tbElt
REtsQmgydGYrS3c0elFleXRHcVoxTkJsTkNZbEFnM29PbVR5VWVMcGtMR00xbGc5dm5aN2Y2aW5w
OC8wTnBwNlI5UWllS0hUeTkrQ0lvOFBvZ3FCV2xVclFvNmVUQWdLYXptdzlCVnhFbEFiTG5sckZI
TUV6UWU2dVVyY2ZHYUl3ajJwaVNiRmVmRndTZG90YktFQ202c09jbUpxUHZ6Y1BHeGF1QWlGR0NW
WUkrZzhqdW1MazNtYUpwYXY5MXdIcGJDTHFtaUN4dGpBS092SC94K3Ftenp3bUNMaUVSYzRodEU4
WDB5RVVFUkJEVVZmdGJoRlErMVFwRUNJSWdDSUlnQ0lJZ0NJSWdDSUlnQ0lLZzk5YXZicGZkZUFw
bGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pVd0lEQWdiMkpxQ2p3OEwweGxibWQwYUNBeU5UazJMMDRn
TXk5R2FXeDBaWEl2Um14aGRHVkVaV052WkdVK1BuTjBjbVZoYlFwNG5KMldkMVJUMlJhSHo3MDN2
VkNTRUlxVTBHdG9VZ0pJRGIxSWtTNHFNUWtRU3NDUUFDSTJSRlJ3UkZHUnBnZ3lLT0NBbzBPUnNT
S0toUUZSc2VzRUdVVFVjWEFVRzVaSlpLMFozN3g1NzgyYjN4LzNmbXVmdmMvZForOTkxcm9Ba1B5
REJjSk1XQW1BREtGWUZPSG54WWlOaTJkZ0J3RU04QUFEYkFEZ2NMT3pRaGI0UmdLWkFuellqR3la
RS9nWHZib09JUG43S3RNL2pNRUEvNStVdVZraU1RQlFtSXpuOHZqWlhCa1h5VGc5VjV3bHQwL0pt
TFkwVGM0d1NzNGlXWUl5VnBOejhpeGJmUGFaWlE4NTh6S0VQQm5MYzg3aVpmRGszQ2ZqalRrU3Zv
eVJZQmtYNXdqNHVUSytKbU9EZEVtR1FNWnY1TEVaZkU0MkFDaVMzQzdtYzFOa2JDMWpraWd5Z2kz
amVRRGdTTWxmOE5JdldNelBFOHNQeGM3TVdpNFNKS2VJR1NaY1U0YU5reE9MNGMvUFRlZUx4Y3d3
RGplTkkrSXgySmtaV1J6aGNnQm16L3haRkhsdEdiSWlPOWc0T1Rnd2JTMXR2aWpVZjEzOG01TDNk
cFplaEgvdUdVUWYrTVAyVjM2WkRRQ3dwbVcxMmZxSGJXa1ZBRjNyQVZDNy9ZZk5ZQzhBaXJLK2RR
NTljUjY2ZkY1U3hPSXNaeXVyM054Y1N3R2ZheWt2Nk8vNm53NS9RMTk4ejFLKzNlL2xZWGp6a3pp
U2RERkRYamR1Wm5xbVJNVEl6dUp3K1F6bW40ZjRId2YrZFI0V0Vmd2t2b2d2bEVWRXk2Wk1JRXlX
dFZ2SUU0Z0ZtVUtHUVBpZm12Z1B3LzZrMmJtV2lkcjRFZENXV0FLbElScEFmaDRBS0NvUklBbDda
Q3ZRNzMwTHhrY0QrYzJMMFptWW5mdlBndjU5VjdoTS9zZ1dKSCtPWTBkRU1yZ1NVYzdzbXZ4YUFq
UWdBRVZBQStwQUcrZ0RFOEFFdHNBUnVBQVA0QU1DUVNpSUJIRmdNZUNDRkpBQlJDQVhGSUMxb0Jp
VWdxMWdKNmdHZGFBUk5JTTJjQmgwZ1dQZ05EZ0hMb0hMWUFUY0FWSXdEcDZBS2ZBS3pFQVFoSVhJ
RUJWU2gzUWdROGdjc29WWWtCdmtBd1ZERVZBY2xBZ2xRMEpJQWhWQTY2QlNxQnlxaHVxaFp1aGI2
Q2gwR3JvQURVTzNvRkZvRXZvVmVnY2pNQW1td1Zxd0VXd0ZzMkJQT0FpT2hCZkJ5ZkF5T0I4dWdy
ZkFsWEFEZkJEdWhFL0RsK0FSV0FvL2dhY1JnQkFST3FLTE1CRVd3a1pDa1hna0NSRWhxNUFTcEFK
cFFOcVFIcVFmdVlwSWthZklXeFFHUlVVeFVFeVVDOG9mRllYaW9wYWhWcUUybzZwUkIxQ2RxRDdV
VmRRb2FncjFFVTFHYTZMTjBjN29BSFFzT2htZGl5NUdWNkNiMEIzb3MrZ1I5RGo2RlFhRG9XT01N
WTRZZjB3Y0poV3pBck1ac3h2VGpqbUZHY2FNWWFheFdLdzYxaHpyaWczRmNyQmliREcyQ25zUWV4
SjdCVHVPZllNajRuUnd0amhmWER4T2lDdkVWZUJhY0Nkd1YzQVR1Qm04RXQ0UTc0d1B4ZlB3eS9G
bCtFWjhEMzRJUDQ2ZklTZ1RqQW11aEVoQ0ttRXRvWkxRUmpoTHVFdDRRU1FTOVloT3hIQ2lnTGlH
V0VrOFJEeFBIQ1crSlZGSVppUTJLWUVrSVcwaDdTZWRJdDBpdlNDVHlVWmtEM0k4V1V6ZVFtNG1u
eUhmSjc5Um9DcFlLZ1FvOEJSV0s5UW9kQ3BjVVhpbWlGYzBWUFJVWEt5WXIxaWhlRVJ4U1BHcEVs
N0pTSW10eEZGYXBWU2pkRlRwaHRLME1sWFpSamxVT1VONXMzS0w4Z1hsUnhRc3hZamlRK0ZSaWlq
N0tHY29ZMVNFcWs5bFU3blVkZFJHNmxucU9BMURNNllGMEZKcHBiUnZhSU8wS1JXS2lwMUt0RXFl
U28zS2NSVXBIYUViMFFQbzZmUXkrbUg2ZGZvN1ZTMVZUMVcrNmliVk50VXJxcS9WNXFoNXFQSFZT
dFRhMVViVTNxa3oxSDNVMDlTM3FYZXAzOU5BYVpocGhHdmthdXpST0t2eGRBNXRqc3NjN3B5U09Z
Zm4zTmFFTmMwMEl6UlhhTzdUSE5DYzF0TFc4dFBLMHFyU09xUDFWSnV1N2FHZHFyMUQrNFQycEE1
VngwMUhvTE5ENTZUT1k0WUt3NU9SenFoazlER21kRFYxL1hVbHV2VzZnN296ZXNaNlVYcUZldTE2
OS9RSitpejlKUDBkK3IzNlV3WTZCaUVHQlFhdEJyY044WVlzd3hURFhZYjlocStOakkxaWpEWVlk
Ums5TWxZekRqRE9OMjQxdm10Q05uRTNXV2JTWUhMTkZHUEtNazB6M1cxNjJRdzJzemRMTWFzeEd6
S0h6UjNNQmVhN3pZY3QwQlpPRmtLTEJvc2JUQkxUazVuRGJHV09XdEl0Z3kwTExic3NuMWtaV01W
YmJiUHF0L3BvYlcrZGJ0MW9mY2VHWWhOb1UyalRZL09yclprdDE3Ykc5dHBjOGx6ZnVhdm5kczk5
Ym1kdXg3ZmJZM2ZUbm1vZllyL0J2dGYrZzRPamc4aWh6V0hTMGNBeDBiSFc4UWFMeGdwamJXYWRk
MEk3ZVRtdGRqcm05TmJad1Zuc2ZOajVGeGVtUzVwTGk4dWplY2J6K1BNYTU0MjU2cmx5WE90ZHBX
NE10MFMzdlc1U2QxMTNqbnVEK3dNUGZRK2VSNVBIaEtlcFo2cm5RYzluWHRaZUlxOE9yOWRzWi9a
SzlpbHZ4TnZQdThSNzBJZmlFK1ZUN1hQZlY4ODMyYmZWZDhyUDNtK0YzeWwvdEgrUS96Yi9Hd0Zh
QWR5QTVvQ3BRTWZBbFlGOVFhU2dCVUhWUVErQ3pZSkZ3VDBoY0VoZ3lQYVF1L01ONXd2bmQ0V0Mw
SURRN2FIM3dvekRsb1Y5SDQ0SkR3dXZDWDhZWVJOUkVORy9nTHBneVlLV0JhOGl2U0xMSXU5RW1V
UkpvbnFqRmFNVG9wdWpYOGQ0eDVUSFNHT3RZbGZHWG9yVGlCUEVkY2RqNDZQam0rS25GL29zM0xs
d1BNRStvVGpoK2lMalJYbUxMaXpXV0p5KytQZ1N4U1djSlVjUzBZa3hpUzJKN3ptaG5BYk85TktB
cGJWTHA3aHM3aTd1RTU0SGJ3ZHZrdS9LTCtkUEpMa21sU2M5U25aTjNwNDhtZUtlVXBIeVZNQVdW
QXVlcC9xbjFxVytUZ3ROMjUvMktUMG12VDBEbDVHWWNWUklFYVlKK3pLMU0vTXloN1BNczRxenBN
dWNsKzFjTmlVS0VqVmxROW1Mc3J2Rk5OblAxSURFUkxKZU1wcmpsbE9UOHlZM092ZElubktlTUc5
Z3VkbnlUY3NuOG4zenYxNkJXc0ZkMFZ1Z1c3QzJZSFNsNThyNlZkQ3FwYXQ2Vit1dkxsbzl2c1p2
ellHMWhMVnBhMzhvdEM0c0wzeTVMbVpkVDVGVzBacWlzZlYrNjF1TEZZcEZ4VGMydUd5bzI0amFL
Tmc0dUdudXBxcE5IMHQ0SlJkTHJVc3JTdDl2NW02KytKWE5WNVZmZmRxU3RHV3d6S0ZzejFiTVZ1
SFc2OXZjdHgwb1Z5N1BMeC9iSHJLOWN3ZGpSOG1PbHp1WDdMeFFZVmRSdDR1d1M3SkxXaGxjMlYx
bFVMVzE2bjExU3ZWSWpWZE5lNjFtN2FiYTE3dDV1Ni9zOGRqVFZxZFZWMXIzYnE5Zzc4MTZ2L3JP
QnFPR2luMllmVG43SGpaR04vWi96ZnE2dVVtanFiVHB3MzdoZnVtQmlBTjl6WTdOelMyYUxXV3Rj
S3VrZGZKZ3dzSEwzM2gvMDkzR2JLdHZwN2VYSGdLSEpJY2VmNXY0N2ZYRFFZZDdqN0NPdEgxbitG
MXRCN1dqcEJQcVhONDUxWlhTSmUyTzZ4NCtHbmkwdDhlbHArTjd5Ky8zSDlNOVZuTmM1WGpaQ2NL
Sm9oT2ZUdWFmbkQ2VmRlcnA2ZVRUWTcxTGV1K2NpVDF6clMrOGIvQnMwTm56NTN6UG5lbjM3RDk1
M3ZYOHNRdk9GNDVlWkYzc3V1UndxWFBBZnFEakIvc2ZPZ1lkQmp1SEhJZTZMenRkN2htZU4zemlp
dnVWMDFlOXI1NjdGbkR0MHNqOGtlSHJVZGR2M2tpNEliM0p1L25vVnZxdDU3ZHpicy9jV1hNWGZi
ZmtudEs5aXZ1YTl4dCtOUDJ4WGVvZ1BUN3FQVHJ3WU1HRE8yUGNzU2MvWmYvMGZyem9JZmxoeFlU
T1JQTWoyMGZISm4wbkx6OWUrSGo4U2RhVG1hZkZQeXYvWFB2TTVObDN2M2o4TWpBVk96WCtYUFQ4
MDYrYlg2aS8yUC9TN21YdmROajAvVmNacjJaZWw3eFJmM1BnTGV0dC83dVlkeE16dWUreDd5cy9t
SDdvK1JqMDhlNm5qRStmZmdQM2hQUDdDbVZ1WkhOMGNtVmhiUXBsYm1Sdlltb0tOVEVnTUNCdllt
b0tQRHd2Vkhsd1pTOURZWFJoYkc5bkwxQmhaMlZ6SURFMElEQWdVajQrQ21WdVpHOWlhZ28xTWlB
d0lHOWlhZ284UEM5RGNtVmhkRzl5S0ZGMVpYTjBJRVJwWVdkdWIzTjBhV056SUZKbGNHOXlkR2x1
WnlCVFpYSjJhV05sY3lrdlVISnZaSFZqWlhJb2FWUmxlSFFnTWk0eExqUWdYQ2hpZVNCc2IzZGha
MmxsTG1OdmJWd3BLUzlUZFdKcVpXTjBLRkJoZEdsbGJuUWdVbVZ3YjNKMGN5a3ZUVzlrUkdGMFpT
aEVPakl3TVRjd05URXhNVFF5T1RNNUxUQTBKekF3SnlrdlFYVjBhRzl5S0ZGMVpYTjBJRVJwWVdk
dWIzTjBhV056SUVsdVkyOXljRzl5WVhSbFpDa3ZRM0psWVhScGIyNUVZWFJsS0VRNk1qQXhOekEx
TVRFeE5ESTVNemt0TURRbk1EQW5LVDQrQ21WdVpHOWlhZ295SURBZ2IySnFDanc4TDFSNWNHVXZU
MkpxVTNSdEwwNGdNamd2VEdWdVozUm9JRFkxTUM5R2FYSnpkQ0F5TVRBdlJtbHNkR1Z5TDBac1lY
UmxSR1ZqYjJSbFBqNXpkSEpsWVcwS2VKenRWbTF2MmpBUS9pdjNCeXEvblJOSHFwQVdPalkwYlVP
QXRFcUlEMm53cWt5UVZFbVl1bisvYzV5Z0RrcFZDbFNydGsvbmMrem43am5mNDFnQUI2RWcxQ0FW
S0tOQmhLQlZCTUtBMWdaRUJBRjVra01vRWFRQXcwT1FFb3dKUUNCRWdRRkplN2lpelNFQklRY2w2
RXRFdmdTaGhRVDZKTFR6RVVRUVJxQmNqSURtQ2NHZ0FFazJvdURTQVNzTzBrRXFBMGhoRFFhQXRK
VnpEb2hrS1IvVUZNTDVBVmxLR0VNS1JYbWdvVkRrWEY2eU9LbnNvTWhyTnMxV3Ryb1lGNnNrWjlO
ZmQ1WTFzKy96dEZoaytTMzdsdVh2OGlyYitKUDFUZTFXdWFXaTEzTlFvNlMwZWUyNGNoaXpQbTBu
dDVvSjRYd2k1bzEwWnU1RGpKSmJ5OGEyS3RabGFpdUN1UDU2ODhPbU5ZMkdLNnBONE5iMmVteFVG
dW5FMWpCam82c0JzS205cjRGVzBPNjR0ZjNXRHVjVWVGbVVrN3NrdFFSelpiOG42MlU5L2hDNzAv
Sm9qaGg5R2doM2NpN1ZBYVZJMVdxRzJoMWdNNHJjR1RhajVoamQ2RHFqRHZBb2hETXRzMVZjM00v
YytvQjRoWkdjczg5MmtTVTdzL0hTMnNYMnJLL2EwNVFieGkzVmxtbEQvNXcwSFRrcTliRGZkODJ4
QU5rYzZQeVBidmxvbHo5dG5hWEp3YjNDdmlRcjJ0RDJ6QWF3VHoyUTJmSWlMcGFMRjJOdWd4N1Qw
eTJtZmp6UGw4SkZqMlo0RE9uUUkyNzBWTGtVU1lhYWZjb1dwRDdWeUU1NjljbkFtOUNicGkvbVQ2
cTNYZG0wRFpqbmExZnhVMnBYaVoybVZsNlNBK1Z1emJhbkZYWTlyWFRYMHlwb3BTdk9MTjF0eG9k
TDkyaVcyOHBWNWhXVXV3RThxbzNWdnl2ZFBjcnppbFZlZWNGYlZwNDh1ZkwybE16WENybC9hZkMz
WERQMVdqWHovd2YwanpSOGZzbFFuckprcUhaS2hyaDV0YUR1YW9aZGZSQkVWejBNdStxaE9lc052
MDM1OEJ2K1FKcDd5RDI4NGpYLy96ajd1Mi80M3lKVUxvNEtaVzVrYzNSeVpXRnRDbVZ1Wkc5aWFn
bzFNeUF3SUc5aWFnbzhQQzlVZVhCbEwxaFNaV1l2VjFzeElESWdNbDB2VW05dmRDQTFNU0F3SUZJ
dlNXNWtaWGhiTUNBMU5GMHZTVVFnV3p4bVpXTXdNVE5qTmpVNFpUazVZakF4T0RBek56YzRNV1Zs
WkdaaU1XRmpNajQ4WkRjMFpUWXlabUl4TjJWbFl6SXlaall6T1Rrek9UVTJOVEJpTmpZMU1tVStY
UzlNWlc1bmRHZ2dNVFl3TDBsdVptOGdOVElnTUNCU0wxTnBlbVVnTlRRdlJtbHNkR1Z5TDBac1lY
UmxSR1ZqYjJSbFBqNXpkSEpsWVcwS2VKd2x6RHNTQVZFUWhlSHVPK00xSHNONFB5SUpxUVhJWkdL
UlphaENSaWlWcUpLUnFCSUliY0E2YkVHa3hLUC91aDE4d2VuVExTSnA2c1NKNlBWc1NBeExlQnM2
aGp2OERMZUdseEhNNENqQ3JVSkJ3OFN5eXNObkFZU1FnU3prSUE5T0IwL2ZpeUNCT2pSME5MUXYw
NjNmbHFBTUZZaWhDalVvNm54djVjWEhXRTJNM2RjNE9IL2Jnalowb0FzOTZFTlRUNUdWTHh1NGla
OC9tVjBVcXdwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ25OMFlYSjBlSEpsWmdvME1qRXhNd29sSlVW
UFJnbz18fHx8fHxGfHx8fHx8fHx8fHx8UVVFU1QgRElBR05PU1RJQ1MtV0VTVCBISUxMU15eXl5e
XkZJXkNMSUFeXjA1RDA2NDI4Mjd8ODQwMSBGQUxMQlJPT0sgQVZFTlVFXl5XRVNUIEhJTExTXkNB
XjkxMzA0LTMyMjZ8MTM2NjQ3OTA5OV5URVJSQVpBU15FTlJJUVVFXl5NRF5eXl5eXl5eTlBJXkVO
Cg==</inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>true</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data

message = stripNonValidXMLChars(message);

return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

globalMap.put(&quot;ORUProcessingChannelId&quot;, channelId);

return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set">
          <string>CURRENT</string>
        </tags>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <className>com.mirth.connect.server.attachments.javascript.JavaScriptAttachmentHandlerProvider</className>
          <type>JavaScript</type>
          <properties>
            <entry>
              <string>javascript.script</string>
              <string>// Modify the message variable below to create attachments

// Create Binary resourse with the original HL7v2 message
var resBinary = &lt;Binary&gt;				
				&lt;id value=&quot;&quot;/&gt;				
				&lt;contentType value=&quot;application/hl7-v2&quot;/&gt;
				&lt;content value=&quot;&quot;/&gt;
			&lt;/Binary&gt;;

// Encode original ORU message
var bytes = new java.lang.String(message.toString()).getBytes();
resBinary.content.@value = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

// Store to be processed by the FHIR_submit destination
globalChannelMap.put(&quot;Binary&quot;, resBinary.toString());


return message;</string>
            </entry>
          </properties>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
      <dependentIds/>
    </channel>
    <channel version="3.4.2">
      <id>b690aebe-457f-494c-8231-8a2050152907</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>Test InsertPatient</name>
      <description></description>
      <enabled>false</enabled>
      <lastModified>
        <time>1495545585645</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>13</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>None</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps/>
          <inboundDataType>DELIMITED</inboundDataType>
          <outboundDataType>DELIMITED</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
              <columnDelimiter>,</columnDelimiter>
              <recordDelimiter>\n</recordDelimiter>
              <quoteToken>&quot;</quoteToken>
              <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
              <quoteEscapeToken>\</quoteEscapeToken>
              <numberedRows>false</numberedRows>
              <ignoreCR>true</ignoreCR>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
              <columnDelimiter>,</columnDelimiter>
              <recordDelimiter>\n</recordDelimiter>
              <quoteToken>&quot;</quoteToken>
              <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
              <quoteEscapeToken>\</quoteEscapeToken>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
              <splitType>Record</splitType>
              <batchSkipRecords>0</batchSkipRecords>
              <batchMessageDelimiter></batchMessageDelimiter>
              <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
              <batchGroupingColumn></batchGroupingColumn>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
              <columnDelimiter>,</columnDelimiter>
              <recordDelimiter>\n</recordDelimiter>
              <quoteToken>&quot;</quoteToken>
              <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
              <quoteEscapeToken>\</quoteEscapeToken>
              <numberedRows>false</numberedRows>
              <ignoreCR>true</ignoreCR>
            </serializationProperties>
            <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
              <columnDelimiter>,</columnDelimiter>
              <recordDelimiter>\n</recordDelimiter>
              <quoteToken>&quot;</quoteToken>
              <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
              <quoteEscapeToken>\</quoteEscapeToken>
            </deserializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
              <splitType>Record</splitType>
              <batchSkipRecords>0</batchSkipRecords>
              <batchMessageDelimiter></batchMessageDelimiter>
              <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
              <batchGroupingColumn></batchGroupingColumn>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Call InsertPatientGuarantor</name>
          <properties class="com.mirth.connect.connectors.http.HttpDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <host>http://ec2-35-162-93-26.us-west-2.compute.amazonaws.com:8012/InsertPatient/</host>
            <useProxyServer>false</useProxyServer>
            <proxyAddress></proxyAddress>
            <proxyPort></proxyPort>
            <method>post</method>
            <headers class="linked-hash-map"/>
            <parameters class="linked-hash-map"/>
            <responseXmlBody>false</responseXmlBody>
            <responseParseMultipart>true</responseParseMultipart>
            <responseIncludeMetadata>false</responseIncludeMetadata>
            <responseBinaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</responseBinaryMimeTypes>
            <responseBinaryMimeTypesRegex>true</responseBinaryMimeTypesRegex>
            <multipart>false</multipart>
            <useAuthentication>false</useAuthentication>
            <authenticationType>Basic</authenticationType>
            <usePreemptiveAuthentication>false</usePreemptiveAuthentication>
            <username></username>
            <password></password>
            <content>${message.rawData}</content>
            <contentType>text/json</contentType>
            <dataTypeBinary>false</dataTypeBinary>
            <charset>UTF-8</charset>
            <socketTimeout>30000</socketTimeout>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>DELIMITED</inboundDataType>
            <outboundDataType>DELIMITED</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
                <numberedRows>false</numberedRows>
                <ignoreCR>true</ignoreCR>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
                <splitType>Record</splitType>
                <batchSkipRecords>0</batchSkipRecords>
                <batchMessageDelimiter></batchMessageDelimiter>
                <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
                <batchGroupingColumn></batchGroupingColumn>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
                <numberedRows>false</numberedRows>
                <ignoreCR>true</ignoreCR>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
                <splitType>Record</splitType>
                <batchSkipRecords>0</batchSkipRecords>
                <batchMessageDelimiter></batchMessageDelimiter>
                <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
                <batchGroupingColumn></batchGroupingColumn>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>DELIMITED</inboundDataType>
            <outboundDataType>DELIMITED</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
                <numberedRows>false</numberedRows>
                <ignoreCR>true</ignoreCR>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
                <splitType>Record</splitType>
                <batchSkipRecords>0</batchSkipRecords>
                <batchMessageDelimiter></batchMessageDelimiter>
                <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
                <batchGroupingColumn></batchGroupingColumn>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
                <numberedRows>false</numberedRows>
                <ignoreCR>true</ignoreCR>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.4.2">
                <columnDelimiter>,</columnDelimiter>
                <recordDelimiter>\n</recordDelimiter>
                <quoteToken>&quot;</quoteToken>
                <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
                <quoteEscapeToken>\</quoteEscapeToken>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.4.2">
                <splitType>Record</splitType>
                <batchSkipRecords>0</batchSkipRecords>
                <batchMessageDelimiter></batchMessageDelimiter>
                <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
                <batchGroupingColumn></batchGroupingColumn>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>HTTP Sender</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>b73a73d9-b589-4dd7-8a5b-d24fe9ed522d</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>Test LRI ACK Server</name>
      <description>Mimics DEX LRI ACK Server</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1480535460256</time>
        <timezone>America/Los_Angeles</timezone>
      </lastModified>
      <revision>2</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>9095</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>getAckResponse</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>true</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>text/xml</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode></responseStatusCode>
          <responseHeaders class="linked-hash-map">
            <entry>
              <string>Content-Type</string>
              <list>
                <string>text/xml; charset=utf-8</string>
              </list>
            </entry>
          </responseHeaders>
          <charset>UTF-8</charset>
          <contextPath></contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Log Request</name>
              <script>//logger.debug(&quot;LRI ACK Server: &quot; + msg.toString());</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>//logger.debug(&quot;LRI ACK Server: &quot; + msg.toString());</string>
                </entry>
              </data>
            </step>
            <step>
              <sequenceNumber>1</sequenceNumber>
              <name>Send Response</name>
              <script>// Acknowledgement response on acknowledgement
var getAckResponse = &lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
   &lt;S:Body&gt;
      &lt;ns2:acknowledgeResultsResponse xmlns:ns2=&quot;http://medplus.com/results&quot;&gt;
         &lt;ns2:AckResult&gt;
            &lt;isMore&gt;false&lt;/isMore&gt;
            &lt;requestId&gt;5ef17e767f00010102d4d7e8a1028015&lt;/requestId&gt;
         &lt;/ns2:AckResult&gt;
      &lt;/ns2:acknowledgeResultsResponse&gt;
   &lt;/S:Body&gt;
&lt;/S:Envelope&gt;;


responseMap.put(&quot;getAckResponse&quot;, getAckResponse);</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Acknowledgement response on acknowledgement
var getAckResponse = &lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
   &lt;S:Body&gt;
      &lt;ns2:acknowledgeResultsResponse xmlns:ns2=&quot;http://medplus.com/results&quot;&gt;
         &lt;ns2:AckResult&gt;
            &lt;isMore&gt;false&lt;/isMore&gt;
            &lt;requestId&gt;5ef17e767f00010102d4d7e8a1028015&lt;/requestId&gt;
         &lt;/ns2:AckResult&gt;
      &lt;/ns2:acknowledgeResultsResponse&gt;
   &lt;/S:Body&gt;
&lt;/S:Envelope&gt;;


responseMap.put(&quot;getAckResponse&quot;, getAckResponse);</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>XML</inboundDataType>
          <outboundDataType>XML</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>false</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>false</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Destination 1</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data


return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>041540bc-16e7-43fe-a9eb-1ca3c5ea17db</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>Test LRI ORU Server</name>
      <description>Mimics DEX LRI Server</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1480535451474</time>
        <timezone>America/Los_Angeles</timezone>
      </lastModified>
      <revision>2</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>9090</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>getResultsResponse</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>true</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>text/xml</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode></responseStatusCode>
          <responseHeaders class="linked-hash-map">
            <entry>
              <string>Content-Type</string>
              <list>
                <string>text/xml; charset=utf-8</string>
              </list>
            </entry>
          </responseHeaders>
          <charset>UTF-8</charset>
          <contextPath></contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Log Request</name>
              <script>//logger.debug(&quot;LRI ORU Server: &quot; + msg.toString());</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>//logger.debug(&quot;LRI ORU Server: &quot; + msg.toString());</string>
                </entry>
              </data>
            </step>
            <step>
              <sequenceNumber>1</sequenceNumber>
              <name>Send Response</name>
              <script>// Example of the empty LRI response
var emptyResultsResponse = &lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
	&lt;S:Body&gt;
		&lt;ns0:getResultsResponse xmlns:ns0=&quot;http://medplus.com/results&quot;&gt;
			&lt;ns0:Results&gt;
				&lt;isMore&gt;false&lt;/isMore&gt;
				&lt;requestId&gt;6eb0eb290a801e1e1113d4d4dfc71efc&lt;/requestId&gt;
			&lt;/ns0:Results&gt;
		&lt;/ns0:getResultsResponse&gt;
	&lt;/S:Body&gt;
&lt;/S:Envelope&gt;;


// Example of three HL7v2.5.1 LRI messages and isMore = true
var resultsResponse1 = &lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
   &lt;S:Body&gt;
      &lt;ns2:getResultsResponse xmlns:ns2=&quot;http://medplus.com/results&quot;&gt;
         &lt;ns2:Results&gt;
            &lt;isMore&gt;true&lt;/isMore&gt;
            &lt;requestId&gt;b3c82849ac1262851cb2db226d02c065&lt;/requestId&gt;
            &lt;results&gt;
               &lt;HL7Message&gt;
                  &lt;controlId&gt;80000000000000038102&lt;/controlId&gt;
                  &lt;message&gt;TVNIfF5+XCZ8UUxTfFBIMV4zOUQwNjU3NzQwXkNMSUF8fDc4NjAwMDAxfDIwMTMwNzIzMTYzMDI3LjAwMC0wNDAwfHxPUlVeUjAxXk9SVV9SMDF8ODAwMDAwMDAwMDAwMDAwMzgxMDJ8UHwyLjUuMXwxfHxBTHxORXx8fHx8TFJJX05HX1JOX1Byb2ZpbGVeXjIuMTYuODQwLjEuMTEzODgzLjkuMjBeSVNPClBJRHwxfHxLUDAzMjA2MVBeXl5eTEFDU058fExhc3ROYW1lXkZpcnN0TmFtZV5eXl5eTHx8fE18fHxeXl5eXlVTQQpOVEV8MXxMfFJFUE9SVCBDT01NRU5UUyBMSU5FIDEKTlRFfDJ8THxSRVBPUlQgQ09NTUVOVFMgTElORSAyCk9SQ3xSRXx8S1AwMzIwNjFQXlFVRVNUX1BIMXx8Q018fHx8fHx8Xkxhc3ROYW1lXkZpcnN0TmFtZXx8fHx8fHx8fF5eXl5eXl5eXjc4NjAwMDAxfFN0cmVldCBBZGRyZXNzXl5DaXR5XlN0YXRlXlppcF5eT15eVVNBCk9CUnwxfHxLUDAzMjA2MVBeUVVFU1RfUEgxfDQ4NF5HTFVDT1NFLCBQTEFTTUFeOTlRREl8fHwyMDEzMDcyMzAzMDAwMC4wMDAtMDQwMHx8fHx8fHx8fF5MYXN0TmFtZV5GaXJzdE5hbWV8fHx8fHwyMDEzMDcyMzE2MzAyNy4wMDAtMDQwMHx8fEYKT0JYfDF8Tk18MjUwMTQ1MDBeR0xVQ09TRSwgUExBU01BXjk5UURJXjE1NTgtNl5HbHVjb3NlIHAgZmFzdCBTZXJQbC1tQ25jXkxOfDF8NzB8bWcvZExeXjk5UURJfDY1LTk5fE58fHxGfHx8MjAxMzA3MjMwMzAwMDAuMDAwLTA0MDB8fHx8fDIwMTMwNzIzMTYzMDI3LjAwMC0wNDAwfHx8fFFVRVNUIERJQUdOT1NUSUNTIEhPUlNIQU1eXl5eXl5GSV5DTElBXl4zOUQwMjA0NDA0fDkwMCBCVVNJTkVTUyBDRU5URVIgRFJJVkVeXkhPUlNIQU1eUEFeMTkwNDQtMzQzMnwxMjA1ODcyMDQxXkxhc3ROYW1lXkZpcnN0TmFtZV5TXl5eXl5eXl5eTlBJCk5URXwxfEx8Ck5URXwyfEx8IEZhc3RpbmcgcmVmZXJlbmNlIGludGVydmFsCk5URXwzfEx8ClNQTXwxfDAyXjAyfHxVU1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8MjAxMzA3MjMwMzAwMDAuMDAwLTA0MDAKT1JDfFJFfHxLUDAzMjA2MVBeUVVFU1RfUEgxfHxDTXx8fHx8fHxeTGFzdE5hbWVeRmlyc3ROYW1lfHx8fHx8fHx8Xl5eXl5eXl5eNzg2MDAwMDF8U3RyZWV0IEFkZHJlc3NeXkNpdHleU3RhdGVeWmlwXl5PXl5VU0EKT0JSfDJ8fEtQMDMyMDYxUF5RVUVTVF9QSDF8NzMzXlBPVEFTU0lVTV45OVFESXx8fDIwMTMwNzIzMDMwMDAwLjAwMC0wNDAwfHx8fHx8fHx8Xkxhc3ROYW1lXkZpcnN0TmFtZXx8fHx8fDIwMTMwNzIzMTYzMDI3LjAwMC0wNDAwfHx8RgpPQlh8MXxOTXwyNTAwMDUwMF5QT1RBU1NJVU1eOTlRREleMjgyMy0zXlBvdGFzc2l1bSBTZXJQbC1zQ25jXkxOfDF8NC41fG1tb2wvTF5eOTlRREl8My41LTUuM3xOfHx8Rnx8fDIwMTMwNzIzMDMwMDAwLjAwMC0wNDAwfHx8fHwyMDEzMDcyMzE2MzAyNy4wMDAtMDQwMHx8fHxRVUVTVCBESUFHTk9TVElDUyBIT1JTSEFNXl5eXl5eRkleQ0xJQV5eMzlEMDIwNDQwNHw5MDAgQlVTSU5FU1MgQ0VOVEVSIERSSVZFXl5IT1JTSEFNXlBBXjE5MDQ0LTM0MzJ8MTIwNTg3MjA0MV5MYXN0TmFtZV5GaXJzdE5hbWVeU15eXl5eXl5eXk5QSQpTUE18MXwwMV4wMXx8VVNQRUNeU291cmNlLCBVbnNwZWNpZmllZF5ITDcwNDg3fHx8fHx8fHx8fHx8fDIwMTMwNzIzMDMwMDAwLjAwMC0wNDAwCg==&lt;/message&gt;
               &lt;/HL7Message&gt;
            &lt;/results&gt;
            &lt;results&gt;
               &lt;HL7Message&gt;
                  &lt;controlId&gt;80000000000000080409&lt;/controlId&gt;
                  &lt;message&gt;TVNIfF5+XCZ8UUxTfENXMV4xNEQwNDE3MDUyXkNMSUF8fDc4NjAwMDA1fDIwMTMwOTE5MTA0MzUyLjAwMC0wNDAwfHxPUlVeUjAxXk9SVV9SMDF8ODAwMDAwMDAwMDAwMDAwODA0MDl8UHwyLjUuMXw0fHxBTHxORXx8fHx8TFJJX05HX1JOX1Byb2ZpbGVeXjIuMTYuODQwLjEuMTEzODgzLjkuMjBeSVNPDVBJRHwxfHxQQVRJRDAxXl5eXlBUfHxURVNUXkFDQ0VTU0lPTlRXT15eXl5eTHx8MTk4ODA4MjV8Rnx8fF5eXl5eVVNBfHxeXl5eXjk2NV40MDkxMTQzDU5URXwxfEx8UkVQT1JUIENPTU1FTlRTIEVOVEVSRUQgQlkgQk9CDU5URXwyfEx8UkVQT1JUIENPTU1FTlRTIEZPUiBHT01BMDAwMQ1PUkN8UkV8TEFCIFJFRjAwMDAxXlFVRVNUX0NXMV83ODYwMDAwNXxDQjAyOTEwOEFeUVVFU1RfQ1cxfHxDTXx8fHx8fE5QUDAwMDFeRFIuQk9CXl5eXl5eXl5eXl5FSXwxMDUzMzI1ODExXlFBVEVTVEVSXk9MSVZJQV5eXl5eXl5eXl5OUEl8fHx8fHx8fHxMT0MwMV5eXl5eXl5eXjc4NjAwMDA1fDEyMDEgQU5ZU1RSRUVUIFJEXlFMU1RFU1ReQ09MTEVHRVZJTExFXlBBXjE5NDI2LTEwNTBeXk9eXlVTQQ1PQlJ8MXxMQUIgUkVGMDAwMDFeUVVFU1RfQ1cxXzc4NjAwMDA1fENCMDI5MTA4QV5RVUVTVF9DVzF8MjkyNTZeQ0ExMjVeOTlRREl8fHwyMDEzMDkxMjEyMDAwMC4wMDAtMDQwMHx8fHx8fHx8fDEwNTMzMjU4MTFeUUFURVNURVJeT0xJVklBXl5eXl5eXl5eXk5QSXx8fHx8fDIwMTMwOTE5MTA0MzUyLjAwMC0wNDAwfHx8Qw1PQlh8MXxOTXw1NTA2MjU1MF5DQSAxMjVeOTlRREleMTAzMzQtMV5DYW5jZXIgQWcxMjUgU2VyUGwtYUNuY15MTnwxfDEyMHxVL21MXl45OVFESXw8IDIxfEh8fHxDfHx8MjAxMzA5MTIxMjAwMDAuMDAwLTA0MDB8fHx8fDIwMTMwOTE5MTA0MzUyLjAwMC0wNDAwfHx8fFFVRVNUIERJQUdOT1NUSUNTIEFOWVRPV05eXl5eXl5GSV5DTElBXl4xNEQwNDE3MDUyfDEzNTUgQU5ZU1RSRUVUIEJPVUxFVkFSRF5eQU5ZVE9XTl5JTF42MDE5MS0xMDI0fF5RQVRFU1RFUl5PTElWSUFeVi5eXl5eXl5eXl5eQ0INTlRFfDF8THwgDU5URXwyfEx8PT4gSW5kaWNhdGVzIGNoYW5nZWQgcmVzdWx0KHMpIG9yIGluZm9ybWF0aW9uLg1OVEV8M3xMfCANTlRFfDR8THxUaGlzIHRlc3Qgd2FzIHBlcmZvcm1lZCB1c2luZyB0aGUgU2llbWVucw1OVEV8NXxMfENoZW1pbHVtaW5lc2NlbnQgbWV0aG9kLiBWYWx1ZXMgb2J0YWluZWQgZnJvbQ1OVEV8NnxMfGRpZmZlcmVudCBhc3NheSBtZXRob2RzIGNhbm5vdCBiZSB1c2VkDU5URXw3fEx8aW50ZXJjaGFuZ2VhYmx5LiBDQSAxMjUgbGV2ZWxzLCByZWdhcmRsZXNzIG9mDU5URXw4fEx8dmFsdWUsIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWJzb2x1dGUNTlRFfDl8THxldmlkZW5jZSBvZiB0aGUgcHJlc2VuY2Ugb3IgYWJzZW5jZSBvZiBkaXNlYXNlLg1OVEV8MTB8THwgDU5URXwxMXxMfEZSRUUgVEVTVCBBRERFRCBUTyBWRVJJRlkgQURERU5EVU0gUkVQT1JUDU5URXwxMnxMfEFOT1RIRVIgVEVYVCBBRERFRCBUTyBWRVJJRlkgVEhFIEFEREVORFVNIFNDRU5BUklPDU5URXwxM3xMfFBMRUFTRSBESVNSRUdBUkQgUFJFVklPVVNMWSBSRVBPUlRFRCBJTkZPUk1BVElPTiBCRUxPVzoNTlRFfDE0fEx8UExFQVNFIERJU1JFR0FSRCBSRVNVTFRTIEJFTE9XOg1OVEV8MTV8THwoVGhlIGluZm9ybWF0aW9uIGJlbG93IHdhcyBvcmlnaW5hbGx5IHJlcG9ydGVkIG9uIDA5LzEyLzIwMTMgYXQgNDoxMyBBTSkNTlRFfDE2fEx8Q0EgMTI1IDIgIA1OVEV8MTd8THwgDU5URXwxOHxMfFRoaXMgdGVzdCB3YXMgcGVyZm9ybWVkIHVzaW5nIHRoZSBTaWVtZW5zDU5URXwxOXxMfENoZW1pbHVtaW5lc2NlbnQgbWV0aG9kLiBWYWx1ZXMgb2J0YWluZWQgZnJvbQ1OVEV8MjB8THxkaWZmZXJlbnQgYXNzYXkgbWV0aG9kcyBjYW5ub3QgYmUgdXNlZA1OVEV8MjF8THxpbnRlcmNoYW5nZWFibHkuIENBIDEyNSBsZXZlbHMsIHJlZ2FyZGxlc3Mgb2YNTlRFfDIyfEx8dmFsdWUsIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWJzb2x1dGUNTlRFfDIzfEx8ZXZpZGVuY2Ugb2YgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgZGlzZWFzZS4NTlRFfDI0fEx8IA1OVEV8MjV8THxQTEVBU0UgRElTUkVHQVJEIFBSRVZJT1VTTFkgUkVQT1JURUQgSU5GT1JNQVRJT04gQkVMT1c6DU5URXwyNnxMfFBMRUFTRSBESVNSRUdBUkQgUkVTVUxUUyBCRUxPVzoNTlRFfDI3fEx8KFRoZSBpbmZvcm1hdGlvbiBiZWxvdyB3YXMgb3JpZ2luYWxseSByZXBvcnRlZCBvbiAwOS8xMi8yMDEzIGF0IDQ6MTMgQU0pDU5URXwyOHxMfENBIDEyNSAyICANTlRFfDI5fEx8IA1OVEV8MzB8THxUaGlzIHRlc3Qgd2FzIHBlcmZvcm1lZCB1c2luZyB0aGUgU2llbWVucw1OVEV8MzF8THxDaGVtaWx1bWluZXNjZW50IG1ldGhvZC4gVmFsdWVzIG9idGFpbmVkIGZyb20NTlRFfDMyfEx8ZGlmZmVyZW50IGFzc2F5IG1ldGhvZHMgY2Fubm90IGJlIHVzZWQNTlRFfDMzfEx8aW50ZXJjaGFuZ2VhYmx5LiBDQSAxMjUgbGV2ZWxzLCByZWdhcmRsZXNzIG9mDU5URXwzNHxMfHZhbHVlLCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIGFic29sdXRlDU5URXwzNXxMfGV2aWRlbmNlIG9mIHRoZSBwcmVzZW5jZSBvciBhYnNlbmNlIG9mIGRpc2Vhc2UuDU5URXwzNnxMfCANTlRFfDM3fEx8UExFQVNFIERJU1JFR0FSRCBQUkVWSU9VU0xZIFJFUE9SVEVEIElORk9STUFUSU9OIEJFTE9XOg1OVEV8Mzh8THxQTEVBU0UgRElTUkVHQVJEIFJFU1VMVFMgQkVMT1c6DU5URXwzOXxMfChUaGUgaW5mb3JtYXRpb24gYmVsb3cgd2FzIG9yaWdpbmFsbHkgcmVwb3J0ZWQgb24gMDkvMTIvMjAxMyBhdCA0OjM0IEFNKQ1OVEV8NDB8THxDQSAxMjUgMTIwIEggDU5URXw0MXxMfCANTlRFfDQyfEx8PT4gSW5kaWNhdGVzIGNoYW5nZWQgcmVzdWx0KHMpIG9yIGluZm9ybWF0aW9uLg1OVEV8NDN8THwgDU5URXw0NHxMfFRoaXMgdGVzdCB3YXMgcGVyZm9ybWVkIHVzaW5nIHRoZSBTaWVtZW5zDU5URXw0NXxMfENoZW1pbHVtaW5lc2NlbnQgbWV0aG9kLiBWYWx1ZXMgb2J0YWluZWQgZnJvbQ1OVEV8NDZ8THxkaWZmZXJlbnQgYXNzYXkgbWV0aG9kcyBjYW5ub3QgYmUgdXNlZA1OVEV8NDd8THxpbnRlcmNoYW5nZWFibHkuIENBIDEyNSBsZXZlbHMsIHJlZ2FyZGxlc3Mgb2YNTlRFfDQ4fEx8dmFsdWUsIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWJzb2x1dGUNTlRFfDQ5fEx8ZXZpZGVuY2Ugb2YgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgZGlzZWFzZS4NTlRFfDUwfEx8IA1OVEV8NTF8THxGUkVFIFRFU1QgQURERUQgVE8gVkVSSUZZIEFEREVORFVNIFJFUE9SVA1OVEV8NTJ8fCAgDU5URXw1M3x8UExFQVNFIERJU1JFR0FSRCBQUkVWSU9VU0xZIFJFUE9SVEVEIElORk9STUFUSU9OIEJFTE9XOiANTlRFfDU0fHwoVGhlIGluZm9ybWF0aW9uIGJlbG93IHdhcyBvcmlnaW5hbGx5IHJlcG9ydGVkIG9uIDA5LzEyLzIwMTMgYXQgNDoxMyBBTSkNTlRFfDU1fHxDQSAxMjUgICAgIDIgICANTlRFfDU2fHwgDU5URXw1N3x8VGhpcyB0ZXN0IHdhcyBwZXJmb3JtZWQgdXNpbmcgdGhlIFNpZW1lbnMNTlRFfDU4fHxDaGVtaWx1bWluZXNjZW50IG1ldGhvZC4gVmFsdWVzIG9idGFpbmVkIGZyb20NTlRFfDU5fHxkaWZmZXJlbnQgYXNzYXkgbWV0aG9kcyBjYW5ub3QgYmUgdXNlZA1OVEV8NjB8fGludGVyY2hhbmdlYWJseS4gQ0EgMTI1IGxldmVscywgcmVnYXJkbGVzcyBvZg1OVEV8NjF8fHZhbHVlLCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIGFic29sdXRlDU5URXw2Mnx8ZXZpZGVuY2Ugb2YgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgZGlzZWFzZS4NTlRFfDYzfHwgDU5URXw2NHx8IA1OVEV8NjV8fChUaGUgaW5mb3JtYXRpb24gYmVsb3cgd2FzIG9yaWdpbmFsbHkgcmVwb3J0ZWQgb24gMDkvMTIvMjAxMyBhdCA0OjEzIEFNKQ1OVEV8NjZ8fENBIDEyNSAgICAgMiAgIA1OVEV8Njd8fCANTlRFfDY4fHxUaGlzIHRlc3Qgd2FzIHBlcmZvcm1lZCB1c2luZyB0aGUgU2llbWVucw1OVEV8Njl8fENoZW1pbHVtaW5lc2NlbnQgbWV0aG9kLiBWYWx1ZXMgb2J0YWluZWQgZnJvbQ1OVEV8NzB8fGRpZmZlcmVudCBhc3NheSBtZXRob2RzIGNhbm5vdCBiZSB1c2VkDU5URXw3MXx8aW50ZXJjaGFuZ2VhYmx5LiBDQSAxMjUgbGV2ZWxzLCByZWdhcmRsZXNzIG9mDU5URXw3Mnx8dmFsdWUsIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWJzb2x1dGUNTlRFfDczfHxldmlkZW5jZSBvZiB0aGUgcHJlc2VuY2Ugb3IgYWJzZW5jZSBvZiBkaXNlYXNlLg1OVEV8NzR8fCANTlRFfDc1fHwgDU5URXw3Nnx8KFRoZSBpbmZvcm1hdGlvbiBiZWxvdyB3YXMgb3JpZ2luYWxseSByZXBvcnRlZCBvbiAwOS8xMi8yMDEzIGF0IDQ6MzQgQU0pDU5URXw3N3x8Q0EgMTI1ICAgICAxMjAgICBIDU5URXw3OHx8IA1OVEV8Nzl8fD0+IEluZGljYXRlcyBjaGFuZ2VkIHJlc3VsdChzKSBvciBpbmZvcm1hdGlvbi4NTlRFfDgwfHwgDU5URXw4MXx8VGhpcyB0ZXN0IHdhcyBwZXJmb3JtZWQgdXNpbmcgdGhlIFNpZW1lbnMNTlRFfDgyfHxDaGVtaWx1bWluZXNjZW50IG1ldGhvZC4gVmFsdWVzIG9idGFpbmVkIGZyb20NTlRFfDgzfHxkaWZmZXJlbnQgYXNzYXkgbWV0aG9kcyBjYW5ub3QgYmUgdXNlZA1OVEV8ODR8fGludGVyY2hhbmdlYWJseS4gQ0EgMTI1IGxldmVscywgcmVnYXJkbGVzcyBvZg1OVEV8ODV8fHZhbHVlLCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIGFic29sdXRlDU5URXw4Nnx8ZXZpZGVuY2Ugb2YgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgZGlzZWFzZS4NTlRFfDg3fHwgDU5URXw4OHx8RlJFRSBURVNUIEFEREVEIFRPIFZFUklGWSBBRERFTkRVTSBSRVBPUlQNU1BNfDF8MDFeMDF8fFVTUEVDXlNvdXJjZSwgVW5zcGVjaWZpZWReSEw3MDQ4N3x8fHx8fHx8fHx8fHwyMDEzMDkxMjEyMDAwMC4wMDAtMDQwMA0=&lt;/message&gt;
               &lt;/HL7Message&gt;
            &lt;/results&gt;
         &lt;/ns2:Results&gt;
      &lt;/ns2:getResultsResponse&gt;
   &lt;/S:Body&gt;
&lt;/S:Envelope&gt;;

// Example of three HL7v2.5.1 LRI messages and isMore = false
var resultsResponse2 = &lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
   &lt;S:Body&gt;
      &lt;ns2:getResultsResponse xmlns:ns2=&quot;http://medplus.com/results&quot;&gt;
         &lt;ns2:Results&gt;
            &lt;isMore&gt;true&lt;/isMore&gt;
            &lt;requestId&gt;b3c82849ac1262851cb2db226d02c065&lt;/requestId&gt;
            &lt;results&gt;
               &lt;HL7Message&gt;
                  &lt;controlId&gt;20161118205155108982&lt;/controlId&gt;
                  &lt;message&gt;TVNIfF5+XCZ8TEFCfFNLQl4xMUQwMjU1OTMxXkNMSUF8fDcxODYxMjAxfDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHxPUlVeUjAxXk9SVV9SMDF8MjAxNjExMTgyMDUxNTUxMDg5ODJ8RHwyLjUuMXwxfHxBTHxORXx8fHx8fExSSV9OR19STl9Qcm9maWxlXl4yLjE2Ljg0MC4xLjExMzg4My45LjIwXklTTwpQSUR8MXx8MjA1MjY2MTl8fFRFU1ReVENeRklWRXx8MTk1MjAxMDF8Rnx8fDI0MDEgVyBCRUxWRURFUkUgQVZFXl5CQUxUSU1PUkVeTUReMjEyMTU1MjE2fHw0MTA0NjExNTYxCk9SQ3xSRXxMUklURVNUXlFVRVNUX1NLQl83MTg2MTIxfENTMTgyMDUxNTUxNF5RVUVTVF9TS0J8fENNfHx8fHx8fDEzNjY0NzI1NTdeSmF2aWxsb15KYXNvbl5TLl5eXl5eXl5eXk5QSXx8fHx8fHx8fEF0bGFudGEgQlVBVCBUZXN0Xl5eXl5eXl5eNzE4NjEyMQpPQlJ8MXxMUklURVNUXlFVRVNUX1NLQl83MTg2MTIxfENTMTgyMDUxNTUxNF5RVUVTVF9TS0J8OTE0MzFeSElWMS8yIEFHL0FCLDQgVy9SRkxeOTlRRElefHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fEYKT0JYfDF8U1R8ODYwMDkwNTJeSElWIEFHL0FCLCA0VEggR0VOXjk5UURJXjU2ODg4LTFeSElWIDErMiBBYitISVYxIHAyNCBBZyBTZXIgUWwgRUlBXkxOfHxOT04tUkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxOfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxeXl5eXl5GSV5DTElBfHxeXl5eXl5eXl5eXl5OUEleQVQKTlRFfDF8THxBIE5vbnJlYWN0aXZlIEhJViBBZy9BYiByZXN1bHQgZG9lcyBub3QgZXhjbHVkZQpOVEV8MnxMfEhJViBpbmZlY3Rpb24gc2luY2UgdGhlIHRpbWUgZnJhbWUgZm9yIHNlcm9jb252ZXJzaW9uCk5URXwzfEx8aXMgdmFyaWFibGUuIElmIGFjdXRlIEhJViBpbmZlY3Rpb24gaXMgc3VzcGVjdGVkLApOVEV8NHxMfGEgSElWLTEgUk5BIFF1YWxpdGF0aXZlIFRNQSB0ZXN0IGlzIHJlY29tbWVuZGVkLgpOVEV8NXxMfApOVEV8NnxMfFBMRUFTRSBOT1RFOiBUaGlzIGluZm9ybWF0aW9uIGhhcyBiZWVuIGRpc2Nsb3NlZCB0byB5b3UKTlRFfDd8THxmcm9tIHJlY29yZHMgd2hvc2UgY29uZmlkZW50aWFsaXR5IG1heSBiZSBwcm90ZWN0ZWQgYnkKTlRFfDh8THxzdGF0ZSBsYXcuIElmIHlvdXIgc3RhdGUgcmVxdWlyZXMgc3VjaCBwcm90ZWN0aW9uLCB0aGVuCk5URXw5fEx8dGhlIHN0YXRlIGxhdyBwcm9oaWJpdHMgeW91IGZyb20gbWFraW5nIGFueSBmdXJ0aGVyCk5URXwxMHxMfGRpc2Nsb3N1cmUgb2YgdGhlIGluZm9ybWF0aW9uIHdpdGhvdXQgdGhlIHNwZWNpZmljCk5URXwxMXxMfHdyaXR0ZW4gY29uc2VudCBvZiB0aGUgcGVyc29uIHRvIHdob20gaXQgcGVydGFpbnMsIG9yCk5URXwxMnxMfGFzIG90aGVyd2lzZSBwZXJtaXR0ZWQgYnkgbGF3LiBBIGdlbmVyYWwgYXV0aG9yaXphdGlvbgpOVEV8MTN8THxmb3IgdGhlIHJlbGVhc2Ugb2YgbWVkaWNhbCBvciBvdGhlciBpbmZvcm1hdGlvbiBpcyBOT1QKTlRFfDE0fEx8c3VmZmljaWVudCBmb3IgdGhpcyBwdXJwb3NlLgpOVEV8MTV8THwKTlRFfDE2fEx8VGhlIHBlcmZvcm1hbmNlIG9mIHRoaXMgYXNzYXkgaGFzIG5vdCBiZWVuIGNsaW5pY2FsbHkKTlRFfDE3fEx8dmFsaWRhdGVkIGluIHBhdGllbnRzIGxlc3MgdGhhbiAyIHllYXJzIG9sZC4KTlRFfDE4fEx8Ck5URXwxOXxMfEZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHBsZWFzZSByZWZlciB0bwpOVEV8MjB8THxodHRwOi8vZWR1Y2F0aW9uLnF1ZXN0ZGlhZ25vc3RpY3MuY29tL2ZhcS9GQVExMDYKTlRFfDIxfEx8KFRoaXMgbGluayBpcyBiZWluZyBwcm92aWRlZCBmb3IgaW5mb3JtYXRpb25hbC8KTlRFfDIyfEx8ZWR1Y2F0aW9uYWwgcHVycG9zZXMgb25seS4pCk5URXwyM3xMfApPUkN8UkV8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfHxDTXx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHx8fHxBdGxhbnRhIEJVQVQgVGVzdF5eXl5eXl5eXjcxODYxMjEKT0JSfDJ8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfDg0NzJeSEVQQVRJVElTIEMgVklSVVMgQUJeOTlRRElefHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fEYKT0JYfDF8U1R8NTUwNzE2MDBeSEVQQVRJVElTIEMgQU5USUJPRFleOTlRREleMTM5NTUtMF5IQ1YgQWIgU2VyUGwgUWwgRUlBXkxOfHxOT04tUkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxOfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxeXl5eXl5GSV5DTElBfHxeXl5eXl5eXl5eXl5OUEleQVQKT0JYfDJ8Tk18NTUwNzE3MDVeU0lHTkFMIFRPIENVVC1PRkZeOTlRREleNDgxNTktOF5IQ1YgQWIgcy9jbyBTZXJQbCBFSUFeTE58fDAuMDJ8fDwxLjAwfE58fHxGfHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHx8fF5eXl5eXkZJXkNMSUF8fF5eXl5eXl5eXl5eXk5QSV5BVApPUkN8UkV8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfHxDTXx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHx8fHxBdGxhbnRhIEJVQVQgVGVzdF5eXl5eXl5eXjcxODYxMjEKT0JSfDN8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfDQ5OF5IQlNBRyBXL1JGTCBDT05GXjk5UURJXnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHx8fHx8MTM2NjQ3MjU1N15KYXZpbGxvXkphc29uXlMuXl5eXl5eXl5eTlBJfHx8fHx8MjAxNjExMTgyMDUxNTUuMTA4KzAwMDB8fHxGCk9CWHwxfFNUfDU1MDE5MzAwXkhFUEFUSVRJUyBCIFNVUkZBQ0UgQU5USUdFTl45OVFESV41MTk2LTFeSEJWIHN1cmZhY2UgQWcgU2VyUGwgUWwgRUlBXkxOfHxOT04tUkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxOfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxeXl5eXl5GSV5DTElBfHxeXl5eXl5eXl5eXl5OUEleQVQKT0JYfDJ8U1R8NTUwMTk2MDBeQ09ORklSTUFUSU9OXjk5UURJXjc5MDUtM15IQlYgc3VyZmFjZSBBZyBTZXJQbCBRbCBOdF5MTnx8RE5SfHx8Tnx8fFh8fHwyMDE2MTExNzA4NDgwMC4wMDAtMDUwMHx8fHx8MjAxNjExMTgyMDUxNTUuMTA4KzAwMDB8fHx8Xl5eXl5eRkleQ0xJQXx8Xl5eXl5eXl5eXl5eTlBJXkFUCk9SQ3xSRXxMUklURVNUXlFVRVNUX1NLQl83MTg2MTIxfENTMTgyMDUxNTUxNF5RVUVTVF9TS0J8fENNfHx8fHx8fDEzNjY0NzI1NTdeSmF2aWxsb15KYXNvbl5TLl5eXl5eXl5eXk5QSXx8fHx8fHx8fEF0bGFudGEgQlVBVCBUZXN0Xl5eXl5eXl5eNzE4NjEyMQpPQlJ8NHxMUklURVNUXlFVRVNUX1NLQl83MTg2MTIxfENTMTgyMDUxNTUxNF5RVUVTVF9TS0J8MzY0MF5IU1YgMiBJR0csIFRZUEUgU1BFQ0lGSUMgQUIgSEVSUEVTRUxFQ1ReOTlRRElefHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fEYKT0JYfDF8VFh8NTIwOS0yXkhTVjIgSWdHIFNlciBFSUEtYUNuY15MTl43MDAyMDYwMF5IU1YgMiBJR0cgVFlQRSBTUEVDSUZJQyBBQl45OVFESXx8PjUuMDB8fHxIfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxBVF5eXl5eXkZJfHxeXl5eXl5eXl5eXl5OUEkKTlRFfDF8fCBWYWx1ZSBJbnRlcnByZXRhdGlvbgpOVEV8Mnx8IC0tLS0tIC0tLS0tLS0tLS0tLS0tCk5URXwzfHwgPDAuOTAgTmVnYXRpdmUKTlRFfDR8fCAwLjkwLTEuMTAgRXF1aXZvY2FsCk5URXw1fHwgPjEuMTAgUG9zaXRpdmUKTlRFfDZ8fApOVEV8N3x8VGhpcyBhc3NheSB1dGlsaXplcyByZWNvbWJpbmFudCB0eXBlLXNwZWNpZmljIGFudGlnZW5zCk5URXw4fHx0byBkaWZmZXJlbnRpYXRlIEhTVi0xIGZyb20gSFNWLTIgaW5mZWN0aW9ucy4gQQpOVEV8OXx8cG9zaXRpdmUgcmVzdWx0IGNhbm5vdCBkaXN0aW5ndWlzaCBiZXR3ZWVuIHJlY2VudCBhbmQKTlRFfDEwfHxwYXN0IGluZmVjdGlvbi4gSWYgcmVjZW50IEhTViBpbmZlY3Rpb24gaXMgc3VzcGVjdGVkCk5URXwxMXx8YnV0IHRoZSByZXN1bHRzIGFyZSBuZWdhdGl2ZSBvciBlcXVpdm9jYWwsIHRoZSBhc3NheQpOVEV8MTJ8fHNob3VsZCBiZSByZXBlYXRlZCBpbiA0LTYgd2Vla3MuIFRoZSBwZXJmb3JtYW5jZQpOVEV8MTN8fGNoYXJhY3RlcmlzdGljcyBvZiB0aGUgYXNzYXkgaGF2ZSBub3QgYmVlbiBlc3RhYmxpc2hlZApOVEV8MTR8fGZvciBwZWRpYXRyaWMgcG9wdWxhdGlvbnMsIGltbXVub2NvbXByb21pc2VkIHBhdGllbnRzLApOVEV8MTV8fG9yIG5lb25hdGFsIHNjcmVlbmluZy4KTlRFfDE2fHwKT1JDfFJFfExSSVRFU1ReUVVFU1RfU0tCXzcxODYxMjF8Q1MxODIwNTE1NTE0XlFVRVNUX1NLQnx8Q018fHx8fHx8MTM2NjQ3MjU1N15KYXZpbGxvXkphc29uXlMuXl5eXl5eXl5eTlBJfHx8fHx8fHx8QXRsYW50YSBCVUFUIFRlc3ReXl5eXl5eXl43MTg2MTIxCk9CUnw1fExSSVRFU1ReUVVFU1RfU0tCXzcxODYxMjF8Q1MxODIwNTE1NTE0XlFVRVNUX1NLQnw3OTleUlBSIChNT05JVE9SKSBXL1JFRkxeOTlRRElefHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fEYKT0JYfDF8U1R8NDAwMTAxMDBeUlBSIChNT05JVE9SKSBXL1JFRkwgVElURVJeOTlRREleMjA1MDctMF5SUFIgU2VyIFFsXkxOfHxSRUFDVElWRXx8Tk9OLVJFQUNUSVZFfEF8fHxGfHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHx8fF5eXl5eXkZJXkNMSUF8fF5eXl5eXl5eXl5eXk5QSV5BVApOVEV8MXxMfFRoZSBSUFIgaXMgYSBub24tdHJlcG9uZW1hbC1zcGVjaWZpYyB0ZXN0OyB0aGVyZWZvcmUsCk5URXwyfEx8YSB0cmVwb25lbWFsLXNwZWNpZmljIGNvbmZpcm1hdG9yeSB0ZXN0IHNob3VsZCBiZQpOVEV8M3xMfHBlcmZvcm1lZCB1bmxlc3MgcHJpb3Igc3lwaGlsaXMgaW5mZWN0aW9uIGhhcyBiZWVuCk5URXw0fEx8ZG9jdW1lbnRlZCBmb3IgdGhpcyBwYXRpZW50LgpPUkN8UkV8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfHxDTXx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHx8fHxBdGxhbnRhIEJVQVQgVGVzdF5eXl5eXl5eXjcxODYxMjEKT0JSfDZ8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfDExMzYyXk5FSVNTRVJJQSBHT05PUlJIT0VBRSBSTkEsIFRNQV45OVFESV58fHwyMDE2MTExNzA4NDgwMC4wMDAtMDUwMHx8fHx8fHx8fDEzNjY0NzI1NTdeSmF2aWxsb15KYXNvbl5TLl5eXl5eXl5eXk5QSXx8fHx8fDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHx8RgpPQlh8MXxTVHw0MzMwNS0yXk4gZ29ub3JyaG9lYSByUk5BIFhYWCBRbCBQQ1JeTE5eNzAwNDM5MDBeTkVJU1NFUklBIEdPTk9SUkhPRUFFIFJOQSwgVE1BXjk5UURJfHxOT1QgREVURUNURUR8fE5PVCBERVRFQ1RFRHxOfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxBVF5eXl5eXkZJfHxeXl5eXl5eXl5eXl5OUEkKT0JYfDJ8VFh8MTAwMDE1OTdeQ09NTUVOVF45OVFESV4xMDAwMTU5N15DT01NRU5UXjk5UURJfHx8fHx8fHxGfHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHx8fEFUXl5eXl5eRkl8fF5eXl5eXl5eXl5eXk5QSQpOVEV8MXx8VGhpcyB0ZXN0IHdhcyBwZXJmb3JtZWQgdXNpbmcgdGhlIEFQVElNQSBDT01CTzIgQXNzYXkKTlRFfDJ8fChHZW4tUHJvYmUgSW5jLikuCk5URXwzfHwKTlRFfDR8fFRoZSBhbmFseXRpY2FsIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiB0aGlzCk5URXw1fHxhc3NheSwgd2hlbiB1c2VkIHRvIHRlc3QgU3VyZVBhdGggc3BlY2ltZW5zIGhhdmUKTlRFfDZ8fGJlZW4gZGV0ZXJtaW5lZCBieSBRdWVzdCBEaWFnbm9zdGljcy4KTlRFfDd8fApOVEV8OHxPfERhdGFiYXNlIFRlc3RpbmcgUmVzdWx0&lt;/message&gt;
               &lt;/HL7Message&gt;
            &lt;/results&gt;
         &lt;/ns2:Results&gt;
      &lt;/ns2:getResultsResponse&gt;
   &lt;/S:Body&gt;
&lt;/S:Envelope&gt;;


var count = globalChannelMap.get(&quot;isMoreCount&quot;);
if (count &lt;= 1) {
	responseMap.put(&quot;getResultsResponse&quot;, resultsResponse1);
	globalChannelMap.put(&quot;isMoreCount&quot;, 2);
} else if (count == 2) {
	responseMap.put(&quot;getResultsResponse&quot;, resultsResponse2);
	globalChannelMap.put(&quot;isMoreCount&quot;, 3);
} else if (count &gt;= 3) {
	responseMap.put(&quot;getResultsResponse&quot;, emptyResultsResponse);
	globalChannelMap.put(&quot;isMoreCount&quot;, 4);
}</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>// Example of the empty LRI response
var emptyResultsResponse = &lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
	&lt;S:Body&gt;
		&lt;ns0:getResultsResponse xmlns:ns0=&quot;http://medplus.com/results&quot;&gt;
			&lt;ns0:Results&gt;
				&lt;isMore&gt;false&lt;/isMore&gt;
				&lt;requestId&gt;6eb0eb290a801e1e1113d4d4dfc71efc&lt;/requestId&gt;
			&lt;/ns0:Results&gt;
		&lt;/ns0:getResultsResponse&gt;
	&lt;/S:Body&gt;
&lt;/S:Envelope&gt;;


// Example of three HL7v2.5.1 LRI messages and isMore = true
var resultsResponse1 = &lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
   &lt;S:Body&gt;
      &lt;ns2:getResultsResponse xmlns:ns2=&quot;http://medplus.com/results&quot;&gt;
         &lt;ns2:Results&gt;
            &lt;isMore&gt;true&lt;/isMore&gt;
            &lt;requestId&gt;b3c82849ac1262851cb2db226d02c065&lt;/requestId&gt;
            &lt;results&gt;
               &lt;HL7Message&gt;
                  &lt;controlId&gt;80000000000000038102&lt;/controlId&gt;
                  &lt;message&gt;TVNIfF5+XCZ8UUxTfFBIMV4zOUQwNjU3NzQwXkNMSUF8fDc4NjAwMDAxfDIwMTMwNzIzMTYzMDI3LjAwMC0wNDAwfHxPUlVeUjAxXk9SVV9SMDF8ODAwMDAwMDAwMDAwMDAwMzgxMDJ8UHwyLjUuMXwxfHxBTHxORXx8fHx8TFJJX05HX1JOX1Byb2ZpbGVeXjIuMTYuODQwLjEuMTEzODgzLjkuMjBeSVNPClBJRHwxfHxLUDAzMjA2MVBeXl5eTEFDU058fExhc3ROYW1lXkZpcnN0TmFtZV5eXl5eTHx8fE18fHxeXl5eXlVTQQpOVEV8MXxMfFJFUE9SVCBDT01NRU5UUyBMSU5FIDEKTlRFfDJ8THxSRVBPUlQgQ09NTUVOVFMgTElORSAyCk9SQ3xSRXx8S1AwMzIwNjFQXlFVRVNUX1BIMXx8Q018fHx8fHx8Xkxhc3ROYW1lXkZpcnN0TmFtZXx8fHx8fHx8fF5eXl5eXl5eXjc4NjAwMDAxfFN0cmVldCBBZGRyZXNzXl5DaXR5XlN0YXRlXlppcF5eT15eVVNBCk9CUnwxfHxLUDAzMjA2MVBeUVVFU1RfUEgxfDQ4NF5HTFVDT1NFLCBQTEFTTUFeOTlRREl8fHwyMDEzMDcyMzAzMDAwMC4wMDAtMDQwMHx8fHx8fHx8fF5MYXN0TmFtZV5GaXJzdE5hbWV8fHx8fHwyMDEzMDcyMzE2MzAyNy4wMDAtMDQwMHx8fEYKT0JYfDF8Tk18MjUwMTQ1MDBeR0xVQ09TRSwgUExBU01BXjk5UURJXjE1NTgtNl5HbHVjb3NlIHAgZmFzdCBTZXJQbC1tQ25jXkxOfDF8NzB8bWcvZExeXjk5UURJfDY1LTk5fE58fHxGfHx8MjAxMzA3MjMwMzAwMDAuMDAwLTA0MDB8fHx8fDIwMTMwNzIzMTYzMDI3LjAwMC0wNDAwfHx8fFFVRVNUIERJQUdOT1NUSUNTIEhPUlNIQU1eXl5eXl5GSV5DTElBXl4zOUQwMjA0NDA0fDkwMCBCVVNJTkVTUyBDRU5URVIgRFJJVkVeXkhPUlNIQU1eUEFeMTkwNDQtMzQzMnwxMjA1ODcyMDQxXkxhc3ROYW1lXkZpcnN0TmFtZV5TXl5eXl5eXl5eTlBJCk5URXwxfEx8Ck5URXwyfEx8IEZhc3RpbmcgcmVmZXJlbmNlIGludGVydmFsCk5URXwzfEx8ClNQTXwxfDAyXjAyfHxVU1BFQ15Tb3VyY2UsIFVuc3BlY2lmaWVkXkhMNzA0ODd8fHx8fHx8fHx8fHx8MjAxMzA3MjMwMzAwMDAuMDAwLTA0MDAKT1JDfFJFfHxLUDAzMjA2MVBeUVVFU1RfUEgxfHxDTXx8fHx8fHxeTGFzdE5hbWVeRmlyc3ROYW1lfHx8fHx8fHx8Xl5eXl5eXl5eNzg2MDAwMDF8U3RyZWV0IEFkZHJlc3NeXkNpdHleU3RhdGVeWmlwXl5PXl5VU0EKT0JSfDJ8fEtQMDMyMDYxUF5RVUVTVF9QSDF8NzMzXlBPVEFTU0lVTV45OVFESXx8fDIwMTMwNzIzMDMwMDAwLjAwMC0wNDAwfHx8fHx8fHx8Xkxhc3ROYW1lXkZpcnN0TmFtZXx8fHx8fDIwMTMwNzIzMTYzMDI3LjAwMC0wNDAwfHx8RgpPQlh8MXxOTXwyNTAwMDUwMF5QT1RBU1NJVU1eOTlRREleMjgyMy0zXlBvdGFzc2l1bSBTZXJQbC1zQ25jXkxOfDF8NC41fG1tb2wvTF5eOTlRREl8My41LTUuM3xOfHx8Rnx8fDIwMTMwNzIzMDMwMDAwLjAwMC0wNDAwfHx8fHwyMDEzMDcyMzE2MzAyNy4wMDAtMDQwMHx8fHxRVUVTVCBESUFHTk9TVElDUyBIT1JTSEFNXl5eXl5eRkleQ0xJQV5eMzlEMDIwNDQwNHw5MDAgQlVTSU5FU1MgQ0VOVEVSIERSSVZFXl5IT1JTSEFNXlBBXjE5MDQ0LTM0MzJ8MTIwNTg3MjA0MV5MYXN0TmFtZV5GaXJzdE5hbWVeU15eXl5eXl5eXk5QSQpTUE18MXwwMV4wMXx8VVNQRUNeU291cmNlLCBVbnNwZWNpZmllZF5ITDcwNDg3fHx8fHx8fHx8fHx8fDIwMTMwNzIzMDMwMDAwLjAwMC0wNDAwCg==&lt;/message&gt;
               &lt;/HL7Message&gt;
            &lt;/results&gt;
            &lt;results&gt;
               &lt;HL7Message&gt;
                  &lt;controlId&gt;80000000000000080409&lt;/controlId&gt;
                  &lt;message&gt;TVNIfF5+XCZ8UUxTfENXMV4xNEQwNDE3MDUyXkNMSUF8fDc4NjAwMDA1fDIwMTMwOTE5MTA0MzUyLjAwMC0wNDAwfHxPUlVeUjAxXk9SVV9SMDF8ODAwMDAwMDAwMDAwMDAwODA0MDl8UHwyLjUuMXw0fHxBTHxORXx8fHx8TFJJX05HX1JOX1Byb2ZpbGVeXjIuMTYuODQwLjEuMTEzODgzLjkuMjBeSVNPDVBJRHwxfHxQQVRJRDAxXl5eXlBUfHxURVNUXkFDQ0VTU0lPTlRXT15eXl5eTHx8MTk4ODA4MjV8Rnx8fF5eXl5eVVNBfHxeXl5eXjk2NV40MDkxMTQzDU5URXwxfEx8UkVQT1JUIENPTU1FTlRTIEVOVEVSRUQgQlkgQk9CDU5URXwyfEx8UkVQT1JUIENPTU1FTlRTIEZPUiBHT01BMDAwMQ1PUkN8UkV8TEFCIFJFRjAwMDAxXlFVRVNUX0NXMV83ODYwMDAwNXxDQjAyOTEwOEFeUVVFU1RfQ1cxfHxDTXx8fHx8fE5QUDAwMDFeRFIuQk9CXl5eXl5eXl5eXl5FSXwxMDUzMzI1ODExXlFBVEVTVEVSXk9MSVZJQV5eXl5eXl5eXl5OUEl8fHx8fHx8fHxMT0MwMV5eXl5eXl5eXjc4NjAwMDA1fDEyMDEgQU5ZU1RSRUVUIFJEXlFMU1RFU1ReQ09MTEVHRVZJTExFXlBBXjE5NDI2LTEwNTBeXk9eXlVTQQ1PQlJ8MXxMQUIgUkVGMDAwMDFeUVVFU1RfQ1cxXzc4NjAwMDA1fENCMDI5MTA4QV5RVUVTVF9DVzF8MjkyNTZeQ0ExMjVeOTlRREl8fHwyMDEzMDkxMjEyMDAwMC4wMDAtMDQwMHx8fHx8fHx8fDEwNTMzMjU4MTFeUUFURVNURVJeT0xJVklBXl5eXl5eXl5eXk5QSXx8fHx8fDIwMTMwOTE5MTA0MzUyLjAwMC0wNDAwfHx8Qw1PQlh8MXxOTXw1NTA2MjU1MF5DQSAxMjVeOTlRREleMTAzMzQtMV5DYW5jZXIgQWcxMjUgU2VyUGwtYUNuY15MTnwxfDEyMHxVL21MXl45OVFESXw8IDIxfEh8fHxDfHx8MjAxMzA5MTIxMjAwMDAuMDAwLTA0MDB8fHx8fDIwMTMwOTE5MTA0MzUyLjAwMC0wNDAwfHx8fFFVRVNUIERJQUdOT1NUSUNTIEFOWVRPV05eXl5eXl5GSV5DTElBXl4xNEQwNDE3MDUyfDEzNTUgQU5ZU1RSRUVUIEJPVUxFVkFSRF5eQU5ZVE9XTl5JTF42MDE5MS0xMDI0fF5RQVRFU1RFUl5PTElWSUFeVi5eXl5eXl5eXl5eQ0INTlRFfDF8THwgDU5URXwyfEx8PT4gSW5kaWNhdGVzIGNoYW5nZWQgcmVzdWx0KHMpIG9yIGluZm9ybWF0aW9uLg1OVEV8M3xMfCANTlRFfDR8THxUaGlzIHRlc3Qgd2FzIHBlcmZvcm1lZCB1c2luZyB0aGUgU2llbWVucw1OVEV8NXxMfENoZW1pbHVtaW5lc2NlbnQgbWV0aG9kLiBWYWx1ZXMgb2J0YWluZWQgZnJvbQ1OVEV8NnxMfGRpZmZlcmVudCBhc3NheSBtZXRob2RzIGNhbm5vdCBiZSB1c2VkDU5URXw3fEx8aW50ZXJjaGFuZ2VhYmx5LiBDQSAxMjUgbGV2ZWxzLCByZWdhcmRsZXNzIG9mDU5URXw4fEx8dmFsdWUsIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWJzb2x1dGUNTlRFfDl8THxldmlkZW5jZSBvZiB0aGUgcHJlc2VuY2Ugb3IgYWJzZW5jZSBvZiBkaXNlYXNlLg1OVEV8MTB8THwgDU5URXwxMXxMfEZSRUUgVEVTVCBBRERFRCBUTyBWRVJJRlkgQURERU5EVU0gUkVQT1JUDU5URXwxMnxMfEFOT1RIRVIgVEVYVCBBRERFRCBUTyBWRVJJRlkgVEhFIEFEREVORFVNIFNDRU5BUklPDU5URXwxM3xMfFBMRUFTRSBESVNSRUdBUkQgUFJFVklPVVNMWSBSRVBPUlRFRCBJTkZPUk1BVElPTiBCRUxPVzoNTlRFfDE0fEx8UExFQVNFIERJU1JFR0FSRCBSRVNVTFRTIEJFTE9XOg1OVEV8MTV8THwoVGhlIGluZm9ybWF0aW9uIGJlbG93IHdhcyBvcmlnaW5hbGx5IHJlcG9ydGVkIG9uIDA5LzEyLzIwMTMgYXQgNDoxMyBBTSkNTlRFfDE2fEx8Q0EgMTI1IDIgIA1OVEV8MTd8THwgDU5URXwxOHxMfFRoaXMgdGVzdCB3YXMgcGVyZm9ybWVkIHVzaW5nIHRoZSBTaWVtZW5zDU5URXwxOXxMfENoZW1pbHVtaW5lc2NlbnQgbWV0aG9kLiBWYWx1ZXMgb2J0YWluZWQgZnJvbQ1OVEV8MjB8THxkaWZmZXJlbnQgYXNzYXkgbWV0aG9kcyBjYW5ub3QgYmUgdXNlZA1OVEV8MjF8THxpbnRlcmNoYW5nZWFibHkuIENBIDEyNSBsZXZlbHMsIHJlZ2FyZGxlc3Mgb2YNTlRFfDIyfEx8dmFsdWUsIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWJzb2x1dGUNTlRFfDIzfEx8ZXZpZGVuY2Ugb2YgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgZGlzZWFzZS4NTlRFfDI0fEx8IA1OVEV8MjV8THxQTEVBU0UgRElTUkVHQVJEIFBSRVZJT1VTTFkgUkVQT1JURUQgSU5GT1JNQVRJT04gQkVMT1c6DU5URXwyNnxMfFBMRUFTRSBESVNSRUdBUkQgUkVTVUxUUyBCRUxPVzoNTlRFfDI3fEx8KFRoZSBpbmZvcm1hdGlvbiBiZWxvdyB3YXMgb3JpZ2luYWxseSByZXBvcnRlZCBvbiAwOS8xMi8yMDEzIGF0IDQ6MTMgQU0pDU5URXwyOHxMfENBIDEyNSAyICANTlRFfDI5fEx8IA1OVEV8MzB8THxUaGlzIHRlc3Qgd2FzIHBlcmZvcm1lZCB1c2luZyB0aGUgU2llbWVucw1OVEV8MzF8THxDaGVtaWx1bWluZXNjZW50IG1ldGhvZC4gVmFsdWVzIG9idGFpbmVkIGZyb20NTlRFfDMyfEx8ZGlmZmVyZW50IGFzc2F5IG1ldGhvZHMgY2Fubm90IGJlIHVzZWQNTlRFfDMzfEx8aW50ZXJjaGFuZ2VhYmx5LiBDQSAxMjUgbGV2ZWxzLCByZWdhcmRsZXNzIG9mDU5URXwzNHxMfHZhbHVlLCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIGFic29sdXRlDU5URXwzNXxMfGV2aWRlbmNlIG9mIHRoZSBwcmVzZW5jZSBvciBhYnNlbmNlIG9mIGRpc2Vhc2UuDU5URXwzNnxMfCANTlRFfDM3fEx8UExFQVNFIERJU1JFR0FSRCBQUkVWSU9VU0xZIFJFUE9SVEVEIElORk9STUFUSU9OIEJFTE9XOg1OVEV8Mzh8THxQTEVBU0UgRElTUkVHQVJEIFJFU1VMVFMgQkVMT1c6DU5URXwzOXxMfChUaGUgaW5mb3JtYXRpb24gYmVsb3cgd2FzIG9yaWdpbmFsbHkgcmVwb3J0ZWQgb24gMDkvMTIvMjAxMyBhdCA0OjM0IEFNKQ1OVEV8NDB8THxDQSAxMjUgMTIwIEggDU5URXw0MXxMfCANTlRFfDQyfEx8PT4gSW5kaWNhdGVzIGNoYW5nZWQgcmVzdWx0KHMpIG9yIGluZm9ybWF0aW9uLg1OVEV8NDN8THwgDU5URXw0NHxMfFRoaXMgdGVzdCB3YXMgcGVyZm9ybWVkIHVzaW5nIHRoZSBTaWVtZW5zDU5URXw0NXxMfENoZW1pbHVtaW5lc2NlbnQgbWV0aG9kLiBWYWx1ZXMgb2J0YWluZWQgZnJvbQ1OVEV8NDZ8THxkaWZmZXJlbnQgYXNzYXkgbWV0aG9kcyBjYW5ub3QgYmUgdXNlZA1OVEV8NDd8THxpbnRlcmNoYW5nZWFibHkuIENBIDEyNSBsZXZlbHMsIHJlZ2FyZGxlc3Mgb2YNTlRFfDQ4fEx8dmFsdWUsIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWJzb2x1dGUNTlRFfDQ5fEx8ZXZpZGVuY2Ugb2YgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgZGlzZWFzZS4NTlRFfDUwfEx8IA1OVEV8NTF8THxGUkVFIFRFU1QgQURERUQgVE8gVkVSSUZZIEFEREVORFVNIFJFUE9SVA1OVEV8NTJ8fCAgDU5URXw1M3x8UExFQVNFIERJU1JFR0FSRCBQUkVWSU9VU0xZIFJFUE9SVEVEIElORk9STUFUSU9OIEJFTE9XOiANTlRFfDU0fHwoVGhlIGluZm9ybWF0aW9uIGJlbG93IHdhcyBvcmlnaW5hbGx5IHJlcG9ydGVkIG9uIDA5LzEyLzIwMTMgYXQgNDoxMyBBTSkNTlRFfDU1fHxDQSAxMjUgICAgIDIgICANTlRFfDU2fHwgDU5URXw1N3x8VGhpcyB0ZXN0IHdhcyBwZXJmb3JtZWQgdXNpbmcgdGhlIFNpZW1lbnMNTlRFfDU4fHxDaGVtaWx1bWluZXNjZW50IG1ldGhvZC4gVmFsdWVzIG9idGFpbmVkIGZyb20NTlRFfDU5fHxkaWZmZXJlbnQgYXNzYXkgbWV0aG9kcyBjYW5ub3QgYmUgdXNlZA1OVEV8NjB8fGludGVyY2hhbmdlYWJseS4gQ0EgMTI1IGxldmVscywgcmVnYXJkbGVzcyBvZg1OVEV8NjF8fHZhbHVlLCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIGFic29sdXRlDU5URXw2Mnx8ZXZpZGVuY2Ugb2YgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgZGlzZWFzZS4NTlRFfDYzfHwgDU5URXw2NHx8IA1OVEV8NjV8fChUaGUgaW5mb3JtYXRpb24gYmVsb3cgd2FzIG9yaWdpbmFsbHkgcmVwb3J0ZWQgb24gMDkvMTIvMjAxMyBhdCA0OjEzIEFNKQ1OVEV8NjZ8fENBIDEyNSAgICAgMiAgIA1OVEV8Njd8fCANTlRFfDY4fHxUaGlzIHRlc3Qgd2FzIHBlcmZvcm1lZCB1c2luZyB0aGUgU2llbWVucw1OVEV8Njl8fENoZW1pbHVtaW5lc2NlbnQgbWV0aG9kLiBWYWx1ZXMgb2J0YWluZWQgZnJvbQ1OVEV8NzB8fGRpZmZlcmVudCBhc3NheSBtZXRob2RzIGNhbm5vdCBiZSB1c2VkDU5URXw3MXx8aW50ZXJjaGFuZ2VhYmx5LiBDQSAxMjUgbGV2ZWxzLCByZWdhcmRsZXNzIG9mDU5URXw3Mnx8dmFsdWUsIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWJzb2x1dGUNTlRFfDczfHxldmlkZW5jZSBvZiB0aGUgcHJlc2VuY2Ugb3IgYWJzZW5jZSBvZiBkaXNlYXNlLg1OVEV8NzR8fCANTlRFfDc1fHwgDU5URXw3Nnx8KFRoZSBpbmZvcm1hdGlvbiBiZWxvdyB3YXMgb3JpZ2luYWxseSByZXBvcnRlZCBvbiAwOS8xMi8yMDEzIGF0IDQ6MzQgQU0pDU5URXw3N3x8Q0EgMTI1ICAgICAxMjAgICBIDU5URXw3OHx8IA1OVEV8Nzl8fD0+IEluZGljYXRlcyBjaGFuZ2VkIHJlc3VsdChzKSBvciBpbmZvcm1hdGlvbi4NTlRFfDgwfHwgDU5URXw4MXx8VGhpcyB0ZXN0IHdhcyBwZXJmb3JtZWQgdXNpbmcgdGhlIFNpZW1lbnMNTlRFfDgyfHxDaGVtaWx1bWluZXNjZW50IG1ldGhvZC4gVmFsdWVzIG9idGFpbmVkIGZyb20NTlRFfDgzfHxkaWZmZXJlbnQgYXNzYXkgbWV0aG9kcyBjYW5ub3QgYmUgdXNlZA1OVEV8ODR8fGludGVyY2hhbmdlYWJseS4gQ0EgMTI1IGxldmVscywgcmVnYXJkbGVzcyBvZg1OVEV8ODV8fHZhbHVlLCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIGFic29sdXRlDU5URXw4Nnx8ZXZpZGVuY2Ugb2YgdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgZGlzZWFzZS4NTlRFfDg3fHwgDU5URXw4OHx8RlJFRSBURVNUIEFEREVEIFRPIFZFUklGWSBBRERFTkRVTSBSRVBPUlQNU1BNfDF8MDFeMDF8fFVTUEVDXlNvdXJjZSwgVW5zcGVjaWZpZWReSEw3MDQ4N3x8fHx8fHx8fHx8fHwyMDEzMDkxMjEyMDAwMC4wMDAtMDQwMA0=&lt;/message&gt;
               &lt;/HL7Message&gt;
            &lt;/results&gt;
         &lt;/ns2:Results&gt;
      &lt;/ns2:getResultsResponse&gt;
   &lt;/S:Body&gt;
&lt;/S:Envelope&gt;;

// Example of three HL7v2.5.1 LRI messages and isMore = false
var resultsResponse2 = &lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
   &lt;S:Body&gt;
      &lt;ns2:getResultsResponse xmlns:ns2=&quot;http://medplus.com/results&quot;&gt;
         &lt;ns2:Results&gt;
            &lt;isMore&gt;true&lt;/isMore&gt;
            &lt;requestId&gt;b3c82849ac1262851cb2db226d02c065&lt;/requestId&gt;
            &lt;results&gt;
               &lt;HL7Message&gt;
                  &lt;controlId&gt;20161118205155108982&lt;/controlId&gt;
                  &lt;message&gt;TVNIfF5+XCZ8TEFCfFNLQl4xMUQwMjU1OTMxXkNMSUF8fDcxODYxMjAxfDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHxPUlVeUjAxXk9SVV9SMDF8MjAxNjExMTgyMDUxNTUxMDg5ODJ8RHwyLjUuMXwxfHxBTHxORXx8fHx8fExSSV9OR19STl9Qcm9maWxlXl4yLjE2Ljg0MC4xLjExMzg4My45LjIwXklTTwpQSUR8MXx8MjA1MjY2MTl8fFRFU1ReVENeRklWRXx8MTk1MjAxMDF8Rnx8fDI0MDEgVyBCRUxWRURFUkUgQVZFXl5CQUxUSU1PUkVeTUReMjEyMTU1MjE2fHw0MTA0NjExNTYxCk9SQ3xSRXxMUklURVNUXlFVRVNUX1NLQl83MTg2MTIxfENTMTgyMDUxNTUxNF5RVUVTVF9TS0J8fENNfHx8fHx8fDEzNjY0NzI1NTdeSmF2aWxsb15KYXNvbl5TLl5eXl5eXl5eXk5QSXx8fHx8fHx8fEF0bGFudGEgQlVBVCBUZXN0Xl5eXl5eXl5eNzE4NjEyMQpPQlJ8MXxMUklURVNUXlFVRVNUX1NLQl83MTg2MTIxfENTMTgyMDUxNTUxNF5RVUVTVF9TS0J8OTE0MzFeSElWMS8yIEFHL0FCLDQgVy9SRkxeOTlRRElefHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fEYKT0JYfDF8U1R8ODYwMDkwNTJeSElWIEFHL0FCLCA0VEggR0VOXjk5UURJXjU2ODg4LTFeSElWIDErMiBBYitISVYxIHAyNCBBZyBTZXIgUWwgRUlBXkxOfHxOT04tUkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxOfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxeXl5eXl5GSV5DTElBfHxeXl5eXl5eXl5eXl5OUEleQVQKTlRFfDF8THxBIE5vbnJlYWN0aXZlIEhJViBBZy9BYiByZXN1bHQgZG9lcyBub3QgZXhjbHVkZQpOVEV8MnxMfEhJViBpbmZlY3Rpb24gc2luY2UgdGhlIHRpbWUgZnJhbWUgZm9yIHNlcm9jb252ZXJzaW9uCk5URXwzfEx8aXMgdmFyaWFibGUuIElmIGFjdXRlIEhJViBpbmZlY3Rpb24gaXMgc3VzcGVjdGVkLApOVEV8NHxMfGEgSElWLTEgUk5BIFF1YWxpdGF0aXZlIFRNQSB0ZXN0IGlzIHJlY29tbWVuZGVkLgpOVEV8NXxMfApOVEV8NnxMfFBMRUFTRSBOT1RFOiBUaGlzIGluZm9ybWF0aW9uIGhhcyBiZWVuIGRpc2Nsb3NlZCB0byB5b3UKTlRFfDd8THxmcm9tIHJlY29yZHMgd2hvc2UgY29uZmlkZW50aWFsaXR5IG1heSBiZSBwcm90ZWN0ZWQgYnkKTlRFfDh8THxzdGF0ZSBsYXcuIElmIHlvdXIgc3RhdGUgcmVxdWlyZXMgc3VjaCBwcm90ZWN0aW9uLCB0aGVuCk5URXw5fEx8dGhlIHN0YXRlIGxhdyBwcm9oaWJpdHMgeW91IGZyb20gbWFraW5nIGFueSBmdXJ0aGVyCk5URXwxMHxMfGRpc2Nsb3N1cmUgb2YgdGhlIGluZm9ybWF0aW9uIHdpdGhvdXQgdGhlIHNwZWNpZmljCk5URXwxMXxMfHdyaXR0ZW4gY29uc2VudCBvZiB0aGUgcGVyc29uIHRvIHdob20gaXQgcGVydGFpbnMsIG9yCk5URXwxMnxMfGFzIG90aGVyd2lzZSBwZXJtaXR0ZWQgYnkgbGF3LiBBIGdlbmVyYWwgYXV0aG9yaXphdGlvbgpOVEV8MTN8THxmb3IgdGhlIHJlbGVhc2Ugb2YgbWVkaWNhbCBvciBvdGhlciBpbmZvcm1hdGlvbiBpcyBOT1QKTlRFfDE0fEx8c3VmZmljaWVudCBmb3IgdGhpcyBwdXJwb3NlLgpOVEV8MTV8THwKTlRFfDE2fEx8VGhlIHBlcmZvcm1hbmNlIG9mIHRoaXMgYXNzYXkgaGFzIG5vdCBiZWVuIGNsaW5pY2FsbHkKTlRFfDE3fEx8dmFsaWRhdGVkIGluIHBhdGllbnRzIGxlc3MgdGhhbiAyIHllYXJzIG9sZC4KTlRFfDE4fEx8Ck5URXwxOXxMfEZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHBsZWFzZSByZWZlciB0bwpOVEV8MjB8THxodHRwOi8vZWR1Y2F0aW9uLnF1ZXN0ZGlhZ25vc3RpY3MuY29tL2ZhcS9GQVExMDYKTlRFfDIxfEx8KFRoaXMgbGluayBpcyBiZWluZyBwcm92aWRlZCBmb3IgaW5mb3JtYXRpb25hbC8KTlRFfDIyfEx8ZWR1Y2F0aW9uYWwgcHVycG9zZXMgb25seS4pCk5URXwyM3xMfApPUkN8UkV8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfHxDTXx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHx8fHxBdGxhbnRhIEJVQVQgVGVzdF5eXl5eXl5eXjcxODYxMjEKT0JSfDJ8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfDg0NzJeSEVQQVRJVElTIEMgVklSVVMgQUJeOTlRRElefHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fEYKT0JYfDF8U1R8NTUwNzE2MDBeSEVQQVRJVElTIEMgQU5USUJPRFleOTlRREleMTM5NTUtMF5IQ1YgQWIgU2VyUGwgUWwgRUlBXkxOfHxOT04tUkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxOfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxeXl5eXl5GSV5DTElBfHxeXl5eXl5eXl5eXl5OUEleQVQKT0JYfDJ8Tk18NTUwNzE3MDVeU0lHTkFMIFRPIENVVC1PRkZeOTlRREleNDgxNTktOF5IQ1YgQWIgcy9jbyBTZXJQbCBFSUFeTE58fDAuMDJ8fDwxLjAwfE58fHxGfHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHx8fF5eXl5eXkZJXkNMSUF8fF5eXl5eXl5eXl5eXk5QSV5BVApPUkN8UkV8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfHxDTXx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHx8fHxBdGxhbnRhIEJVQVQgVGVzdF5eXl5eXl5eXjcxODYxMjEKT0JSfDN8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfDQ5OF5IQlNBRyBXL1JGTCBDT05GXjk5UURJXnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHx8fHx8MTM2NjQ3MjU1N15KYXZpbGxvXkphc29uXlMuXl5eXl5eXl5eTlBJfHx8fHx8MjAxNjExMTgyMDUxNTUuMTA4KzAwMDB8fHxGCk9CWHwxfFNUfDU1MDE5MzAwXkhFUEFUSVRJUyBCIFNVUkZBQ0UgQU5USUdFTl45OVFESV41MTk2LTFeSEJWIHN1cmZhY2UgQWcgU2VyUGwgUWwgRUlBXkxOfHxOT04tUkVBQ1RJVkV8fE5PTi1SRUFDVElWRXxOfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxeXl5eXl5GSV5DTElBfHxeXl5eXl5eXl5eXl5OUEleQVQKT0JYfDJ8U1R8NTUwMTk2MDBeQ09ORklSTUFUSU9OXjk5UURJXjc5MDUtM15IQlYgc3VyZmFjZSBBZyBTZXJQbCBRbCBOdF5MTnx8RE5SfHx8Tnx8fFh8fHwyMDE2MTExNzA4NDgwMC4wMDAtMDUwMHx8fHx8MjAxNjExMTgyMDUxNTUuMTA4KzAwMDB8fHx8Xl5eXl5eRkleQ0xJQXx8Xl5eXl5eXl5eXl5eTlBJXkFUCk9SQ3xSRXxMUklURVNUXlFVRVNUX1NLQl83MTg2MTIxfENTMTgyMDUxNTUxNF5RVUVTVF9TS0J8fENNfHx8fHx8fDEzNjY0NzI1NTdeSmF2aWxsb15KYXNvbl5TLl5eXl5eXl5eXk5QSXx8fHx8fHx8fEF0bGFudGEgQlVBVCBUZXN0Xl5eXl5eXl5eNzE4NjEyMQpPQlJ8NHxMUklURVNUXlFVRVNUX1NLQl83MTg2MTIxfENTMTgyMDUxNTUxNF5RVUVTVF9TS0J8MzY0MF5IU1YgMiBJR0csIFRZUEUgU1BFQ0lGSUMgQUIgSEVSUEVTRUxFQ1ReOTlRRElefHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fEYKT0JYfDF8VFh8NTIwOS0yXkhTVjIgSWdHIFNlciBFSUEtYUNuY15MTl43MDAyMDYwMF5IU1YgMiBJR0cgVFlQRSBTUEVDSUZJQyBBQl45OVFESXx8PjUuMDB8fHxIfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxBVF5eXl5eXkZJfHxeXl5eXl5eXl5eXl5OUEkKTlRFfDF8fCBWYWx1ZSBJbnRlcnByZXRhdGlvbgpOVEV8Mnx8IC0tLS0tIC0tLS0tLS0tLS0tLS0tCk5URXwzfHwgPDAuOTAgTmVnYXRpdmUKTlRFfDR8fCAwLjkwLTEuMTAgRXF1aXZvY2FsCk5URXw1fHwgPjEuMTAgUG9zaXRpdmUKTlRFfDZ8fApOVEV8N3x8VGhpcyBhc3NheSB1dGlsaXplcyByZWNvbWJpbmFudCB0eXBlLXNwZWNpZmljIGFudGlnZW5zCk5URXw4fHx0byBkaWZmZXJlbnRpYXRlIEhTVi0xIGZyb20gSFNWLTIgaW5mZWN0aW9ucy4gQQpOVEV8OXx8cG9zaXRpdmUgcmVzdWx0IGNhbm5vdCBkaXN0aW5ndWlzaCBiZXR3ZWVuIHJlY2VudCBhbmQKTlRFfDEwfHxwYXN0IGluZmVjdGlvbi4gSWYgcmVjZW50IEhTViBpbmZlY3Rpb24gaXMgc3VzcGVjdGVkCk5URXwxMXx8YnV0IHRoZSByZXN1bHRzIGFyZSBuZWdhdGl2ZSBvciBlcXVpdm9jYWwsIHRoZSBhc3NheQpOVEV8MTJ8fHNob3VsZCBiZSByZXBlYXRlZCBpbiA0LTYgd2Vla3MuIFRoZSBwZXJmb3JtYW5jZQpOVEV8MTN8fGNoYXJhY3RlcmlzdGljcyBvZiB0aGUgYXNzYXkgaGF2ZSBub3QgYmVlbiBlc3RhYmxpc2hlZApOVEV8MTR8fGZvciBwZWRpYXRyaWMgcG9wdWxhdGlvbnMsIGltbXVub2NvbXByb21pc2VkIHBhdGllbnRzLApOVEV8MTV8fG9yIG5lb25hdGFsIHNjcmVlbmluZy4KTlRFfDE2fHwKT1JDfFJFfExSSVRFU1ReUVVFU1RfU0tCXzcxODYxMjF8Q1MxODIwNTE1NTE0XlFVRVNUX1NLQnx8Q018fHx8fHx8MTM2NjQ3MjU1N15KYXZpbGxvXkphc29uXlMuXl5eXl5eXl5eTlBJfHx8fHx8fHx8QXRsYW50YSBCVUFUIFRlc3ReXl5eXl5eXl43MTg2MTIxCk9CUnw1fExSSVRFU1ReUVVFU1RfU0tCXzcxODYxMjF8Q1MxODIwNTE1NTE0XlFVRVNUX1NLQnw3OTleUlBSIChNT05JVE9SKSBXL1JFRkxeOTlRRElefHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fEYKT0JYfDF8U1R8NDAwMTAxMDBeUlBSIChNT05JVE9SKSBXL1JFRkwgVElURVJeOTlRREleMjA1MDctMF5SUFIgU2VyIFFsXkxOfHxSRUFDVElWRXx8Tk9OLVJFQUNUSVZFfEF8fHxGfHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHx8fF5eXl5eXkZJXkNMSUF8fF5eXl5eXl5eXl5eXk5QSV5BVApOVEV8MXxMfFRoZSBSUFIgaXMgYSBub24tdHJlcG9uZW1hbC1zcGVjaWZpYyB0ZXN0OyB0aGVyZWZvcmUsCk5URXwyfEx8YSB0cmVwb25lbWFsLXNwZWNpZmljIGNvbmZpcm1hdG9yeSB0ZXN0IHNob3VsZCBiZQpOVEV8M3xMfHBlcmZvcm1lZCB1bmxlc3MgcHJpb3Igc3lwaGlsaXMgaW5mZWN0aW9uIGhhcyBiZWVuCk5URXw0fEx8ZG9jdW1lbnRlZCBmb3IgdGhpcyBwYXRpZW50LgpPUkN8UkV8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfHxDTXx8fHx8fHwxMzY2NDcyNTU3XkphdmlsbG9eSmFzb25eUy5eXl5eXl5eXl5OUEl8fHx8fHx8fHxBdGxhbnRhIEJVQVQgVGVzdF5eXl5eXl5eXjcxODYxMjEKT0JSfDZ8TFJJVEVTVF5RVUVTVF9TS0JfNzE4NjEyMXxDUzE4MjA1MTU1MTReUVVFU1RfU0tCfDExMzYyXk5FSVNTRVJJQSBHT05PUlJIT0VBRSBSTkEsIFRNQV45OVFESV58fHwyMDE2MTExNzA4NDgwMC4wMDAtMDUwMHx8fHx8fHx8fDEzNjY0NzI1NTdeSmF2aWxsb15KYXNvbl5TLl5eXl5eXl5eXk5QSXx8fHx8fDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHx8RgpPQlh8MXxTVHw0MzMwNS0yXk4gZ29ub3JyaG9lYSByUk5BIFhYWCBRbCBQQ1JeTE5eNzAwNDM5MDBeTkVJU1NFUklBIEdPTk9SUkhPRUFFIFJOQSwgVE1BXjk5UURJfHxOT1QgREVURUNURUR8fE5PVCBERVRFQ1RFRHxOfHx8Rnx8fDIwMTYxMTE3MDg0ODAwLjAwMC0wNTAwfHx8fHwyMDE2MTExODIwNTE1NS4xMDgrMDAwMHx8fHxBVF5eXl5eXkZJfHxeXl5eXl5eXl5eXl5OUEkKT0JYfDJ8VFh8MTAwMDE1OTdeQ09NTUVOVF45OVFESV4xMDAwMTU5N15DT01NRU5UXjk5UURJfHx8fHx8fHxGfHx8MjAxNjExMTcwODQ4MDAuMDAwLTA1MDB8fHx8fDIwMTYxMTE4MjA1MTU1LjEwOCswMDAwfHx8fEFUXl5eXl5eRkl8fF5eXl5eXl5eXl5eXk5QSQpOVEV8MXx8VGhpcyB0ZXN0IHdhcyBwZXJmb3JtZWQgdXNpbmcgdGhlIEFQVElNQSBDT01CTzIgQXNzYXkKTlRFfDJ8fChHZW4tUHJvYmUgSW5jLikuCk5URXwzfHwKTlRFfDR8fFRoZSBhbmFseXRpY2FsIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiB0aGlzCk5URXw1fHxhc3NheSwgd2hlbiB1c2VkIHRvIHRlc3QgU3VyZVBhdGggc3BlY2ltZW5zIGhhdmUKTlRFfDZ8fGJlZW4gZGV0ZXJtaW5lZCBieSBRdWVzdCBEaWFnbm9zdGljcy4KTlRFfDd8fApOVEV8OHxPfERhdGFiYXNlIFRlc3RpbmcgUmVzdWx0&lt;/message&gt;
               &lt;/HL7Message&gt;
            &lt;/results&gt;
         &lt;/ns2:Results&gt;
      &lt;/ns2:getResultsResponse&gt;
   &lt;/S:Body&gt;
&lt;/S:Envelope&gt;;


var count = globalChannelMap.get(&quot;isMoreCount&quot;);
if (count &lt;= 1) {
	responseMap.put(&quot;getResultsResponse&quot;, resultsResponse1);
	globalChannelMap.put(&quot;isMoreCount&quot;, 2);
} else if (count == 2) {
	responseMap.put(&quot;getResultsResponse&quot;, resultsResponse2);
	globalChannelMap.put(&quot;isMoreCount&quot;, 3);
} else if (count &gt;= 3) {
	responseMap.put(&quot;getResultsResponse&quot;, emptyResultsResponse);
	globalChannelMap.put(&quot;isMoreCount&quot;, 4);
}</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64"></inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>XML</inboundDataType>
          <outboundDataType>XML</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>false</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
            <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
              <stripNamespaces>false</stripNamespaces>
            </serializationProperties>
            <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
              <splitType>Element_Name</splitType>
              <elementName></elementName>
              <level>1</level>
              <query></query>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Destination 1</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data

return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data


globalChannelMap.put(&quot;isMoreCount&quot;, 1);

return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>b8496491-c20f-4799-9732-87d95032edb3</id>
      <nextMetaDataId>2</nextMetaDataId>
      <name>TestListener</name>
      <description></description>
      <enabled>false</enabled>
      <lastModified>
        <time>1493498151737</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>3</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="3.4.2">
          <pluginProperties>
            <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="3.4.2">
  <authType>NONE</authType>
            </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
          </pluginProperties>
          <listenerConnectorProperties version="3.4.2">
            <host>0.0.0.0</host>
            <port>8011</port>
          </listenerConnectorProperties>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>d1</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
          <xmlBody>false</xmlBody>
          <parseMultipart>true</parseMultipart>
          <includeMetadata>false</includeMetadata>
          <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
          <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
          <responseContentType>text/plain</responseContentType>
          <responseDataTypeBinary>false</responseDataTypeBinary>
          <responseStatusCode></responseStatusCode>
          <responseHeaders class="linked-hash-map"/>
          <charset>UTF-8</charset>
          <contextPath>addPatient</contextPath>
          <timeout>0</timeout>
          <staticResources/>
        </properties>
        <transformer version="3.4.2">
          <steps/>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>HTTP Listener</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Response</name>
          <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <script>return &quot;ArbitraryResult&quot;;</script>
          </properties>
          <transformer version="3.4.2">
            <steps/>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>JSON</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>JavaScript Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
    <channel version="3.4.2">
      <id>20fb74a5-8bfe-4b1c-a2b7-2dbaa17d7fce</id>
      <nextMetaDataId>4</nextMetaDataId>
      <name>Unused Submit Order</name>
      <description>Submits a new lab order, including both Basic Lab Orders and Patient Service Center (PSC) Hold Orders.&#xd;
The Order object contains the inbound lab order message (HL7v2.5.1 OML_O21).&#xd;
&#xd;
This channel expects JSON feed with all data filled to build the outbound OML_O21 message.&#xd;
&#xd;
Last updated: March 12, 2017</description>
      <enabled>false</enabled>
      <lastModified>
        <time>1495396848765</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <revision>3</revision>
      <sourceConnector version="3.4.2">
        <metaDataId>0</metaDataId>
        <name>sourceConnector</name>
        <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
          <pluginProperties/>
          <sourceConnectorProperties version="3.4.2">
            <responseVariable>Outcome</responseVariable>
            <respondAfterProcessing>true</respondAfterProcessing>
            <processBatch>false</processBatch>
            <firstResponse>false</firstResponse>
            <processingThreads>1</processingThreads>
            <resourceIds class="linked-hash-map">
              <entry>
                <string>Default Resource</string>
                <string>[Default Resource]</string>
              </entry>
            </resourceIds>
            <queueBufferSize>1000</queueBufferSize>
          </sourceConnectorProperties>
        </properties>
        <transformer version="3.4.2">
          <steps>
            <step>
              <sequenceNumber>0</sequenceNumber>
              <name>Validate JSON feed</name>
              <script>var error = [];				// A list of possible incoming JSON feed validation errors
var hasPatient = false;			// PID
var hasDiagnosticReport = false;	// ORC
var hasDiagnosticOrder = false;	// OBR
var hasCoverage = false;			// IN1
var hasPerson = false;			// GT1
var hasPractitioner = false;		// OBR.16
var conditionCount = 0;

// Feed UUID ~~ RKW The placement of static text in an ID value is pointless, and usually requires stripping out later - such as here. How about not putting it there in the first place?
var uuid = msg.Bundle.id.value.toString().toLowerCase().replace(&quot;oml-o21&quot;,&quot;&quot;);

// TODO: Define min length for UUID
if (uuid)
	channelMap.put(&quot;FeedUUID&quot;, uuid);
else 
	error.push(&quot;Feed Bundle id/@value should contain UUID in format OML-O21-xxxxxxxx-...&quot;);	


// The Data Exchange verifies that fields are populated depending on the coverage type
var billType = [&apos;T&apos;,&apos;P&apos;,&apos;C&apos;];
var coverageType;
msg.Bundle.entry.forEach(function(obj){
	if (obj.resource.Coverage) {
		coverageType = obj.resource.Coverage.type.code.value.toString();
		if (billType.indexOf(coverageType) &lt; 0) error.push(&quot;resource.Coverage.type.code.value for IN1.47[Coverage Type] is required and must be T, P or C&quot;);
	}
});

// Store IN1.47 [Coverage Type] value for future use
channelMap.put(&quot;CoverageType&quot;, coverageType);


// Validate incoming JSON field for required resources (aka segments)
msg.Bundle.entry.forEach(function(objRes){

	// Need to set the hasSomeResource only once
	if (objRes.resource.Patient != null &amp;&amp; objRes.resource.Patient != undefined) hasPatient = true;
	if (objRes.resource.DiagnosticReport != null &amp;&amp; objRes.resource.DiagnosticReport != undefined) hasDiagnosticReport = true;
	if (objRes.resource.DiagnosticOrder != null &amp;&amp; objRes.resource.DiagnosticOrder != undefined) hasDiagnosticOrder = true;
	if (objRes.resource.Coverage != null &amp;&amp; objRes.resource.Coverage != undefined) hasCoverage = true;
	if (objRes.resource.Person != null &amp;&amp; objRes.resource.Person != undefined) hasPerson = true;
	if (objRes.resource.Practitioner != null &amp;&amp; objRes.resource.Practitioner != undefined) hasPractitioner = true;
	if (objRes.resource.Condition != null &amp;&amp; objRes.resource.Condition != undefined) {
		conditionCount ++;
	}
});


// Validate for required segments
if (!hasPatient) error.push(&quot;resource.Patient for PID segment is Required&quot;);
if (!hasCoverage) error.push(&quot;resource.Coverage for IN1 segment is Required&quot;);
if (!hasDiagnosticReport) error.push(&quot;resource.DiagnosticReport for ORC segment is Required&quot;); // ~~ RKW - Expecting a diagnostic report - a result observation artifact - in an order? Why? 
if (!hasDiagnosticOrder) error.push(&quot;resource.DiagnosticOrder for OBR segment is Required&quot;);
if (!hasPractitioner) error.push(&quot;resource.Practitioner for OBR.16 [Ordering Provider] field is Required&quot;);
if (coverageType == &quot;T&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Third-Party Bill type&quot;);

// Updated to comply with CS12 Billing certification criteria
if (coverageType == &quot;P&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Patient Bill type&quot;);
if (conditionCount &gt; 12) error.push(&quot;Maximum of 12 resource.Condition with unique ICD-10 codes are permitted. You sent &quot; + conditionCount);  // ~~ RKW - Conditions? Not going to happen, and not in requirements

// Verify for errors 
if (error.length &gt; 0) {
	
	// OML_O21 message will not be created ~~ RKW. There is this thing called a filter. Manipulation of the destinationSet is hacking, as it makes the channel more opaque.
	destinationSet.removeAll();

	var messages = {request:&quot;&quot;, resp:&quot;&quot;};
	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	
	// To be sent to the upstream channel
	responseMap.put(&quot;Outcome&quot;, outcome);
	//logger.debug(&quot;SubmitOrder (Source): &quot; + outcome);
}</script>
              <type>JavaScript</type>
              <data>
                <entry>
                  <string>Script</string>
                  <string>var error = [];				// A list of possible incoming JSON feed validation errors
var hasPatient = false;			// PID
var hasDiagnosticReport = false;	// ORC
var hasDiagnosticOrder = false;	// OBR
var hasCoverage = false;			// IN1
var hasPerson = false;			// GT1
var hasPractitioner = false;		// OBR.16
var conditionCount = 0;

// Feed UUID ~~ RKW The placement of static text in an ID value is pointless, and usually requires stripping out later - such as here. How about not putting it there in the first place?
var uuid = msg.Bundle.id.value.toString().toLowerCase().replace(&quot;oml-o21&quot;,&quot;&quot;);

// TODO: Define min length for UUID
if (uuid)
	channelMap.put(&quot;FeedUUID&quot;, uuid);
else 
	error.push(&quot;Feed Bundle id/@value should contain UUID in format OML-O21-xxxxxxxx-...&quot;);	


// The Data Exchange verifies that fields are populated depending on the coverage type
var billType = [&apos;T&apos;,&apos;P&apos;,&apos;C&apos;];
var coverageType;
msg.Bundle.entry.forEach(function(obj){
	if (obj.resource.Coverage) {
		coverageType = obj.resource.Coverage.type.code.value.toString();
		if (billType.indexOf(coverageType) &lt; 0) error.push(&quot;resource.Coverage.type.code.value for IN1.47[Coverage Type] is required and must be T, P or C&quot;);
	}
});

// Store IN1.47 [Coverage Type] value for future use
channelMap.put(&quot;CoverageType&quot;, coverageType);


// Validate incoming JSON field for required resources (aka segments)
msg.Bundle.entry.forEach(function(objRes){

	// Need to set the hasSomeResource only once
	if (objRes.resource.Patient != null &amp;&amp; objRes.resource.Patient != undefined) hasPatient = true;
	if (objRes.resource.DiagnosticReport != null &amp;&amp; objRes.resource.DiagnosticReport != undefined) hasDiagnosticReport = true;
	if (objRes.resource.DiagnosticOrder != null &amp;&amp; objRes.resource.DiagnosticOrder != undefined) hasDiagnosticOrder = true;
	if (objRes.resource.Coverage != null &amp;&amp; objRes.resource.Coverage != undefined) hasCoverage = true;
	if (objRes.resource.Person != null &amp;&amp; objRes.resource.Person != undefined) hasPerson = true;
	if (objRes.resource.Practitioner != null &amp;&amp; objRes.resource.Practitioner != undefined) hasPractitioner = true;
	if (objRes.resource.Condition != null &amp;&amp; objRes.resource.Condition != undefined) {
		conditionCount ++;
	}
});


// Validate for required segments
if (!hasPatient) error.push(&quot;resource.Patient for PID segment is Required&quot;);
if (!hasCoverage) error.push(&quot;resource.Coverage for IN1 segment is Required&quot;);
if (!hasDiagnosticReport) error.push(&quot;resource.DiagnosticReport for ORC segment is Required&quot;); // ~~ RKW - Expecting a diagnostic report - a result observation artifact - in an order? Why? 
if (!hasDiagnosticOrder) error.push(&quot;resource.DiagnosticOrder for OBR segment is Required&quot;);
if (!hasPractitioner) error.push(&quot;resource.Practitioner for OBR.16 [Ordering Provider] field is Required&quot;);
if (coverageType == &quot;T&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Third-Party Bill type&quot;);

// Updated to comply with CS12 Billing certification criteria
if (coverageType == &quot;P&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Patient Bill type&quot;);
if (conditionCount &gt; 12) error.push(&quot;Maximum of 12 resource.Condition with unique ICD-10 codes are permitted. You sent &quot; + conditionCount);  // ~~ RKW - Conditions? Not going to happen, and not in requirements

// Verify for errors 
if (error.length &gt; 0) {
	
	// OML_O21 message will not be created ~~ RKW. There is this thing called a filter. Manipulation of the destinationSet is hacking, as it makes the channel more opaque.
	destinationSet.removeAll();

	var messages = {request:&quot;&quot;, resp:&quot;&quot;};
	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	
	// To be sent to the upstream channel
	responseMap.put(&quot;Outcome&quot;, outcome);
	//logger.debug(&quot;SubmitOrder (Source): &quot; + outcome);
}</string>
                </entry>
              </data>
            </step>
          </steps>
          <inboundTemplate encoding="base64">eyJCdW5kbGUiOiB7CiAgImVudHJ5IjogWwogICAgeyJyZXNvdXJjZSI6IHsiUGF0aWVudCI6IHsK
ICAgICAgImlkZW50aWZpZXIiOiBbCiAgICAgICAgewogICAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAic2Vjb25kYXJ5In0sCiAgICAgICAgICAidHlwZSI6IHsiY29kaW5nIjogeyJjb2RlIjogeyJ2
YWx1ZSI6ICJQVCJ9fX0sCiAgICAgICAgICAidmFsdWUiOiB7InZhbHVlIjogMjA1MjY2MTl9CiAg
ICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJvZmZpY2lhbCJ9
LAogICAgICAgICAgImFzc2lnbmVyIjogeyJkaXNwbGF5IjogeyJ2YWx1ZSI6ICJNUk4ifX0sCiAg
ICAgICAgICAidHlwZSI6IHsiY29kaW5nIjogeyJjb2RlIjogeyJ2YWx1ZSI6ICJQVCJ9fX0sCiAg
ICAgICAgICAidmFsdWUiOiB7InZhbHVlIjogMjA1MjY2MTl9CiAgICAgICAgfQogICAgICBdLAog
ICAgICAiYWRkcmVzcyI6IHsKICAgICAgICAiY291bnRyeSI6IHsidmFsdWUiOiAiVVNBIn0sCiAg
ICAgICAgImNpdHkiOiB7InZhbHVlIjogIk1hc29uIn0sCiAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAiaG9tZSJ9LAogICAgICAgICJsaW5lIjogeyJ2YWx1ZSI6ICI0NjkwIFBhcmt3YXkgRHIuIn0s
CiAgICAgICAgInBvc3RhbENvZGUiOiB7InZhbHVlIjogNDUwNDB9LAogICAgICAgICJzdGF0ZSI6
IHsidmFsdWUiOiAiT0gifQogICAgICB9LAogICAgICAiZ2VuZGVyIjogeyJ2YWx1ZSI6ICJtYWxl
In0sCiAgICAgICJuYW1lIjogewogICAgICAgICJnaXZlbiI6IFsKICAgICAgICAgIHsidmFsdWUi
OiAiUGF0aWVudF9GaXJzdG5hbWUifSwKICAgICAgICAgIHsidmFsdWUiOiAiTWlkZGxlIn0KICAg
ICAgICBdLAogICAgICAgICJ1c2UiOiB7InZhbHVlIjogIm9mZmljaWFsIn0sCiAgICAgICAgImZh
bWlseSI6IHsidmFsdWUiOiAiUGF0aWVudF9MYXN0bmFtZSJ9CiAgICAgIH0sCiAgICAgICJ0ZWxl
Y29tIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0sCiAgICAgICAgInVz
ZSI6IHsidmFsdWUiOiAiaG9tZSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFsdWUiOiAiMV4zMzNe
NDQ0NTU1NSJ9CiAgICAgIH0sCiAgICAgICJpZCI6IHsidmFsdWUiOiAiUElELXBhdGllbnQtaWRl
bnRpZmljYXRpb24ifSwKICAgICAgInRleHQiOiB7CiAgICAgICAgImRpdiI6IHsKICAgICAgICAg
ICJwIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIkZpcnN0IFBhdGllbnQgcmVsYXRlZCBpbnRlcm5hbCBjb21tZW50
IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiY2xhc3Mi
OiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiU2Vjb25kIFBhdGllbnQgcmVsYXRlZCBp
bnRlcm5hbCBjb21tZW50IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAg
ICAgICAgICAiY2xhc3MiOiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiVGhpcmQgUGF0
aWVudCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAg
ICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6ICJJIiwKICAgICAgICAgICAgICAiY29udGVu
dCI6ICJGb3J0aCBQYXRpZW50IHJlbGF0ZWQgaW50ZXJuYWwgY29tbWVudCBsaW5lIgogICAgICAg
ICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIlIiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIkZpcnN0IFBhdGllbnQgcmVsYXRlZCByZXBvcnQgY29tbWVudCBs
aW5lIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjog
IlIiLAogICAgICAgICAgICAgICJjb250ZW50IjogIlNlY29uZCBQYXRpZW50IHJlbGF0ZWQgcmVw
b3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAg
ICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJUaGlyZCBQYXRpZW50
IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAg
ewogICAgICAgICAgICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJG
b3J0aCBQYXRpZW50IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfQog
ICAgICAgICAgXSwKICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3ho
dG1sIgogICAgICAgIH0sCiAgICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAiZ2VuZXJhdGVkIn0K
ICAgICAgfSwKICAgICAgImJpcnRoRGF0ZSI6IHsidmFsdWUiOiAiMTk2OC0wMS0wMSJ9CiAgICB9
fX0sCiAgICB7InJlc291cmNlIjogeyJEaWFnbm9zdGljUmVwb3J0IjogewogICAgICAicmVzdWx0
IjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIk9ic2VydmF0aW9uIn19LAogICAgICAiaWRlbnRp
ZmllciI6IHsKICAgICAgICAic3lzdGVtIjogeyJ2YWx1ZSI6ICJRVUVTVF9TS0JfNzE4NjEyMSJ9
LAogICAgICAgICJ0eXBlIjogeyJpZCI6ICI5OVFESSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFs
dWUiOiA5ODc2NTQzMjF9CiAgICAgIH0sCiAgICAgICJyZXF1ZXN0IjogeyJyZWZlcmVuY2UiOiB7
InZhbHVlIjogIkRpYWdub3N0aWNPcmRlci9vYnItb2JzZXJ2YXRpb24tcmVxdWVzdCJ9fSwKICAg
ICAgImNvbnRhaW5lZCI6IHsiUHJhY3RpdGlvbmVyIjogewogICAgICAgICJpZGVudGlmaWVyIjog
eyJ2YWx1ZSI6IHsidmFsdWUiOiAiTlBQX0lEIn19LAogICAgICAgICJuYW1lIjogeyJmYW1pbHki
OiB7InZhbHVlIjogIk5QUF9OYW1lIn19LAogICAgICAgICJpZCI6IHsidmFsdWUiOiAiT1JDMTEt
dmVyaWZpZWQtYnkifQogICAgICB9fSwKICAgICAgImNvZGUiOiB7ImlkIjogMTAxMjR9LAogICAg
ICAicGVyZm9ybWVyIjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIlByYWN0aXRpb25lci9PUkMx
MS12ZXJpZmllZC1ieSJ9fSwKICAgICAgImVmZmVjdGl2ZURhdGVUaW1lIjogeyJleHRlbnNpb24i
OiB7InVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YzL051bGxGbGF2b3IvTkkifX0sCiAgICAg
ICJzdWJqZWN0IjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIlBhdGllbnQifX0sCiAgICAgICJp
ZCI6IHsidmFsdWUiOiAiT1JDLWNvbW1vbi1vcmRlciJ9LAogICAgICAiaXNzdWVkIjogeyJleHRl
bnNpb24iOiB7InVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YzL051bGxGbGF2b3IvTkkifX0s
CiAgICAgICJzdGF0dXMiOiB7InZhbHVlIjogImZpbmFsIn0KICAgIH19fSwKICAgIHsicmVzb3Vy
Y2UiOiB7IkRpYWdub3N0aWNPcmRlciI6IHsKICAgICAgIml0ZW0iOiB7CiAgICAgICAgImNvZGUi
OiB7ImNvZGluZyI6IHsKICAgICAgICAgICJjb2RlIjogeyJ2YWx1ZSI6IDg0NzJ9LAogICAgICAg
ICAgImRpc3BsYXkiOiB7InZhbHVlIjogIkhFUEFUSVRJUyBDIFZJUlVTIEFCIn0KICAgICAgICB9
fSwKICAgICAgICAic3BlY2ltZW4iOiB7ImRpc3BsYXkiOiB7InZhbHVlIjogIkcifX0KICAgICAg
fSwKICAgICAgInN1YmplY3QiOiB7ImlkIjogIlBhdGllbnQifSwKICAgICAgImlkIjogeyJ2YWx1
ZSI6ICJPQlItb2JzZXJ2YXRpb24tcmVxdWVzdCJ9LAogICAgICAidGV4dCI6IHsKICAgICAgICAi
ZGl2IjogewogICAgICAgICAgInAiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiY2xh
c3MiOiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiRmlyc3QgT2JzZXJ2YXRpb24gUmVx
dWVzdCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAg
ICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6ICJJIiwKICAgICAgICAgICAgICAiY29udGVu
dCI6ICJTZWNvbmQgT2JzZXJ2YXRpb24gUmVxdWVzdCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQg
bGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6
ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJGaXJzdCBPYnNlcnZhdGlvbiBSZXF1ZXN0
IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAg
ewogICAgICAgICAgICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJT
ZWNvbmQgT2JzZXJ2YXRpb24gUmVxdWVzdCByZWxhdGVkIHJlcG9ydCBjb21tZW50IGxpbmUiCiAg
ICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAieG1sbnMiOiAiaHR0cDovL3d3dy53
My5vcmcvMTk5OS94aHRtbCIKICAgICAgICB9LAogICAgICAgICJzdGF0dXMiOiB7InZhbHVlIjog
ImdlbmVyYXRlZCJ9CiAgICAgIH0sCiAgICAgICJldmVudCI6IHsKICAgICAgICAiZGF0ZVRpbWUi
OiB7InZhbHVlIjogIjIwMTYtMTEtMThUMjA6NTE6NTUrMDA6MDAifSwKICAgICAgICAiYWN0b3Ii
OiB7InJlZmVyZW5jZSI6IHsidmFsdWUiOiAiUHJhY3RpdGlvbmVyL29yZGVyaW5nLXByb3ZpZGVy
In19LAogICAgICAgICJzdGF0dXMiOiB7InZhbHVlIjogImNvbXBsZXRlZCJ9CiAgICAgIH0KICAg
IH19fSwKICAgIHsicmVzb3VyY2UiOiB7Ik9ic2VydmF0aW9uIjogewogICAgICAiY29kZSI6IHsi
Y29kaW5nIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogImh0dHA6Ly9zbm9tZWQuaW5m
by9zY3QifSwKICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAzNjU5ODEwMDd9LAogICAgICAgICJk
aXNwbGF5IjogeyJ2YWx1ZSI6ICJGaW5kaW5nIG9mIHRvYmFjY28gc21va2luZyBiZWhhdmlvciJ9
CiAgICAgIH19LAogICAgICAidmFsdWVTdHJpbmciOiB7InZhbHVlIjogIlNtb2tlIHR3byBjaWdh
cnMgZGFpbHkifSwKICAgICAgImlkIjogeyJ2YWx1ZSI6ICJPQlgtb2JzZXJ2YXRpb24ifSwKICAg
ICAgInRleHQiOiB7CiAgICAgICAgImRpdiI6IHsKICAgICAgICAgICJwIjogWwogICAgICAgICAg
ICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAgICAgICAgICJjb250ZW50Ijog
IkZpcnN0IG9ic2VydmF0aW9uIHJlbGF0ZWQgaW50ZXJuYWwgY29tbWVudCBsaW5lIgogICAgICAg
ICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIlNlY29uZCBvYnNlcnZhdGlvbiByZWxhdGVkIGludGVybmFsIGNv
bW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICJj
bGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJGaXJzdCBvYnNlcnZhdGlvbiBy
ZWxhdGVkIHJlcG9ydCBjb21tZW50IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsK
ICAgICAgICAgICAgICAiY2xhc3MiOiAiUiIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiU2Vj
b25kIG9ic2VydmF0aW9uIHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAg
fQogICAgICAgICAgXSwKICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8xOTk5
L3hodG1sIgogICAgICAgIH0sCiAgICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAiZ2VuZXJhdGVk
In0KICAgICAgfSwKICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAicHJlbGltaW5hcnkifQogICAg
fX19LAogICAgeyJyZXNvdXJjZSI6IHsiQ29uZGl0aW9uIjogewogICAgICAiY29kZSI6IHsiY29k
aW5nIjogWwogICAgICAgIHsKICAgICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogImh0dHA6Ly9o
bDcub3JnL2ZoaXIvVmFsdWVTZXQvaWNkLTEwIn0sCiAgICAgICAgICAiY29kZSI6IHsidmFsdWUi
OiAiSTI1NzAwIn0sCiAgICAgICAgICAiZGlzcGxheSI6IHsidmFsdWUiOiAiQXRoZXJvc2NsZXJv
c2lzIG9mIENBQkcifQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgInN5c3RlbSI6IHsi
dmFsdWUiOiAiaHR0cDovL2hsNy5vcmcvZmhpci9zaWQvaWNkLTkifSwKICAgICAgICAgICJjb2Rl
IjogeyJ2YWx1ZSI6IDQxNC4zfQogICAgICAgIH0KICAgICAgXX0sCiAgICAgICJ2ZXJpZmljYXRp
b25TdGF0dXMiOiB7InZhbHVlIjogImNvbmZpcm1lZCJ9LAogICAgICAicGF0aWVudCI6IHsicmVm
ZXJlbmNlIjogeyJ2YWx1ZSI6ICJQYXRpZW50In19LAogICAgICAiaWQiOiB7InZhbHVlIjogIkRH
MS1kaWFnbm9zaXMifQogICAgfX19LAogICAgeyJyZXNvdXJjZSI6IHsiQ292ZXJhZ2UiOiB7CiAg
ICAgICJpZGVudGlmaWVyIjogeyJ2YWx1ZSI6IHsidmFsdWUiOiAxMjM0NTY3ODl9fSwKICAgICAg
ImNvbnRhaW5lZCI6IFsKICAgICAgICB7Ik9yZ2FuaXphdGlvbiI6IHsKICAgICAgICAgICJpZGVu
dGlmaWVyIjogeyJ2YWx1ZSI6IHsidmFsdWUiOiAiQVVIU0MifX0sCiAgICAgICAgICAiYWRkcmVz
cyI6IHsKICAgICAgICAgICAgImNvdW50cnkiOiB7InZhbHVlIjogIlVTQSJ9LAogICAgICAgICAg
ICAiY2l0eSI6IHsidmFsdWUiOiAiTWFzb24ifSwKICAgICAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAid29yayJ9LAogICAgICAgICAgICAibGluZSI6IHsidmFsdWUiOiAiNDY5MCBQYXJrd2F5IERy
LiJ9LAogICAgICAgICAgICAicG9zdGFsQ29kZSI6IHsidmFsdWUiOiA0NTA0MH0sCiAgICAgICAg
ICAgICJzdGF0ZSI6IHsidmFsdWUiOiAiT0gifQogICAgICAgICAgfSwKICAgICAgICAgICJuYW1l
IjogeyJ2YWx1ZSI6ICJBRVROQSJ9LAogICAgICAgICAgInRlbGVjb20iOiB7CiAgICAgICAgICAg
ICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0sCiAgICAgICAgICAgICJ1c2UiOiB7InZhbHVl
IjogIndvcmsifSwKICAgICAgICAgICAgInZhbHVlIjogeyJ2YWx1ZSI6ICIxXjMzM140NDQ1NTU1
In0KICAgICAgICAgIH0sCiAgICAgICAgICAiaWQiOiB7InZhbHVlIjogImluc3VyYW5jZS1jb21w
YW55In0KICAgICAgICB9fSwKICAgICAgICB7IlBlcnNvbiI6IHsKICAgICAgICAgICJhZGRyZXNz
IjogewogICAgICAgICAgICAiY291bnRyeSI6IHsidmFsdWUiOiAiVVNBIn0sCiAgICAgICAgICAg
ICJjaXR5IjogeyJ2YWx1ZSI6ICJNYXNvbiJ9LAogICAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6
ICJob21lIn0sCiAgICAgICAgICAgICJsaW5lIjogeyJ2YWx1ZSI6ICIxMjMgTWFpbiBSb2FkIn0s
CiAgICAgICAgICAgICJwb3N0YWxDb2RlIjogeyJ2YWx1ZSI6IDQ1MDc3fSwKICAgICAgICAgICAg
InN0YXRlIjogeyJ2YWx1ZSI6ICJPSCJ9CiAgICAgICAgICB9LAogICAgICAgICAgIm5hbWUiOiB7
CiAgICAgICAgICAgICJnaXZlbiI6IFsKICAgICAgICAgICAgICB7InZhbHVlIjogIkluc3VyZWRf
Rmlyc3RuYW1lIn0sCiAgICAgICAgICAgICAgeyJ2YWx1ZSI6ICJNaWRkbGUifQogICAgICAgICAg
ICBdLAogICAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJvZmZpY2lhbCJ9LAogICAgICAgICAg
ICAiZmFtaWx5IjogeyJ2YWx1ZSI6ICJJbnN1cmVkX0xhc3RuYW1lIn0KICAgICAgICAgIH0sCiAg
ICAgICAgICAiaWQiOiB7InZhbHVlIjogImluc3VyZWQtcGVyc29uIn0KICAgICAgICB9fQogICAg
ICBdLAogICAgICAiZXh0ZW5zaW9uIjogWwogICAgICAgIHsKICAgICAgICAgICJ2YWx1ZUlkZW50
aWZpZXIiOiB7InZhbHVlIjogeyJ2YWx1ZSI6ICJBRVROQSJ9fSwKICAgICAgICAgICJ1cmwiOiAi
aHR0cDovL3d3dy5xdWVzdGRpYWdub3N0aWNzLmNvbSIKICAgICAgICB9LAogICAgICAgIHsKICAg
ICAgICAgICJ2YWx1ZVRpbWluZyI6IHsKICAgICAgICAgICAgImNvZGUiOiB7ImNvZGluZyI6IHsK
ICAgICAgICAgICAgICAic3lzdGVtIjogeyJ2YWx1ZSI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3Yy
LzA0ODUifSwKICAgICAgICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAiUyJ9LAogICAgICAgICAg
ICAgICJkaXNwbGF5IjogeyJ2YWx1ZSI6ICJTdGF0In0KICAgICAgICAgICAgfX0sCiAgICAgICAg
ICAgICJldmVudCI6IHsidmFsdWUiOiAiMjAxNi0wMS0wN1QwOTowMDowMC0wNTowMCJ9CiAgICAg
ICAgICB9LAogICAgICAgICAgInVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YyL3RxMSIKICAg
ICAgICB9CiAgICAgIF0sCiAgICAgICJwbGFuaG9sZGVyUmVmZXJlbmNlIjogeyJyZWZlcmVuY2Ui
OiB7InZhbHVlIjogIlBhdGllbnQvUElELXBhdGllbnQtaWRlbnRpZmljYXRpb24ifX0sCiAgICAg
ICJzdWJQbGFuIjogeyJ2YWx1ZSI6ICJDMTIzNDU2In0sCiAgICAgICJpc3N1ZXJSZWZlcmVuY2Ui
OiB7InJlZmVyZW5jZSI6IHsidmFsdWUiOiAiT3JnYW5pemF0aW9uL2luc3VyYW5jZS1jb21wYW55
In19LAogICAgICAiYmVuZWZpY2lhcnlJZGVudGlmaWVyIjogIiIsCiAgICAgICJpZCI6IHsidmFs
dWUiOiAiSU4xLWluc3VyYW5jZSJ9LAogICAgICAidHlwZSI6IHsiY29kZSI6IHsidmFsdWUiOiAi
UCJ9fSwKICAgICAgInJlbGF0aW9uc2hpcCI6IHsKICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAx
fSwKICAgICAgICAiZGlzcGxheSI6IHsidmFsdWUiOiAiU2VsZiJ9CiAgICAgIH0sCiAgICAgICJw
bGFuIjogeyJ2YWx1ZSI6ICJQMTIzNDU2UiJ9LAogICAgICAiZ3JvdXAiOiB7InZhbHVlIjogIkEx
MjM0NSJ9CiAgICB9fX0sCiAgICB7InJlc291cmNlIjogeyJQZXJzb24iOiB7CiAgICAgICJhZGRy
ZXNzIjogewogICAgICAgICJjb3VudHJ5IjogeyJ2YWx1ZSI6ICJVU0EifSwKICAgICAgICAiY2l0
eSI6IHsidmFsdWUiOiAiTWFzb24ifSwKICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJob21lIn0s
CiAgICAgICAgImxpbmUiOiB7InZhbHVlIjogIjQ2OTAgUGFya3dheSBEci4ifSwKICAgICAgICAi
cG9zdGFsQ29kZSI6IHsidmFsdWUiOiA0NTA0MH0sCiAgICAgICAgInN0YXRlIjogeyJ2YWx1ZSI6
ICJPSCJ9CiAgICAgIH0sCiAgICAgICJuYW1lIjogewogICAgICAgICJnaXZlbiI6IFsKICAgICAg
ICAgIHsidmFsdWUiOiAiSW5zdXJlZF9GaXJzdG5hbWUifSwKICAgICAgICAgIHsidmFsdWUiOiAi
TWlkZGxlIn0KICAgICAgICBdLAogICAgICAgICJ1c2UiOiB7InZhbHVlIjogIm9mZmljaWFsIn0s
CiAgICAgICAgImZhbWlseSI6IHsidmFsdWUiOiAiSW5zdXJlZF9MYXN0bmFtZSJ9CiAgICAgIH0s
CiAgICAgICJ0ZWxlY29tIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0s
CiAgICAgICAgInVzZSI6IHsidmFsdWUiOiAiaG9tZSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFs
dWUiOiAiMV4zMzNeNDQ0NTU1NSJ9CiAgICAgIH0sCiAgICAgICJpZCI6IHsidmFsdWUiOiAiR1Qx
LWd1YXJhbnRvciJ9CiAgICB9fX0sCiAgICB7InJlc291cmNlIjogeyJQcmFjdGl0aW9uZXIiOiB7
CiAgICAgICJpZGVudGlmaWVyIjogewogICAgICAgICJhc3NpZ25lciI6IHsiZGlzcGxheSI6IHsi
dmFsdWUiOiAiTlBJIn19LAogICAgICAgICJ2YWx1ZSI6IHsidmFsdWUiOiAxMzY2NDcyNTU3fQog
ICAgICB9LAogICAgICAibmFtZSI6IHsKICAgICAgICAiZ2l2ZW4iOiBbCiAgICAgICAgICB7InZh
bHVlIjogIkphc29uIn0sCiAgICAgICAgICB7InZhbHVlIjogIlMuIn0KICAgICAgICBdLAogICAg
ICAgICJmYW1pbHkiOiB7InZhbHVlIjogIkphdmlsbG8ifQogICAgICB9LAogICAgICAiaWQiOiB7
InZhbHVlIjogIm9yZGVyaW5nLXByb3ZpZGVyIn0KICAgIH19fQogIF0sCiAgImlkIjogeyJ2YWx1
ZSI6ICJPTUwtTzIxLWIxYTE3Y2QyLTg2NWYtNDg2YS05NjBkLThlYTc3NjRlYzAwZCJ9LAogICJ0
eXBlIjogeyJ2YWx1ZSI6ICJzZWFyY2hzZXQifQp9fQ==</inboundTemplate>
          <outboundTemplate encoding="base64"></outboundTemplate>
          <inboundDataType>JSON</inboundDataType>
          <outboundDataType>JSON</outboundDataType>
          <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </inboundProperties>
          <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
            <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
              <splitType>JavaScript</splitType>
              <batchScript></batchScript>
            </batchProperties>
          </outboundProperties>
        </transformer>
        <filter version="3.4.2">
          <rules/>
        </filter>
        <transportName>Channel Reader</transportName>
        <mode>SOURCE</mode>
        <enabled>true</enabled>
        <waitForPrevious>true</waitForPrevious>
      </sourceConnector>
      <destinationConnectors>
        <connector version="3.4.2">
          <metaDataId>2</metaDataId>
          <name>Create OML_O21</name>
          <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <script>return true;
</script>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>OML templates</name>
                <script>// OML_O21 template with placeholders for required fields only
var oml_template = &quot;MSH|^~\&amp;|||||||OML^O21^OML_O21|||2.5.1\r&quot; + &quot;PID|1|||||||\r&quot;;
var oml = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(oml_template));

// MSH segment required fields (may be overwritten by MessageHeader resource)
oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = $(&quot;application&quot;);
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = $(&quot;account&quot;);
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = $(&quot;receivingFacility&quot;);

// Overrides
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = &quot;MET&quot;;
oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = &quot;PSC&quot;;
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = &quot;90046003&quot;;

// (Quest) Note: All date timestamps are set to Coordinated Universal Time (UTC).
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmssZ&quot;);
oml[&apos;MSH&apos;][&apos;MSH.7&apos;] = currentDate;

// Message Control ID is calculated based on date of submission
oml[&apos;MSH&apos;][&apos;MSH.10&apos;] = currentDate.toString().substring(0,14) + UUIDGenerator.getUUID().toString().substring(0,6);
oml[&apos;MSH&apos;][&apos;MSH.11&apos;] = $(&quot;processingID&quot;);


// A list of possible incoming JSON feed validation errors based on IN1.47 [Coverage Type] value
var error = [];</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// OML_O21 template with placeholders for required fields only
var oml_template = &quot;MSH|^~\&amp;|||||||OML^O21^OML_O21|||2.5.1\r&quot; + &quot;PID|1|||||||\r&quot;;
var oml = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(oml_template));

// MSH segment required fields (may be overwritten by MessageHeader resource)
oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = $(&quot;application&quot;);
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = $(&quot;account&quot;);
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = $(&quot;receivingFacility&quot;);

// Overrides
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = &quot;MET&quot;;
oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = &quot;PSC&quot;;
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = &quot;90046003&quot;;

// (Quest) Note: All date timestamps are set to Coordinated Universal Time (UTC).
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmssZ&quot;);
oml[&apos;MSH&apos;][&apos;MSH.7&apos;] = currentDate;

// Message Control ID is calculated based on date of submission
oml[&apos;MSH&apos;][&apos;MSH.10&apos;] = currentDate.toString().substring(0,14) + UUIDGenerator.getUUID().toString().substring(0,6);
oml[&apos;MSH&apos;][&apos;MSH.11&apos;] = $(&quot;processingID&quot;);


// A list of possible incoming JSON feed validation errors based on IN1.47 [Coverage Type] value
var error = [];</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>Iterate JSON resources</name>
                <script>// Global NTE Set ID value
var countNTE = 1; 

// Insurance list to retain primary and secondary
var coverageMap = new Packages.java.util.HashMap(2);

// Guarantor
var guarantorMap = new Packages.java.util.HashMap(1);

// Common Order
var commonOrderMap = new Packages.java.util.HashMap(4);
var placedOrderNumberMap = new Packages.java.util.HashMap(4);

// Timing/Quantity
var timingQuantityMap = new Packages.java.util.HashMap(4);

// Observation Request
var observationRequestMap = new Packages.java.util.HashMap(4);
var observationRequestCommentsMap = new Packages.java.util.HashMap(4);

// Diagnosis
var diagnosisMap = new Packages.java.util.HashMap(12);

// Observation/Result aka AOEs
var observationMap = new Packages.java.util.HashMap(4);
var observationCommentsMap = new Packages.java.util.HashMap(4);
var observationReferencesMap = new Packages.java.util.HashMap(4);

// ORC.12 Ordering Provider
// OBX.16 Ordering Provider
var practitionerMap = new Packages.java.util.HashMap(4);



// Preliminary store referenced resources
for each (obj in msg.Bundle.entry) {

	if (obj.resource.Practitioner != null &amp;&amp; obj.resource.Practitioner != undefined) {
logger.error( &quot;Found Practitioner&quot; );	

		
		// Practitioner is required to complete ORC and OBR segments
		var id = ((obj.resource.Practitioner.id != undefined) ? obj.resource.Practitioner.id.value.toString() : &quot;&quot;);
		if (id.length &gt; 0)
			practitionerMap.put(id.toString(), obj);
	}
}

logger.error( &quot;About to iterate: &quot; + obj.resource.toString() );	
// Iterate over all inbound feed resource
for each (obj in msg.Bundle.entry) {

logger.error( &quot;Resource: \n&quot; + JSON.stringify( obj.resource ) );	

	if (obj.resource.MessageHeader != null &amp;&amp; obj.resource.MessageHeader != undefined) {
logger.error( &quot;Found MessagerHeader&quot; );			
		// Update MessageHeader segment
		processMessageHeader(obj);

	} else if (obj.resource.Patient != null &amp;&amp; obj.resource.Patient != undefined) {
		// Populate PID segment
		processPatient(obj);
		
	} else if (obj.resource.DiagnosticReport != null &amp;&amp; obj.resource.DiagnosticReport != undefined) {
logger.error( &quot;Found Report&quot;);	
		// Populate ORC segment
		processCommonOrder(obj);
		
	} else if (obj.resource.DiagnosticOrder != null &amp;&amp; obj.resource.DiagnosticOrder != undefined) {
logger.error( &quot;Found Order&quot;);	
		// Populate OBR segment
		processObservationRequest(obj);

	} else if (obj.resource.Coverage != null &amp;&amp; obj.resource.Coverage != undefined) {
		// Populate IN1 segment
		processCoverage(obj);
		
	} else if (obj.resource.Person != null &amp;&amp; obj.resource.Person != undefined) {
		// Populate GT1 segment
		processGuarantor(obj);
		
	} else if (obj.resource.Observation != null &amp;&amp; obj.resource.Observation != undefined) {
		// Store Observation resource for OBX segment
		processObservation(obj);
	}

}


// ==================== COMPILE THE OML MESSAGE ====================

// Required primary insurance segment
var segInsurancePrimary = coverageMap.get(1);
if (segInsurancePrimary != null) try {
	oml.appendChild(new XML(segInsurancePrimary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding primary insurance segment - &quot; + ex);
}
// Optional secondary insurance segment
var segInsuranceSecondary = coverageMap.get(2);
if (segInsuranceSecondary != null) try {
	oml.appendChild(new XML(segInsuranceSecondary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding secondary insurance segment - &quot; + ex);
} 



// Optional Guarantor segment
var segGuarantor = guarantorMap.get(1);
if (segGuarantor != null) try {
	oml.appendChild(new XML(segGuarantor));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding Guarantor segment - &quot; + ex);	
}



// Required ORDER group
for (var i = 0; i &lt; commonOrderMap.size(); i++) {

	// ORC [Common Order] segment
	var segCommonOrder = commonOrderMap.get((i+1).toString());
	if (segCommonOrder != null) try {
		oml.appendChild(new XML(segCommonOrder));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding CommonOrder segment - &quot; + ex);
	}

	// TQ1 [Timing/Quantity] segment
	var segTimingQuantity = timingQuantityMap.get((i+1).toString());
	if (segTimingQuantity != null) try {
		oml.appendChild(new XML(segTimingQuantity));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Timing/Quantity segment - &quot; + ex);
	}

	// OBR [Observation Request] segment
	var segObservation = observationRequestMap.get((i+1).toString());
	if (segObservation != null) try {
		oml.appendChild(new XML(segObservation));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Observation Request segment - &quot; + ex);
	}
		

	// Observation level NTE [Comments] segments
	var obsComments = observationRequestCommentsMap.get((i+1).toString());
	if (obsComments != null &amp;&amp; Array.isArray(obsComments)) {
		for (var kk = 0; kk &lt; obsComments.length; kk++) {
			var nte = obsComments[kk];
			if (nte.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(nte.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Observation Comment segment - &quot; + ex);
			}
		}
		obsComments.length = 0;
	}
	
	// DG1 [Diagnosis] segments
	var conditions = diagnosisMap.get((i+1).toString());
	if (conditions != null &amp;&amp; Array.isArray(conditions)) {
		for (var dd = 0; dd &lt; conditions.length; dd++) {
			var dg1 = conditions[dd];
			if (dg1.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(dg1.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Diagnosis segment - &quot; + ex);
			}
		}
		conditions.length = 0;		
	}

	// OBX [Observation] segments
	// Get the list of OBX segment references
	var obsReference = observationReferencesMap.get((i+1).toString());
	if (obsReference != null &amp;&amp; Array.isArray(obsReference)) {
		for (var rr = 0; rr &lt; obsReference.length; rr++) {
			// Get the actual OBX segments
			var obx = observationMap.get(obsReference[rr]);
			if (obx != null &amp;&amp; obx.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(obx.toString()));

				// OBX level NTE [Comment] segments
				var observationComments = observationCommentsMap.get(obsReference[rr]);
				if (observationComments != null &amp;&amp; Array.isArray(observationComments)) {
					for (var oc = 0; oc &lt; observationComments.length; oc++) {
						var obxNTE = observationComments[oc];
						if (obxNTE != null &amp;&amp; obxNTE.length &gt; 0)
							oml.appendChild(new XML(obxNTE.toString()));
					}
				}
				observationComments.length = 0;
				
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding OBX segment - &quot; + ex);
			}		
		}		
		obsReference.length = 0;		
	}

}


// Clear all temporary maps
coverageMap.clear();
guarantorMap.clear();
commonOrderMap.clear();
placedOrderNumberMap.clear();
timingQuantityMap.clear();
observationRequestMap.clear();
observationRequestCommentsMap.clear();
diagnosisMap.clear();
observationMap.clear();
observationCommentsMap.clear(); 
observationReferencesMap.clear();
practitionerMap.clear();</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Global NTE Set ID value
var countNTE = 1; 

// Insurance list to retain primary and secondary
var coverageMap = new Packages.java.util.HashMap(2);

// Guarantor
var guarantorMap = new Packages.java.util.HashMap(1);

// Common Order
var commonOrderMap = new Packages.java.util.HashMap(4);
var placedOrderNumberMap = new Packages.java.util.HashMap(4);

// Timing/Quantity
var timingQuantityMap = new Packages.java.util.HashMap(4);

// Observation Request
var observationRequestMap = new Packages.java.util.HashMap(4);
var observationRequestCommentsMap = new Packages.java.util.HashMap(4);

// Diagnosis
var diagnosisMap = new Packages.java.util.HashMap(12);

// Observation/Result aka AOEs
var observationMap = new Packages.java.util.HashMap(4);
var observationCommentsMap = new Packages.java.util.HashMap(4);
var observationReferencesMap = new Packages.java.util.HashMap(4);

// ORC.12 Ordering Provider
// OBX.16 Ordering Provider
var practitionerMap = new Packages.java.util.HashMap(4);



// Preliminary store referenced resources
for each (obj in msg.Bundle.entry) {

	if (obj.resource.Practitioner != null &amp;&amp; obj.resource.Practitioner != undefined) {
logger.error( &quot;Found Practitioner&quot; );	

		
		// Practitioner is required to complete ORC and OBR segments
		var id = ((obj.resource.Practitioner.id != undefined) ? obj.resource.Practitioner.id.value.toString() : &quot;&quot;);
		if (id.length &gt; 0)
			practitionerMap.put(id.toString(), obj);
	}
}

logger.error( &quot;About to iterate: &quot; + obj.resource.toString() );	
// Iterate over all inbound feed resource
for each (obj in msg.Bundle.entry) {

logger.error( &quot;Resource: \n&quot; + JSON.stringify( obj.resource ) );	

	if (obj.resource.MessageHeader != null &amp;&amp; obj.resource.MessageHeader != undefined) {
logger.error( &quot;Found MessagerHeader&quot; );			
		// Update MessageHeader segment
		processMessageHeader(obj);

	} else if (obj.resource.Patient != null &amp;&amp; obj.resource.Patient != undefined) {
		// Populate PID segment
		processPatient(obj);
		
	} else if (obj.resource.DiagnosticReport != null &amp;&amp; obj.resource.DiagnosticReport != undefined) {
logger.error( &quot;Found Report&quot;);	
		// Populate ORC segment
		processCommonOrder(obj);
		
	} else if (obj.resource.DiagnosticOrder != null &amp;&amp; obj.resource.DiagnosticOrder != undefined) {
logger.error( &quot;Found Order&quot;);	
		// Populate OBR segment
		processObservationRequest(obj);

	} else if (obj.resource.Coverage != null &amp;&amp; obj.resource.Coverage != undefined) {
		// Populate IN1 segment
		processCoverage(obj);
		
	} else if (obj.resource.Person != null &amp;&amp; obj.resource.Person != undefined) {
		// Populate GT1 segment
		processGuarantor(obj);
		
	} else if (obj.resource.Observation != null &amp;&amp; obj.resource.Observation != undefined) {
		// Store Observation resource for OBX segment
		processObservation(obj);
	}

}


// ==================== COMPILE THE OML MESSAGE ====================

// Required primary insurance segment
var segInsurancePrimary = coverageMap.get(1);
if (segInsurancePrimary != null) try {
	oml.appendChild(new XML(segInsurancePrimary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding primary insurance segment - &quot; + ex);
}
// Optional secondary insurance segment
var segInsuranceSecondary = coverageMap.get(2);
if (segInsuranceSecondary != null) try {
	oml.appendChild(new XML(segInsuranceSecondary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding secondary insurance segment - &quot; + ex);
} 



// Optional Guarantor segment
var segGuarantor = guarantorMap.get(1);
if (segGuarantor != null) try {
	oml.appendChild(new XML(segGuarantor));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding Guarantor segment - &quot; + ex);	
}



// Required ORDER group
for (var i = 0; i &lt; commonOrderMap.size(); i++) {

	// ORC [Common Order] segment
	var segCommonOrder = commonOrderMap.get((i+1).toString());
	if (segCommonOrder != null) try {
		oml.appendChild(new XML(segCommonOrder));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding CommonOrder segment - &quot; + ex);
	}

	// TQ1 [Timing/Quantity] segment
	var segTimingQuantity = timingQuantityMap.get((i+1).toString());
	if (segTimingQuantity != null) try {
		oml.appendChild(new XML(segTimingQuantity));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Timing/Quantity segment - &quot; + ex);
	}

	// OBR [Observation Request] segment
	var segObservation = observationRequestMap.get((i+1).toString());
	if (segObservation != null) try {
		oml.appendChild(new XML(segObservation));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Observation Request segment - &quot; + ex);
	}
		

	// Observation level NTE [Comments] segments
	var obsComments = observationRequestCommentsMap.get((i+1).toString());
	if (obsComments != null &amp;&amp; Array.isArray(obsComments)) {
		for (var kk = 0; kk &lt; obsComments.length; kk++) {
			var nte = obsComments[kk];
			if (nte.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(nte.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Observation Comment segment - &quot; + ex);
			}
		}
		obsComments.length = 0;
	}
	
	// DG1 [Diagnosis] segments
	var conditions = diagnosisMap.get((i+1).toString());
	if (conditions != null &amp;&amp; Array.isArray(conditions)) {
		for (var dd = 0; dd &lt; conditions.length; dd++) {
			var dg1 = conditions[dd];
			if (dg1.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(dg1.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Diagnosis segment - &quot; + ex);
			}
		}
		conditions.length = 0;		
	}

	// OBX [Observation] segments
	// Get the list of OBX segment references
	var obsReference = observationReferencesMap.get((i+1).toString());
	if (obsReference != null &amp;&amp; Array.isArray(obsReference)) {
		for (var rr = 0; rr &lt; obsReference.length; rr++) {
			// Get the actual OBX segments
			var obx = observationMap.get(obsReference[rr]);
			if (obx != null &amp;&amp; obx.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(obx.toString()));

				// OBX level NTE [Comment] segments
				var observationComments = observationCommentsMap.get(obsReference[rr]);
				if (observationComments != null &amp;&amp; Array.isArray(observationComments)) {
					for (var oc = 0; oc &lt; observationComments.length; oc++) {
						var obxNTE = observationComments[oc];
						if (obxNTE != null &amp;&amp; obxNTE.length &gt; 0)
							oml.appendChild(new XML(obxNTE.toString()));
					}
				}
				observationComments.length = 0;
				
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding OBX segment - &quot; + ex);
			}		
		}		
		obsReference.length = 0;		
	}

}


// Clear all temporary maps
coverageMap.clear();
guarantorMap.clear();
commonOrderMap.clear();
placedOrderNumberMap.clear();
timingQuantityMap.clear();
observationRequestMap.clear();
observationRequestCommentsMap.clear();
diagnosisMap.clear();
observationMap.clear();
observationCommentsMap.clear(); 
observationReferencesMap.clear();
practitionerMap.clear();</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>2</sequenceNumber>
                <name>MSH segment</name>
                <script>/**
	Populates MSG segment with data from the MessageHeader resource
	@param {Object} obj - MessageHeader object resource
	@return - nothing, uses global HL7v2 message object
*/
function processMessageHeader(obj) {

	if (obj.resource.MessageHeader.source) {
		
		// The name of the sending application
		var sendingApplication = ((obj.resource.MessageHeader.source.name) ? obj.resource.MessageHeader.source.name.value.toString() : &quot;&quot;);
		if (sendingApplication) oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = sendingApplication;
		
		// Primary or secondary account number(s) defined for the placer. ~~ RKW - And the actual account number was less important?
		var sendingFacility = ((obj.resource.MessageHeader.source.endpoint) ? obj.resource.MessageHeader.source.endpoint.value.toString() : &quot;&quot;);
		if (sendingFacility) oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = sendingFacility;
			
	} 

	if (obj.resource.MessageHeader.destination) {
		
		// If provided must be hard-coded to &quot;PSC&quot; for PSC hold orders. If the &lt;name&gt; element is not provided or value is other than &quot;PSC&quot; the order is considered to be a basic lab order.
		var receivingApplication = ((obj.resource.MessageHeader.destination.name) ? obj.resource.MessageHeader.destination.name.value.toString() : &quot;&quot;);
		if (receivingApplication) oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = receivingApplication;


		// The receiving facility. The three-letter ID of the facility that performs the test.
		var receivingFacility = ((obj.resource.MessageHeader.destination.endpoint) ? obj.resource.MessageHeader.destination.endpoint.value.toString() : &quot;&quot;);
		if (receivingFacility) oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = receivingFacility;			
	}

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates MSG segment with data from the MessageHeader resource
	@param {Object} obj - MessageHeader object resource
	@return - nothing, uses global HL7v2 message object
*/
function processMessageHeader(obj) {

	if (obj.resource.MessageHeader.source) {
		
		// The name of the sending application
		var sendingApplication = ((obj.resource.MessageHeader.source.name) ? obj.resource.MessageHeader.source.name.value.toString() : &quot;&quot;);
		if (sendingApplication) oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = sendingApplication;
		
		// Primary or secondary account number(s) defined for the placer. ~~ RKW - And the actual account number was less important?
		var sendingFacility = ((obj.resource.MessageHeader.source.endpoint) ? obj.resource.MessageHeader.source.endpoint.value.toString() : &quot;&quot;);
		if (sendingFacility) oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = sendingFacility;
			
	} 

	if (obj.resource.MessageHeader.destination) {
		
		// If provided must be hard-coded to &quot;PSC&quot; for PSC hold orders. If the &lt;name&gt; element is not provided or value is other than &quot;PSC&quot; the order is considered to be a basic lab order.
		var receivingApplication = ((obj.resource.MessageHeader.destination.name) ? obj.resource.MessageHeader.destination.name.value.toString() : &quot;&quot;);
		if (receivingApplication) oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = receivingApplication;


		// The receiving facility. The three-letter ID of the facility that performs the test.
		var receivingFacility = ((obj.resource.MessageHeader.destination.endpoint) ? obj.resource.MessageHeader.destination.endpoint.value.toString() : &quot;&quot;);
		if (receivingFacility) oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = receivingFacility;			
	}

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>3</sequenceNumber>
                <name>PID segment</name>
                <script>/**
	Populates PID segment with data from the Patient resource
	@param {Object} obj - Patient object resource
	@return - nothing, uses global HL7v2 message object
*/
function processPatient(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var comments = [];

	// Iterate over all patient identifiers
	obj.resource.Patient.identifier.forEach(function(item){

		// PID.3 [Patient Identifier List]
		if (item.use.value.toString() == &quot;official&quot;) {
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = id;

			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.5&apos;] = type;

			var assigner = ((item.assigner) ? item.assigner.display.value.toString() : &quot;&quot;);
			if (assigner)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = assigner;								

		// PID.2 [Patient ID]	
		} else if (item.use.value.toString() == &quot;secondary&quot;) {
		
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.1&apos;] = id;
				
			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.5&apos;] = type;			
						
		}
		
	});


	// Parse patient&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Patient.name, true);
	oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = nameParts.family;
	if (nameParts.given1) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = nameParts.given1;
	if (nameParts.given2) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = nameParts.given2;


	// Patient&apos;s DOB
	if (obj.resource.Patient.birthDate) {
		var dob = obj.resource.Patient.birthDate.value.toString();
		oml[&apos;PID&apos;][&apos;PID.7&apos;] = dob.replace(/-/g,&quot;&quot;);
	} else {
		error.push(&quot;resource.Patient.birthDate for PID.7[DateTime of Birth] is required&quot;);
	}

	// Administrative Gender 
	if (obj.resource.Patient.gender) {
		var gender = obj.resource.Patient.gender.value;
		oml[&apos;PID&apos;][&apos;PID.8&apos;] = convertTable(&quot;0001&quot;, gender);
	} else {
		error.push(&quot;resource.Patient.gender for PID.8[Administrative Sex] is required&quot;);		
	}




	// Patient Address
	if (obj.resource.Patient.address) {

		var street = ((obj.resource.Patient.address.line) ? obj.resource.Patient.address.line.value.toString() : &quot;&quot;);
		if (street)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = street;
		
		var city = ((obj.resource.Patient.address.city) ? obj.resource.Patient.address.city.value.toString() : &quot;&quot;);
		if (city)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = city;	
		
		var state = ((obj.resource.Patient.address.state) ? obj.resource.Patient.address.state.value.toString() : &quot;&quot;);
		if (state)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.4&apos;] = state;
	
		var postal = ((obj.resource.Patient.address.postalCode) ? obj.resource.Patient.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;] = postal;
	
		var country = ((obj.resource.Patient.address.country) ? obj.resource.Patient.address.country.value.toString() : &quot;&quot;);
		if (country)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.6&apos;] = country;

		// There might be a better definition what is required &quot;patient’s address&quot;.
		hasAddress = (street || city || state || postal);	
	}

	// Patient Phone Number (Home)	
	var phone = ((obj.resource.Patient.telecom) ? obj.resource.Patient.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		oml[&apos;PID&apos;][&apos;PID.13&apos;] = convertPhoneXTN(phone);
	}


	// Validate conditional fields
	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (!hasAddress) error.push(&quot;resource.Patient.address for PID.11[Patient Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Patient.telecom for PID.13[Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);
	}


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.Patient.text &amp;&amp; obj.resource.Patient.text.div) {	
		
		var internalCommentsCount = 0; //  only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.Patient.text.div.p.length &amp;&amp; obj.resource.Patient.text.div.p.length &gt; 0) {
			obj.resource.Patient.text.div.p.forEach(function(item){
				// For internal (I) or report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					// If the comment is not internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				} 		
			});	
		} else if (obj.resource.Patient.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.Patient.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.Patient.text.div.p, countNTE++));
		}

		for (var i = comments.length - 1; i &gt;= 0; i--) {
			var nte = comments[i];
			if (nte.toString() != &quot;&quot;)
				oml[&apos;PID&apos;] += new XML(nte.toString());
		}

		comments.length = 0;
	}

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates PID segment with data from the Patient resource
	@param {Object} obj - Patient object resource
	@return - nothing, uses global HL7v2 message object
*/
function processPatient(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var comments = [];

	// Iterate over all patient identifiers
	obj.resource.Patient.identifier.forEach(function(item){

		// PID.3 [Patient Identifier List]
		if (item.use.value.toString() == &quot;official&quot;) {
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = id;

			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.5&apos;] = type;

			var assigner = ((item.assigner) ? item.assigner.display.value.toString() : &quot;&quot;);
			if (assigner)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = assigner;								

		// PID.2 [Patient ID]	
		} else if (item.use.value.toString() == &quot;secondary&quot;) {
		
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.1&apos;] = id;
				
			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.5&apos;] = type;			
						
		}
		
	});


	// Parse patient&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Patient.name, true);
	oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = nameParts.family;
	if (nameParts.given1) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = nameParts.given1;
	if (nameParts.given2) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = nameParts.given2;


	// Patient&apos;s DOB
	if (obj.resource.Patient.birthDate) {
		var dob = obj.resource.Patient.birthDate.value.toString();
		oml[&apos;PID&apos;][&apos;PID.7&apos;] = dob.replace(/-/g,&quot;&quot;);
	} else {
		error.push(&quot;resource.Patient.birthDate for PID.7[DateTime of Birth] is required&quot;);
	}

	// Administrative Gender 
	if (obj.resource.Patient.gender) {
		var gender = obj.resource.Patient.gender.value;
		oml[&apos;PID&apos;][&apos;PID.8&apos;] = convertTable(&quot;0001&quot;, gender);
	} else {
		error.push(&quot;resource.Patient.gender for PID.8[Administrative Sex] is required&quot;);		
	}




	// Patient Address
	if (obj.resource.Patient.address) {

		var street = ((obj.resource.Patient.address.line) ? obj.resource.Patient.address.line.value.toString() : &quot;&quot;);
		if (street)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = street;
		
		var city = ((obj.resource.Patient.address.city) ? obj.resource.Patient.address.city.value.toString() : &quot;&quot;);
		if (city)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = city;	
		
		var state = ((obj.resource.Patient.address.state) ? obj.resource.Patient.address.state.value.toString() : &quot;&quot;);
		if (state)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.4&apos;] = state;
	
		var postal = ((obj.resource.Patient.address.postalCode) ? obj.resource.Patient.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;] = postal;
	
		var country = ((obj.resource.Patient.address.country) ? obj.resource.Patient.address.country.value.toString() : &quot;&quot;);
		if (country)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.6&apos;] = country;

		// There might be a better definition what is required &quot;patient’s address&quot;.
		hasAddress = (street || city || state || postal);	
	}

	// Patient Phone Number (Home)	
	var phone = ((obj.resource.Patient.telecom) ? obj.resource.Patient.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		oml[&apos;PID&apos;][&apos;PID.13&apos;] = convertPhoneXTN(phone);
	}


	// Validate conditional fields
	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (!hasAddress) error.push(&quot;resource.Patient.address for PID.11[Patient Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Patient.telecom for PID.13[Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);
	}


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.Patient.text &amp;&amp; obj.resource.Patient.text.div) {	
		
		var internalCommentsCount = 0; //  only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.Patient.text.div.p.length &amp;&amp; obj.resource.Patient.text.div.p.length &gt; 0) {
			obj.resource.Patient.text.div.p.forEach(function(item){
				// For internal (I) or report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					// If the comment is not internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				} 		
			});	
		} else if (obj.resource.Patient.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.Patient.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.Patient.text.div.p, countNTE++));
		}

		for (var i = comments.length - 1; i &gt;= 0; i--) {
			var nte = comments[i];
			if (nte.toString() != &quot;&quot;)
				oml[&apos;PID&apos;] += new XML(nte.toString());
		}

		comments.length = 0;
	}

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>4</sequenceNumber>
                <name>IN1 primary and secondary segments</name>
                <script>/**
	Populates IN1 [Insurance] segments with data from the primary and secondary Coverage resources	
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCoverage(obj) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var isContainedPerson = hasPersonAddress = false;
	var isContainedOrganization = hasOrganizationAddress = false;

	var segIns = &lt;IN1&gt;
				&lt;IN1.1&gt;
					&lt;IN1.1.1&gt;1&lt;/IN1.1.1&gt;
				&lt;/IN1.1&gt;
				&lt;IN1.2/&gt;&lt;IN1.3/&gt;&lt;IN1.4/&gt;&lt;IN1.5/&gt;&lt;IN1.6/&gt;&lt;IN1.7/&gt;&lt;IN1.8/&gt;&lt;IN1.9/&gt;
				&lt;IN1.10/&gt;&lt;IN1.11/&gt;&lt;IN1.12/&gt;&lt;IN1.13/&gt;&lt;IN1.14/&gt;&lt;IN1.15/&gt;&lt;IN1.16/&gt;&lt;IN1.17/&gt;&lt;IN1.18/&gt;&lt;IN1.19/&gt;
				&lt;IN1.20/&gt;&lt;IN1.21/&gt;&lt;IN1.22/&gt;&lt;IN1.23/&gt;&lt;IN1.24/&gt;&lt;IN1.25/&gt;&lt;IN1.26/&gt;&lt;IN1.27/&gt;&lt;IN1.28/&gt;&lt;IN1.29/&gt;
				&lt;IN1.30/&gt;&lt;IN1.31/&gt;&lt;IN1.32/&gt;&lt;IN1.33/&gt;&lt;IN1.34/&gt;&lt;IN1.35/&gt;&lt;IN1.36/&gt;&lt;IN1.37/&gt;&lt;IN1.38/&gt;&lt;IN1.39/&gt;
				&lt;IN1.40/&gt;&lt;IN1.41/&gt;&lt;IN1.42/&gt;&lt;IN1.43/&gt;&lt;IN1.44/&gt;&lt;IN1.45/&gt;&lt;IN1.46/&gt;&lt;IN1.47/&gt;
			&lt;/IN1&gt;;

	// Insurance Set ID
	var coverageType = 1; 
	var setID = obj.resource.Coverage.id.value.toString();
	if (setID.indexOf(&quot;2&quot;) &gt; -1) {
		segIns[&apos;IN1.1&apos;] = &quot;2&quot;;
		coverageType = 2; // secondary - &quot;IN1-insurance-2&quot;
	} else {
		segIns[&apos;IN1.1&apos;] = &quot;1&quot;;
		coverageType = 1; // primary - &quot;IN1-insurance-1&quot;		
	}


	// Insurance Plan ID
	var planID = obj.resource.Coverage.identifier.value.value.toString();
	if (planID)
		segIns[&apos;IN1.2&apos;] = planID;


	if (obj.resource.Coverage.contained.length &amp;&amp; obj.resource.Coverage.contained.length &gt; 0) {

		// Loop through contained resources
		obj.resource.Coverage.contained.forEach(function(item){

			// Process contained insurance company
			processInsuranceOrganization(segIns, item);

			if (item.Person != null &amp;&amp; item.Person != undefined) {

				isContainedPerson = true;
				
				// Process insured person name with DEX name length limitation applied
				nameParts = processPersonName(item.Person.name, true);
	
				// Insured&apos;s Address
				if (item.Person.address) {
					var street = item.Person.address.line.value.toString();
					if (street)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.1&apos;] = street;
					
					var city = ((item.Person.address.city) ? item.Person.address.city.value.toString() : &quot;&quot;);
					if (city)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.3&apos;] = city;	
					
					var state = ((item.Person.address.state) ? item.Person.address.state.value.toString() : &quot;&quot;);
					if (state)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.4&apos;] = state;
				
					var postal = ((item.Person.address.postalCode) ? item.Person.address.postalCode.value.toString() : &quot;&quot;);
					if (postal)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.5&apos;] = postal;
				
					var country = ((item.Person.address.country) ? item.Person.address.country.value.toString() : &quot;&quot;);
					if (country)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.6&apos;] = country;
						
					// There might be a better definition what is required &quot;insured’s Address&quot;.
					hasPersonAddress = (street || city || state || postal);	
				}
			}
		});

	} else {
		// When only contained  insurance company is present
		processInsuranceOrganization(segIns, obj.resource.Coverage.contained);
	}

	// Insured&apos;s Group Employer Name 
	if (obj.resource.Coverage.extension) {
		var emplName = ((obj.resource.Coverage.extension.valueIdentifier) ? obj.resource.Coverage.extension.valueIdentifier.value.value.toString() : &quot;&quot;);
		if (emplName)
			segIns[&apos;IN1.11&apos;] = emplName;
	}


	// Group Number
	var groupNumber = ((obj.resource.Coverage.group) ? obj.resource.Coverage.group.value.toString() : &quot;&quot;);
	if (groupNumber)
		segIns[&apos;IN1.8&apos;] = groupNumber;



	

	// Name Of Insured
	// (SN) March 11, 2017: Fix to downgrade to DSTU3 Coverage resource. Previously checked only planholderReference.
/*	
	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
*/

	// Name Of Insured
	// (SN) March 13 2017: Disabled
	//var insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();

	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
	
	if (insuredRef == &quot;Patient/PID-patient-identification&quot;) {
		// Same as the PID segment
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString();
		
	} else if (insuredRef == &quot;Person/insured-person&quot;) {
		// Taken from the contained Person resource
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = nameParts.family;
		if (nameParts.given1.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = nameParts.given1;
		if (nameParts.given2.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = nameParts.given2;		
	}

	// Insured&apos;s Relationship To Patient
	if ( obj.resource.Coverage.relationship) {
		var relationship = ((obj.resource.Coverage.relationship.code) ? obj.resource.Coverage.relationship.code.value.toString() : &quot;&quot;);
		if (relationship)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;] = relationship;
		
		var relationshipDesc = ((obj.resource.Coverage.relationship.display) ? obj.resource.Coverage.relationship.display.value.toString() : &quot;&quot;);
		if (relationshipDesc)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.2&apos;] = relationshipDesc;
	}

	// Company Plan Code
	var planCode = (( obj.resource.Coverage.subPlan) ? obj.resource.Coverage.subPlan.value.toString() : &quot;&quot;);
	if (planCode)
		segIns[&apos;IN1.35&apos;] = planCode;

	// Policy Number
	var policyNumber = ((obj.resource.Coverage.plan) ? obj.resource.Coverage.plan.value.toString() : &quot;&quot;);
	if (policyNumber)
		segIns[&apos;IN1.36&apos;] = policyNumber;

	// Coverage Type
	segIns[&apos;IN1.47&apos;] = channelMap.get(&quot;CoverageType&quot;);


	if (coverage == &quot;T&quot;) {
		if (segIns[&apos;IN1.4&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Organization.name for IN1.4[Insurance Company Name] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.8&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.group for IN1.8[Group Number] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Person.name for IN1.16[Name Of Insured] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.relationship.code for IN1.17[Insured Relationship To Patient] is required if IN1.47[Coverage Type] is T&quot;);
		if (isContainedPerson &amp;&amp; !hasPersonAddress) error.push(&quot;resource.Coverage.contained.Person.address for IN1.19[Insured Address] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.36&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.plan for IN1.36[Policy Number] is required if IN1.47[Coverage Type] is T&quot;);		
	}


	// Store the segment to be later compiled into a message
	coverageMap.put(coverageType, segIns.toString());

	return;
}


/**
	Populates IN1.3 [Insurance Company ID] field with data from the contained Organization resource
	@param {Object} obj - Organization object resource
	@return - nothing, uses global HL7v2 message object
*/
function processInsuranceOrganization(segIns, item) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;

	if (item.Organization != null &amp;&amp; item.Organization != undefined) {

		isContainedOrganization = true;
		
		// Insurance Company ID
		var companyID = ((item.Organization.identifier) ? item.Organization.identifier.value.value.toString() : &quot;&quot;);
		if (companyID) 
			segIns[&apos;IN1.3&apos;] = companyID;
	
		// Insurance Company Name
		var companyName = ((item.Organization.name) ? item.Organization.name.value.toString() : &quot;&quot;);
		if (companyName)
			segIns[&apos;IN1.4&apos;] = companyName;

		// Insurance Company Address
		if (item.Organization.address) {
			var street = ((item.Organization.address.line) ? item.Organization.address.line.value.toString() : &quot;&quot;);
			if (street)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.1&apos;] = street;
				
			var city = ((item.Organization.address.city) ? item.Organization.address.city.value.toString() : &quot;&quot;);
			if (city)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.3&apos;] = city;
			
			var state = ((item.Organization.address.state) ? item.Organization.address.state.value.toString() : &quot;&quot;);
			if (state)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.4&apos;] = state;
		
			var postal = ((item.Organization.address.postalCode) ? item.Organization.address.postalCode.value.toString() : &quot;&quot;);
			if (postal)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.5&apos;] = postal;
		
			var country = ((item.Organization.address.country) ? item.Organization.address.country.value.toString() : &quot;&quot;);
			if (country)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.6&apos;] = country;

			// There might be a better definition what is required &quot;Insurance Company Address&quot;
			hasOrganizationAddress = (street || city || state || postal);						
		}		

		// Insurance Co Phone Number
		var phone = ((item.Organization.telecom) ? item.Organization.telecom.value.value.toString() : &quot;&quot;);
		if (phone) {
			hasPhone = true;
			segIns[&apos;IN1.7&apos;] = convertPhoneXTN(phone);
		}
	}

	// Validate conditional fields
	if (coverage == &quot;T&quot;) {		
		if (isContainedOrganization &amp;&amp; !hasOrganizationAddress) error.push(&quot;resource.Coverage.contained.Organization.address for IN1.5[Insurance Company Address] is required if IN1.47[Coverage Type] is T&quot;);
	}


	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates IN1 [Insurance] segments with data from the primary and secondary Coverage resources	
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCoverage(obj) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var isContainedPerson = hasPersonAddress = false;
	var isContainedOrganization = hasOrganizationAddress = false;

	var segIns = &lt;IN1&gt;
				&lt;IN1.1&gt;
					&lt;IN1.1.1&gt;1&lt;/IN1.1.1&gt;
				&lt;/IN1.1&gt;
				&lt;IN1.2/&gt;&lt;IN1.3/&gt;&lt;IN1.4/&gt;&lt;IN1.5/&gt;&lt;IN1.6/&gt;&lt;IN1.7/&gt;&lt;IN1.8/&gt;&lt;IN1.9/&gt;
				&lt;IN1.10/&gt;&lt;IN1.11/&gt;&lt;IN1.12/&gt;&lt;IN1.13/&gt;&lt;IN1.14/&gt;&lt;IN1.15/&gt;&lt;IN1.16/&gt;&lt;IN1.17/&gt;&lt;IN1.18/&gt;&lt;IN1.19/&gt;
				&lt;IN1.20/&gt;&lt;IN1.21/&gt;&lt;IN1.22/&gt;&lt;IN1.23/&gt;&lt;IN1.24/&gt;&lt;IN1.25/&gt;&lt;IN1.26/&gt;&lt;IN1.27/&gt;&lt;IN1.28/&gt;&lt;IN1.29/&gt;
				&lt;IN1.30/&gt;&lt;IN1.31/&gt;&lt;IN1.32/&gt;&lt;IN1.33/&gt;&lt;IN1.34/&gt;&lt;IN1.35/&gt;&lt;IN1.36/&gt;&lt;IN1.37/&gt;&lt;IN1.38/&gt;&lt;IN1.39/&gt;
				&lt;IN1.40/&gt;&lt;IN1.41/&gt;&lt;IN1.42/&gt;&lt;IN1.43/&gt;&lt;IN1.44/&gt;&lt;IN1.45/&gt;&lt;IN1.46/&gt;&lt;IN1.47/&gt;
			&lt;/IN1&gt;;

	// Insurance Set ID
	var coverageType = 1; 
	var setID = obj.resource.Coverage.id.value.toString();
	if (setID.indexOf(&quot;2&quot;) &gt; -1) {
		segIns[&apos;IN1.1&apos;] = &quot;2&quot;;
		coverageType = 2; // secondary - &quot;IN1-insurance-2&quot;
	} else {
		segIns[&apos;IN1.1&apos;] = &quot;1&quot;;
		coverageType = 1; // primary - &quot;IN1-insurance-1&quot;		
	}


	// Insurance Plan ID
	var planID = obj.resource.Coverage.identifier.value.value.toString();
	if (planID)
		segIns[&apos;IN1.2&apos;] = planID;


	if (obj.resource.Coverage.contained.length &amp;&amp; obj.resource.Coverage.contained.length &gt; 0) {

		// Loop through contained resources
		obj.resource.Coverage.contained.forEach(function(item){

			// Process contained insurance company
			processInsuranceOrganization(segIns, item);

			if (item.Person != null &amp;&amp; item.Person != undefined) {

				isContainedPerson = true;
				
				// Process insured person name with DEX name length limitation applied
				nameParts = processPersonName(item.Person.name, true);
	
				// Insured&apos;s Address
				if (item.Person.address) {
					var street = item.Person.address.line.value.toString();
					if (street)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.1&apos;] = street;
					
					var city = ((item.Person.address.city) ? item.Person.address.city.value.toString() : &quot;&quot;);
					if (city)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.3&apos;] = city;	
					
					var state = ((item.Person.address.state) ? item.Person.address.state.value.toString() : &quot;&quot;);
					if (state)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.4&apos;] = state;
				
					var postal = ((item.Person.address.postalCode) ? item.Person.address.postalCode.value.toString() : &quot;&quot;);
					if (postal)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.5&apos;] = postal;
				
					var country = ((item.Person.address.country) ? item.Person.address.country.value.toString() : &quot;&quot;);
					if (country)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.6&apos;] = country;
						
					// There might be a better definition what is required &quot;insured’s Address&quot;.
					hasPersonAddress = (street || city || state || postal);	
				}
			}
		});

	} else {
		// When only contained  insurance company is present
		processInsuranceOrganization(segIns, obj.resource.Coverage.contained);
	}

	// Insured&apos;s Group Employer Name 
	if (obj.resource.Coverage.extension) {
		var emplName = ((obj.resource.Coverage.extension.valueIdentifier) ? obj.resource.Coverage.extension.valueIdentifier.value.value.toString() : &quot;&quot;);
		if (emplName)
			segIns[&apos;IN1.11&apos;] = emplName;
	}


	// Group Number
	var groupNumber = ((obj.resource.Coverage.group) ? obj.resource.Coverage.group.value.toString() : &quot;&quot;);
	if (groupNumber)
		segIns[&apos;IN1.8&apos;] = groupNumber;



	

	// Name Of Insured
	// (SN) March 11, 2017: Fix to downgrade to DSTU3 Coverage resource. Previously checked only planholderReference.
/*	
	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
*/

	// Name Of Insured
	// (SN) March 13 2017: Disabled
	//var insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();

	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
	
	if (insuredRef == &quot;Patient/PID-patient-identification&quot;) {
		// Same as the PID segment
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString();
		
	} else if (insuredRef == &quot;Person/insured-person&quot;) {
		// Taken from the contained Person resource
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = nameParts.family;
		if (nameParts.given1.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = nameParts.given1;
		if (nameParts.given2.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = nameParts.given2;		
	}

	// Insured&apos;s Relationship To Patient
	if ( obj.resource.Coverage.relationship) {
		var relationship = ((obj.resource.Coverage.relationship.code) ? obj.resource.Coverage.relationship.code.value.toString() : &quot;&quot;);
		if (relationship)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;] = relationship;
		
		var relationshipDesc = ((obj.resource.Coverage.relationship.display) ? obj.resource.Coverage.relationship.display.value.toString() : &quot;&quot;);
		if (relationshipDesc)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.2&apos;] = relationshipDesc;
	}

	// Company Plan Code
	var planCode = (( obj.resource.Coverage.subPlan) ? obj.resource.Coverage.subPlan.value.toString() : &quot;&quot;);
	if (planCode)
		segIns[&apos;IN1.35&apos;] = planCode;

	// Policy Number
	var policyNumber = ((obj.resource.Coverage.plan) ? obj.resource.Coverage.plan.value.toString() : &quot;&quot;);
	if (policyNumber)
		segIns[&apos;IN1.36&apos;] = policyNumber;

	// Coverage Type
	segIns[&apos;IN1.47&apos;] = channelMap.get(&quot;CoverageType&quot;);


	if (coverage == &quot;T&quot;) {
		if (segIns[&apos;IN1.4&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Organization.name for IN1.4[Insurance Company Name] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.8&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.group for IN1.8[Group Number] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Person.name for IN1.16[Name Of Insured] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.relationship.code for IN1.17[Insured Relationship To Patient] is required if IN1.47[Coverage Type] is T&quot;);
		if (isContainedPerson &amp;&amp; !hasPersonAddress) error.push(&quot;resource.Coverage.contained.Person.address for IN1.19[Insured Address] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.36&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.plan for IN1.36[Policy Number] is required if IN1.47[Coverage Type] is T&quot;);		
	}


	// Store the segment to be later compiled into a message
	coverageMap.put(coverageType, segIns.toString());

	return;
}


/**
	Populates IN1.3 [Insurance Company ID] field with data from the contained Organization resource
	@param {Object} obj - Organization object resource
	@return - nothing, uses global HL7v2 message object
*/
function processInsuranceOrganization(segIns, item) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;

	if (item.Organization != null &amp;&amp; item.Organization != undefined) {

		isContainedOrganization = true;
		
		// Insurance Company ID
		var companyID = ((item.Organization.identifier) ? item.Organization.identifier.value.value.toString() : &quot;&quot;);
		if (companyID) 
			segIns[&apos;IN1.3&apos;] = companyID;
	
		// Insurance Company Name
		var companyName = ((item.Organization.name) ? item.Organization.name.value.toString() : &quot;&quot;);
		if (companyName)
			segIns[&apos;IN1.4&apos;] = companyName;

		// Insurance Company Address
		if (item.Organization.address) {
			var street = ((item.Organization.address.line) ? item.Organization.address.line.value.toString() : &quot;&quot;);
			if (street)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.1&apos;] = street;
				
			var city = ((item.Organization.address.city) ? item.Organization.address.city.value.toString() : &quot;&quot;);
			if (city)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.3&apos;] = city;
			
			var state = ((item.Organization.address.state) ? item.Organization.address.state.value.toString() : &quot;&quot;);
			if (state)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.4&apos;] = state;
		
			var postal = ((item.Organization.address.postalCode) ? item.Organization.address.postalCode.value.toString() : &quot;&quot;);
			if (postal)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.5&apos;] = postal;
		
			var country = ((item.Organization.address.country) ? item.Organization.address.country.value.toString() : &quot;&quot;);
			if (country)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.6&apos;] = country;

			// There might be a better definition what is required &quot;Insurance Company Address&quot;
			hasOrganizationAddress = (street || city || state || postal);						
		}		

		// Insurance Co Phone Number
		var phone = ((item.Organization.telecom) ? item.Organization.telecom.value.value.toString() : &quot;&quot;);
		if (phone) {
			hasPhone = true;
			segIns[&apos;IN1.7&apos;] = convertPhoneXTN(phone);
		}
	}

	// Validate conditional fields
	if (coverage == &quot;T&quot;) {		
		if (isContainedOrganization &amp;&amp; !hasOrganizationAddress) error.push(&quot;resource.Coverage.contained.Organization.address for IN1.5[Insurance Company Address] is required if IN1.47[Coverage Type] is T&quot;);
	}


	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>5</sequenceNumber>
                <name>GT1 segment</name>
                <script>/**
	Creates and populates GT1 [Guarantor] segment from the Person resource
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processGuarantor(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var gt1 = &lt;GT1&gt;
				&lt;GT1.1&gt;&lt;GT1.1.1&gt;1&lt;/GT1.1.1&gt;&lt;/GT1.1&gt;
				&lt;GT1.2/&gt;
				&lt;GT1.3&gt;&lt;GT1.3.1/&gt;&lt;GT1.3.2/&gt;&lt;/GT1.3&gt;
			&lt;/GT1&gt;;

	// Parse guarantor&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Person.name, true);
	gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;] = nameParts.family;
	if (nameParts.given1.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.2&apos;] = nameParts.given1;
	if (nameParts.given2.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.3&apos;] = nameParts.given2;	


	// Guarantor Address
	if (obj.resource.Person.address) {
		var street = ((obj.resource.Person.address.line) ? obj.resource.Person.address.line.value.toString() : &quot;&quot;);
		if (street)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.1&apos;] = street;
		
		var city = ((obj.resource.Person.address.city) ? obj.resource.Person.address.city.value.toString() : &quot;&quot;);
		if (city)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.3&apos;] = city;	
		
		var state = ((obj.resource.Person.address.state) ? obj.resource.Person.address.state.value.toString() : &quot;&quot;);
		if (state)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.4&apos;] = state;
	
		var postal = ((obj.resource.Person.address.postalCode) ? obj.resource.Person.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.5&apos;] = postal;
	
		var country = ((obj.resource.Person.address.country) ? obj.resource.Person.address.country.value.toString() : &quot;&quot;);
		if (country)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.6&apos;] = country;

		// There might be a better definition what is required &quot;guarantor address&quot;.
		hasAddress = (street || city || state || postal);			
	}


	// Guarantor Phon Number - Home
	var phone = ((obj.resource.Person.telecom) ? obj.resource.Person.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		gt1[&apos;GT1.6&apos;] = convertPhoneXTN(phone);
	}


	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Person.name for GT1.3[Guarantor Name] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasAddress) error.push(&quot;resource.Person.address for GT1.5[Guarantor Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Person.telecom for GT1.6[Guarantor Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);		
	}

	// Store the segment to be later compiled into a message
	guarantorMap.put(1, gt1.toString());

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Creates and populates GT1 [Guarantor] segment from the Person resource
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processGuarantor(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var gt1 = &lt;GT1&gt;
				&lt;GT1.1&gt;&lt;GT1.1.1&gt;1&lt;/GT1.1.1&gt;&lt;/GT1.1&gt;
				&lt;GT1.2/&gt;
				&lt;GT1.3&gt;&lt;GT1.3.1/&gt;&lt;GT1.3.2/&gt;&lt;/GT1.3&gt;
			&lt;/GT1&gt;;

	// Parse guarantor&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Person.name, true);
	gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;] = nameParts.family;
	if (nameParts.given1.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.2&apos;] = nameParts.given1;
	if (nameParts.given2.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.3&apos;] = nameParts.given2;	


	// Guarantor Address
	if (obj.resource.Person.address) {
		var street = ((obj.resource.Person.address.line) ? obj.resource.Person.address.line.value.toString() : &quot;&quot;);
		if (street)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.1&apos;] = street;
		
		var city = ((obj.resource.Person.address.city) ? obj.resource.Person.address.city.value.toString() : &quot;&quot;);
		if (city)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.3&apos;] = city;	
		
		var state = ((obj.resource.Person.address.state) ? obj.resource.Person.address.state.value.toString() : &quot;&quot;);
		if (state)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.4&apos;] = state;
	
		var postal = ((obj.resource.Person.address.postalCode) ? obj.resource.Person.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.5&apos;] = postal;
	
		var country = ((obj.resource.Person.address.country) ? obj.resource.Person.address.country.value.toString() : &quot;&quot;);
		if (country)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.6&apos;] = country;

		// There might be a better definition what is required &quot;guarantor address&quot;.
		hasAddress = (street || city || state || postal);			
	}


	// Guarantor Phon Number - Home
	var phone = ((obj.resource.Person.telecom) ? obj.resource.Person.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		gt1[&apos;GT1.6&apos;] = convertPhoneXTN(phone);
	}


	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Person.name for GT1.3[Guarantor Name] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasAddress) error.push(&quot;resource.Person.address for GT1.5[Guarantor Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Person.telecom for GT1.6[Guarantor Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);		
	}

	// Store the segment to be later compiled into a message
	guarantorMap.put(1, gt1.toString());

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>6</sequenceNumber>
                <name>ORC segment</name>
                <script>/**
	Populates ORC [Common Order] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticReport object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCommonOrder(obj) {


	var orc = &lt;ORC&gt;&lt;ORC.1&gt;&lt;ORC.1.1&gt;NW&lt;/ORC.1.1&gt;&lt;/ORC.1&gt;&lt;/ORC&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticReport.id) ? obj.resource.DiagnosticReport.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);

	logger.error( &quot;Group Count: &quot; + groupCount );
	logger.error( &quot;Group ID: &quot; + groupID );
			
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticReport.id element is undefined or not properly formatted, expected: ORC-common-order-n, where n identifies the order group&quot;);
	}


	// Placer Order Number
	// The value in ORC.02.01 (Entity Identifier) is the same as the value in OBR.02.01 (Entity Identifier)
	// All values for this field in all ORC and OBR segments are identical.
	// March 12: Moved into DiagnosticReport.identifier verified block 
	//var id = obj.resource.DiagnosticReport.identifier.value.value.toString();
	//if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;

	if (obj.resource.DiagnosticReport.identifier) {

		var id = ((obj.resource.DiagnosticReport.identifier.value.value) ? obj.resource.DiagnosticReport.identifier.value.value.toString():&quot;&quot;);
		if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;
		logger.error( &quot;Placer Number Order: &quot; + id );
		
		var namespaceID = ((obj.resource.DiagnosticReport.identifier.system) ? obj.resource.DiagnosticReport.identifier.system.value.toString() : &quot;&quot;);
		if (namespaceID) orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;] = namespaceID;
	
		var universalID = ((obj.resource.DiagnosticReport.identifier.type) ? obj.resource.DiagnosticReport.identifier.type.id.toString() : &quot;&quot;);
		if (universalID) orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;] = universalID;
	}
	else
	{
		logger.error( &quot;Missing identifier in in Diagnostic Report:&quot; + groupID )
	}


	// Store the Placer Order Number for the OBR segment
	var diagnosticOrderID = ((obj.resource.DiagnosticReport.request) ? obj.resource.DiagnosticReport.request.reference.value.toString() : &quot;&quot;);
	if (diagnosticOrderID.indexOf(&quot;DiagnosticOrder/&quot;) &gt; -1) {
		diagnosticOrderID = diagnosticOrderID.substring(&quot;DiagnosticOrder/&quot;.length, diagnosticOrderID.length);

		logger.error( &quot;DiagnosticOrderID: &quot; + diagnosticOrderID );
		
		var placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};

		placedOrderNumber.id = orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;].toString();
		placedOrderNumber.namespaceID = orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;].toString();
		placedOrderNumber.universalID = orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;].toString();
		placedOrderNumberMap.put(diagnosticOrderID, placedOrderNumber);		
	}
	else
	{
		logger.error( &quot;No Diagnostic Order Found&quot; );
	}


	// Verified By Practitioner
	if (obj.resource.DiagnosticReport.contained != null &amp;&amp; obj.resource.DiagnosticReport.contained != undefined) {
		var verifiedByID = obj.resource.DiagnosticReport.contained.Practitioner.identifier.value.value.toString();
		if (verifiedByID)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.1&apos;] = verifiedByID;
			
		var familyName = ((obj.resource.DiagnosticReport.contained.Practitioner.name) ? obj.resource.DiagnosticReport.contained.Practitioner.name.family.value.toString() : &quot;&quot;);
		if (familyName)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.2&apos;] = familyName;		
	}

	// Process extension for TQ1 [Timing/Quantity] segment
	if (obj.resource.DiagnosticReport.extension.valueTiming != null &amp;&amp; obj.resource.DiagnosticReport.extension.valueTiming != undefined) {
		processTimingQuantity(groupCount, obj.resource.DiagnosticReport.extension.valueTiming);
	}

	// Process zero or many DiagnosticReport/codedDiagnosis elements for DG1 [Diagnosis] segment
	var conditions = [];
	if (obj.resource.DiagnosticReport.codedDiagnosis) {

		if (obj.resource.DiagnosticReport.codedDiagnosis.length &gt; 0) {
			var setID = 1;
			obj.resource.DiagnosticReport.codedDiagnosis.forEach(function(item){
				// A maximum of 12 unique ICD-10 codes are permitted per entire OML message
				// (SN) This code checks only codedDiagnosis in a single DiagnosticReport
				if (setID &lt;= 12) conditions.push(processCondition(item, setID++));				 
			});
		} else {
			conditions.push(processCondition(obj.resource.DiagnosticReport.codedDiagnosis, 1)); 
		}
	}

	// Process zero or many result/reference elements for OBX [Observation] segment
	var observationReferences = [];
	if (obj.resource.DiagnosticReport.result) {
		var ref;
		if (obj.resource.DiagnosticReport.result.length &gt; 0) {
			obj.resource.DiagnosticReport.result.forEach(function(item){
				ref = item.reference.value.toString();
				if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
			});
		} else {
			ref = ((obj.resource.DiagnosticReport.result.reference != undefined) ? obj.resource.DiagnosticReport.result.reference.value.toString() : &quot;&quot;);
			if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
		}		
	}


	// ORC.12 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticReport.performer != undefined) ? obj.resource.DiagnosticReport.performer.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(&quot;Practitioner/&quot;.length, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) orc[&apos;ORC.12&apos;][&apos;ORC.12.1&apos;] = id;
	
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) orc[&apos;ORC.12&apos;][&apos;ORC.12.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			orc[&apos;ORC.12&apos;][&apos;ORC.12.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.4&apos;] = nameParts.given2;				
		}
	}
	

	// Store the segment to be later compiled into a message
	commonOrderMap.put(groupCount.toString(), orc.toString());

	// Store the array of diagnosis to be later compiled into a message
	if (conditions.length &gt; 0) diagnosisMap.put(groupCount.toString(), conditions);

	// Store the array of Observations to be later compiled into a message
	if (observationReferences.length &gt; 0) observationReferencesMap.put(groupCount.toString(), observationReferences);


	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates ORC [Common Order] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticReport object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCommonOrder(obj) {


	var orc = &lt;ORC&gt;&lt;ORC.1&gt;&lt;ORC.1.1&gt;NW&lt;/ORC.1.1&gt;&lt;/ORC.1&gt;&lt;/ORC&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticReport.id) ? obj.resource.DiagnosticReport.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);

	logger.error( &quot;Group Count: &quot; + groupCount );
	logger.error( &quot;Group ID: &quot; + groupID );
			
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticReport.id element is undefined or not properly formatted, expected: ORC-common-order-n, where n identifies the order group&quot;);
	}


	// Placer Order Number
	// The value in ORC.02.01 (Entity Identifier) is the same as the value in OBR.02.01 (Entity Identifier)
	// All values for this field in all ORC and OBR segments are identical.
	// March 12: Moved into DiagnosticReport.identifier verified block 
	//var id = obj.resource.DiagnosticReport.identifier.value.value.toString();
	//if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;

	if (obj.resource.DiagnosticReport.identifier) {

		var id = ((obj.resource.DiagnosticReport.identifier.value.value) ? obj.resource.DiagnosticReport.identifier.value.value.toString():&quot;&quot;);
		if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;
		logger.error( &quot;Placer Number Order: &quot; + id );
		
		var namespaceID = ((obj.resource.DiagnosticReport.identifier.system) ? obj.resource.DiagnosticReport.identifier.system.value.toString() : &quot;&quot;);
		if (namespaceID) orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;] = namespaceID;
	
		var universalID = ((obj.resource.DiagnosticReport.identifier.type) ? obj.resource.DiagnosticReport.identifier.type.id.toString() : &quot;&quot;);
		if (universalID) orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;] = universalID;
	}
	else
	{
		logger.error( &quot;Missing identifier in in Diagnostic Report:&quot; + groupID )
	}


	// Store the Placer Order Number for the OBR segment
	var diagnosticOrderID = ((obj.resource.DiagnosticReport.request) ? obj.resource.DiagnosticReport.request.reference.value.toString() : &quot;&quot;);
	if (diagnosticOrderID.indexOf(&quot;DiagnosticOrder/&quot;) &gt; -1) {
		diagnosticOrderID = diagnosticOrderID.substring(&quot;DiagnosticOrder/&quot;.length, diagnosticOrderID.length);

		logger.error( &quot;DiagnosticOrderID: &quot; + diagnosticOrderID );
		
		var placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};

		placedOrderNumber.id = orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;].toString();
		placedOrderNumber.namespaceID = orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;].toString();
		placedOrderNumber.universalID = orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;].toString();
		placedOrderNumberMap.put(diagnosticOrderID, placedOrderNumber);		
	}
	else
	{
		logger.error( &quot;No Diagnostic Order Found&quot; );
	}


	// Verified By Practitioner
	if (obj.resource.DiagnosticReport.contained != null &amp;&amp; obj.resource.DiagnosticReport.contained != undefined) {
		var verifiedByID = obj.resource.DiagnosticReport.contained.Practitioner.identifier.value.value.toString();
		if (verifiedByID)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.1&apos;] = verifiedByID;
			
		var familyName = ((obj.resource.DiagnosticReport.contained.Practitioner.name) ? obj.resource.DiagnosticReport.contained.Practitioner.name.family.value.toString() : &quot;&quot;);
		if (familyName)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.2&apos;] = familyName;		
	}

	// Process extension for TQ1 [Timing/Quantity] segment
	if (obj.resource.DiagnosticReport.extension.valueTiming != null &amp;&amp; obj.resource.DiagnosticReport.extension.valueTiming != undefined) {
		processTimingQuantity(groupCount, obj.resource.DiagnosticReport.extension.valueTiming);
	}

	// Process zero or many DiagnosticReport/codedDiagnosis elements for DG1 [Diagnosis] segment
	var conditions = [];
	if (obj.resource.DiagnosticReport.codedDiagnosis) {

		if (obj.resource.DiagnosticReport.codedDiagnosis.length &gt; 0) {
			var setID = 1;
			obj.resource.DiagnosticReport.codedDiagnosis.forEach(function(item){
				// A maximum of 12 unique ICD-10 codes are permitted per entire OML message
				// (SN) This code checks only codedDiagnosis in a single DiagnosticReport
				if (setID &lt;= 12) conditions.push(processCondition(item, setID++));				 
			});
		} else {
			conditions.push(processCondition(obj.resource.DiagnosticReport.codedDiagnosis, 1)); 
		}
	}

	// Process zero or many result/reference elements for OBX [Observation] segment
	var observationReferences = [];
	if (obj.resource.DiagnosticReport.result) {
		var ref;
		if (obj.resource.DiagnosticReport.result.length &gt; 0) {
			obj.resource.DiagnosticReport.result.forEach(function(item){
				ref = item.reference.value.toString();
				if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
			});
		} else {
			ref = ((obj.resource.DiagnosticReport.result.reference != undefined) ? obj.resource.DiagnosticReport.result.reference.value.toString() : &quot;&quot;);
			if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
		}		
	}


	// ORC.12 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticReport.performer != undefined) ? obj.resource.DiagnosticReport.performer.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(&quot;Practitioner/&quot;.length, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) orc[&apos;ORC.12&apos;][&apos;ORC.12.1&apos;] = id;
	
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) orc[&apos;ORC.12&apos;][&apos;ORC.12.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			orc[&apos;ORC.12&apos;][&apos;ORC.12.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.4&apos;] = nameParts.given2;				
		}
	}
	

	// Store the segment to be later compiled into a message
	commonOrderMap.put(groupCount.toString(), orc.toString());

	// Store the array of diagnosis to be later compiled into a message
	if (conditions.length &gt; 0) diagnosisMap.put(groupCount.toString(), conditions);

	// Store the array of Observations to be later compiled into a message
	if (observationReferences.length &gt; 0) observationReferencesMap.put(groupCount.toString(), observationReferences);


	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>7</sequenceNumber>
                <name>TQ1 segment</name>
                <script>/**
	Populates TQ1 [Timing/Quantity] segment with data from the DiagnosticReport extension
	@param {Integer} count - Common Order group count
	@param {Object} valueTiming - valueTiming extension
	@return - nothing, uses global map
*/
function processTimingQuantity(count, valueTiming) {
	
	// TQ1 [Timing/Quantity] segment
	if (valueTiming != null &amp;&amp; valueTiming != undefined) {

		var tq1 = &lt;TQ1&gt;&lt;TQ1.1&gt;&lt;TQ1.1.1&gt;1&lt;/TQ1.1.1&gt;&lt;/TQ1.1&gt;&lt;/TQ1&gt;;

		tq1[&apos;TQ1.1&apos;][&apos;TQ1.1.1&apos;] = count;
			
		var startDateTime = ((valueTiming.event) ? valueTiming.event.value.toString() : &quot;&quot;);
		if (startDateTime)
			tq1[&apos;TQ1.7&apos;] = convertJSONDateTime(startDateTime);

		var priorityCode = ((valueTiming.code) ? valueTiming.code.coding.code.value.toString() : &quot;&quot;);
		if (priorityCode)
			tq1[&apos;TQ1.9&apos;][&apos;TQ1.9.1&apos;] = priorityCode;
	}

	// Store the segment to be later compiled into a message
	timingQuantityMap.put(count.toString(), tq1.toString());

	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates TQ1 [Timing/Quantity] segment with data from the DiagnosticReport extension
	@param {Integer} count - Common Order group count
	@param {Object} valueTiming - valueTiming extension
	@return - nothing, uses global map
*/
function processTimingQuantity(count, valueTiming) {
	
	// TQ1 [Timing/Quantity] segment
	if (valueTiming != null &amp;&amp; valueTiming != undefined) {

		var tq1 = &lt;TQ1&gt;&lt;TQ1.1&gt;&lt;TQ1.1.1&gt;1&lt;/TQ1.1.1&gt;&lt;/TQ1.1&gt;&lt;/TQ1&gt;;

		tq1[&apos;TQ1.1&apos;][&apos;TQ1.1.1&apos;] = count;
			
		var startDateTime = ((valueTiming.event) ? valueTiming.event.value.toString() : &quot;&quot;);
		if (startDateTime)
			tq1[&apos;TQ1.7&apos;] = convertJSONDateTime(startDateTime);

		var priorityCode = ((valueTiming.code) ? valueTiming.code.coding.code.value.toString() : &quot;&quot;);
		if (priorityCode)
			tq1[&apos;TQ1.9&apos;][&apos;TQ1.9.1&apos;] = priorityCode;
	}

	// Store the segment to be later compiled into a message
	timingQuantityMap.put(count.toString(), tq1.toString());

	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>8</sequenceNumber>
                <name>OBR segment</name>
                <script>/**
	Populates OBR [Observation Request] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticOrder object resource
	@return - nothing, uses global HL7v2 message object
*/
function processObservationRequest(obj) {

	var comments = [];

	var obr = &lt;OBR&gt;&lt;OBR.1&gt;&lt;OBR.1.1&gt;1&lt;/OBR.1.1&gt;&lt;/OBR.1&gt;
				&lt;OBR.2/&gt;&lt;OBR.3/&gt;
				&lt;OBR.4&gt;&lt;OBR.4.1/&gt;&lt;OBR.4.2/&gt;&lt;OBR.4.3/&gt;&lt;OBR.4.4/&gt;&lt;OBR.4.5/&gt;&lt;/OBR.4&gt;
				&lt;OBR.5/&gt;&lt;OBR.6/&gt;&lt;OBR.7/&gt;&lt;OBR.8/&gt;&lt;OBR.9/&gt;
				&lt;OBR.10/&gt;&lt;OBR.11/&gt;&lt;OBR.12/&gt;&lt;OBR.13/&gt;&lt;OBR.14/&gt;&lt;OBR.15/&gt;
				&lt;OBR.16&gt;&lt;OBR.16.1/&gt;&lt;OBR.16.2/&gt;&lt;OBR.16.3/&gt;&lt;OBR.16.4/&gt;&lt;OBR.16.5/&gt;&lt;OBR.16.6/&gt;&lt;OBR.16.7/&gt;&lt;OBR.16.8/&gt;&lt;/OBR.16&gt;
			&lt;/OBR&gt;;


	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticOrder.id) ? obj.resource.DiagnosticOrder.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);
		
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticOrder.id element is undefined or not properly formatted, expected: OBR-observation-request-n, where n identifies the order group&quot;);
	}


	// OBR.2 [Placer Order Number] is stored during the DiagnosticReport resource processing	
	var resourceID = obj.resource.DiagnosticOrder.id.value.toString();
	// Extracts the following object - placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};
	var placedOrderNumber = placedOrderNumberMap.get(resourceID);
	if (placedOrderNumber) {
		if (placedOrderNumber.id) obr[&apos;OBR.2&apos;][&apos;OBR.2.1&apos;] = placedOrderNumber.id.toString();
		if (placedOrderNumber.namespaceID) obr[&apos;OBR.2&apos;][&apos;OBR.2.2&apos;] = placedOrderNumber.namespaceID.toStrign();
		if (placedOrderNumber.universalID) obr[&apos;OBR.2&apos;][&apos;OBR.2.3&apos;] = placedOrderNumber.universalID.toString();
	}
	

	// Universal Service Identifier	
	var alternateID = obj.resource.DiagnosticOrder.item.code.coding.code.value.toString();
	if (alternateID)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.4&apos;] = alternateID;

	var alternateText = obj.resource.DiagnosticOrder.item.code.coding.display.value.toString();
	if (alternateText)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.5&apos;] = alternateText;

	// Observation Date/Time	
	var observationDateTime = obj.resource.DiagnosticOrder.event.dateTime.value.toString();
	if (observationDateTime) {
		// Format : yyyymmddhhmm
		var specimenCollectionDate = convertJSONDateTime(observationDateTime);
		obr[&apos;OBR.7&apos;] = specimenCollectionDate.substring(0, 12);
	}

	// Specimen Action Code
	var actionCode = ((obj.resource.DiagnosticOrder.item.specimen) ? obj.resource.DiagnosticOrder.item.specimen.display.value.toString() : &quot;&quot;);
	if (actionCode)
		obr[&apos;OBR.11&apos;] = actionCode;

	// OBR.16 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticOrder.event.actor.reference != undefined) ? obj.resource.DiagnosticOrder.event.actor.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(13, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) obr[&apos;OBR.16&apos;][&apos;OBR.16.1&apos;] = id;
				
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) obr[&apos;OBR.16&apos;][&apos;OBR.16.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			obr[&apos;OBR.16&apos;][&apos;OBR.16.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.4&apos;] = nameParts.given2;			
		}
	}

	// Store the segment to be later compiled into a message
	observationRequestMap.put(groupCount.toString(), obr.toString());




	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.DiagnosticOrder.text &amp;&amp; obj.resource.DiagnosticOrder.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.DiagnosticOrder.text.div.p.length &amp;&amp; obj.resource.DiagnosticOrder.text.div.p.length &gt; 0) {
			obj.resource.DiagnosticOrder.text.div.p.forEach(function(item){
				// For internal (I) and report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
						
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
						// If the comment is other than internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.DiagnosticOrder.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.DiagnosticOrder.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.DiagnosticOrder.text.div.p, countNTE++));			
		}

		// Store the comments array to be later compiled into a message
		observationRequestCommentsMap.put(groupCount.toString(), comments);

	}


	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates OBR [Observation Request] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticOrder object resource
	@return - nothing, uses global HL7v2 message object
*/
function processObservationRequest(obj) {

	var comments = [];

	var obr = &lt;OBR&gt;&lt;OBR.1&gt;&lt;OBR.1.1&gt;1&lt;/OBR.1.1&gt;&lt;/OBR.1&gt;
				&lt;OBR.2/&gt;&lt;OBR.3/&gt;
				&lt;OBR.4&gt;&lt;OBR.4.1/&gt;&lt;OBR.4.2/&gt;&lt;OBR.4.3/&gt;&lt;OBR.4.4/&gt;&lt;OBR.4.5/&gt;&lt;/OBR.4&gt;
				&lt;OBR.5/&gt;&lt;OBR.6/&gt;&lt;OBR.7/&gt;&lt;OBR.8/&gt;&lt;OBR.9/&gt;
				&lt;OBR.10/&gt;&lt;OBR.11/&gt;&lt;OBR.12/&gt;&lt;OBR.13/&gt;&lt;OBR.14/&gt;&lt;OBR.15/&gt;
				&lt;OBR.16&gt;&lt;OBR.16.1/&gt;&lt;OBR.16.2/&gt;&lt;OBR.16.3/&gt;&lt;OBR.16.4/&gt;&lt;OBR.16.5/&gt;&lt;OBR.16.6/&gt;&lt;OBR.16.7/&gt;&lt;OBR.16.8/&gt;&lt;/OBR.16&gt;
			&lt;/OBR&gt;;


	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticOrder.id) ? obj.resource.DiagnosticOrder.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);
		
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticOrder.id element is undefined or not properly formatted, expected: OBR-observation-request-n, where n identifies the order group&quot;);
	}


	// OBR.2 [Placer Order Number] is stored during the DiagnosticReport resource processing	
	var resourceID = obj.resource.DiagnosticOrder.id.value.toString();
	// Extracts the following object - placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};
	var placedOrderNumber = placedOrderNumberMap.get(resourceID);
	if (placedOrderNumber) {
		if (placedOrderNumber.id) obr[&apos;OBR.2&apos;][&apos;OBR.2.1&apos;] = placedOrderNumber.id.toString();
		if (placedOrderNumber.namespaceID) obr[&apos;OBR.2&apos;][&apos;OBR.2.2&apos;] = placedOrderNumber.namespaceID.toStrign();
		if (placedOrderNumber.universalID) obr[&apos;OBR.2&apos;][&apos;OBR.2.3&apos;] = placedOrderNumber.universalID.toString();
	}
	

	// Universal Service Identifier	
	var alternateID = obj.resource.DiagnosticOrder.item.code.coding.code.value.toString();
	if (alternateID)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.4&apos;] = alternateID;

	var alternateText = obj.resource.DiagnosticOrder.item.code.coding.display.value.toString();
	if (alternateText)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.5&apos;] = alternateText;

	// Observation Date/Time	
	var observationDateTime = obj.resource.DiagnosticOrder.event.dateTime.value.toString();
	if (observationDateTime) {
		// Format : yyyymmddhhmm
		var specimenCollectionDate = convertJSONDateTime(observationDateTime);
		obr[&apos;OBR.7&apos;] = specimenCollectionDate.substring(0, 12);
	}

	// Specimen Action Code
	var actionCode = ((obj.resource.DiagnosticOrder.item.specimen) ? obj.resource.DiagnosticOrder.item.specimen.display.value.toString() : &quot;&quot;);
	if (actionCode)
		obr[&apos;OBR.11&apos;] = actionCode;

	// OBR.16 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticOrder.event.actor.reference != undefined) ? obj.resource.DiagnosticOrder.event.actor.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(13, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) obr[&apos;OBR.16&apos;][&apos;OBR.16.1&apos;] = id;
				
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) obr[&apos;OBR.16&apos;][&apos;OBR.16.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			obr[&apos;OBR.16&apos;][&apos;OBR.16.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.4&apos;] = nameParts.given2;			
		}
	}

	// Store the segment to be later compiled into a message
	observationRequestMap.put(groupCount.toString(), obr.toString());




	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.DiagnosticOrder.text &amp;&amp; obj.resource.DiagnosticOrder.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.DiagnosticOrder.text.div.p.length &amp;&amp; obj.resource.DiagnosticOrder.text.div.p.length &gt; 0) {
			obj.resource.DiagnosticOrder.text.div.p.forEach(function(item){
				// For internal (I) and report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
						
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
						// If the comment is other than internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.DiagnosticOrder.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.DiagnosticOrder.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.DiagnosticOrder.text.div.p, countNTE++));			
		}

		// Store the comments array to be later compiled into a message
		observationRequestCommentsMap.put(groupCount.toString(), comments);

	}


	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>9</sequenceNumber>
                <name>DG1 segment</name>
                <script>/**
	Populates DG1 [Diagnosis] segment from the Condition resource
	@param {Object} obj - Condition object resource
	@return {String} dg1 - DG1 segment serialized to string
*/
function processCondition(obj, setID) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);

	var dg1 = &lt;DG1&gt;
				&lt;DG1.1&gt;&lt;DG1.1.1&gt;1&lt;/DG1.1.1&gt;&lt;/DG1.1&gt;
				&lt;DG1.3&gt;&lt;DG1.3.1/&gt;&lt;DG1.3.2/&gt;&lt;DG1.3.3/&gt;&lt;DG1.3.4/&gt;&lt;/DG1.3&gt;
				&lt;DG1.6&gt;&lt;DG1.6.1&gt;F&lt;/DG1.6.1&gt;&lt;/DG1.6&gt;
			&lt;/DG1&gt;;

	dg1[&apos;DG1.1&apos;][&apos;DG1.1.1&apos;] = setID;

	// Diagnosis Code
	if (obj.coding) {
		if (obj.coding.length &gt; 0) {
			obj.coding.forEach(function(item){
	
				var code = ((item.code) ? item.code.value.toString() : &quot;&quot;);
				var system = item.system.value.toString().toLowerCase();
			
				if (system)
					if (system.indexOf(&quot;icd-10&quot;) &gt; -1) {
	
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
	
					var text = ((item.display) ? item.display.value.toString() : &quot;&quot;);
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
									
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
				} else {
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;] = code;
				}
			});
		} else {
			var code = ((obj.coding.code) ? obj.coding.code.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
			var text = ((obj.coding.display) ? obj.coding.display.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
		}
	}

	
	// DG1.6 [Diagnosis Type] - hard-coded, required by HL7v2.5.1, F - Final
	//dg1[&apos;DG1.6&apos;][&apos;DG1.6.1&apos;] = &quot;F&quot;;

	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;].toString() == &quot;&quot;) 
			error.push(&quot;resource.Condition.code for DG1.3[Diagnosis Code] is required if IN1.47[Coverage Type] is P or T&quot;);
	}

	return dg1.toString();
	
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates DG1 [Diagnosis] segment from the Condition resource
	@param {Object} obj - Condition object resource
	@return {String} dg1 - DG1 segment serialized to string
*/
function processCondition(obj, setID) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);

	var dg1 = &lt;DG1&gt;
				&lt;DG1.1&gt;&lt;DG1.1.1&gt;1&lt;/DG1.1.1&gt;&lt;/DG1.1&gt;
				&lt;DG1.3&gt;&lt;DG1.3.1/&gt;&lt;DG1.3.2/&gt;&lt;DG1.3.3/&gt;&lt;DG1.3.4/&gt;&lt;/DG1.3&gt;
				&lt;DG1.6&gt;&lt;DG1.6.1&gt;F&lt;/DG1.6.1&gt;&lt;/DG1.6&gt;
			&lt;/DG1&gt;;

	dg1[&apos;DG1.1&apos;][&apos;DG1.1.1&apos;] = setID;

	// Diagnosis Code
	if (obj.coding) {
		if (obj.coding.length &gt; 0) {
			obj.coding.forEach(function(item){
	
				var code = ((item.code) ? item.code.value.toString() : &quot;&quot;);
				var system = item.system.value.toString().toLowerCase();
			
				if (system)
					if (system.indexOf(&quot;icd-10&quot;) &gt; -1) {
	
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
	
					var text = ((item.display) ? item.display.value.toString() : &quot;&quot;);
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
									
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
				} else {
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;] = code;
				}
			});
		} else {
			var code = ((obj.coding.code) ? obj.coding.code.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
			var text = ((obj.coding.display) ? obj.coding.display.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
		}
	}

	
	// DG1.6 [Diagnosis Type] - hard-coded, required by HL7v2.5.1, F - Final
	//dg1[&apos;DG1.6&apos;][&apos;DG1.6.1&apos;] = &quot;F&quot;;

	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;].toString() == &quot;&quot;) 
			error.push(&quot;resource.Condition.code for DG1.3[Diagnosis Code] is required if IN1.47[Coverage Type] is P or T&quot;);
	}

	return dg1.toString();
	
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>10</sequenceNumber>
                <name>OBX segment</name>
                <script>/**
	Populates OBX [Observation/Result] segment from the Observation resource
	@param {Object} obj - Observation object resource
	@return {String} obx - OBX segment serialized to string
*/
function processObservation(obj) {

	var obx =	&lt;OBX&gt;
				&lt;OBX.1&gt;&lt;OBX.1.1/&gt;&lt;/OBX.1&gt;
				&lt;OBX.2&gt;&lt;OBX.2.1/&gt;&lt;/OBX.2&gt;
				&lt;OBX.3&gt;&lt;OBX.3.1/&gt;&lt;OBX.3.2/&gt;&lt;OBX.3.3/&gt;&lt;OBX.3.4/&gt;&lt;OBX.3.5/&gt;&lt;OBX.3.6/&gt;&lt;/OBX.3&gt;
				&lt;OBX.4/&gt;
				&lt;OBX.5&gt;&lt;OBX.5.1/&gt;&lt;/OBX.5&gt;
				&lt;OBX.11&gt;&lt;OBX.11.1&gt;P&lt;/OBX.11.1&gt;&lt;/OBX.11&gt;
			&lt;/OBX&gt;;


	var id = obj.resource.Observation.id.value.toString();
	obx[&apos;OBX.1&apos;][&apos;OBX.1.1&apos;] = id.substring(&quot;OBX-observation-&quot;.length, id.length);

	// Contains a value that reports the results for an AOE
	if (obj.resource.Observation.code) {
		// local code
		var code = obj.resource.Observation.code.coding.code.value.toString();		
		obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;] = code;
		
		// Local description
		var description = obj.resource.Observation.code.coding.display.value.toString();
		obx[&apos;OBX.3&apos;][&apos;OBX.3.5&apos;] = description;

		// Code system - Optional
		if (obj.resource.Observation.code.coding.system != undefined) {
			var codeSystem = obj.resource.Observation.code.coding.system.value.toString();
			if (codeSystem.toLowerCase().indexOf(&quot;snomed&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;SCT&quot;;
			else if (codeSystem.toLowerCase().indexOf(&quot;loinc&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;LN&quot;;
			else 
				delete obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;];
		}
		
	}


	// If valueString is used, expected that the answer is always a string, therefore OBX.2 [Value Type] is hard-coded to &quot;ST&quot;
	if (obj.resource.Observation.valueString) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;ST&quot;;

		var aoe = obj.resource.Observation.valueString.value.toString();
		if (aoe) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = aoe;		

	// If valueQuantity is used the OBX.2 [Value Type] is hard-coded to &quot;NM&quot;	
	} else if (obj.resource.Observation.valueQuantity) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;NM&quot;;		
		var quantity = obj.resource.Observation.valueQuantity.value.value.toString();
		if (quantity) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = quantity;
	}
	

	// Observation Result Status - not required by Quest
	// Hard-coded to &quot;P&quot; - Preliminary


	// OBX level comments (Issue #17)
	var observationComments = [];

	// Iterate over all possible comment entries in /text/div/p  (also see Issue #17)
	if (obj.resource.Observation.text &amp;&amp; obj.resource.Observation.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;,&quot;&quot;]; // Optional source of comment

		if (obj.resource.Observation.text.div.p.length != undefined &amp;&amp; obj.resource.Observation.text.div.p.length &gt; 0) {
			// Several comments from any acceptable sources
			obj.resource.Observation.text.div.p.forEach(function(item){
				if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					observationComments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.Observation.text.div.p) {
			// A single comment from any acceptable source
			if (sourceOfComment.indexOf(obj.resource.Observation.text.div.p.class.toString()) &gt; -1) {
				observationComments.push(getNTESegment(obj.resource.Observation.text.div.p, countNTE++));
			}			
		}
	}

	observationMap.put(id, obx.toString());
	observationCommentsMap.put(id, observationComments);
	
	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>/**
	Populates OBX [Observation/Result] segment from the Observation resource
	@param {Object} obj - Observation object resource
	@return {String} obx - OBX segment serialized to string
*/
function processObservation(obj) {

	var obx =	&lt;OBX&gt;
				&lt;OBX.1&gt;&lt;OBX.1.1/&gt;&lt;/OBX.1&gt;
				&lt;OBX.2&gt;&lt;OBX.2.1/&gt;&lt;/OBX.2&gt;
				&lt;OBX.3&gt;&lt;OBX.3.1/&gt;&lt;OBX.3.2/&gt;&lt;OBX.3.3/&gt;&lt;OBX.3.4/&gt;&lt;OBX.3.5/&gt;&lt;OBX.3.6/&gt;&lt;/OBX.3&gt;
				&lt;OBX.4/&gt;
				&lt;OBX.5&gt;&lt;OBX.5.1/&gt;&lt;/OBX.5&gt;
				&lt;OBX.11&gt;&lt;OBX.11.1&gt;P&lt;/OBX.11.1&gt;&lt;/OBX.11&gt;
			&lt;/OBX&gt;;


	var id = obj.resource.Observation.id.value.toString();
	obx[&apos;OBX.1&apos;][&apos;OBX.1.1&apos;] = id.substring(&quot;OBX-observation-&quot;.length, id.length);

	// Contains a value that reports the results for an AOE
	if (obj.resource.Observation.code) {
		// local code
		var code = obj.resource.Observation.code.coding.code.value.toString();		
		obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;] = code;
		
		// Local description
		var description = obj.resource.Observation.code.coding.display.value.toString();
		obx[&apos;OBX.3&apos;][&apos;OBX.3.5&apos;] = description;

		// Code system - Optional
		if (obj.resource.Observation.code.coding.system != undefined) {
			var codeSystem = obj.resource.Observation.code.coding.system.value.toString();
			if (codeSystem.toLowerCase().indexOf(&quot;snomed&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;SCT&quot;;
			else if (codeSystem.toLowerCase().indexOf(&quot;loinc&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;LN&quot;;
			else 
				delete obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;];
		}
		
	}


	// If valueString is used, expected that the answer is always a string, therefore OBX.2 [Value Type] is hard-coded to &quot;ST&quot;
	if (obj.resource.Observation.valueString) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;ST&quot;;

		var aoe = obj.resource.Observation.valueString.value.toString();
		if (aoe) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = aoe;		

	// If valueQuantity is used the OBX.2 [Value Type] is hard-coded to &quot;NM&quot;	
	} else if (obj.resource.Observation.valueQuantity) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;NM&quot;;		
		var quantity = obj.resource.Observation.valueQuantity.value.value.toString();
		if (quantity) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = quantity;
	}
	

	// Observation Result Status - not required by Quest
	// Hard-coded to &quot;P&quot; - Preliminary


	// OBX level comments (Issue #17)
	var observationComments = [];

	// Iterate over all possible comment entries in /text/div/p  (also see Issue #17)
	if (obj.resource.Observation.text &amp;&amp; obj.resource.Observation.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;,&quot;&quot;]; // Optional source of comment

		if (obj.resource.Observation.text.div.p.length != undefined &amp;&amp; obj.resource.Observation.text.div.p.length &gt; 0) {
			// Several comments from any acceptable sources
			obj.resource.Observation.text.div.p.forEach(function(item){
				if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					observationComments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.Observation.text.div.p) {
			// A single comment from any acceptable source
			if (sourceOfComment.indexOf(obj.resource.Observation.text.div.p.class.toString()) &gt; -1) {
				observationComments.push(getNTESegment(obj.resource.Observation.text.div.p, countNTE++));
			}			
		}
	}

	observationMap.put(id, obx.toString());
	observationCommentsMap.put(id, observationComments);
	
	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>11</sequenceNumber>
                <name>Check for issues</name>
                <script>// Use fixHL7NodeOrder() to fix a possible node order issue 
// see http://www.mirthcorp.com/community/issues/browse/MIRTH-625

var messages = {request: &quot;&quot;, resp: &quot;&quot;};
messages.request = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(fixHL7NodeOrder(oml));

channelMap.put(&quot;omlHL7&quot;, messages.request); // testing
channelMap.put(&quot;error&quot;, error); // testing

logger.debug(&quot;SubmitOrder: Destination - &quot; + messages.request);


// Verify for errors 
if (error.length &gt; 0) {

	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));

	// To be sent to original feed submitter
	responseMap.put(&quot;Outcome&quot;, outcome);

	// Nothing to send to DEX
	channelMap.put(&quot;RequestMessage&quot;, null);
	
} else {

	// Temporary save the OML_O21 message for the next destination to process

//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!	
	channelMap.put(&quot;RequestMessage&quot;, null);
	//var info = {severity: &quot;Information&quot;, code: &quot;Information&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	//(AM) operation outcome mapping expects lowercase; code is &apos;informational&apos; not &apos;information&apos;
	var info = {severity: &quot;information&quot;, code: &quot;informational&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	outcome = getOperationOutcome(error, info, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));	
	responseMap.put(&quot;Outcome&quot;, outcome);

	logger.info(&quot;sent done&quot;);
//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!

	// (SN) Enable this line to actually submit the SubmitOrder request
	channelMap.put(&quot;RequestMessage&quot;, messages.request);
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>// Use fixHL7NodeOrder() to fix a possible node order issue 
// see http://www.mirthcorp.com/community/issues/browse/MIRTH-625

var messages = {request: &quot;&quot;, resp: &quot;&quot;};
messages.request = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(fixHL7NodeOrder(oml));

channelMap.put(&quot;omlHL7&quot;, messages.request); // testing
channelMap.put(&quot;error&quot;, error); // testing

logger.debug(&quot;SubmitOrder: Destination - &quot; + messages.request);


// Verify for errors 
if (error.length &gt; 0) {

	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));

	// To be sent to original feed submitter
	responseMap.put(&quot;Outcome&quot;, outcome);

	// Nothing to send to DEX
	channelMap.put(&quot;RequestMessage&quot;, null);
	
} else {

	// Temporary save the OML_O21 message for the next destination to process

//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!	
	channelMap.put(&quot;RequestMessage&quot;, null);
	//var info = {severity: &quot;Information&quot;, code: &quot;Information&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	//(AM) operation outcome mapping expects lowercase; code is &apos;informational&apos; not &apos;information&apos;
	var info = {severity: &quot;information&quot;, code: &quot;informational&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	outcome = getOperationOutcome(error, info, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));	
	responseMap.put(&quot;Outcome&quot;, outcome);

	logger.info(&quot;sent done&quot;);
//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!

	// (SN) Enable this line to actually submit the SubmitOrder request
	channelMap.put(&quot;RequestMessage&quot;, messages.request);
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>true</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>HL7V2</inboundDataType>
            <outboundDataType>HL7V2</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
                <handleRepetitions>true</handleRepetitions>
                <handleSubcomponents>true</handleSubcomponents>
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <stripNamespaces>true</stripNamespaces>
                <segmentDelimiter>\r</segmentDelimiter>
                <convertLineBreaks>true</convertLineBreaks>
              </serializationProperties>
              <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
                <useStrictParser>false</useStrictParser>
                <useStrictValidation>false</useStrictValidation>
                <segmentDelimiter>\r</segmentDelimiter>
              </deserializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
                <splitType>MSH_Segment</splitType>
                <batchScript></batchScript>
              </batchProperties>
              <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
                <segmentDelimiter>\r</segmentDelimiter>
                <successfulACKCode>AA</successfulACKCode>
                <successfulACKMessage></successfulACKMessage>
                <errorACKCode>AE</errorACKCode>
                <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
                <rejectedACKCode>AR</rejectedACKCode>
                <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
                <msh15ACKAccept>false</msh15ACKAccept>
                <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
              </responseGenerationProperties>
              <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
                <successfulACKCode>AA,CA</successfulACKCode>
                <errorACKCode>AE,CE</errorACKCode>
                <rejectedACKCode>AR,CR</rejectedACKCode>
                <validateMessageControlId>true</validateMessageControlId>
                <originalMessageControlId>Destination_Encoded</originalMessageControlId>
                <originalIdMapVariable></originalIdMapVariable>
              </responseValidationProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>JavaScript Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>true</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
        <connector version="3.4.2">
          <metaDataId>1</metaDataId>
          <name>Submit Order WS</name>
          <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
            <pluginProperties/>
            <destinationConnectorProperties version="3.4.2">
              <queueEnabled>false</queueEnabled>
              <sendFirst>false</sendFirst>
              <retryIntervalMillis>10000</retryIntervalMillis>
              <regenerateTemplate>false</regenerateTemplate>
              <retryCount>0</retryCount>
              <rotate>false</rotate>
              <includeFilterTransformer>false</includeFilterTransformer>
              <threadCount>1</threadCount>
              <threadAssignmentVariable></threadAssignmentVariable>
              <validateResponse>false</validateResponse>
              <resourceIds class="linked-hash-map">
                <entry>
                  <string>Default Resource</string>
                  <string>[Default Resource]</string>
                </entry>
              </resourceIds>
              <queueBufferSize>1000</queueBufferSize>
            </destinationConnectorProperties>
            <channelId>none</channelId>
            <channelTemplate>${message.encodedData}</channelTemplate>
            <mapVariables/>
          </properties>
          <transformer version="3.4.2">
            <steps>
              <step>
                <sequenceNumber>0</sequenceNumber>
                <name>SOAP query</name>
                <script>var 	submitOrderSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
				   &lt;soapenv:Header/&gt;
				   &lt;soapenv:Body&gt;
				      &lt;ord:submitOrder&gt;
				         &lt;ord:SubmitOrderRequest&gt;
				            &lt;hl7Order&gt;OML_O21&lt;/hl7Order&gt;
				         &lt;/ord:SubmitOrderRequest&gt;
				      &lt;/ord:submitOrder&gt;
				   &lt;/soapenv:Body&gt;
				&lt;/soapenv:Envelope&gt;;

var oml = channelMap.get(&quot;RequestMessage&quot;);
if (oml != null &amp;&amp; oml.toString().length() &gt; 0) {
		
	var bytes = new java.lang.String(oml.toString()).getBytes();
	submitOrderSoap.*::Body.*::submitOrder.*::SubmitOrderRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

} else {
	submitOrderSoap = &quot;&quot;;
	return;
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var 	submitOrderSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
				   &lt;soapenv:Header/&gt;
				   &lt;soapenv:Body&gt;
				      &lt;ord:submitOrder&gt;
				         &lt;ord:SubmitOrderRequest&gt;
				            &lt;hl7Order&gt;OML_O21&lt;/hl7Order&gt;
				         &lt;/ord:SubmitOrderRequest&gt;
				      &lt;/ord:submitOrder&gt;
				   &lt;/soapenv:Body&gt;
				&lt;/soapenv:Envelope&gt;;

var oml = channelMap.get(&quot;RequestMessage&quot;);
if (oml != null &amp;&amp; oml.toString().length() &gt; 0) {
		
	var bytes = new java.lang.String(oml.toString()).getBytes();
	submitOrderSoap.*::Body.*::submitOrder.*::SubmitOrderRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

} else {
	submitOrderSoap = &quot;&quot;;
	return;
}</string>
                  </entry>
                </data>
              </step>
              <step>
                <sequenceNumber>1</sequenceNumber>
                <name>POST request</name>
                <script>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null &amp;&amp; submitOrderSoap.toString().length &gt; 0) try {
	var error = [];
	var messages = {request: submitOrderSoap.toString(), resp: &quot;&quot;};
	var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};
	sslClient.setURL( $cfg(&quot;submitOrderURL&quot;) );
	sslClient.setSOAPRequest(submitOrderSoap);
	// Submit the request
	var httpCode = sslClient.doPost();

logger.debug (&quot;httpCode is &quot; + httpCode);
	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));
logger.debug (&quot;soapResp is &quot; + soapResp);
	if (200 == httpCode) {

		var orderACK = soapResp.*::Body.*::submitOrderResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String(FileUtil.decode(orderACK));
		messages.resp = ackHL7;
		
		var ack = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(ackHL7));
		channelMap.put(&quot;HL7ACK&quot;, ackHL7);
		// Check Acknowledgment Code: AA - Accept, AE - Error
		if (ack[&apos;MSA&apos;][&apos;MSA.1&apos;][&apos;MSA.1.1&apos;].toString() == &quot;AA&quot;) {
			issue.severity = &quot;information&quot;;
			issue.code = &quot;informational&quot;;
			issue.details = &quot;SUCCESS&quot;;			
		} else {
			// Acknowledgment Code == AE or anything else 
			issue.severity = &quot;error&quot;;
			issue.code = &quot;processing&quot;;
			issue.details = &quot;Order was not successfully processed&quot;;		
			error = ack[&apos;MSA&apos;][&apos;MSA.6&apos;][&apos;MSA.6.2&apos;].toString().split(&quot;,&quot;);	
		} 
		 
	} else {
		// HTTP code is not 200 OK
		issue.severity = &quot;error&quot;;
		issue.code = &quot;processing&quot;;
		issue.details = &quot;HTTP Code: &quot; + httpCode;
	}	
	
} catch(ex) {
	
	issue.severity = &quot;fatal&quot;;
	issue.code = &quot;exception&quot;;
	issue.details = &quot;SubmitOrder WS Transformer: &quot; + ex;
		
} finally {

	// Return submission results
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	responseMap.put(&quot;Outcome&quot;, outcome);
//	logger.debug(&quot;Outcome (Submit Order WS): &quot; + outcome);
}</script>
                <type>JavaScript</type>
                <data>
                  <entry>
                    <string>Script</string>
                    <string>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null &amp;&amp; submitOrderSoap.toString().length &gt; 0) try {
	var error = [];
	var messages = {request: submitOrderSoap.toString(), resp: &quot;&quot;};
	var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};
	sslClient.setURL( $cfg(&quot;submitOrderURL&quot;) );
	sslClient.setSOAPRequest(submitOrderSoap);
	// Submit the request
	var httpCode = sslClient.doPost();

logger.debug (&quot;httpCode is &quot; + httpCode);
	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));
logger.debug (&quot;soapResp is &quot; + soapResp);
	if (200 == httpCode) {

		var orderACK = soapResp.*::Body.*::submitOrderResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String(FileUtil.decode(orderACK));
		messages.resp = ackHL7;
		
		var ack = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(ackHL7));
		channelMap.put(&quot;HL7ACK&quot;, ackHL7);
		// Check Acknowledgment Code: AA - Accept, AE - Error
		if (ack[&apos;MSA&apos;][&apos;MSA.1&apos;][&apos;MSA.1.1&apos;].toString() == &quot;AA&quot;) {
			issue.severity = &quot;information&quot;;
			issue.code = &quot;informational&quot;;
			issue.details = &quot;SUCCESS&quot;;			
		} else {
			// Acknowledgment Code == AE or anything else 
			issue.severity = &quot;error&quot;;
			issue.code = &quot;processing&quot;;
			issue.details = &quot;Order was not successfully processed&quot;;		
			error = ack[&apos;MSA&apos;][&apos;MSA.6&apos;][&apos;MSA.6.2&apos;].toString().split(&quot;,&quot;);	
		} 
		 
	} else {
		// HTTP code is not 200 OK
		issue.severity = &quot;error&quot;;
		issue.code = &quot;processing&quot;;
		issue.details = &quot;HTTP Code: &quot; + httpCode;
	}	
	
} catch(ex) {
	
	issue.severity = &quot;fatal&quot;;
	issue.code = &quot;exception&quot;;
	issue.details = &quot;SubmitOrder WS Transformer: &quot; + ex;
		
} finally {

	// Return submission results
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	responseMap.put(&quot;Outcome&quot;, outcome);
//	logger.debug(&quot;Outcome (Submit Order WS): &quot; + outcome);
}</string>
                  </entry>
                </data>
              </step>
            </steps>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>JSON</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
              <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
                <splitType>JavaScript</splitType>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </transformer>
          <responseTransformer version="3.4.2">
            <steps/>
            <inboundTemplate encoding="base64"></inboundTemplate>
            <outboundTemplate encoding="base64"></outboundTemplate>
            <inboundDataType>XML</inboundDataType>
            <outboundDataType>XML</outboundDataType>
            <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </inboundProperties>
            <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
              <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
                <stripNamespaces>false</stripNamespaces>
              </serializationProperties>
              <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
                <splitType>Element_Name</splitType>
                <elementName></elementName>
                <level>1</level>
                <query></query>
                <batchScript></batchScript>
              </batchProperties>
            </outboundProperties>
          </responseTransformer>
          <filter version="3.4.2">
            <rules/>
          </filter>
          <transportName>Channel Writer</transportName>
          <mode>DESTINATION</mode>
          <enabled>false</enabled>
          <waitForPrevious>true</waitForPrevious>
        </connector>
      </destinationConnectors>
      <preprocessingScript>// Modify the message variable below to pre process data

// Delete some characters that may break JSON to XML parsing
message = message.replace(/null/g,&apos;&quot;&quot;&apos;);
message = message.replace(/&amp;/g,&quot;&amp;amp;&quot;); // ampersand
message = message.replace(/&lt;/g,&quot;&amp;lt;&quot;);  // less than
message = message.replace(/&gt;/g,&quot;&amp;gt;&quot;);  // greater than
message = message.replace(/&quot;&quot;&quot;&quot;/g,&apos;&quot;&quot;&apos;); // quotes around quotes

return message;</preprocessingScript>
      <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
      <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

// Format of the OperationOutcome. Supported: &quot;XML&quot; or &quot;JSON&quot;
globalChannelMap.put(&quot;outcomeFormat&quot;, &quot;XML&quot;);

// Prepare SSL Client to access submitOrder Conformance Environment
if (globalMap.containsKey(&quot;sslClient&quot;) &amp;&amp; globalMap.get(&quot;sslClient&quot;)) 
	try {

		var sslClient = new Packages.org.safemovement.DEXSSLClient();		
		sslClient.setAuthorizationType(org.safemovement.DEXSSLClient.Authorization.BASIC);
		sslClient.setContentType(&quot;text/xml;charset=UTF-8&quot;);
		sslClient.setUserName($(&quot;username&quot;));
		sslClient.setUserPassword($(&quot;userpsw&quot;));		
		sslClient.setConnectionType(&quot;Close&quot;);
		
		globalChannelMap.put(&quot;sslClientClass&quot;, sslClient);
		
	} catch(ex) {
		logger.error(&quot;SubmitOrder: Deploy - cannot initialize SSLClient - &quot; + ex);
		
		// Stop this channel to resolve the problem
		ChannelUtil.stopChannel(channelId);
		throw (&quot;SubmitOrder: Deploy - cannot initialize SSLClient - &quot; + ex);		
	}



return;</deployScript>
      <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data

if (globalChannelMap.containsKey(&quot;sslClientClass&quot;)){
	globalChannelMap.remove(&quot;sslClientClass&quot;);
}


return;</undeployScript>
      <properties version="3.4.2">
        <clearGlobalChannelMap>true</clearGlobalChannelMap>
        <messageStorageMode>DEVELOPMENT</messageStorageMode>
        <encryptData>false</encryptData>
        <removeContentOnCompletion>false</removeContentOnCompletion>
        <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
        <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
        <initialState>STARTED</initialState>
        <storeAttachments>false</storeAttachments>
        <tags class="linked-hash-set"/>
        <metaDataColumns>
          <metaDataColumn>
            <name>SOURCE</name>
            <type>STRING</type>
            <mappingName>mirth_source</mappingName>
          </metaDataColumn>
          <metaDataColumn>
            <name>TYPE</name>
            <type>STRING</type>
            <mappingName>mirth_type</mappingName>
          </metaDataColumn>
        </metaDataColumns>
        <attachmentProperties version="3.4.2">
          <type>None</type>
          <properties/>
        </attachmentProperties>
        <archiveEnabled>true</archiveEnabled>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
      </properties>
      <codeTemplateLibraries/>
    </channel>
  </channels>
  <alerts/>
  <codeTemplateLibraries>
    <codeTemplateLibrary version="3.4.2">
      <id>aa9b2404-fbde-4bbe-851f-a0a19ca6ae36</id>
      <name>DEX Library</name>
      <revision>5</revision>
      <lastModified>
        <time>1493415645281</time>
        <timezone>UTC</timezone>
      </lastModified>
      <description>Last updated: March 25, 2017</description>
      <includeNewChannels>true</includeNewChannels>
      <enabledChannelIds>
        <string>b73a73d9-b589-4dd7-8a5b-d24fe9ed522d</string>
        <string>afa52ba3-bd0a-4634-8ae5-b9c91c4dc3b9</string>
        <string>9eeed45d-4613-4501-86f1-236e91808742</string>
        <string>4c7bc0bd-aede-4e90-9ce8-cde50750f1e8</string>
        <string>041540bc-16e7-43fe-a9eb-1ca3c5ea17db</string>
        <string>ae149084-1aaa-4867-a7e3-b66860874f05</string>
        <string>829fe0c9-9229-4cb3-9cc3-1250213f284f</string>
        <string>e0f422e1-0550-40f1-8a37-e148e0b5f636</string>
      </enabledChannelIds>
      <disabledChannelIds>
        <string>f24a2bfd-8f45-4170-b6d6-6410f426ec66</string>
      </disabledChannelIds>
      <codeTemplates>
        <codeTemplate version="3.4.2">
          <id>5e2f9cc3-3b23-4967-9fd1-6a9c602dd29e</id>
          <name>Convert FHIR to HL7v2 code</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077779</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts FHIR code to HL7v2 code as defined by the conversion table according to the HL7v2 specification

	@param {String} table - HL7v2 Table code as per specification
	@param {String] value - value to convert
	@return {String} return code according to conversion table
*/
function convertTable(table, value) {

	switch(table) {
		
		// Table 0001 - Administrative Sex
		case &quot;0001&quot;:
			if (value.toString() == &quot;male&quot;) return &quot;M&quot;
			else if (value.toString() == &quot;female&quot;) return &quot;F&quot;
			else if (value.toString() == &quot;other&quot;) return &quot;O&quot;
			else return &quot;U&quot;;
			break;
	}

	return &quot;&quot;;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>025ece06-d4ad-47d7-8047-67acaf3072a5</id>
          <name>Convert HL7 Date Time</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077689</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts date, time and time zone from HL7v2 to ISO 8601 (JSON) format.
	Possible input string format: yyyymmddhhmm[ss[.s[s[s[s]]]]][+/-zzzz]

	@param {String} date - datetime to be converted
	@return {String} return JSON representation of the datetime
*/
function convertHL7DateTime(datetime) {

/*
	Format: yyyymmddhhmm[ss[.s[s[s[s]]]]][+/-zzzz]
	The date and time elements are populated as follows:
	yyyy = Required
	mm = Required if yyyy is not 0000.
	dd = Required if yyyy is not 0000.
	hh = Required if yyyy is not 0000.
	mm = Required if yyyy is not 0000.
	[ss[.s[s[s[s]]]]] = Conditional. Optional if yyyy is not 0000.
	[+/-zzzz] = Optional
*/


	if (datetime == null || datetime.length == 0 || typeof datetime === &quot;undefined&quot;) return &quot;&quot;;

	try {
		var strDateTime = new Packages.java.lang.StringBuffer(datetime.toString());
	
		// Extract time zone
		var index;
		var symbol;
		var timeZone;
		
		if (strDateTime.indexOf(&quot;-&quot;) &gt; 0) {
			index = strDateTime.indexOf(&quot;-&quot;);
		} else if (strDateTime.indexOf(&quot;+&quot;) &gt; 0) {
			index = strDateTime.indexOf(&quot;+&quot;);
		} else
			index = -1;
	
		if (index &gt; 0) {		
			symbol = strDateTime.substring(index, index+1);
			timeZone = new Packages.java.lang.StringBuffer(strDateTime.substring(index+1));
			if (timeZone.length() &gt; 2)
				timeZone.insert(2,&quot;:&quot;);
			strDateTime.delete(index, strDateTime.length());		
		} else {
			symbol = &quot;&quot;;
			timeZone = &quot;&quot;;
		}
	
		// Extract decimal fraction of a second
		var fraction = strDateTime.indexOf(&quot;.&quot;);
		var milliseconds;
		if (fraction &gt; 0) {
			milliseconds = strDateTime.substring(fraction, strDateTime.length());
			strDateTime.delete(fraction, strDateTime.length());
		} else {
			milliseconds = &quot;&quot;;
		}
	
		// Convert the main part
		var jsonDateTime = new Packages.java.lang.StringBuffer(strDateTime);
		
		// yyyyMMdd
		if (strDateTime.length() &gt;= &quot;yyyyMMdd&quot;.length) {
			jsonDateTime.insert(4,&quot;-&quot;);
			jsonDateTime.insert(7,&quot;-&quot;);
		}
	
		// yyyyMMddhh
		if (strDateTime.length() &gt;= &quot;yyyyMMddhh&quot;.length) {
			jsonDateTime.insert(10,&quot;T&quot;);
		}
	
		// yyyyMMddhhmm
		if (strDateTime.length() &gt;= &quot;yyyyMMddhhmm&quot;.length) {
			jsonDateTime.insert(13,&quot;:&quot;);
			
		}
		
		// yyyymmddhhmmss
		if (strDateTime.length() &gt;= &quot;yyyymmddhhmmss&quot;.length) {
			jsonDateTime.insert(16,&quot;:&quot;);		
		}
	
	} catch(ex) {
		jsonDateTime = &quot;0000-00-00&quot;
		milliseconds = &quot;&quot;;
		symbol = &quot;&quot;;
		timeZone = &quot;&quot;;
		logger.error(&quot;convertHL7DateTime(&quot; + datetime + &quot;) exception: &quot; + ex);	
	} finally {
		return jsonDateTime.toString() + milliseconds.toString() + symbol.toString() + timeZone.toString();
	}
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>3d9a32c6-2d37-49d2-afe4-e309356085b7</id>
          <name>Convert JSON Date Time</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609078075</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts date, time and time zone from ISO 8601 (JSON) to HL7v2 format.
	Possible input string format: yyyy-mm-ddThh:mm:ss.nnnnnn+|-hh:mm

	@param {String} date - datetime to be converted
	@return {String} return HL7v2 representation of the datetime
*/
function convertJSONDateTime(datetime) {

/*
	Format: yyyy-mm-dd[Thh:mm[:ss[.nnnnnn[+|-hh:mm]]]]
*/

	var date;
	var time;
	
	var arrDateTime = datetime.split(&quot;T&quot;);
	
	if (arrDateTime.length == 1) {
		date = arrDateTime[0];
		time = &quot;&quot;;
	} else if (arrDateTime.length == 2) {
		date = arrDateTime[0];
		time = arrDateTime[1];
	} else 
		return &quot;&quot;;

	date = date.replace(/\-/g, &quot;&quot;);
	time = time.replace(/\:/g, &quot;&quot;);

	return date + time;

}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>a758235b-06a9-4c9d-8256-e9cd70d38bb1</id>
          <name>Convert Phone</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077936</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Inserts hyphens into the phone number if it is 7 digits in length

	@param {String} phone - initial string to convert
	@return {String} return phone number
*/
function convertPhone(phone) {

	try {
		var strPhone = new Packages.java.lang.StringBuffer(phone.toString());	
		
		if (strPhone.length() == 7) {			
			strPhone.insert(3,&quot;-&quot;);
			strPhone.insert(6,&quot;-&quot;);
			return strPhone.toString();			
		} else 
			return phone.toString();
		
	} catch(ex) {
		return phone.toString();		
	} 
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>dc6049ce-02d8-4022-b10e-6bc9978ab3bd</id>
          <name>Convert XML to JSON</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077867</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts a string in XML format into its JSON representation.
	This function requires org.json.jar to be deployed to the /custom-lib folder on Mirth

	@param {String} input - A string in XML format
	@return {String} return a string representing initial XML feed but in JSON format
*/
function convertXMLtoJSON(input) {
	var strJSON = Packages.org.json.XML.toJSONObject(input.toString());
	return strJSON.toString(2);	
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>2f174050-3927-4c30-a984-26c98e29bd61</id>
          <name>Converts Administrative Gender</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609078148</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Verifies and converts HL7v2 administrative gender value to FHIR value set defined by
	http://hl7.org/fhir/administrative-gender
	
	@param {String} code - HL7v2 PID.8 [Administrative Sex] code
	@return {String} return FHIR value set code
*/
function getGenderValue(code) {

	var gender;

	switch(code) {
		case &quot;M&quot;:
			gender = &quot;male&quot;;
			break;
		case &quot;F&quot;:
			gender = &quot;female&quot;;
		 	break;
		case &quot;O&quot;:
		case &quot;A&quot;:
		case &quot;N&quot;:
			gender = &quot;other&quot;;
			break; 	
		default:
			gender = &quot;unknown&quot;;		 	
	}

	return gender;	
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>943f9793-83e0-403a-84e9-40ea3fcd92d6</id>
          <name>Converts Phone string to XTN</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609078031</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts phone number string with caret dividers into XTN data type.
	Supported formats: 1-314-8727127 or 314-8727127
	Returned formats: ^^PH^^1^314^8727127 or ^^PH^^^314^8727127 or ^^PH^^^^8727127

	@param {String} phone - Phone string in one of the supported format
	@return {String} return Phone string as per XTN data type
*/
function convertPhoneXTN(phone) {

	phone = phone.replace(/\+/g,&quot;&quot;);

	// XTN data type example: ^^PH^^^734^6777777

	//	    916-3000		\d{3}-\d{4}			^^PH^^^^9163000
	//	    9163000		\d{7}				^^PH^^^^9163000
	//   972-9163000		\d{3}-\d{7}			^^PH^^^972^9163000
	//   972-916-3000  		\d{3}-\d{3}-\d{4}		^^PH^^^972^9163000
	// 1-972-9163000 		\d{1}-\d{3}-\d{7}		^^PH^^1^972^9163000
	// 1-972-916-3000 		\d{1}-\d{3}-\d{3}-\d{4}	^^PH^^1^972^9163000

	var arrPhone = phone.split(&quot;-&quot;);
	if (arrPhone.length &lt;= 1) return &quot;^^^^^^^^&quot; + phone;

	// 1-972-9163000
	if (phone.match(/\d{1}-\d{3}-\d{7}/) != null) {
		// ^^PH^^1^734^6777777
		return &quot;^^PH^^&quot; + arrPhone[0] + &quot;^&quot; + arrPhone[1] + &quot;^&quot; + arrPhone[2];

	// 1-972-916-3000	
	} else if (phone.match(/\d{1}-\d{3}-\d{3}-\d{4}/) != null) {
		// ^^PH^^1^734^6777777
		return &quot;^^PH^^&quot; + arrPhone[0] + &quot;^&quot; + arrPhone[1] + &quot;^&quot; + arrPhone[2] + arrPhone[3];

	// 972-9163000	
	} else if (phone.match(/\d{3}-\d{7}/) != null) {
		// ^^PH^^^734^6777777
		return &quot;^^PH^^^&quot; + arrPhone[0] + &quot;^&quot; + arrPhone[1];

	// 972-916-3000
	} else if (phone.match(/\d{3}-\d{3}-\d{4}/) != null) {
		// ^^PH^^^972^9163000
		return &quot;^^PH^^^&quot; + arrPhone[0] + &quot;^&quot; + arrPhone[1] + arrPhone[2];

	// 9163000
	} else if (phone.match(/\d{7}/) != null) {
		// ^^PH^^^^9163000
		return &quot;^^PH^^^^&quot; + arrPhone[0];

	// 916-3000
	} else if (phone.match(/\d{3}-\d{4}/) != null) {
		// ^^PH^^^^9163000
		return &quot;^^PH^^^^&quot; + arrPhone[0] + arrPhone[1];
		
	} else
		return &quot;^^^^^^^^&quot; + phone; 

}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>58a19daa-aada-46ac-ae7f-2b5e5848405b</id>
          <name>Create OperationOutcome resource</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077663</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Creates OperationOutcome resource to inform about validation errors
	
	@param {Array} error - A list of errors or comments
	@param {Object} issue - An object with severity, code and details associated with outcome
	@param {Object} messages - An object with inbounb and outbound messages to be logged
	@param {String} uuid - A string with uuid to pair request and response FHIR feeds	
	@param {String} format - A resource output format (xml | json)	
	@return {String} outcome - OperationOutcome resource in required format
*/
function getOperationOutcome(error, issue, messages, uuid, format) {

	// Expected issue object format:
	// var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};

	// Expected messages object format:
	// var messages = {request: &quot;&quot;, resp: &quot;&quot;};

	// Namespaces are required to validate against FHIR XML Schema
	if (format.toUpperCase() != &quot;JSON&quot;) 
		default xml namespace = &quot;http://hl7.org/fhir&quot;;
		
	var outcome = &lt;OperationOutcome&gt;
				&lt;id value=&quot;responsestatus&quot;/&gt;
				&lt;extension url=&quot;request&quot;&gt;
					&lt;valueBase64Binary value=&quot;&quot;/&gt;
				&lt;/extension&gt;
				&lt;extension url=&quot;response&quot;&gt;
					&lt;valueBase64Binary value=&quot;&quot;/&gt;
				&lt;/extension&gt;
				&lt;issue&gt;
					&lt;severity value=&quot;&quot;/&gt;
					&lt;code value=&quot;&quot;/&gt;
					&lt;details&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/details&gt;
				&lt;/issue&gt;
			&lt;/OperationOutcome&gt;;

	if (uuid != null &amp;&amp; uuid != undefined &amp;&amp; uuid.toString() != &quot;&quot;) 
		outcome.id.@value = &quot;responsestatus&quot; + uuid;
		
	outcome.issue.severity.@value = issue.severity;
	outcome.issue.code.@value = issue.code;
	outcome.issue.details.text.@value = issue.details;

	// xhtml namespace is intentionally removed
	var text = &lt;text&gt;
			    	&lt;status value=&quot;generated&quot;/&gt;
			    	&lt;div/&gt;
			  &lt;/text&gt;;

	text.div.* = new XMLList();
	error.forEach(function(n){
	  text.div.* += new XML(&quot;&lt;p&gt;&quot; + n +&quot;&lt;/p&gt;&quot;);
	});

	outcome.id += text;

	// If request or response messages are available, encode them
	if (messages.request != undefined &amp;&amp; messages.request.toString() != &quot;&quot;) 
		outcome.extension.(@url == &quot;request&quot;)[0].valueBase64Binary.@value = getBase64Encoded(messages.request.toString());	
	else
		delete outcome.extension.(@url == &quot;request&quot;)[0];


	if (messages.resp != undefined &amp;&amp; messages.resp.toString() != &quot;&quot;) 	
		outcome.extension.(@url == &quot;response&quot;)[0].valueBase64Binary.@value = getBase64Encoded(messages.resp.toString());
	else
		delete outcome.extension.(@url == &quot;response&quot;)[0];

	// Convert to a requested format
	if (format.toUpperCase() == &quot;JSON&quot;) {
		return convertXMLtoJSON(outcome.toString());		
	} else {
		// Namespace is required to validate FHIR XML
		outcome = outcome.toString().replace(&apos;&lt;div&gt;&apos;, &apos;&lt;div  xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&apos;);
		return outcome.toString();
	}
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>52360391-d3f2-4714-8bd3-98c53c85c387</id>
          <name>Fix HL7v2 node order</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077814</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Returns a new E4X node where the order of all siblings and descendants have been fixed as per the Mirth HL7 dot notation convention.
	@param {String} node - The node to be fixed
	@return {String} return - E4X node
*/
/*
	Author: Nick Rupley
	Date Modified: 4/18/2012
*/
function fixHL7NodeOrder(node) {
	// Create output node
	var newNode = new XML();
	// In case the node is an XMLList of multiple siblings, loop through each sibling
	for each (sibling in node) {
		// Create new sibling node
		var newSibling = new XML(&apos;&lt;&apos;+sibling.name().toString()+&apos;/&gt;&apos;);
		// Iterate through each child node
		for each (child in sibling.children())
			// If the child has its own children, then recursively fix the node order of the child
			if (child.hasComplexContent())
				newSibling.appendChild(fixHL7NodeOrder(child));
			// If the child doesn&apos;t have its own children, then just add the child to the new sibling node
			else
				newSibling.appendChild(child);
		// After recursively fixing all of the child nodes, now we&apos;ll fix the current node
		newNode += sortHL7Node(newSibling);
	}
	// Return the fixed node
	return newNode;
}

// Helper function for fixHL7NodeOrder
function sortHL7Node(node) {
	// If the node has no children, then there&apos;s nothing to sort
	if (node.hasSimpleContent())
		return node;
	// Create new output node
	var newNode = new XML(&apos;&lt;&apos;+node.name().toString()+&apos;/&gt;&apos;);
	// Iterate through each child in the node
	for each (child in node.children()) {
		// If the child has a QName, then we can sort on it
		if (child.name()) {
			// Get the current &quot;index&quot; of the child. Id est, if the QName is PID.3.1, then the index is 1
			curChildIndex = parseInt(child.name().toString().substring(child.name().toString().lastIndexOf(&apos;.&apos;)+1),10);
			// Boolean placeholder
			var inserted = false;
			// Iterate through each child currently in the NEW node
			for (var i = 0; i &lt;= newNode.children().length()-1; i++) {
				// Get the index of the child of the new node
				loopChildIndex = parseInt(newNode.child(i).name().toString().substring(newNode.child(i).name().toString().lastIndexOf(&apos;.&apos;)+1),10);
				// If the child we want to insert has a lower index then the current child of the new node, then we&apos;re going to insert the child 
				// right before the current newNode child
				if (curChildIndex &lt; loopChildIndex) {
					// Insert the child
					newNode.insertChildBefore(newNode.children()[i],child);
					// Set our flag, indicating that an insertion was made
					inserted = true;
					// No need to continue iteration
					break;
				}
			}
			// If no insertion was made, then the index of the child we want to insert is greater than or equal to all of the
			// indices of the children that have already been inserted in newNode. So, we&apos;ll just append the child to the end.
			if (!inserted)
				newNode.appendChild(child);
		}
	}
	// Return the sorted HL7 node
	return newNode;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>711f9e92-9872-4718-83aa-f8e62e3885b2</id>
          <name>Get Base64 encoded string</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077840</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Encodes given string into a Base64 string.

	@param {String} strData - String to be encoded
	@return {String} return Base64 encoded string
*/
function getBase64Encoded(strData) {
	
	try {
		
		if (null == strData) strData = &apos;&apos;;
		var byteData = new Packages.java.lang.String(strData).getBytes();
		return FileUtil.encode(byteData).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

	} catch(err) {
		logger.error(err);
		return &quot;&quot;;
	}
}
</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>872dae30-3381-458c-a4e5-4f412e21b1fa</id>
          <name>Get HL7v2 Code Description</name>
          <revision>1</revision>
          <lastModified>
            <time>1490476779449</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Retrieve code description for a given HL7v2 table (to be used for ORC, OBR and OBX segments)

	@param {String} table - HL7v2 Table code as per specification
	@param {String] value - value to convert
	@return {String} return code description
*/
function getHL7v2CodeDescription(table, value) {

	switch(table) {
		
		// Table 0038 - Order Status
		case &quot;0038&quot;:
			if (&quot;CM&quot; === value.toString()) return &quot;Order complete&quot;
			else if (&quot;IP&quot; === value.toString()) return &quot;Order incomplete, or contains pending items&quot;
			else if (&quot;CA&quot; === value.toString()) return &quot;Order was canceled&quot;
			else if (&quot;DC&quot; === value.toString()) return &quot;Order was discontinued&quot;
			else if (&quot;ER&quot; === value.toString()) return &quot;Error, order not found&quot;
			else if (&quot;HD&quot; === value.toString()) return &quot;Order is on hold&quot;
			else if (&quot;RP&quot; === value.toString()) return &quot;Order has been replaced&quot;
			else if (&quot;SC&quot; === value.toString()) return &quot;In process, scheduled&quot;
			else if (&quot;&quot; === value.toString()) return &quot;&quot;
			else return &quot;&quot;;
			break;

		// Table 0123 - Result Status
		case &quot;0123&quot;:
			if (&quot;F&quot; === value.toString()) return &quot;Final results&quot;
			else if (&quot;A&quot; === value.toString()) return &quot;Partial results&quot;
			else if (&quot;C&quot; === value.toString()) return &quot;Correction to results&quot;
			else if (&quot;I&quot; === value.toString()) return &quot;No results available. The specimen was received, but the procedure is incomplete.&quot;
			else if (&quot;O&quot; === value.toString()) return &quot;Specimen not yet received&quot;
			else if (&quot;P&quot; === value.toString()) return &quot;Preliminary results&quot;
			else if (&quot;R&quot; === value.toString()) return &quot;Results stored&quot;
			else if (&quot;S&quot; === value.toString()) return &quot;No results available. The procedure is scheduled, but has not been performed.&quot;
			else if (&quot;X&quot; === value.toString()) return &quot;No results available. The order was canceled.&quot;
			else return &quot;&quot;;		
			break;

		// Table 0085 - Observation Result Status
		case &quot;0085&quot;:
			if (&quot;F&quot; === value.toString()) return &quot;Final results; can only be changed with a corrected result.&quot;
			else if (&quot;D&quot; === value.toString()) return &quot;Deletes the OBX record&quot;
			else if (&quot;I&quot; === value.toString()) return &quot;Specimen in lab; results pending.&quot;
			else if (&quot;N&quot; === value.toString()) return &quot;Not asked; used to affirmatively document that the observation identified in the OBX was not sought when the universal service ID in OBR.04 implies that it would be sought.&quot;
			else if (&quot;O&quot; === value.toString()) return &quot;Order detail description only (no result)&quot;
			else if (&quot;P&quot; === value.toString()) return &quot;Preliminary results&quot;
			else if (&quot;R&quot; === value.toString()) return &quot;Results entered but not verified&quot;
			else if (&quot;X&quot; === value.toString()) return &quot;Results cannot be obtained for this observation&quot;
			else if (&quot;U&quot; === value.toString()) return &quot;Results status change to final without retransmitting results already sent as preliminary. For example, radiology changes status from preliminary to final.&quot;
			else if (&quot;W&quot; === value.toString()) return &quot;Post original as wrong. For example, transmitted for wrong patient.&quot;
			else return &quot;&quot;;
			break;
	}

	return &quot;&quot;;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>53e03352-fda6-455a-bc6a-54f1b3287838</id>
          <name>Get NTE segment</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077721</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Builds NTE segment with the comment entry from a single /text/div/p resource element
	Expected comment entry object is {&quot;class&quot;:&quot;&quot;,&quot;content&quot;:&quot;&quot;}

	// TODO: may require a flag to NOT restrict comment line longer than 60 chars as required for the Order message

	@param {String} entry - JSON object with comment entries
	@param {String} count - total NTE segment count i.e., NTE.1 [Set ID]	
	@return {String} return NTE segment string in XML format
*/
function getNTESegment(entry, count) {

	if (entry != undefined) {

		var nte = &lt;NTE&gt;
					&lt;NTE.1&gt;
						&lt;NTE.1.1&gt;&lt;/NTE.1.1&gt;
					&lt;/NTE.1&gt;
					&lt;NTE.2&gt;
						&lt;NTE.2.1&gt;&lt;/NTE.2.1&gt;
					&lt;/NTE.2&gt;
					&lt;NTE.3&gt;
						&lt;NTE.3.1&gt;&lt;/NTE.3.1&gt;
					&lt;/NTE.3&gt;
				&lt;/NTE&gt;;

		// NTE.1 [Set ID]		
		nte[&apos;NTE.1&apos;][&apos;NTE.1.1&apos;] = count;
			
		// NTE.2 [Source of Comment]
		nte[&apos;NTE.2&apos;][&apos;NTE.2.1&apos;] = entry.class.toString();

		// NTE.3 [Comment]
		// Comment shall be no longer than 60 characters for the OML_O21 Submit Order message
		if (entry.content.toString().length &gt; 60)
			entry.content = entry.content.toString().substring(0,60);
			
		nte[&apos;NTE.3&apos;][&apos;NTE.3.1&apos;] = entry.content.toString();

		return nte.toString();
		
	} else 
		return &quot;&quot;;
		
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>0f2c8346-d098-49b3-8e97-184eef9fc7b4</id>
          <name>HTTP Response Code indications</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077971</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Add the HTTP response status code description to the HTTP code

	@param {Integer} code - HTTP response status code
	@return {String} return HTTP response status code and its description
*/
function getHttpCodeDescription(code) {

	var text;
	
	switch(code) {
		case 200:
			text = &quot;OK&quot;;
			break;
		case 400:
			text = &quot;The request was not properly constructed&quot;;
			break;
		case 401:
			text = &quot;The user credentials submitted are not authorized&quot;;
			break;
		case 403:
			text = &quot;The user name submitted does not have permission to access the Results RESTful web service&quot;;
			break;
		case 404:
			text = &quot;The user credentials submitted are not authorized&quot;;
			break;
		case 500:
			text = &quot;An internal server error occurred&quot;;
			break;	        
		default:
			text = &quot;This response status code is undefined in the DEX spec&quot;;
	}

	return (code + &quot; - &quot; + text);
	
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>5032a64e-7da6-4885-83e2-348e5ab75600</id>
          <name>Parse person&apos;s name node</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077624</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Process Person.name element with zero or multiple given names with possible DEX name length limitation

	@param {Object} item - JSON representation of /resource/Person/name node
	@param {Boolean} lengthLimit - If person&apos;s name limitation applies according to DEX spec (true - apply, false - does not)	
	@return {Object} return name parts object with family and given names
*/
function processPersonName(item, lengthLimit) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	if (item.family != null &amp;&amp; item.family != undefined) {
		
		// Last name of the person
		var family = item.family.value.toString();
		
		// If Quest&apos;s length limit applies
		if (lengthLimit) {
			// The last name can be a maximum of 20 characters. (p.201)
			if (family.length &gt; 20) 
				family = family.substring(0, 20);
			// The entire patient name cannot exceed 24 characters (p.201)
			var limit = 24 - family.length;
		}
		nameParts.family = family;
	}

	if (item.given == null || item.given == undefined) return nameParts;
		
	if (item.given.length != undefined) {
		
		var count = 0;
		item.given.forEach(function(entry){
			var given = entry.value.toString();
			
			if (given.length &gt; 0) {					
				if (0 == count) {
					// The first name is limited to the difference between the number of characters in the last name and 24.				
					if (given.length &gt; limit &amp;&amp; lengthLimit) given = given.substring(0, limit);
					nameParts.given1 = given;
					limit -= given.length;
				} else {
					// if the limit is exceeded, a minimum of the first character of the middle initial is always returned in the result message.
					if (given.length &gt; limit &amp;&amp; lengthLimit) given = given.substring(0, 1);
					nameParts.given2 = given;
				}
			}
			count++;
		});			
	} else {
		var given = item.given.value.toString();
		if (given.length &gt; limit &amp;&amp; lengthLimit) given = given.substring(0, limit);
		nameParts.given1 = given;
	}

	return nameParts;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>08f30179-5465-4895-a2d3-4933f182035e</id>
          <name>Remove illegal XML chanracters</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609078114</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Strip non valid XML characters from a given text string.
	CAUTION: This is not a full-fledged function for XML input sanitization 

	@param {String} text - text string that may contain illegal XML characters
	@return {String} return text string with illegal XML characters replaced
*/
function stripNonValidXMLChars(text) {

	if (text == null || text == undefined || text.toString().length == 0) return &quot;&quot;;

	//text = comment.replace(/&amp;/g,&quot;&amp;amp;&quot;);// ampersand - (SN) temporary disabled
	text = text.replace(/&lt;/g,&quot;&amp;lt;&quot;); // less than
	text = text.replace(/&gt;/g,&quot;&amp;gt;&quot;); // greater than
	text = text.replace(/&apos;/g,&quot;&amp;apos;&quot;); // single quotes
	text = text.replace(/&quot;/g,&quot;&amp;apos;&quot;); // double quotes

	// (SN) Issue #6, #11: unexpected &quot;%&quot; in field
	text = text.replace(/\|%/g, &quot;|&quot;);

	return text;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>15559e88-2f64-415a-8544-9cbbc2742c79</id>
          <name>Verifies if Lab test is STD</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077902</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Verifies if the submitted Lab test code is in the list of STD lab tests

	@param {String} code - Lab test code
	@return {String} return true if Lab test code in the list of STD codes, false otherwise
*/
function isSTDLabTest(code) {

	// Check for LOINC codes
	switch(code) {
		// 86631, 86632 Chlamydia trachomatis Antibodies 
		case &quot;1833274&quot;:
		case &quot;1832970&quot;:
		case &quot;1833579&quot;:
		case &quot;44079-2&quot;:
		// 87591 Neisseria gonorrhoeae
		case &quot;43305-2&quot;:
		// 86704	Hepatitis A
		case &quot;13951-9&quot;:
		// 87340	Hepatitis B
		case &quot;1203841&quot;:
		case &quot;2193342&quot;:
		case &quot;10900-9&quot;:
		case &quot;13952-7&quot;:
		// 81001	Hepatitis C (Urinalysis, Complete)
		case &quot;13955-0&quot;:
		case &quot;48159-8&quot;:
		// 86695	Herpes Simplex Virus 1 (IgG)
		case &quot;1207706&quot;:
		// 86696	Herpes Simplex Virus 2 (IgG)
		case &quot;1208621&quot;:
		// 86592	VDRL, Serum (Syphilis)
		case &quot;1239118&quot;:
		// 86701	HIV-1 Antibody
		case &quot;29893-5&quot;:
		// 86702	HIV-2 Antibody
		case &quot;30361-0&quot;:
		// 87389	HIV-1/2 Antig. and Antib.,4th Gen
		case &quot;56888-1&quot;:
			return true;
			break;
	}

	return false;
	
}</code>
        </codeTemplate>
      </codeTemplates>
    </codeTemplateLibrary>
  </codeTemplateLibraries>
  <serverSettings>
    <clearGlobalMap>true</clearGlobalMap>
    <queueBufferSize>1000</queueBufferSize>
    <defaultMetaDataColumns>
      <metaDataColumn>
        <name>SOURCE</name>
        <type>STRING</type>
        <mappingName>mirth_source</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>TYPE</name>
        <type>STRING</type>
        <mappingName>mirth_type</mappingName>
      </metaDataColumn>
    </defaultMetaDataColumns>
    <smtpTimeout>5000</smtpTimeout>
    <smtpSecure>0</smtpSecure>
    <smtpAuth>false</smtpAuth>
  </serverSettings>
  <updateSettings version="3.4.2">
    <statsEnabled>true</statsEnabled>
    <lastStatsTime>1500310593878</lastStatsTime>
  </updateSettings>
  <globalScripts>
    <entry>
      <string>Undeploy</string>
      <string>// This script executes once for each deploy, undeploy, or redeploy task
// if at least one channel was undeployed
// You only have access to the globalMap here to persist data
return;</string>
    </entry>
    <entry>
      <string>Postprocessor</string>
      <string>// This script executes once after a message has been processed
// This script applies across all channels
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
// You have access to &quot;response&quot;, if returned from the channel postprocessor
return;</string>
    </entry>
    <entry>
      <string>Deploy</string>
      <string>// This script executes once for each deploy or redeploy task
// You only have access to the globalMap here to persist data



// Verify if SSLClient class is present
var sslClientExists = false;
try {
	var uuid = UUIDGenerator.getUUID();	
	sslClientExists = (uuid == new Packages.org.safemovement.DEXSSLClient().ping(uuid));
	//if (sslClientExists) logger.info(&quot;SSLClient is found&quot;);	
} catch(ex) {
	logger.error(&quot;Cannot find DEXSSLClient class. Verify that dex-ssl-client-1.x.jar is in Mirth /custom-lib folder.&quot;);	
} finally {
	globalMap.put(&quot;sslClient&quot;, sslClientExists);
}


// Verify if httpClient class is present
var httpClientExists = false;
try {
	var uuid = UUIDGenerator.getUUID();	
	httpClientExists = (uuid == new Packages.org.safemovement.DEXHTTPClient().ping(uuid));
	//if (httpClientExists) logger.info(&quot;httpClient is found&quot;);	
} catch(ex) {
	logger.error(&quot;Cannot find DEXHTTPClient class. Verify that dex-ssl-client-1.x.jar is in Mirth /custom-lib folder.&quot;);	
} finally {
	globalMap.put(&quot;httpClient&quot;, httpClientExists);
}


return;</string>
    </entry>
    <entry>
      <string>Preprocessor</string>
      <string>// Modify the message variable below to pre process data
// This script applies across all channels
return message;</string>
    </entry>
  </globalScripts>
  <pluginProperties>
    <entry>
      <string>Data Pruner</string>
      <properties>
        <property name="archiveEnabled">&lt;boolean&gt;false&lt;/boolean&gt;</property>
        <property name="archiverBlockSize">50</property>
        <property name="archiverOptions">&lt;com.mirth.connect.util.messagewriter.MessageWriterOptions&gt;
  &lt;destinationContent&gt;false&lt;/destinationContent&gt;
  &lt;encrypt&gt;false&lt;/encrypt&gt;
  &lt;includeAttachments&gt;false&lt;/includeAttachments&gt;
&lt;/com.mirth.connect.util.messagewriter.MessageWriterOptions&gt;</property>
        <property name="enabled">false</property>
        <property name="includeAttachments">&lt;boolean&gt;false&lt;/boolean&gt;</property>
        <property name="maxEventAge"></property>
        <property name="pollingProperties">&lt;com.mirth.connect.donkey.model.channel.PollConnectorProperties version=&quot;3.4.2&quot;&gt;
  &lt;pollingType&gt;INTERVAL&lt;/pollingType&gt;
  &lt;pollOnStart&gt;false&lt;/pollOnStart&gt;
  &lt;pollingFrequency&gt;3600000&lt;/pollingFrequency&gt;
  &lt;pollingHour&gt;0&lt;/pollingHour&gt;
  &lt;pollingMinute&gt;0&lt;/pollingMinute&gt;
  &lt;cronJobs/&gt;
  &lt;pollConnectorPropertiesAdvanced&gt;
    &lt;weekly&gt;true&lt;/weekly&gt;
    &lt;inactiveDays&gt;
      &lt;boolean&gt;false&lt;/boolean&gt;
      &lt;boolean&gt;false&lt;/boolean&gt;
      &lt;boolean&gt;false&lt;/boolean&gt;
      &lt;boolean&gt;false&lt;/boolean&gt;
      &lt;boolean&gt;false&lt;/boolean&gt;
      &lt;boolean&gt;false&lt;/boolean&gt;
      &lt;boolean&gt;false&lt;/boolean&gt;
      &lt;boolean&gt;false&lt;/boolean&gt;
    &lt;/inactiveDays&gt;
    &lt;dayOfMonth&gt;1&lt;/dayOfMonth&gt;
    &lt;allDay&gt;true&lt;/allDay&gt;
    &lt;startingHour&gt;8&lt;/startingHour&gt;
    &lt;startingMinute&gt;0&lt;/startingMinute&gt;
    &lt;endingHour&gt;17&lt;/endingHour&gt;
    &lt;endingMinute&gt;0&lt;/endingMinute&gt;
  &lt;/pollConnectorPropertiesAdvanced&gt;
&lt;/com.mirth.connect.donkey.model.channel.PollConnectorProperties&gt;</property>
        <property name="pruneEvents">false</property>
        <property name="pruningBlockSize">1000</property>
      </properties>
    </entry>
  </pluginProperties>
  <resourceProperties>
    <list>
      <com.mirth.connect.plugins.directoryresource.DirectoryResourceProperties version="3.4.2">
  <pluginPointName>Directory Resource</pluginPointName>
        <type>Directory</type>
        <id>Default Resource</id>
        <name>[Default Resource]</name>
        <description>Loads libraries from the custom-lib folder in the Mirth Connect home directory.</description>
        <includeWithGlobalScripts>true</includeWithGlobalScripts>
        <directory>custom-lib</directory>
        <directoryRecursion>false</directoryRecursion>
      </com.mirth.connect.plugins.directoryresource.DirectoryResourceProperties>
      <com.mirth.connect.plugins.directoryresource.DirectoryResourceProperties version="3.4.2">
  <pluginPointName>Directory Resource</pluginPointName>
        <type>Directory</type>
        <id>29f52768-5925-40e8-b62d-a265b40e6ab4</id>
        <name>hapi-fhir</name>
        <description>HAPI-FHIR Java Framework</description>
        <includeWithGlobalScripts>false</includeWithGlobalScripts>
        <directory>C:\Program Files (x86)\Mirth Connect\custom-lib\fhir</directory>
        <directoryRecursion>false</directoryRecursion>
      </com.mirth.connect.plugins.directoryresource.DirectoryResourceProperties>
    </list>
  </resourceProperties>
  <channelDependencies>
    <channelDependency>
      <dependentId>9eeed45d-4613-4501-86f1-236e91808742</dependentId>
      <dependencyId>b21b42cb-5080-4b45-ad37-e761ff386050</dependencyId>
    </channelDependency>
  </channelDependencies>
</serverConfiguration>