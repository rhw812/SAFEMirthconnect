<channel version="3.4.2">
  <id>20fb74a5-8bfe-4b1c-a2b7-2dbaa17d7fce</id>
  <nextMetaDataId>4</nextMetaDataId>
  <name>Unused Submit Order</name>
  <description>Submits a new lab order, including both Basic Lab Orders and Patient Service Center (PSC) Hold Orders.&#xd;
The Order object contains the inbound lab order message (HL7v2.5.1 OML_O21).&#xd;
&#xd;
This channel expects JSON feed with all data filled to build the outbound OML_O21 message.&#xd;
&#xd;
Last updated: March 12, 2017</description>
  <enabled>false</enabled>
  <lastModified>
    <time>1495396848765</time>
    <timezone>America/New_York</timezone>
  </lastModified>
  <revision>3</revision>
  <sourceConnector version="3.4.2">
    <metaDataId>0</metaDataId>
    <name>sourceConnector</name>
    <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.4.2">
      <pluginProperties/>
      <sourceConnectorProperties version="3.4.2">
        <responseVariable>Outcome</responseVariable>
        <respondAfterProcessing>true</respondAfterProcessing>
        <processBatch>false</processBatch>
        <firstResponse>false</firstResponse>
        <processingThreads>1</processingThreads>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
        <queueBufferSize>1000</queueBufferSize>
      </sourceConnectorProperties>
    </properties>
    <transformer version="3.4.2">
      <steps>
        <step>
          <sequenceNumber>0</sequenceNumber>
          <name>Validate JSON feed</name>
          <script>var error = [];				// A list of possible incoming JSON feed validation errors
var hasPatient = false;			// PID
var hasDiagnosticReport = false;	// ORC
var hasDiagnosticOrder = false;	// OBR
var hasCoverage = false;			// IN1
var hasPerson = false;			// GT1
var hasPractitioner = false;		// OBR.16
var conditionCount = 0;

// Feed UUID ~~ RKW The placement of static text in an ID value is pointless, and usually requires stripping out later - such as here. How about not putting it there in the first place?
var uuid = msg.Bundle.id.value.toString().toLowerCase().replace(&quot;oml-o21&quot;,&quot;&quot;);

// TODO: Define min length for UUID
if (uuid)
	channelMap.put(&quot;FeedUUID&quot;, uuid);
else 
	error.push(&quot;Feed Bundle id/@value should contain UUID in format OML-O21-xxxxxxxx-...&quot;);	


// The Data Exchange verifies that fields are populated depending on the coverage type
var billType = [&apos;T&apos;,&apos;P&apos;,&apos;C&apos;];
var coverageType;
msg.Bundle.entry.forEach(function(obj){
	if (obj.resource.Coverage) {
		coverageType = obj.resource.Coverage.type.code.value.toString();
		if (billType.indexOf(coverageType) &lt; 0) error.push(&quot;resource.Coverage.type.code.value for IN1.47[Coverage Type] is required and must be T, P or C&quot;);
	}
});

// Store IN1.47 [Coverage Type] value for future use
channelMap.put(&quot;CoverageType&quot;, coverageType);


// Validate incoming JSON field for required resources (aka segments)
msg.Bundle.entry.forEach(function(objRes){

	// Need to set the hasSomeResource only once
	if (objRes.resource.Patient != null &amp;&amp; objRes.resource.Patient != undefined) hasPatient = true;
	if (objRes.resource.DiagnosticReport != null &amp;&amp; objRes.resource.DiagnosticReport != undefined) hasDiagnosticReport = true;
	if (objRes.resource.DiagnosticOrder != null &amp;&amp; objRes.resource.DiagnosticOrder != undefined) hasDiagnosticOrder = true;
	if (objRes.resource.Coverage != null &amp;&amp; objRes.resource.Coverage != undefined) hasCoverage = true;
	if (objRes.resource.Person != null &amp;&amp; objRes.resource.Person != undefined) hasPerson = true;
	if (objRes.resource.Practitioner != null &amp;&amp; objRes.resource.Practitioner != undefined) hasPractitioner = true;
	if (objRes.resource.Condition != null &amp;&amp; objRes.resource.Condition != undefined) {
		conditionCount ++;
	}
});


// Validate for required segments
if (!hasPatient) error.push(&quot;resource.Patient for PID segment is Required&quot;);
if (!hasCoverage) error.push(&quot;resource.Coverage for IN1 segment is Required&quot;);
if (!hasDiagnosticReport) error.push(&quot;resource.DiagnosticReport for ORC segment is Required&quot;); // ~~ RKW - Expecting a diagnostic report - a result observation artifact - in an order? Why? 
if (!hasDiagnosticOrder) error.push(&quot;resource.DiagnosticOrder for OBR segment is Required&quot;);
if (!hasPractitioner) error.push(&quot;resource.Practitioner for OBR.16 [Ordering Provider] field is Required&quot;);
if (coverageType == &quot;T&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Third-Party Bill type&quot;);

// Updated to comply with CS12 Billing certification criteria
if (coverageType == &quot;P&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Patient Bill type&quot;);
if (conditionCount &gt; 12) error.push(&quot;Maximum of 12 resource.Condition with unique ICD-10 codes are permitted. You sent &quot; + conditionCount);  // ~~ RKW - Conditions? Not going to happen, and not in requirements

// Verify for errors 
if (error.length &gt; 0) {
	
	// OML_O21 message will not be created ~~ RKW. There is this thing called a filter. Manipulation of the destinationSet is hacking, as it makes the channel more opaque.
	destinationSet.removeAll();

	var messages = {request:&quot;&quot;, resp:&quot;&quot;};
	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	
	// To be sent to the upstream channel
	responseMap.put(&quot;Outcome&quot;, outcome);
	//logger.debug(&quot;SubmitOrder (Source): &quot; + outcome);
}</script>
          <type>JavaScript</type>
          <data>
            <entry>
              <string>Script</string>
              <string>var error = [];				// A list of possible incoming JSON feed validation errors
var hasPatient = false;			// PID
var hasDiagnosticReport = false;	// ORC
var hasDiagnosticOrder = false;	// OBR
var hasCoverage = false;			// IN1
var hasPerson = false;			// GT1
var hasPractitioner = false;		// OBR.16
var conditionCount = 0;

// Feed UUID ~~ RKW The placement of static text in an ID value is pointless, and usually requires stripping out later - such as here. How about not putting it there in the first place?
var uuid = msg.Bundle.id.value.toString().toLowerCase().replace(&quot;oml-o21&quot;,&quot;&quot;);

// TODO: Define min length for UUID
if (uuid)
	channelMap.put(&quot;FeedUUID&quot;, uuid);
else 
	error.push(&quot;Feed Bundle id/@value should contain UUID in format OML-O21-xxxxxxxx-...&quot;);	


// The Data Exchange verifies that fields are populated depending on the coverage type
var billType = [&apos;T&apos;,&apos;P&apos;,&apos;C&apos;];
var coverageType;
msg.Bundle.entry.forEach(function(obj){
	if (obj.resource.Coverage) {
		coverageType = obj.resource.Coverage.type.code.value.toString();
		if (billType.indexOf(coverageType) &lt; 0) error.push(&quot;resource.Coverage.type.code.value for IN1.47[Coverage Type] is required and must be T, P or C&quot;);
	}
});

// Store IN1.47 [Coverage Type] value for future use
channelMap.put(&quot;CoverageType&quot;, coverageType);


// Validate incoming JSON field for required resources (aka segments)
msg.Bundle.entry.forEach(function(objRes){

	// Need to set the hasSomeResource only once
	if (objRes.resource.Patient != null &amp;&amp; objRes.resource.Patient != undefined) hasPatient = true;
	if (objRes.resource.DiagnosticReport != null &amp;&amp; objRes.resource.DiagnosticReport != undefined) hasDiagnosticReport = true;
	if (objRes.resource.DiagnosticOrder != null &amp;&amp; objRes.resource.DiagnosticOrder != undefined) hasDiagnosticOrder = true;
	if (objRes.resource.Coverage != null &amp;&amp; objRes.resource.Coverage != undefined) hasCoverage = true;
	if (objRes.resource.Person != null &amp;&amp; objRes.resource.Person != undefined) hasPerson = true;
	if (objRes.resource.Practitioner != null &amp;&amp; objRes.resource.Practitioner != undefined) hasPractitioner = true;
	if (objRes.resource.Condition != null &amp;&amp; objRes.resource.Condition != undefined) {
		conditionCount ++;
	}
});


// Validate for required segments
if (!hasPatient) error.push(&quot;resource.Patient for PID segment is Required&quot;);
if (!hasCoverage) error.push(&quot;resource.Coverage for IN1 segment is Required&quot;);
if (!hasDiagnosticReport) error.push(&quot;resource.DiagnosticReport for ORC segment is Required&quot;); // ~~ RKW - Expecting a diagnostic report - a result observation artifact - in an order? Why? 
if (!hasDiagnosticOrder) error.push(&quot;resource.DiagnosticOrder for OBR segment is Required&quot;);
if (!hasPractitioner) error.push(&quot;resource.Practitioner for OBR.16 [Ordering Provider] field is Required&quot;);
if (coverageType == &quot;T&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Third-Party Bill type&quot;);

// Updated to comply with CS12 Billing certification criteria
if (coverageType == &quot;P&quot; &amp;&amp; !hasPerson) error.push(&quot;resource.Person to populate GT1 segment is Required for Patient Bill type&quot;);
if (conditionCount &gt; 12) error.push(&quot;Maximum of 12 resource.Condition with unique ICD-10 codes are permitted. You sent &quot; + conditionCount);  // ~~ RKW - Conditions? Not going to happen, and not in requirements

// Verify for errors 
if (error.length &gt; 0) {
	
	// OML_O21 message will not be created ~~ RKW. There is this thing called a filter. Manipulation of the destinationSet is hacking, as it makes the channel more opaque.
	destinationSet.removeAll();

	var messages = {request:&quot;&quot;, resp:&quot;&quot;};
	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	
	// To be sent to the upstream channel
	responseMap.put(&quot;Outcome&quot;, outcome);
	//logger.debug(&quot;SubmitOrder (Source): &quot; + outcome);
}</string>
            </entry>
          </data>
        </step>
      </steps>
      <inboundTemplate encoding="base64">eyJCdW5kbGUiOiB7CiAgImVudHJ5IjogWwogICAgeyJyZXNvdXJjZSI6IHsiUGF0aWVudCI6IHsK
ICAgICAgImlkZW50aWZpZXIiOiBbCiAgICAgICAgewogICAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAic2Vjb25kYXJ5In0sCiAgICAgICAgICAidHlwZSI6IHsiY29kaW5nIjogeyJjb2RlIjogeyJ2
YWx1ZSI6ICJQVCJ9fX0sCiAgICAgICAgICAidmFsdWUiOiB7InZhbHVlIjogMjA1MjY2MTl9CiAg
ICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJvZmZpY2lhbCJ9
LAogICAgICAgICAgImFzc2lnbmVyIjogeyJkaXNwbGF5IjogeyJ2YWx1ZSI6ICJNUk4ifX0sCiAg
ICAgICAgICAidHlwZSI6IHsiY29kaW5nIjogeyJjb2RlIjogeyJ2YWx1ZSI6ICJQVCJ9fX0sCiAg
ICAgICAgICAidmFsdWUiOiB7InZhbHVlIjogMjA1MjY2MTl9CiAgICAgICAgfQogICAgICBdLAog
ICAgICAiYWRkcmVzcyI6IHsKICAgICAgICAiY291bnRyeSI6IHsidmFsdWUiOiAiVVNBIn0sCiAg
ICAgICAgImNpdHkiOiB7InZhbHVlIjogIk1hc29uIn0sCiAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAiaG9tZSJ9LAogICAgICAgICJsaW5lIjogeyJ2YWx1ZSI6ICI0NjkwIFBhcmt3YXkgRHIuIn0s
CiAgICAgICAgInBvc3RhbENvZGUiOiB7InZhbHVlIjogNDUwNDB9LAogICAgICAgICJzdGF0ZSI6
IHsidmFsdWUiOiAiT0gifQogICAgICB9LAogICAgICAiZ2VuZGVyIjogeyJ2YWx1ZSI6ICJtYWxl
In0sCiAgICAgICJuYW1lIjogewogICAgICAgICJnaXZlbiI6IFsKICAgICAgICAgIHsidmFsdWUi
OiAiUGF0aWVudF9GaXJzdG5hbWUifSwKICAgICAgICAgIHsidmFsdWUiOiAiTWlkZGxlIn0KICAg
ICAgICBdLAogICAgICAgICJ1c2UiOiB7InZhbHVlIjogIm9mZmljaWFsIn0sCiAgICAgICAgImZh
bWlseSI6IHsidmFsdWUiOiAiUGF0aWVudF9MYXN0bmFtZSJ9CiAgICAgIH0sCiAgICAgICJ0ZWxl
Y29tIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0sCiAgICAgICAgInVz
ZSI6IHsidmFsdWUiOiAiaG9tZSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFsdWUiOiAiMV4zMzNe
NDQ0NTU1NSJ9CiAgICAgIH0sCiAgICAgICJpZCI6IHsidmFsdWUiOiAiUElELXBhdGllbnQtaWRl
bnRpZmljYXRpb24ifSwKICAgICAgInRleHQiOiB7CiAgICAgICAgImRpdiI6IHsKICAgICAgICAg
ICJwIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIkZpcnN0IFBhdGllbnQgcmVsYXRlZCBpbnRlcm5hbCBjb21tZW50
IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiY2xhc3Mi
OiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiU2Vjb25kIFBhdGllbnQgcmVsYXRlZCBp
bnRlcm5hbCBjb21tZW50IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAg
ICAgICAgICAiY2xhc3MiOiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiVGhpcmQgUGF0
aWVudCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAg
ICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6ICJJIiwKICAgICAgICAgICAgICAiY29udGVu
dCI6ICJGb3J0aCBQYXRpZW50IHJlbGF0ZWQgaW50ZXJuYWwgY29tbWVudCBsaW5lIgogICAgICAg
ICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIlIiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIkZpcnN0IFBhdGllbnQgcmVsYXRlZCByZXBvcnQgY29tbWVudCBs
aW5lIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjog
IlIiLAogICAgICAgICAgICAgICJjb250ZW50IjogIlNlY29uZCBQYXRpZW50IHJlbGF0ZWQgcmVw
b3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAg
ICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJUaGlyZCBQYXRpZW50
IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAg
ewogICAgICAgICAgICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJG
b3J0aCBQYXRpZW50IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfQog
ICAgICAgICAgXSwKICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3ho
dG1sIgogICAgICAgIH0sCiAgICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAiZ2VuZXJhdGVkIn0K
ICAgICAgfSwKICAgICAgImJpcnRoRGF0ZSI6IHsidmFsdWUiOiAiMTk2OC0wMS0wMSJ9CiAgICB9
fX0sCiAgICB7InJlc291cmNlIjogeyJEaWFnbm9zdGljUmVwb3J0IjogewogICAgICAicmVzdWx0
IjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIk9ic2VydmF0aW9uIn19LAogICAgICAiaWRlbnRp
ZmllciI6IHsKICAgICAgICAic3lzdGVtIjogeyJ2YWx1ZSI6ICJRVUVTVF9TS0JfNzE4NjEyMSJ9
LAogICAgICAgICJ0eXBlIjogeyJpZCI6ICI5OVFESSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFs
dWUiOiA5ODc2NTQzMjF9CiAgICAgIH0sCiAgICAgICJyZXF1ZXN0IjogeyJyZWZlcmVuY2UiOiB7
InZhbHVlIjogIkRpYWdub3N0aWNPcmRlci9vYnItb2JzZXJ2YXRpb24tcmVxdWVzdCJ9fSwKICAg
ICAgImNvbnRhaW5lZCI6IHsiUHJhY3RpdGlvbmVyIjogewogICAgICAgICJpZGVudGlmaWVyIjog
eyJ2YWx1ZSI6IHsidmFsdWUiOiAiTlBQX0lEIn19LAogICAgICAgICJuYW1lIjogeyJmYW1pbHki
OiB7InZhbHVlIjogIk5QUF9OYW1lIn19LAogICAgICAgICJpZCI6IHsidmFsdWUiOiAiT1JDMTEt
dmVyaWZpZWQtYnkifQogICAgICB9fSwKICAgICAgImNvZGUiOiB7ImlkIjogMTAxMjR9LAogICAg
ICAicGVyZm9ybWVyIjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIlByYWN0aXRpb25lci9PUkMx
MS12ZXJpZmllZC1ieSJ9fSwKICAgICAgImVmZmVjdGl2ZURhdGVUaW1lIjogeyJleHRlbnNpb24i
OiB7InVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YzL051bGxGbGF2b3IvTkkifX0sCiAgICAg
ICJzdWJqZWN0IjogeyJyZWZlcmVuY2UiOiB7InZhbHVlIjogIlBhdGllbnQifX0sCiAgICAgICJp
ZCI6IHsidmFsdWUiOiAiT1JDLWNvbW1vbi1vcmRlciJ9LAogICAgICAiaXNzdWVkIjogeyJleHRl
bnNpb24iOiB7InVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YzL051bGxGbGF2b3IvTkkifX0s
CiAgICAgICJzdGF0dXMiOiB7InZhbHVlIjogImZpbmFsIn0KICAgIH19fSwKICAgIHsicmVzb3Vy
Y2UiOiB7IkRpYWdub3N0aWNPcmRlciI6IHsKICAgICAgIml0ZW0iOiB7CiAgICAgICAgImNvZGUi
OiB7ImNvZGluZyI6IHsKICAgICAgICAgICJjb2RlIjogeyJ2YWx1ZSI6IDg0NzJ9LAogICAgICAg
ICAgImRpc3BsYXkiOiB7InZhbHVlIjogIkhFUEFUSVRJUyBDIFZJUlVTIEFCIn0KICAgICAgICB9
fSwKICAgICAgICAic3BlY2ltZW4iOiB7ImRpc3BsYXkiOiB7InZhbHVlIjogIkcifX0KICAgICAg
fSwKICAgICAgInN1YmplY3QiOiB7ImlkIjogIlBhdGllbnQifSwKICAgICAgImlkIjogeyJ2YWx1
ZSI6ICJPQlItb2JzZXJ2YXRpb24tcmVxdWVzdCJ9LAogICAgICAidGV4dCI6IHsKICAgICAgICAi
ZGl2IjogewogICAgICAgICAgInAiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiY2xh
c3MiOiAiSSIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiRmlyc3QgT2JzZXJ2YXRpb24gUmVx
dWVzdCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAg
ICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6ICJJIiwKICAgICAgICAgICAgICAiY29udGVu
dCI6ICJTZWNvbmQgT2JzZXJ2YXRpb24gUmVxdWVzdCByZWxhdGVkIGludGVybmFsIGNvbW1lbnQg
bGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICJjbGFzcyI6
ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJGaXJzdCBPYnNlcnZhdGlvbiBSZXF1ZXN0
IHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAg
ewogICAgICAgICAgICAgICJjbGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJT
ZWNvbmQgT2JzZXJ2YXRpb24gUmVxdWVzdCByZWxhdGVkIHJlcG9ydCBjb21tZW50IGxpbmUiCiAg
ICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAieG1sbnMiOiAiaHR0cDovL3d3dy53
My5vcmcvMTk5OS94aHRtbCIKICAgICAgICB9LAogICAgICAgICJzdGF0dXMiOiB7InZhbHVlIjog
ImdlbmVyYXRlZCJ9CiAgICAgIH0sCiAgICAgICJldmVudCI6IHsKICAgICAgICAiZGF0ZVRpbWUi
OiB7InZhbHVlIjogIjIwMTYtMTEtMThUMjA6NTE6NTUrMDA6MDAifSwKICAgICAgICAiYWN0b3Ii
OiB7InJlZmVyZW5jZSI6IHsidmFsdWUiOiAiUHJhY3RpdGlvbmVyL29yZGVyaW5nLXByb3ZpZGVy
In19LAogICAgICAgICJzdGF0dXMiOiB7InZhbHVlIjogImNvbXBsZXRlZCJ9CiAgICAgIH0KICAg
IH19fSwKICAgIHsicmVzb3VyY2UiOiB7Ik9ic2VydmF0aW9uIjogewogICAgICAiY29kZSI6IHsi
Y29kaW5nIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogImh0dHA6Ly9zbm9tZWQuaW5m
by9zY3QifSwKICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAzNjU5ODEwMDd9LAogICAgICAgICJk
aXNwbGF5IjogeyJ2YWx1ZSI6ICJGaW5kaW5nIG9mIHRvYmFjY28gc21va2luZyBiZWhhdmlvciJ9
CiAgICAgIH19LAogICAgICAidmFsdWVTdHJpbmciOiB7InZhbHVlIjogIlNtb2tlIHR3byBjaWdh
cnMgZGFpbHkifSwKICAgICAgImlkIjogeyJ2YWx1ZSI6ICJPQlgtb2JzZXJ2YXRpb24ifSwKICAg
ICAgInRleHQiOiB7CiAgICAgICAgImRpdiI6IHsKICAgICAgICAgICJwIjogWwogICAgICAgICAg
ICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAgICAgICAgICJjb250ZW50Ijog
IkZpcnN0IG9ic2VydmF0aW9uIHJlbGF0ZWQgaW50ZXJuYWwgY29tbWVudCBsaW5lIgogICAgICAg
ICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImNsYXNzIjogIkkiLAogICAgICAg
ICAgICAgICJjb250ZW50IjogIlNlY29uZCBvYnNlcnZhdGlvbiByZWxhdGVkIGludGVybmFsIGNv
bW1lbnQgbGluZSIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICJj
bGFzcyI6ICJSIiwKICAgICAgICAgICAgICAiY29udGVudCI6ICJGaXJzdCBvYnNlcnZhdGlvbiBy
ZWxhdGVkIHJlcG9ydCBjb21tZW50IGxpbmUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsK
ICAgICAgICAgICAgICAiY2xhc3MiOiAiUiIsCiAgICAgICAgICAgICAgImNvbnRlbnQiOiAiU2Vj
b25kIG9ic2VydmF0aW9uIHJlbGF0ZWQgcmVwb3J0IGNvbW1lbnQgbGluZSIKICAgICAgICAgICAg
fQogICAgICAgICAgXSwKICAgICAgICAgICJ4bWxucyI6ICJodHRwOi8vd3d3LnczLm9yZy8xOTk5
L3hodG1sIgogICAgICAgIH0sCiAgICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAiZ2VuZXJhdGVk
In0KICAgICAgfSwKICAgICAgInN0YXR1cyI6IHsidmFsdWUiOiAicHJlbGltaW5hcnkifQogICAg
fX19LAogICAgeyJyZXNvdXJjZSI6IHsiQ29uZGl0aW9uIjogewogICAgICAiY29kZSI6IHsiY29k
aW5nIjogWwogICAgICAgIHsKICAgICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogImh0dHA6Ly9o
bDcub3JnL2ZoaXIvVmFsdWVTZXQvaWNkLTEwIn0sCiAgICAgICAgICAiY29kZSI6IHsidmFsdWUi
OiAiSTI1NzAwIn0sCiAgICAgICAgICAiZGlzcGxheSI6IHsidmFsdWUiOiAiQXRoZXJvc2NsZXJv
c2lzIG9mIENBQkcifQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgInN5c3RlbSI6IHsi
dmFsdWUiOiAiaHR0cDovL2hsNy5vcmcvZmhpci9zaWQvaWNkLTkifSwKICAgICAgICAgICJjb2Rl
IjogeyJ2YWx1ZSI6IDQxNC4zfQogICAgICAgIH0KICAgICAgXX0sCiAgICAgICJ2ZXJpZmljYXRp
b25TdGF0dXMiOiB7InZhbHVlIjogImNvbmZpcm1lZCJ9LAogICAgICAicGF0aWVudCI6IHsicmVm
ZXJlbmNlIjogeyJ2YWx1ZSI6ICJQYXRpZW50In19LAogICAgICAiaWQiOiB7InZhbHVlIjogIkRH
MS1kaWFnbm9zaXMifQogICAgfX19LAogICAgeyJyZXNvdXJjZSI6IHsiQ292ZXJhZ2UiOiB7CiAg
ICAgICJpZGVudGlmaWVyIjogeyJ2YWx1ZSI6IHsidmFsdWUiOiAxMjM0NTY3ODl9fSwKICAgICAg
ImNvbnRhaW5lZCI6IFsKICAgICAgICB7Ik9yZ2FuaXphdGlvbiI6IHsKICAgICAgICAgICJpZGVu
dGlmaWVyIjogeyJ2YWx1ZSI6IHsidmFsdWUiOiAiQVVIU0MifX0sCiAgICAgICAgICAiYWRkcmVz
cyI6IHsKICAgICAgICAgICAgImNvdW50cnkiOiB7InZhbHVlIjogIlVTQSJ9LAogICAgICAgICAg
ICAiY2l0eSI6IHsidmFsdWUiOiAiTWFzb24ifSwKICAgICAgICAgICAgInVzZSI6IHsidmFsdWUi
OiAid29yayJ9LAogICAgICAgICAgICAibGluZSI6IHsidmFsdWUiOiAiNDY5MCBQYXJrd2F5IERy
LiJ9LAogICAgICAgICAgICAicG9zdGFsQ29kZSI6IHsidmFsdWUiOiA0NTA0MH0sCiAgICAgICAg
ICAgICJzdGF0ZSI6IHsidmFsdWUiOiAiT0gifQogICAgICAgICAgfSwKICAgICAgICAgICJuYW1l
IjogeyJ2YWx1ZSI6ICJBRVROQSJ9LAogICAgICAgICAgInRlbGVjb20iOiB7CiAgICAgICAgICAg
ICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0sCiAgICAgICAgICAgICJ1c2UiOiB7InZhbHVl
IjogIndvcmsifSwKICAgICAgICAgICAgInZhbHVlIjogeyJ2YWx1ZSI6ICIxXjMzM140NDQ1NTU1
In0KICAgICAgICAgIH0sCiAgICAgICAgICAiaWQiOiB7InZhbHVlIjogImluc3VyYW5jZS1jb21w
YW55In0KICAgICAgICB9fSwKICAgICAgICB7IlBlcnNvbiI6IHsKICAgICAgICAgICJhZGRyZXNz
IjogewogICAgICAgICAgICAiY291bnRyeSI6IHsidmFsdWUiOiAiVVNBIn0sCiAgICAgICAgICAg
ICJjaXR5IjogeyJ2YWx1ZSI6ICJNYXNvbiJ9LAogICAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6
ICJob21lIn0sCiAgICAgICAgICAgICJsaW5lIjogeyJ2YWx1ZSI6ICIxMjMgTWFpbiBSb2FkIn0s
CiAgICAgICAgICAgICJwb3N0YWxDb2RlIjogeyJ2YWx1ZSI6IDQ1MDc3fSwKICAgICAgICAgICAg
InN0YXRlIjogeyJ2YWx1ZSI6ICJPSCJ9CiAgICAgICAgICB9LAogICAgICAgICAgIm5hbWUiOiB7
CiAgICAgICAgICAgICJnaXZlbiI6IFsKICAgICAgICAgICAgICB7InZhbHVlIjogIkluc3VyZWRf
Rmlyc3RuYW1lIn0sCiAgICAgICAgICAgICAgeyJ2YWx1ZSI6ICJNaWRkbGUifQogICAgICAgICAg
ICBdLAogICAgICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJvZmZpY2lhbCJ9LAogICAgICAgICAg
ICAiZmFtaWx5IjogeyJ2YWx1ZSI6ICJJbnN1cmVkX0xhc3RuYW1lIn0KICAgICAgICAgIH0sCiAg
ICAgICAgICAiaWQiOiB7InZhbHVlIjogImluc3VyZWQtcGVyc29uIn0KICAgICAgICB9fQogICAg
ICBdLAogICAgICAiZXh0ZW5zaW9uIjogWwogICAgICAgIHsKICAgICAgICAgICJ2YWx1ZUlkZW50
aWZpZXIiOiB7InZhbHVlIjogeyJ2YWx1ZSI6ICJBRVROQSJ9fSwKICAgICAgICAgICJ1cmwiOiAi
aHR0cDovL3d3dy5xdWVzdGRpYWdub3N0aWNzLmNvbSIKICAgICAgICB9LAogICAgICAgIHsKICAg
ICAgICAgICJ2YWx1ZVRpbWluZyI6IHsKICAgICAgICAgICAgImNvZGUiOiB7ImNvZGluZyI6IHsK
ICAgICAgICAgICAgICAic3lzdGVtIjogeyJ2YWx1ZSI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3Yy
LzA0ODUifSwKICAgICAgICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAiUyJ9LAogICAgICAgICAg
ICAgICJkaXNwbGF5IjogeyJ2YWx1ZSI6ICJTdGF0In0KICAgICAgICAgICAgfX0sCiAgICAgICAg
ICAgICJldmVudCI6IHsidmFsdWUiOiAiMjAxNi0wMS0wN1QwOTowMDowMC0wNTowMCJ9CiAgICAg
ICAgICB9LAogICAgICAgICAgInVybCI6ICJodHRwOi8vaGw3Lm9yZy9maGlyL3YyL3RxMSIKICAg
ICAgICB9CiAgICAgIF0sCiAgICAgICJwbGFuaG9sZGVyUmVmZXJlbmNlIjogeyJyZWZlcmVuY2Ui
OiB7InZhbHVlIjogIlBhdGllbnQvUElELXBhdGllbnQtaWRlbnRpZmljYXRpb24ifX0sCiAgICAg
ICJzdWJQbGFuIjogeyJ2YWx1ZSI6ICJDMTIzNDU2In0sCiAgICAgICJpc3N1ZXJSZWZlcmVuY2Ui
OiB7InJlZmVyZW5jZSI6IHsidmFsdWUiOiAiT3JnYW5pemF0aW9uL2luc3VyYW5jZS1jb21wYW55
In19LAogICAgICAiYmVuZWZpY2lhcnlJZGVudGlmaWVyIjogIiIsCiAgICAgICJpZCI6IHsidmFs
dWUiOiAiSU4xLWluc3VyYW5jZSJ9LAogICAgICAidHlwZSI6IHsiY29kZSI6IHsidmFsdWUiOiAi
UCJ9fSwKICAgICAgInJlbGF0aW9uc2hpcCI6IHsKICAgICAgICAiY29kZSI6IHsidmFsdWUiOiAx
fSwKICAgICAgICAiZGlzcGxheSI6IHsidmFsdWUiOiAiU2VsZiJ9CiAgICAgIH0sCiAgICAgICJw
bGFuIjogeyJ2YWx1ZSI6ICJQMTIzNDU2UiJ9LAogICAgICAiZ3JvdXAiOiB7InZhbHVlIjogIkEx
MjM0NSJ9CiAgICB9fX0sCiAgICB7InJlc291cmNlIjogeyJQZXJzb24iOiB7CiAgICAgICJhZGRy
ZXNzIjogewogICAgICAgICJjb3VudHJ5IjogeyJ2YWx1ZSI6ICJVU0EifSwKICAgICAgICAiY2l0
eSI6IHsidmFsdWUiOiAiTWFzb24ifSwKICAgICAgICAidXNlIjogeyJ2YWx1ZSI6ICJob21lIn0s
CiAgICAgICAgImxpbmUiOiB7InZhbHVlIjogIjQ2OTAgUGFya3dheSBEci4ifSwKICAgICAgICAi
cG9zdGFsQ29kZSI6IHsidmFsdWUiOiA0NTA0MH0sCiAgICAgICAgInN0YXRlIjogeyJ2YWx1ZSI6
ICJPSCJ9CiAgICAgIH0sCiAgICAgICJuYW1lIjogewogICAgICAgICJnaXZlbiI6IFsKICAgICAg
ICAgIHsidmFsdWUiOiAiSW5zdXJlZF9GaXJzdG5hbWUifSwKICAgICAgICAgIHsidmFsdWUiOiAi
TWlkZGxlIn0KICAgICAgICBdLAogICAgICAgICJ1c2UiOiB7InZhbHVlIjogIm9mZmljaWFsIn0s
CiAgICAgICAgImZhbWlseSI6IHsidmFsdWUiOiAiSW5zdXJlZF9MYXN0bmFtZSJ9CiAgICAgIH0s
CiAgICAgICJ0ZWxlY29tIjogewogICAgICAgICJzeXN0ZW0iOiB7InZhbHVlIjogInBob25lIn0s
CiAgICAgICAgInVzZSI6IHsidmFsdWUiOiAiaG9tZSJ9LAogICAgICAgICJ2YWx1ZSI6IHsidmFs
dWUiOiAiMV4zMzNeNDQ0NTU1NSJ9CiAgICAgIH0sCiAgICAgICJpZCI6IHsidmFsdWUiOiAiR1Qx
LWd1YXJhbnRvciJ9CiAgICB9fX0sCiAgICB7InJlc291cmNlIjogeyJQcmFjdGl0aW9uZXIiOiB7
CiAgICAgICJpZGVudGlmaWVyIjogewogICAgICAgICJhc3NpZ25lciI6IHsiZGlzcGxheSI6IHsi
dmFsdWUiOiAiTlBJIn19LAogICAgICAgICJ2YWx1ZSI6IHsidmFsdWUiOiAxMzY2NDcyNTU3fQog
ICAgICB9LAogICAgICAibmFtZSI6IHsKICAgICAgICAiZ2l2ZW4iOiBbCiAgICAgICAgICB7InZh
bHVlIjogIkphc29uIn0sCiAgICAgICAgICB7InZhbHVlIjogIlMuIn0KICAgICAgICBdLAogICAg
ICAgICJmYW1pbHkiOiB7InZhbHVlIjogIkphdmlsbG8ifQogICAgICB9LAogICAgICAiaWQiOiB7
InZhbHVlIjogIm9yZGVyaW5nLXByb3ZpZGVyIn0KICAgIH19fQogIF0sCiAgImlkIjogeyJ2YWx1
ZSI6ICJPTUwtTzIxLWIxYTE3Y2QyLTg2NWYtNDg2YS05NjBkLThlYTc3NjRlYzAwZCJ9LAogICJ0
eXBlIjogeyJ2YWx1ZSI6ICJzZWFyY2hzZXQifQp9fQ==</inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundDataType>JSON</inboundDataType>
      <outboundDataType>JSON</outboundDataType>
      <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
        <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
          <splitType>JavaScript</splitType>
          <batchScript></batchScript>
        </batchProperties>
      </inboundProperties>
      <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
        <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
          <splitType>JavaScript</splitType>
          <batchScript></batchScript>
        </batchProperties>
      </outboundProperties>
    </transformer>
    <filter version="3.4.2">
      <rules/>
    </filter>
    <transportName>Channel Reader</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <waitForPrevious>true</waitForPrevious>
  </sourceConnector>
  <destinationConnectors>
    <connector version="3.4.2">
      <metaDataId>2</metaDataId>
      <name>Create OML_O21</name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.4.2">
        <pluginProperties/>
        <destinationConnectorProperties version="3.4.2">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
        </destinationConnectorProperties>
        <script>return true;
</script>
      </properties>
      <transformer version="3.4.2">
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>OML templates</name>
            <script>// OML_O21 template with placeholders for required fields only
var oml_template = &quot;MSH|^~\&amp;|||||||OML^O21^OML_O21|||2.5.1\r&quot; + &quot;PID|1|||||||\r&quot;;
var oml = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(oml_template));

// MSH segment required fields (may be overwritten by MessageHeader resource)
oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = $(&quot;application&quot;);
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = $(&quot;account&quot;);
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = $(&quot;receivingFacility&quot;);

// Overrides
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = &quot;MET&quot;;
oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = &quot;PSC&quot;;
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = &quot;90046003&quot;;

// (Quest) Note: All date timestamps are set to Coordinated Universal Time (UTC).
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmssZ&quot;);
oml[&apos;MSH&apos;][&apos;MSH.7&apos;] = currentDate;

// Message Control ID is calculated based on date of submission
oml[&apos;MSH&apos;][&apos;MSH.10&apos;] = currentDate.toString().substring(0,14) + UUIDGenerator.getUUID().toString().substring(0,6);
oml[&apos;MSH&apos;][&apos;MSH.11&apos;] = $(&quot;processingID&quot;);


// A list of possible incoming JSON feed validation errors based on IN1.47 [Coverage Type] value
var error = [];</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>// OML_O21 template with placeholders for required fields only
var oml_template = &quot;MSH|^~\&amp;|||||||OML^O21^OML_O21|||2.5.1\r&quot; + &quot;PID|1|||||||\r&quot;;
var oml = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(oml_template));

// MSH segment required fields (may be overwritten by MessageHeader resource)
oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = $(&quot;application&quot;);
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = $(&quot;account&quot;);
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = $(&quot;receivingFacility&quot;);

// Overrides
oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = &quot;MET&quot;;
oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = &quot;PSC&quot;;
oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = &quot;90046003&quot;;

// (Quest) Note: All date timestamps are set to Coordinated Universal Time (UTC).
var currentDate = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmssZ&quot;);
oml[&apos;MSH&apos;][&apos;MSH.7&apos;] = currentDate;

// Message Control ID is calculated based on date of submission
oml[&apos;MSH&apos;][&apos;MSH.10&apos;] = currentDate.toString().substring(0,14) + UUIDGenerator.getUUID().toString().substring(0,6);
oml[&apos;MSH&apos;][&apos;MSH.11&apos;] = $(&quot;processingID&quot;);


// A list of possible incoming JSON feed validation errors based on IN1.47 [Coverage Type] value
var error = [];</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>1</sequenceNumber>
            <name>Iterate JSON resources</name>
            <script>// Global NTE Set ID value
var countNTE = 1; 

// Insurance list to retain primary and secondary
var coverageMap = new Packages.java.util.HashMap(2);

// Guarantor
var guarantorMap = new Packages.java.util.HashMap(1);

// Common Order
var commonOrderMap = new Packages.java.util.HashMap(4);
var placedOrderNumberMap = new Packages.java.util.HashMap(4);

// Timing/Quantity
var timingQuantityMap = new Packages.java.util.HashMap(4);

// Observation Request
var observationRequestMap = new Packages.java.util.HashMap(4);
var observationRequestCommentsMap = new Packages.java.util.HashMap(4);

// Diagnosis
var diagnosisMap = new Packages.java.util.HashMap(12);

// Observation/Result aka AOEs
var observationMap = new Packages.java.util.HashMap(4);
var observationCommentsMap = new Packages.java.util.HashMap(4);
var observationReferencesMap = new Packages.java.util.HashMap(4);

// ORC.12 Ordering Provider
// OBX.16 Ordering Provider
var practitionerMap = new Packages.java.util.HashMap(4);



// Preliminary store referenced resources
for each (obj in msg.Bundle.entry) {

	if (obj.resource.Practitioner != null &amp;&amp; obj.resource.Practitioner != undefined) {
logger.error( &quot;Found Practitioner&quot; );	

		
		// Practitioner is required to complete ORC and OBR segments
		var id = ((obj.resource.Practitioner.id != undefined) ? obj.resource.Practitioner.id.value.toString() : &quot;&quot;);
		if (id.length &gt; 0)
			practitionerMap.put(id.toString(), obj);
	}
}

logger.error( &quot;About to iterate: &quot; + obj.resource.toString() );	
// Iterate over all inbound feed resource
for each (obj in msg.Bundle.entry) {

logger.error( &quot;Resource: \n&quot; + JSON.stringify( obj.resource ) );	

	if (obj.resource.MessageHeader != null &amp;&amp; obj.resource.MessageHeader != undefined) {
logger.error( &quot;Found MessagerHeader&quot; );			
		// Update MessageHeader segment
		processMessageHeader(obj);

	} else if (obj.resource.Patient != null &amp;&amp; obj.resource.Patient != undefined) {
		// Populate PID segment
		processPatient(obj);
		
	} else if (obj.resource.DiagnosticReport != null &amp;&amp; obj.resource.DiagnosticReport != undefined) {
logger.error( &quot;Found Report&quot;);	
		// Populate ORC segment
		processCommonOrder(obj);
		
	} else if (obj.resource.DiagnosticOrder != null &amp;&amp; obj.resource.DiagnosticOrder != undefined) {
logger.error( &quot;Found Order&quot;);	
		// Populate OBR segment
		processObservationRequest(obj);

	} else if (obj.resource.Coverage != null &amp;&amp; obj.resource.Coverage != undefined) {
		// Populate IN1 segment
		processCoverage(obj);
		
	} else if (obj.resource.Person != null &amp;&amp; obj.resource.Person != undefined) {
		// Populate GT1 segment
		processGuarantor(obj);
		
	} else if (obj.resource.Observation != null &amp;&amp; obj.resource.Observation != undefined) {
		// Store Observation resource for OBX segment
		processObservation(obj);
	}

}


// ==================== COMPILE THE OML MESSAGE ====================

// Required primary insurance segment
var segInsurancePrimary = coverageMap.get(1);
if (segInsurancePrimary != null) try {
	oml.appendChild(new XML(segInsurancePrimary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding primary insurance segment - &quot; + ex);
}
// Optional secondary insurance segment
var segInsuranceSecondary = coverageMap.get(2);
if (segInsuranceSecondary != null) try {
	oml.appendChild(new XML(segInsuranceSecondary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding secondary insurance segment - &quot; + ex);
} 



// Optional Guarantor segment
var segGuarantor = guarantorMap.get(1);
if (segGuarantor != null) try {
	oml.appendChild(new XML(segGuarantor));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding Guarantor segment - &quot; + ex);	
}



// Required ORDER group
for (var i = 0; i &lt; commonOrderMap.size(); i++) {

	// ORC [Common Order] segment
	var segCommonOrder = commonOrderMap.get((i+1).toString());
	if (segCommonOrder != null) try {
		oml.appendChild(new XML(segCommonOrder));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding CommonOrder segment - &quot; + ex);
	}

	// TQ1 [Timing/Quantity] segment
	var segTimingQuantity = timingQuantityMap.get((i+1).toString());
	if (segTimingQuantity != null) try {
		oml.appendChild(new XML(segTimingQuantity));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Timing/Quantity segment - &quot; + ex);
	}

	// OBR [Observation Request] segment
	var segObservation = observationRequestMap.get((i+1).toString());
	if (segObservation != null) try {
		oml.appendChild(new XML(segObservation));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Observation Request segment - &quot; + ex);
	}
		

	// Observation level NTE [Comments] segments
	var obsComments = observationRequestCommentsMap.get((i+1).toString());
	if (obsComments != null &amp;&amp; Array.isArray(obsComments)) {
		for (var kk = 0; kk &lt; obsComments.length; kk++) {
			var nte = obsComments[kk];
			if (nte.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(nte.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Observation Comment segment - &quot; + ex);
			}
		}
		obsComments.length = 0;
	}
	
	// DG1 [Diagnosis] segments
	var conditions = diagnosisMap.get((i+1).toString());
	if (conditions != null &amp;&amp; Array.isArray(conditions)) {
		for (var dd = 0; dd &lt; conditions.length; dd++) {
			var dg1 = conditions[dd];
			if (dg1.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(dg1.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Diagnosis segment - &quot; + ex);
			}
		}
		conditions.length = 0;		
	}

	// OBX [Observation] segments
	// Get the list of OBX segment references
	var obsReference = observationReferencesMap.get((i+1).toString());
	if (obsReference != null &amp;&amp; Array.isArray(obsReference)) {
		for (var rr = 0; rr &lt; obsReference.length; rr++) {
			// Get the actual OBX segments
			var obx = observationMap.get(obsReference[rr]);
			if (obx != null &amp;&amp; obx.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(obx.toString()));

				// OBX level NTE [Comment] segments
				var observationComments = observationCommentsMap.get(obsReference[rr]);
				if (observationComments != null &amp;&amp; Array.isArray(observationComments)) {
					for (var oc = 0; oc &lt; observationComments.length; oc++) {
						var obxNTE = observationComments[oc];
						if (obxNTE != null &amp;&amp; obxNTE.length &gt; 0)
							oml.appendChild(new XML(obxNTE.toString()));
					}
				}
				observationComments.length = 0;
				
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding OBX segment - &quot; + ex);
			}		
		}		
		obsReference.length = 0;		
	}

}


// Clear all temporary maps
coverageMap.clear();
guarantorMap.clear();
commonOrderMap.clear();
placedOrderNumberMap.clear();
timingQuantityMap.clear();
observationRequestMap.clear();
observationRequestCommentsMap.clear();
diagnosisMap.clear();
observationMap.clear();
observationCommentsMap.clear(); 
observationReferencesMap.clear();
practitionerMap.clear();</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>// Global NTE Set ID value
var countNTE = 1; 

// Insurance list to retain primary and secondary
var coverageMap = new Packages.java.util.HashMap(2);

// Guarantor
var guarantorMap = new Packages.java.util.HashMap(1);

// Common Order
var commonOrderMap = new Packages.java.util.HashMap(4);
var placedOrderNumberMap = new Packages.java.util.HashMap(4);

// Timing/Quantity
var timingQuantityMap = new Packages.java.util.HashMap(4);

// Observation Request
var observationRequestMap = new Packages.java.util.HashMap(4);
var observationRequestCommentsMap = new Packages.java.util.HashMap(4);

// Diagnosis
var diagnosisMap = new Packages.java.util.HashMap(12);

// Observation/Result aka AOEs
var observationMap = new Packages.java.util.HashMap(4);
var observationCommentsMap = new Packages.java.util.HashMap(4);
var observationReferencesMap = new Packages.java.util.HashMap(4);

// ORC.12 Ordering Provider
// OBX.16 Ordering Provider
var practitionerMap = new Packages.java.util.HashMap(4);



// Preliminary store referenced resources
for each (obj in msg.Bundle.entry) {

	if (obj.resource.Practitioner != null &amp;&amp; obj.resource.Practitioner != undefined) {
logger.error( &quot;Found Practitioner&quot; );	

		
		// Practitioner is required to complete ORC and OBR segments
		var id = ((obj.resource.Practitioner.id != undefined) ? obj.resource.Practitioner.id.value.toString() : &quot;&quot;);
		if (id.length &gt; 0)
			practitionerMap.put(id.toString(), obj);
	}
}

logger.error( &quot;About to iterate: &quot; + obj.resource.toString() );	
// Iterate over all inbound feed resource
for each (obj in msg.Bundle.entry) {

logger.error( &quot;Resource: \n&quot; + JSON.stringify( obj.resource ) );	

	if (obj.resource.MessageHeader != null &amp;&amp; obj.resource.MessageHeader != undefined) {
logger.error( &quot;Found MessagerHeader&quot; );			
		// Update MessageHeader segment
		processMessageHeader(obj);

	} else if (obj.resource.Patient != null &amp;&amp; obj.resource.Patient != undefined) {
		// Populate PID segment
		processPatient(obj);
		
	} else if (obj.resource.DiagnosticReport != null &amp;&amp; obj.resource.DiagnosticReport != undefined) {
logger.error( &quot;Found Report&quot;);	
		// Populate ORC segment
		processCommonOrder(obj);
		
	} else if (obj.resource.DiagnosticOrder != null &amp;&amp; obj.resource.DiagnosticOrder != undefined) {
logger.error( &quot;Found Order&quot;);	
		// Populate OBR segment
		processObservationRequest(obj);

	} else if (obj.resource.Coverage != null &amp;&amp; obj.resource.Coverage != undefined) {
		// Populate IN1 segment
		processCoverage(obj);
		
	} else if (obj.resource.Person != null &amp;&amp; obj.resource.Person != undefined) {
		// Populate GT1 segment
		processGuarantor(obj);
		
	} else if (obj.resource.Observation != null &amp;&amp; obj.resource.Observation != undefined) {
		// Store Observation resource for OBX segment
		processObservation(obj);
	}

}


// ==================== COMPILE THE OML MESSAGE ====================

// Required primary insurance segment
var segInsurancePrimary = coverageMap.get(1);
if (segInsurancePrimary != null) try {
	oml.appendChild(new XML(segInsurancePrimary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding primary insurance segment - &quot; + ex);
}
// Optional secondary insurance segment
var segInsuranceSecondary = coverageMap.get(2);
if (segInsuranceSecondary != null) try {
	oml.appendChild(new XML(segInsuranceSecondary));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding secondary insurance segment - &quot; + ex);
} 



// Optional Guarantor segment
var segGuarantor = guarantorMap.get(1);
if (segGuarantor != null) try {
	oml.appendChild(new XML(segGuarantor));
} catch(ex) {
	logger.error(&quot;SubmitOrder-Destination: Error adding Guarantor segment - &quot; + ex);	
}



// Required ORDER group
for (var i = 0; i &lt; commonOrderMap.size(); i++) {

	// ORC [Common Order] segment
	var segCommonOrder = commonOrderMap.get((i+1).toString());
	if (segCommonOrder != null) try {
		oml.appendChild(new XML(segCommonOrder));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding CommonOrder segment - &quot; + ex);
	}

	// TQ1 [Timing/Quantity] segment
	var segTimingQuantity = timingQuantityMap.get((i+1).toString());
	if (segTimingQuantity != null) try {
		oml.appendChild(new XML(segTimingQuantity));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Timing/Quantity segment - &quot; + ex);
	}

	// OBR [Observation Request] segment
	var segObservation = observationRequestMap.get((i+1).toString());
	if (segObservation != null) try {
		oml.appendChild(new XML(segObservation));
	} catch(ex) {
		logger.error(&quot;SubmitOrder-Destination: Error adding Observation Request segment - &quot; + ex);
	}
		

	// Observation level NTE [Comments] segments
	var obsComments = observationRequestCommentsMap.get((i+1).toString());
	if (obsComments != null &amp;&amp; Array.isArray(obsComments)) {
		for (var kk = 0; kk &lt; obsComments.length; kk++) {
			var nte = obsComments[kk];
			if (nte.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(nte.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Observation Comment segment - &quot; + ex);
			}
		}
		obsComments.length = 0;
	}
	
	// DG1 [Diagnosis] segments
	var conditions = diagnosisMap.get((i+1).toString());
	if (conditions != null &amp;&amp; Array.isArray(conditions)) {
		for (var dd = 0; dd &lt; conditions.length; dd++) {
			var dg1 = conditions[dd];
			if (dg1.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(dg1.toString()));
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding Diagnosis segment - &quot; + ex);
			}
		}
		conditions.length = 0;		
	}

	// OBX [Observation] segments
	// Get the list of OBX segment references
	var obsReference = observationReferencesMap.get((i+1).toString());
	if (obsReference != null &amp;&amp; Array.isArray(obsReference)) {
		for (var rr = 0; rr &lt; obsReference.length; rr++) {
			// Get the actual OBX segments
			var obx = observationMap.get(obsReference[rr]);
			if (obx != null &amp;&amp; obx.toString() != &quot;&quot;) try {
				oml.appendChild(new XML(obx.toString()));

				// OBX level NTE [Comment] segments
				var observationComments = observationCommentsMap.get(obsReference[rr]);
				if (observationComments != null &amp;&amp; Array.isArray(observationComments)) {
					for (var oc = 0; oc &lt; observationComments.length; oc++) {
						var obxNTE = observationComments[oc];
						if (obxNTE != null &amp;&amp; obxNTE.length &gt; 0)
							oml.appendChild(new XML(obxNTE.toString()));
					}
				}
				observationComments.length = 0;
				
			} catch(ex) {
				logger.error(&quot;SubmitOrder-Destination: Error adding OBX segment - &quot; + ex);
			}		
		}		
		obsReference.length = 0;		
	}

}


// Clear all temporary maps
coverageMap.clear();
guarantorMap.clear();
commonOrderMap.clear();
placedOrderNumberMap.clear();
timingQuantityMap.clear();
observationRequestMap.clear();
observationRequestCommentsMap.clear();
diagnosisMap.clear();
observationMap.clear();
observationCommentsMap.clear(); 
observationReferencesMap.clear();
practitionerMap.clear();</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>2</sequenceNumber>
            <name>MSH segment</name>
            <script>/**
	Populates MSG segment with data from the MessageHeader resource
	@param {Object} obj - MessageHeader object resource
	@return - nothing, uses global HL7v2 message object
*/
function processMessageHeader(obj) {

	if (obj.resource.MessageHeader.source) {
		
		// The name of the sending application
		var sendingApplication = ((obj.resource.MessageHeader.source.name) ? obj.resource.MessageHeader.source.name.value.toString() : &quot;&quot;);
		if (sendingApplication) oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = sendingApplication;
		
		// Primary or secondary account number(s) defined for the placer. ~~ RKW - And the actual account number was less important?
		var sendingFacility = ((obj.resource.MessageHeader.source.endpoint) ? obj.resource.MessageHeader.source.endpoint.value.toString() : &quot;&quot;);
		if (sendingFacility) oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = sendingFacility;
			
	} 

	if (obj.resource.MessageHeader.destination) {
		
		// If provided must be hard-coded to &quot;PSC&quot; for PSC hold orders. If the &lt;name&gt; element is not provided or value is other than &quot;PSC&quot; the order is considered to be a basic lab order.
		var receivingApplication = ((obj.resource.MessageHeader.destination.name) ? obj.resource.MessageHeader.destination.name.value.toString() : &quot;&quot;);
		if (receivingApplication) oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = receivingApplication;


		// The receiving facility. The three-letter ID of the facility that performs the test.
		var receivingFacility = ((obj.resource.MessageHeader.destination.endpoint) ? obj.resource.MessageHeader.destination.endpoint.value.toString() : &quot;&quot;);
		if (receivingFacility) oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = receivingFacility;			
	}

	return;
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>/**
	Populates MSG segment with data from the MessageHeader resource
	@param {Object} obj - MessageHeader object resource
	@return - nothing, uses global HL7v2 message object
*/
function processMessageHeader(obj) {

	if (obj.resource.MessageHeader.source) {
		
		// The name of the sending application
		var sendingApplication = ((obj.resource.MessageHeader.source.name) ? obj.resource.MessageHeader.source.name.value.toString() : &quot;&quot;);
		if (sendingApplication) oml[&apos;MSH&apos;][&apos;MSH.3&apos;] = sendingApplication;
		
		// Primary or secondary account number(s) defined for the placer. ~~ RKW - And the actual account number was less important?
		var sendingFacility = ((obj.resource.MessageHeader.source.endpoint) ? obj.resource.MessageHeader.source.endpoint.value.toString() : &quot;&quot;);
		if (sendingFacility) oml[&apos;MSH&apos;][&apos;MSH.4&apos;] = sendingFacility;
			
	} 

	if (obj.resource.MessageHeader.destination) {
		
		// If provided must be hard-coded to &quot;PSC&quot; for PSC hold orders. If the &lt;name&gt; element is not provided or value is other than &quot;PSC&quot; the order is considered to be a basic lab order.
		var receivingApplication = ((obj.resource.MessageHeader.destination.name) ? obj.resource.MessageHeader.destination.name.value.toString() : &quot;&quot;);
		if (receivingApplication) oml[&apos;MSH&apos;][&apos;MSH.5&apos;] = receivingApplication;


		// The receiving facility. The three-letter ID of the facility that performs the test.
		var receivingFacility = ((obj.resource.MessageHeader.destination.endpoint) ? obj.resource.MessageHeader.destination.endpoint.value.toString() : &quot;&quot;);
		if (receivingFacility) oml[&apos;MSH&apos;][&apos;MSH.6&apos;] = receivingFacility;			
	}

	return;
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>3</sequenceNumber>
            <name>PID segment</name>
            <script>/**
	Populates PID segment with data from the Patient resource
	@param {Object} obj - Patient object resource
	@return - nothing, uses global HL7v2 message object
*/
function processPatient(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var comments = [];

	// Iterate over all patient identifiers
	obj.resource.Patient.identifier.forEach(function(item){

		// PID.3 [Patient Identifier List]
		if (item.use.value.toString() == &quot;official&quot;) {
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = id;

			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.5&apos;] = type;

			var assigner = ((item.assigner) ? item.assigner.display.value.toString() : &quot;&quot;);
			if (assigner)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = assigner;								

		// PID.2 [Patient ID]	
		} else if (item.use.value.toString() == &quot;secondary&quot;) {
		
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.1&apos;] = id;
				
			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.5&apos;] = type;			
						
		}
		
	});


	// Parse patient&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Patient.name, true);
	oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = nameParts.family;
	if (nameParts.given1) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = nameParts.given1;
	if (nameParts.given2) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = nameParts.given2;


	// Patient&apos;s DOB
	if (obj.resource.Patient.birthDate) {
		var dob = obj.resource.Patient.birthDate.value.toString();
		oml[&apos;PID&apos;][&apos;PID.7&apos;] = dob.replace(/-/g,&quot;&quot;);
	} else {
		error.push(&quot;resource.Patient.birthDate for PID.7[DateTime of Birth] is required&quot;);
	}

	// Administrative Gender 
	if (obj.resource.Patient.gender) {
		var gender = obj.resource.Patient.gender.value;
		oml[&apos;PID&apos;][&apos;PID.8&apos;] = convertTable(&quot;0001&quot;, gender);
	} else {
		error.push(&quot;resource.Patient.gender for PID.8[Administrative Sex] is required&quot;);		
	}




	// Patient Address
	if (obj.resource.Patient.address) {

		var street = ((obj.resource.Patient.address.line) ? obj.resource.Patient.address.line.value.toString() : &quot;&quot;);
		if (street)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = street;
		
		var city = ((obj.resource.Patient.address.city) ? obj.resource.Patient.address.city.value.toString() : &quot;&quot;);
		if (city)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = city;	
		
		var state = ((obj.resource.Patient.address.state) ? obj.resource.Patient.address.state.value.toString() : &quot;&quot;);
		if (state)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.4&apos;] = state;
	
		var postal = ((obj.resource.Patient.address.postalCode) ? obj.resource.Patient.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;] = postal;
	
		var country = ((obj.resource.Patient.address.country) ? obj.resource.Patient.address.country.value.toString() : &quot;&quot;);
		if (country)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.6&apos;] = country;

		// There might be a better definition what is required &quot;patient’s address&quot;.
		hasAddress = (street || city || state || postal);	
	}

	// Patient Phone Number (Home)	
	var phone = ((obj.resource.Patient.telecom) ? obj.resource.Patient.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		oml[&apos;PID&apos;][&apos;PID.13&apos;] = convertPhoneXTN(phone);
	}


	// Validate conditional fields
	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (!hasAddress) error.push(&quot;resource.Patient.address for PID.11[Patient Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Patient.telecom for PID.13[Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);
	}


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.Patient.text &amp;&amp; obj.resource.Patient.text.div) {	
		
		var internalCommentsCount = 0; //  only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.Patient.text.div.p.length &amp;&amp; obj.resource.Patient.text.div.p.length &gt; 0) {
			obj.resource.Patient.text.div.p.forEach(function(item){
				// For internal (I) or report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					// If the comment is not internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				} 		
			});	
		} else if (obj.resource.Patient.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.Patient.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.Patient.text.div.p, countNTE++));
		}

		for (var i = comments.length - 1; i &gt;= 0; i--) {
			var nte = comments[i];
			if (nte.toString() != &quot;&quot;)
				oml[&apos;PID&apos;] += new XML(nte.toString());
		}

		comments.length = 0;
	}

	return;
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>/**
	Populates PID segment with data from the Patient resource
	@param {Object} obj - Patient object resource
	@return - nothing, uses global HL7v2 message object
*/
function processPatient(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var comments = [];

	// Iterate over all patient identifiers
	obj.resource.Patient.identifier.forEach(function(item){

		// PID.3 [Patient Identifier List]
		if (item.use.value.toString() == &quot;official&quot;) {
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = id;

			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.5&apos;] = type;

			var assigner = ((item.assigner) ? item.assigner.display.value.toString() : &quot;&quot;);
			if (assigner)
				oml[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = assigner;								

		// PID.2 [Patient ID]	
		} else if (item.use.value.toString() == &quot;secondary&quot;) {
		
			var id = item.value.value.toString();
			if (id) 
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.1&apos;] = id;
				
			var type = ((item.type &amp;&amp; item.type.coding) ? item.type.coding.code.value.toString() : &quot;&quot;);
			if (type)
				oml[&apos;PID&apos;][&apos;PID.2&apos;][&apos;PID.2.5&apos;] = type;			
						
		}
		
	});


	// Parse patient&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Patient.name, true);
	oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = nameParts.family;
	if (nameParts.given1) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = nameParts.given1;
	if (nameParts.given2) oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = nameParts.given2;


	// Patient&apos;s DOB
	if (obj.resource.Patient.birthDate) {
		var dob = obj.resource.Patient.birthDate.value.toString();
		oml[&apos;PID&apos;][&apos;PID.7&apos;] = dob.replace(/-/g,&quot;&quot;);
	} else {
		error.push(&quot;resource.Patient.birthDate for PID.7[DateTime of Birth] is required&quot;);
	}

	// Administrative Gender 
	if (obj.resource.Patient.gender) {
		var gender = obj.resource.Patient.gender.value;
		oml[&apos;PID&apos;][&apos;PID.8&apos;] = convertTable(&quot;0001&quot;, gender);
	} else {
		error.push(&quot;resource.Patient.gender for PID.8[Administrative Sex] is required&quot;);		
	}




	// Patient Address
	if (obj.resource.Patient.address) {

		var street = ((obj.resource.Patient.address.line) ? obj.resource.Patient.address.line.value.toString() : &quot;&quot;);
		if (street)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = street;
		
		var city = ((obj.resource.Patient.address.city) ? obj.resource.Patient.address.city.value.toString() : &quot;&quot;);
		if (city)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = city;	
		
		var state = ((obj.resource.Patient.address.state) ? obj.resource.Patient.address.state.value.toString() : &quot;&quot;);
		if (state)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.4&apos;] = state;
	
		var postal = ((obj.resource.Patient.address.postalCode) ? obj.resource.Patient.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;] = postal;
	
		var country = ((obj.resource.Patient.address.country) ? obj.resource.Patient.address.country.value.toString() : &quot;&quot;);
		if (country)
			oml[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.6&apos;] = country;

		// There might be a better definition what is required &quot;patient’s address&quot;.
		hasAddress = (street || city || state || postal);	
	}

	// Patient Phone Number (Home)	
	var phone = ((obj.resource.Patient.telecom) ? obj.resource.Patient.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		oml[&apos;PID&apos;][&apos;PID.13&apos;] = convertPhoneXTN(phone);
	}


	// Validate conditional fields
	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (!hasAddress) error.push(&quot;resource.Patient.address for PID.11[Patient Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Patient.telecom for PID.13[Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);
	}


	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.Patient.text &amp;&amp; obj.resource.Patient.text.div) {	
		
		var internalCommentsCount = 0; //  only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.Patient.text.div.p.length &amp;&amp; obj.resource.Patient.text.div.p.length &gt; 0) {
			obj.resource.Patient.text.div.p.forEach(function(item){
				// For internal (I) or report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					// If the comment is not internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				} 		
			});	
		} else if (obj.resource.Patient.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.Patient.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.Patient.text.div.p, countNTE++));
		}

		for (var i = comments.length - 1; i &gt;= 0; i--) {
			var nte = comments[i];
			if (nte.toString() != &quot;&quot;)
				oml[&apos;PID&apos;] += new XML(nte.toString());
		}

		comments.length = 0;
	}

	return;
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>4</sequenceNumber>
            <name>IN1 primary and secondary segments</name>
            <script>/**
	Populates IN1 [Insurance] segments with data from the primary and secondary Coverage resources	
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCoverage(obj) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var isContainedPerson = hasPersonAddress = false;
	var isContainedOrganization = hasOrganizationAddress = false;

	var segIns = &lt;IN1&gt;
				&lt;IN1.1&gt;
					&lt;IN1.1.1&gt;1&lt;/IN1.1.1&gt;
				&lt;/IN1.1&gt;
				&lt;IN1.2/&gt;&lt;IN1.3/&gt;&lt;IN1.4/&gt;&lt;IN1.5/&gt;&lt;IN1.6/&gt;&lt;IN1.7/&gt;&lt;IN1.8/&gt;&lt;IN1.9/&gt;
				&lt;IN1.10/&gt;&lt;IN1.11/&gt;&lt;IN1.12/&gt;&lt;IN1.13/&gt;&lt;IN1.14/&gt;&lt;IN1.15/&gt;&lt;IN1.16/&gt;&lt;IN1.17/&gt;&lt;IN1.18/&gt;&lt;IN1.19/&gt;
				&lt;IN1.20/&gt;&lt;IN1.21/&gt;&lt;IN1.22/&gt;&lt;IN1.23/&gt;&lt;IN1.24/&gt;&lt;IN1.25/&gt;&lt;IN1.26/&gt;&lt;IN1.27/&gt;&lt;IN1.28/&gt;&lt;IN1.29/&gt;
				&lt;IN1.30/&gt;&lt;IN1.31/&gt;&lt;IN1.32/&gt;&lt;IN1.33/&gt;&lt;IN1.34/&gt;&lt;IN1.35/&gt;&lt;IN1.36/&gt;&lt;IN1.37/&gt;&lt;IN1.38/&gt;&lt;IN1.39/&gt;
				&lt;IN1.40/&gt;&lt;IN1.41/&gt;&lt;IN1.42/&gt;&lt;IN1.43/&gt;&lt;IN1.44/&gt;&lt;IN1.45/&gt;&lt;IN1.46/&gt;&lt;IN1.47/&gt;
			&lt;/IN1&gt;;

	// Insurance Set ID
	var coverageType = 1; 
	var setID = obj.resource.Coverage.id.value.toString();
	if (setID.indexOf(&quot;2&quot;) &gt; -1) {
		segIns[&apos;IN1.1&apos;] = &quot;2&quot;;
		coverageType = 2; // secondary - &quot;IN1-insurance-2&quot;
	} else {
		segIns[&apos;IN1.1&apos;] = &quot;1&quot;;
		coverageType = 1; // primary - &quot;IN1-insurance-1&quot;		
	}


	// Insurance Plan ID
	var planID = obj.resource.Coverage.identifier.value.value.toString();
	if (planID)
		segIns[&apos;IN1.2&apos;] = planID;


	if (obj.resource.Coverage.contained.length &amp;&amp; obj.resource.Coverage.contained.length &gt; 0) {

		// Loop through contained resources
		obj.resource.Coverage.contained.forEach(function(item){

			// Process contained insurance company
			processInsuranceOrganization(segIns, item);

			if (item.Person != null &amp;&amp; item.Person != undefined) {

				isContainedPerson = true;
				
				// Process insured person name with DEX name length limitation applied
				nameParts = processPersonName(item.Person.name, true);
	
				// Insured&apos;s Address
				if (item.Person.address) {
					var street = item.Person.address.line.value.toString();
					if (street)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.1&apos;] = street;
					
					var city = ((item.Person.address.city) ? item.Person.address.city.value.toString() : &quot;&quot;);
					if (city)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.3&apos;] = city;	
					
					var state = ((item.Person.address.state) ? item.Person.address.state.value.toString() : &quot;&quot;);
					if (state)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.4&apos;] = state;
				
					var postal = ((item.Person.address.postalCode) ? item.Person.address.postalCode.value.toString() : &quot;&quot;);
					if (postal)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.5&apos;] = postal;
				
					var country = ((item.Person.address.country) ? item.Person.address.country.value.toString() : &quot;&quot;);
					if (country)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.6&apos;] = country;
						
					// There might be a better definition what is required &quot;insured’s Address&quot;.
					hasPersonAddress = (street || city || state || postal);	
				}
			}
		});

	} else {
		// When only contained  insurance company is present
		processInsuranceOrganization(segIns, obj.resource.Coverage.contained);
	}

	// Insured&apos;s Group Employer Name 
	if (obj.resource.Coverage.extension) {
		var emplName = ((obj.resource.Coverage.extension.valueIdentifier) ? obj.resource.Coverage.extension.valueIdentifier.value.value.toString() : &quot;&quot;);
		if (emplName)
			segIns[&apos;IN1.11&apos;] = emplName;
	}


	// Group Number
	var groupNumber = ((obj.resource.Coverage.group) ? obj.resource.Coverage.group.value.toString() : &quot;&quot;);
	if (groupNumber)
		segIns[&apos;IN1.8&apos;] = groupNumber;



	

	// Name Of Insured
	// (SN) March 11, 2017: Fix to downgrade to DSTU3 Coverage resource. Previously checked only planholderReference.
/*	
	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
*/

	// Name Of Insured
	// (SN) March 13 2017: Disabled
	//var insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();

	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
	
	if (insuredRef == &quot;Patient/PID-patient-identification&quot;) {
		// Same as the PID segment
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString();
		
	} else if (insuredRef == &quot;Person/insured-person&quot;) {
		// Taken from the contained Person resource
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = nameParts.family;
		if (nameParts.given1.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = nameParts.given1;
		if (nameParts.given2.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = nameParts.given2;		
	}

	// Insured&apos;s Relationship To Patient
	if ( obj.resource.Coverage.relationship) {
		var relationship = ((obj.resource.Coverage.relationship.code) ? obj.resource.Coverage.relationship.code.value.toString() : &quot;&quot;);
		if (relationship)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;] = relationship;
		
		var relationshipDesc = ((obj.resource.Coverage.relationship.display) ? obj.resource.Coverage.relationship.display.value.toString() : &quot;&quot;);
		if (relationshipDesc)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.2&apos;] = relationshipDesc;
	}

	// Company Plan Code
	var planCode = (( obj.resource.Coverage.subPlan) ? obj.resource.Coverage.subPlan.value.toString() : &quot;&quot;);
	if (planCode)
		segIns[&apos;IN1.35&apos;] = planCode;

	// Policy Number
	var policyNumber = ((obj.resource.Coverage.plan) ? obj.resource.Coverage.plan.value.toString() : &quot;&quot;);
	if (policyNumber)
		segIns[&apos;IN1.36&apos;] = policyNumber;

	// Coverage Type
	segIns[&apos;IN1.47&apos;] = channelMap.get(&quot;CoverageType&quot;);


	if (coverage == &quot;T&quot;) {
		if (segIns[&apos;IN1.4&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Organization.name for IN1.4[Insurance Company Name] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.8&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.group for IN1.8[Group Number] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Person.name for IN1.16[Name Of Insured] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.relationship.code for IN1.17[Insured Relationship To Patient] is required if IN1.47[Coverage Type] is T&quot;);
		if (isContainedPerson &amp;&amp; !hasPersonAddress) error.push(&quot;resource.Coverage.contained.Person.address for IN1.19[Insured Address] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.36&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.plan for IN1.36[Policy Number] is required if IN1.47[Coverage Type] is T&quot;);		
	}


	// Store the segment to be later compiled into a message
	coverageMap.put(coverageType, segIns.toString());

	return;
}


/**
	Populates IN1.3 [Insurance Company ID] field with data from the contained Organization resource
	@param {Object} obj - Organization object resource
	@return - nothing, uses global HL7v2 message object
*/
function processInsuranceOrganization(segIns, item) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;

	if (item.Organization != null &amp;&amp; item.Organization != undefined) {

		isContainedOrganization = true;
		
		// Insurance Company ID
		var companyID = ((item.Organization.identifier) ? item.Organization.identifier.value.value.toString() : &quot;&quot;);
		if (companyID) 
			segIns[&apos;IN1.3&apos;] = companyID;
	
		// Insurance Company Name
		var companyName = ((item.Organization.name) ? item.Organization.name.value.toString() : &quot;&quot;);
		if (companyName)
			segIns[&apos;IN1.4&apos;] = companyName;

		// Insurance Company Address
		if (item.Organization.address) {
			var street = ((item.Organization.address.line) ? item.Organization.address.line.value.toString() : &quot;&quot;);
			if (street)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.1&apos;] = street;
				
			var city = ((item.Organization.address.city) ? item.Organization.address.city.value.toString() : &quot;&quot;);
			if (city)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.3&apos;] = city;
			
			var state = ((item.Organization.address.state) ? item.Organization.address.state.value.toString() : &quot;&quot;);
			if (state)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.4&apos;] = state;
		
			var postal = ((item.Organization.address.postalCode) ? item.Organization.address.postalCode.value.toString() : &quot;&quot;);
			if (postal)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.5&apos;] = postal;
		
			var country = ((item.Organization.address.country) ? item.Organization.address.country.value.toString() : &quot;&quot;);
			if (country)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.6&apos;] = country;

			// There might be a better definition what is required &quot;Insurance Company Address&quot;
			hasOrganizationAddress = (street || city || state || postal);						
		}		

		// Insurance Co Phone Number
		var phone = ((item.Organization.telecom) ? item.Organization.telecom.value.value.toString() : &quot;&quot;);
		if (phone) {
			hasPhone = true;
			segIns[&apos;IN1.7&apos;] = convertPhoneXTN(phone);
		}
	}

	// Validate conditional fields
	if (coverage == &quot;T&quot;) {		
		if (isContainedOrganization &amp;&amp; !hasOrganizationAddress) error.push(&quot;resource.Coverage.contained.Organization.address for IN1.5[Insurance Company Address] is required if IN1.47[Coverage Type] is T&quot;);
	}


	return;
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>/**
	Populates IN1 [Insurance] segments with data from the primary and secondary Coverage resources	
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCoverage(obj) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var isContainedPerson = hasPersonAddress = false;
	var isContainedOrganization = hasOrganizationAddress = false;

	var segIns = &lt;IN1&gt;
				&lt;IN1.1&gt;
					&lt;IN1.1.1&gt;1&lt;/IN1.1.1&gt;
				&lt;/IN1.1&gt;
				&lt;IN1.2/&gt;&lt;IN1.3/&gt;&lt;IN1.4/&gt;&lt;IN1.5/&gt;&lt;IN1.6/&gt;&lt;IN1.7/&gt;&lt;IN1.8/&gt;&lt;IN1.9/&gt;
				&lt;IN1.10/&gt;&lt;IN1.11/&gt;&lt;IN1.12/&gt;&lt;IN1.13/&gt;&lt;IN1.14/&gt;&lt;IN1.15/&gt;&lt;IN1.16/&gt;&lt;IN1.17/&gt;&lt;IN1.18/&gt;&lt;IN1.19/&gt;
				&lt;IN1.20/&gt;&lt;IN1.21/&gt;&lt;IN1.22/&gt;&lt;IN1.23/&gt;&lt;IN1.24/&gt;&lt;IN1.25/&gt;&lt;IN1.26/&gt;&lt;IN1.27/&gt;&lt;IN1.28/&gt;&lt;IN1.29/&gt;
				&lt;IN1.30/&gt;&lt;IN1.31/&gt;&lt;IN1.32/&gt;&lt;IN1.33/&gt;&lt;IN1.34/&gt;&lt;IN1.35/&gt;&lt;IN1.36/&gt;&lt;IN1.37/&gt;&lt;IN1.38/&gt;&lt;IN1.39/&gt;
				&lt;IN1.40/&gt;&lt;IN1.41/&gt;&lt;IN1.42/&gt;&lt;IN1.43/&gt;&lt;IN1.44/&gt;&lt;IN1.45/&gt;&lt;IN1.46/&gt;&lt;IN1.47/&gt;
			&lt;/IN1&gt;;

	// Insurance Set ID
	var coverageType = 1; 
	var setID = obj.resource.Coverage.id.value.toString();
	if (setID.indexOf(&quot;2&quot;) &gt; -1) {
		segIns[&apos;IN1.1&apos;] = &quot;2&quot;;
		coverageType = 2; // secondary - &quot;IN1-insurance-2&quot;
	} else {
		segIns[&apos;IN1.1&apos;] = &quot;1&quot;;
		coverageType = 1; // primary - &quot;IN1-insurance-1&quot;		
	}


	// Insurance Plan ID
	var planID = obj.resource.Coverage.identifier.value.value.toString();
	if (planID)
		segIns[&apos;IN1.2&apos;] = planID;


	if (obj.resource.Coverage.contained.length &amp;&amp; obj.resource.Coverage.contained.length &gt; 0) {

		// Loop through contained resources
		obj.resource.Coverage.contained.forEach(function(item){

			// Process contained insurance company
			processInsuranceOrganization(segIns, item);

			if (item.Person != null &amp;&amp; item.Person != undefined) {

				isContainedPerson = true;
				
				// Process insured person name with DEX name length limitation applied
				nameParts = processPersonName(item.Person.name, true);
	
				// Insured&apos;s Address
				if (item.Person.address) {
					var street = item.Person.address.line.value.toString();
					if (street)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.1&apos;] = street;
					
					var city = ((item.Person.address.city) ? item.Person.address.city.value.toString() : &quot;&quot;);
					if (city)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.3&apos;] = city;	
					
					var state = ((item.Person.address.state) ? item.Person.address.state.value.toString() : &quot;&quot;);
					if (state)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.4&apos;] = state;
				
					var postal = ((item.Person.address.postalCode) ? item.Person.address.postalCode.value.toString() : &quot;&quot;);
					if (postal)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.5&apos;] = postal;
				
					var country = ((item.Person.address.country) ? item.Person.address.country.value.toString() : &quot;&quot;);
					if (country)
						segIns[&apos;IN1.19&apos;][&apos;IN1.19.6&apos;] = country;
						
					// There might be a better definition what is required &quot;insured’s Address&quot;.
					hasPersonAddress = (street || city || state || postal);	
				}
			}
		});

	} else {
		// When only contained  insurance company is present
		processInsuranceOrganization(segIns, obj.resource.Coverage.contained);
	}

	// Insured&apos;s Group Employer Name 
	if (obj.resource.Coverage.extension) {
		var emplName = ((obj.resource.Coverage.extension.valueIdentifier) ? obj.resource.Coverage.extension.valueIdentifier.value.value.toString() : &quot;&quot;);
		if (emplName)
			segIns[&apos;IN1.11&apos;] = emplName;
	}


	// Group Number
	var groupNumber = ((obj.resource.Coverage.group) ? obj.resource.Coverage.group.value.toString() : &quot;&quot;);
	if (groupNumber)
		segIns[&apos;IN1.8&apos;] = groupNumber;



	

	// Name Of Insured
	// (SN) March 11, 2017: Fix to downgrade to DSTU3 Coverage resource. Previously checked only planholderReference.
/*	
	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
*/

	// Name Of Insured
	// (SN) March 13 2017: Disabled
	//var insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();

	var insuredRef;
	if (obj.resource.Coverage.planholderReference) {
		// STU3
		insuredRef = obj.resource.Coverage.planholderReference.reference.value.toString();
	} else if (obj.resource.Coverage.subscriberReference) {
		// DSTU3
		insuredRef = obj.resource.Coverage.subscriberReference.reference.value.toString();
	}
	
	if (insuredRef == &quot;Patient/PID-patient-identification&quot;) {
		// Same as the PID segment
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
		if (oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString())
			segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = oml[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString();
		
	} else if (insuredRef == &quot;Person/insured-person&quot;) {
		// Taken from the contained Person resource
		segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;] = nameParts.family;
		if (nameParts.given1.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.2&apos;] = nameParts.given1;
		if (nameParts.given2.length &gt; 0) segIns[&apos;IN1.16&apos;][&apos;IN1.16.3&apos;] = nameParts.given2;		
	}

	// Insured&apos;s Relationship To Patient
	if ( obj.resource.Coverage.relationship) {
		var relationship = ((obj.resource.Coverage.relationship.code) ? obj.resource.Coverage.relationship.code.value.toString() : &quot;&quot;);
		if (relationship)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;] = relationship;
		
		var relationshipDesc = ((obj.resource.Coverage.relationship.display) ? obj.resource.Coverage.relationship.display.value.toString() : &quot;&quot;);
		if (relationshipDesc)
			segIns[&apos;IN1.17&apos;][&apos;IN1.17.2&apos;] = relationshipDesc;
	}

	// Company Plan Code
	var planCode = (( obj.resource.Coverage.subPlan) ? obj.resource.Coverage.subPlan.value.toString() : &quot;&quot;);
	if (planCode)
		segIns[&apos;IN1.35&apos;] = planCode;

	// Policy Number
	var policyNumber = ((obj.resource.Coverage.plan) ? obj.resource.Coverage.plan.value.toString() : &quot;&quot;);
	if (policyNumber)
		segIns[&apos;IN1.36&apos;] = policyNumber;

	// Coverage Type
	segIns[&apos;IN1.47&apos;] = channelMap.get(&quot;CoverageType&quot;);


	if (coverage == &quot;T&quot;) {
		if (segIns[&apos;IN1.4&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Organization.name for IN1.4[Insurance Company Name] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.8&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.group for IN1.8[Group Number] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.16&apos;][&apos;IN1.16.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.contained.Person.name for IN1.16[Name Of Insured] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.17&apos;][&apos;IN1.17.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.relationship.code for IN1.17[Insured Relationship To Patient] is required if IN1.47[Coverage Type] is T&quot;);
		if (isContainedPerson &amp;&amp; !hasPersonAddress) error.push(&quot;resource.Coverage.contained.Person.address for IN1.19[Insured Address] is required if IN1.47[Coverage Type] is T&quot;);
		if (segIns[&apos;IN1.36&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Coverage.plan for IN1.36[Policy Number] is required if IN1.47[Coverage Type] is T&quot;);		
	}


	// Store the segment to be later compiled into a message
	coverageMap.put(coverageType, segIns.toString());

	return;
}


/**
	Populates IN1.3 [Insurance Company ID] field with data from the contained Organization resource
	@param {Object} obj - Organization object resource
	@return - nothing, uses global HL7v2 message object
*/
function processInsuranceOrganization(segIns, item) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;

	if (item.Organization != null &amp;&amp; item.Organization != undefined) {

		isContainedOrganization = true;
		
		// Insurance Company ID
		var companyID = ((item.Organization.identifier) ? item.Organization.identifier.value.value.toString() : &quot;&quot;);
		if (companyID) 
			segIns[&apos;IN1.3&apos;] = companyID;
	
		// Insurance Company Name
		var companyName = ((item.Organization.name) ? item.Organization.name.value.toString() : &quot;&quot;);
		if (companyName)
			segIns[&apos;IN1.4&apos;] = companyName;

		// Insurance Company Address
		if (item.Organization.address) {
			var street = ((item.Organization.address.line) ? item.Organization.address.line.value.toString() : &quot;&quot;);
			if (street)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.1&apos;] = street;
				
			var city = ((item.Organization.address.city) ? item.Organization.address.city.value.toString() : &quot;&quot;);
			if (city)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.3&apos;] = city;
			
			var state = ((item.Organization.address.state) ? item.Organization.address.state.value.toString() : &quot;&quot;);
			if (state)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.4&apos;] = state;
		
			var postal = ((item.Organization.address.postalCode) ? item.Organization.address.postalCode.value.toString() : &quot;&quot;);
			if (postal)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.5&apos;] = postal;
		
			var country = ((item.Organization.address.country) ? item.Organization.address.country.value.toString() : &quot;&quot;);
			if (country)
				segIns[&apos;IN1.5&apos;][&apos;IN1.5.6&apos;] = country;

			// There might be a better definition what is required &quot;Insurance Company Address&quot;
			hasOrganizationAddress = (street || city || state || postal);						
		}		

		// Insurance Co Phone Number
		var phone = ((item.Organization.telecom) ? item.Organization.telecom.value.value.toString() : &quot;&quot;);
		if (phone) {
			hasPhone = true;
			segIns[&apos;IN1.7&apos;] = convertPhoneXTN(phone);
		}
	}

	// Validate conditional fields
	if (coverage == &quot;T&quot;) {		
		if (isContainedOrganization &amp;&amp; !hasOrganizationAddress) error.push(&quot;resource.Coverage.contained.Organization.address for IN1.5[Insurance Company Address] is required if IN1.47[Coverage Type] is T&quot;);
	}


	return;
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>5</sequenceNumber>
            <name>GT1 segment</name>
            <script>/**
	Creates and populates GT1 [Guarantor] segment from the Person resource
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processGuarantor(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var gt1 = &lt;GT1&gt;
				&lt;GT1.1&gt;&lt;GT1.1.1&gt;1&lt;/GT1.1.1&gt;&lt;/GT1.1&gt;
				&lt;GT1.2/&gt;
				&lt;GT1.3&gt;&lt;GT1.3.1/&gt;&lt;GT1.3.2/&gt;&lt;/GT1.3&gt;
			&lt;/GT1&gt;;

	// Parse guarantor&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Person.name, true);
	gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;] = nameParts.family;
	if (nameParts.given1.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.2&apos;] = nameParts.given1;
	if (nameParts.given2.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.3&apos;] = nameParts.given2;	


	// Guarantor Address
	if (obj.resource.Person.address) {
		var street = ((obj.resource.Person.address.line) ? obj.resource.Person.address.line.value.toString() : &quot;&quot;);
		if (street)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.1&apos;] = street;
		
		var city = ((obj.resource.Person.address.city) ? obj.resource.Person.address.city.value.toString() : &quot;&quot;);
		if (city)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.3&apos;] = city;	
		
		var state = ((obj.resource.Person.address.state) ? obj.resource.Person.address.state.value.toString() : &quot;&quot;);
		if (state)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.4&apos;] = state;
	
		var postal = ((obj.resource.Person.address.postalCode) ? obj.resource.Person.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.5&apos;] = postal;
	
		var country = ((obj.resource.Person.address.country) ? obj.resource.Person.address.country.value.toString() : &quot;&quot;);
		if (country)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.6&apos;] = country;

		// There might be a better definition what is required &quot;guarantor address&quot;.
		hasAddress = (street || city || state || postal);			
	}


	// Guarantor Phon Number - Home
	var phone = ((obj.resource.Person.telecom) ? obj.resource.Person.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		gt1[&apos;GT1.6&apos;] = convertPhoneXTN(phone);
	}


	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Person.name for GT1.3[Guarantor Name] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasAddress) error.push(&quot;resource.Person.address for GT1.5[Guarantor Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Person.telecom for GT1.6[Guarantor Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);		
	}

	// Store the segment to be later compiled into a message
	guarantorMap.put(1, gt1.toString());

	return;
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>/**
	Creates and populates GT1 [Guarantor] segment from the Person resource
	@param {Object} obj - Coverage object resource
	@return - nothing, uses global HL7v2 message object
*/
function processGuarantor(obj) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);
	var hasAddress = false;
	var hasPhone = false;

	var gt1 = &lt;GT1&gt;
				&lt;GT1.1&gt;&lt;GT1.1.1&gt;1&lt;/GT1.1.1&gt;&lt;/GT1.1&gt;
				&lt;GT1.2/&gt;
				&lt;GT1.3&gt;&lt;GT1.3.1/&gt;&lt;GT1.3.2/&gt;&lt;/GT1.3&gt;
			&lt;/GT1&gt;;

	// Parse guarantor&apos;s name with DEX name length limitation applied
	var nameParts = processPersonName(obj.resource.Person.name, true);
	gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;] = nameParts.family;
	if (nameParts.given1.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.2&apos;] = nameParts.given1;
	if (nameParts.given2.length &gt; 0) gt1[&apos;GT1.3&apos;][&apos;GT1.3.3&apos;] = nameParts.given2;	


	// Guarantor Address
	if (obj.resource.Person.address) {
		var street = ((obj.resource.Person.address.line) ? obj.resource.Person.address.line.value.toString() : &quot;&quot;);
		if (street)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.1&apos;] = street;
		
		var city = ((obj.resource.Person.address.city) ? obj.resource.Person.address.city.value.toString() : &quot;&quot;);
		if (city)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.3&apos;] = city;	
		
		var state = ((obj.resource.Person.address.state) ? obj.resource.Person.address.state.value.toString() : &quot;&quot;);
		if (state)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.4&apos;] = state;
	
		var postal = ((obj.resource.Person.address.postalCode) ? obj.resource.Person.address.postalCode.value.toString() : &quot;&quot;);
		if (postal)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.5&apos;] = postal;
	
		var country = ((obj.resource.Person.address.country) ? obj.resource.Person.address.country.value.toString() : &quot;&quot;);
		if (country)
			gt1[&apos;GT1.5&apos;][&apos;GT1.5.6&apos;] = country;

		// There might be a better definition what is required &quot;guarantor address&quot;.
		hasAddress = (street || city || state || postal);			
	}


	// Guarantor Phon Number - Home
	var phone = ((obj.resource.Person.telecom) ? obj.resource.Person.telecom.value.value.toString() : &quot;&quot;);
	if (phone) {
		hasPhone = true;
		gt1[&apos;GT1.6&apos;] = convertPhoneXTN(phone);
	}


	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (gt1[&apos;GT1.3&apos;][&apos;GT1.3.1&apos;].toString() == &quot;&quot;) error.push(&quot;resource.Person.name for GT1.3[Guarantor Name] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasAddress) error.push(&quot;resource.Person.address for GT1.5[Guarantor Address] is required if IN1.47[Coverage Type] is P or T&quot;);
		if (!hasPhone) error.push(&quot;resource.Person.telecom for GT1.6[Guarantor Phone Number-Home] is required if IN1.47[Coverage Type] is P or T&quot;);		
	}

	// Store the segment to be later compiled into a message
	guarantorMap.put(1, gt1.toString());

	return;
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>6</sequenceNumber>
            <name>ORC segment</name>
            <script>/**
	Populates ORC [Common Order] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticReport object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCommonOrder(obj) {


	var orc = &lt;ORC&gt;&lt;ORC.1&gt;&lt;ORC.1.1&gt;NW&lt;/ORC.1.1&gt;&lt;/ORC.1&gt;&lt;/ORC&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticReport.id) ? obj.resource.DiagnosticReport.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);

	logger.error( &quot;Group Count: &quot; + groupCount );
	logger.error( &quot;Group ID: &quot; + groupID );
			
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticReport.id element is undefined or not properly formatted, expected: ORC-common-order-n, where n identifies the order group&quot;);
	}


	// Placer Order Number
	// The value in ORC.02.01 (Entity Identifier) is the same as the value in OBR.02.01 (Entity Identifier)
	// All values for this field in all ORC and OBR segments are identical.
	// March 12: Moved into DiagnosticReport.identifier verified block 
	//var id = obj.resource.DiagnosticReport.identifier.value.value.toString();
	//if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;

	if (obj.resource.DiagnosticReport.identifier) {

		var id = ((obj.resource.DiagnosticReport.identifier.value.value) ? obj.resource.DiagnosticReport.identifier.value.value.toString():&quot;&quot;);
		if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;
		logger.error( &quot;Placer Number Order: &quot; + id );
		
		var namespaceID = ((obj.resource.DiagnosticReport.identifier.system) ? obj.resource.DiagnosticReport.identifier.system.value.toString() : &quot;&quot;);
		if (namespaceID) orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;] = namespaceID;
	
		var universalID = ((obj.resource.DiagnosticReport.identifier.type) ? obj.resource.DiagnosticReport.identifier.type.id.toString() : &quot;&quot;);
		if (universalID) orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;] = universalID;
	}
	else
	{
		logger.error( &quot;Missing identifier in in Diagnostic Report:&quot; + groupID )
	}


	// Store the Placer Order Number for the OBR segment
	var diagnosticOrderID = ((obj.resource.DiagnosticReport.request) ? obj.resource.DiagnosticReport.request.reference.value.toString() : &quot;&quot;);
	if (diagnosticOrderID.indexOf(&quot;DiagnosticOrder/&quot;) &gt; -1) {
		diagnosticOrderID = diagnosticOrderID.substring(&quot;DiagnosticOrder/&quot;.length, diagnosticOrderID.length);

		logger.error( &quot;DiagnosticOrderID: &quot; + diagnosticOrderID );
		
		var placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};

		placedOrderNumber.id = orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;].toString();
		placedOrderNumber.namespaceID = orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;].toString();
		placedOrderNumber.universalID = orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;].toString();
		placedOrderNumberMap.put(diagnosticOrderID, placedOrderNumber);		
	}
	else
	{
		logger.error( &quot;No Diagnostic Order Found&quot; );
	}


	// Verified By Practitioner
	if (obj.resource.DiagnosticReport.contained != null &amp;&amp; obj.resource.DiagnosticReport.contained != undefined) {
		var verifiedByID = obj.resource.DiagnosticReport.contained.Practitioner.identifier.value.value.toString();
		if (verifiedByID)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.1&apos;] = verifiedByID;
			
		var familyName = ((obj.resource.DiagnosticReport.contained.Practitioner.name) ? obj.resource.DiagnosticReport.contained.Practitioner.name.family.value.toString() : &quot;&quot;);
		if (familyName)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.2&apos;] = familyName;		
	}

	// Process extension for TQ1 [Timing/Quantity] segment
	if (obj.resource.DiagnosticReport.extension.valueTiming != null &amp;&amp; obj.resource.DiagnosticReport.extension.valueTiming != undefined) {
		processTimingQuantity(groupCount, obj.resource.DiagnosticReport.extension.valueTiming);
	}

	// Process zero or many DiagnosticReport/codedDiagnosis elements for DG1 [Diagnosis] segment
	var conditions = [];
	if (obj.resource.DiagnosticReport.codedDiagnosis) {

		if (obj.resource.DiagnosticReport.codedDiagnosis.length &gt; 0) {
			var setID = 1;
			obj.resource.DiagnosticReport.codedDiagnosis.forEach(function(item){
				// A maximum of 12 unique ICD-10 codes are permitted per entire OML message
				// (SN) This code checks only codedDiagnosis in a single DiagnosticReport
				if (setID &lt;= 12) conditions.push(processCondition(item, setID++));				 
			});
		} else {
			conditions.push(processCondition(obj.resource.DiagnosticReport.codedDiagnosis, 1)); 
		}
	}

	// Process zero or many result/reference elements for OBX [Observation] segment
	var observationReferences = [];
	if (obj.resource.DiagnosticReport.result) {
		var ref;
		if (obj.resource.DiagnosticReport.result.length &gt; 0) {
			obj.resource.DiagnosticReport.result.forEach(function(item){
				ref = item.reference.value.toString();
				if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
			});
		} else {
			ref = ((obj.resource.DiagnosticReport.result.reference != undefined) ? obj.resource.DiagnosticReport.result.reference.value.toString() : &quot;&quot;);
			if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
		}		
	}


	// ORC.12 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticReport.performer != undefined) ? obj.resource.DiagnosticReport.performer.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(&quot;Practitioner/&quot;.length, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) orc[&apos;ORC.12&apos;][&apos;ORC.12.1&apos;] = id;
	
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) orc[&apos;ORC.12&apos;][&apos;ORC.12.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			orc[&apos;ORC.12&apos;][&apos;ORC.12.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.4&apos;] = nameParts.given2;				
		}
	}
	

	// Store the segment to be later compiled into a message
	commonOrderMap.put(groupCount.toString(), orc.toString());

	// Store the array of diagnosis to be later compiled into a message
	if (conditions.length &gt; 0) diagnosisMap.put(groupCount.toString(), conditions);

	// Store the array of Observations to be later compiled into a message
	if (observationReferences.length &gt; 0) observationReferencesMap.put(groupCount.toString(), observationReferences);


	return;
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>/**
	Populates ORC [Common Order] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticReport object resource
	@return - nothing, uses global HL7v2 message object
*/
function processCommonOrder(obj) {


	var orc = &lt;ORC&gt;&lt;ORC.1&gt;&lt;ORC.1.1&gt;NW&lt;/ORC.1.1&gt;&lt;/ORC.1&gt;&lt;/ORC&gt;;

	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticReport.id) ? obj.resource.DiagnosticReport.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);

	logger.error( &quot;Group Count: &quot; + groupCount );
	logger.error( &quot;Group ID: &quot; + groupID );
			
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticReport.id element is undefined or not properly formatted, expected: ORC-common-order-n, where n identifies the order group&quot;);
	}


	// Placer Order Number
	// The value in ORC.02.01 (Entity Identifier) is the same as the value in OBR.02.01 (Entity Identifier)
	// All values for this field in all ORC and OBR segments are identical.
	// March 12: Moved into DiagnosticReport.identifier verified block 
	//var id = obj.resource.DiagnosticReport.identifier.value.value.toString();
	//if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;

	if (obj.resource.DiagnosticReport.identifier) {

		var id = ((obj.resource.DiagnosticReport.identifier.value.value) ? obj.resource.DiagnosticReport.identifier.value.value.toString():&quot;&quot;);
		if (id) orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;] = id;
		logger.error( &quot;Placer Number Order: &quot; + id );
		
		var namespaceID = ((obj.resource.DiagnosticReport.identifier.system) ? obj.resource.DiagnosticReport.identifier.system.value.toString() : &quot;&quot;);
		if (namespaceID) orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;] = namespaceID;
	
		var universalID = ((obj.resource.DiagnosticReport.identifier.type) ? obj.resource.DiagnosticReport.identifier.type.id.toString() : &quot;&quot;);
		if (universalID) orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;] = universalID;
	}
	else
	{
		logger.error( &quot;Missing identifier in in Diagnostic Report:&quot; + groupID )
	}


	// Store the Placer Order Number for the OBR segment
	var diagnosticOrderID = ((obj.resource.DiagnosticReport.request) ? obj.resource.DiagnosticReport.request.reference.value.toString() : &quot;&quot;);
	if (diagnosticOrderID.indexOf(&quot;DiagnosticOrder/&quot;) &gt; -1) {
		diagnosticOrderID = diagnosticOrderID.substring(&quot;DiagnosticOrder/&quot;.length, diagnosticOrderID.length);

		logger.error( &quot;DiagnosticOrderID: &quot; + diagnosticOrderID );
		
		var placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};

		placedOrderNumber.id = orc[&apos;ORC.2&apos;][&apos;ORC.2.1&apos;].toString();
		placedOrderNumber.namespaceID = orc[&apos;ORC.2&apos;][&apos;ORC.2.2&apos;].toString();
		placedOrderNumber.universalID = orc[&apos;ORC.2&apos;][&apos;ORC.2.3&apos;].toString();
		placedOrderNumberMap.put(diagnosticOrderID, placedOrderNumber);		
	}
	else
	{
		logger.error( &quot;No Diagnostic Order Found&quot; );
	}


	// Verified By Practitioner
	if (obj.resource.DiagnosticReport.contained != null &amp;&amp; obj.resource.DiagnosticReport.contained != undefined) {
		var verifiedByID = obj.resource.DiagnosticReport.contained.Practitioner.identifier.value.value.toString();
		if (verifiedByID)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.1&apos;] = verifiedByID;
			
		var familyName = ((obj.resource.DiagnosticReport.contained.Practitioner.name) ? obj.resource.DiagnosticReport.contained.Practitioner.name.family.value.toString() : &quot;&quot;);
		if (familyName)
			orc[&apos;ORC.11&apos;][&apos;ORC.11.2&apos;] = familyName;		
	}

	// Process extension for TQ1 [Timing/Quantity] segment
	if (obj.resource.DiagnosticReport.extension.valueTiming != null &amp;&amp; obj.resource.DiagnosticReport.extension.valueTiming != undefined) {
		processTimingQuantity(groupCount, obj.resource.DiagnosticReport.extension.valueTiming);
	}

	// Process zero or many DiagnosticReport/codedDiagnosis elements for DG1 [Diagnosis] segment
	var conditions = [];
	if (obj.resource.DiagnosticReport.codedDiagnosis) {

		if (obj.resource.DiagnosticReport.codedDiagnosis.length &gt; 0) {
			var setID = 1;
			obj.resource.DiagnosticReport.codedDiagnosis.forEach(function(item){
				// A maximum of 12 unique ICD-10 codes are permitted per entire OML message
				// (SN) This code checks only codedDiagnosis in a single DiagnosticReport
				if (setID &lt;= 12) conditions.push(processCondition(item, setID++));				 
			});
		} else {
			conditions.push(processCondition(obj.resource.DiagnosticReport.codedDiagnosis, 1)); 
		}
	}

	// Process zero or many result/reference elements for OBX [Observation] segment
	var observationReferences = [];
	if (obj.resource.DiagnosticReport.result) {
		var ref;
		if (obj.resource.DiagnosticReport.result.length &gt; 0) {
			obj.resource.DiagnosticReport.result.forEach(function(item){
				ref = item.reference.value.toString();
				if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
			});
		} else {
			ref = ((obj.resource.DiagnosticReport.result.reference != undefined) ? obj.resource.DiagnosticReport.result.reference.value.toString() : &quot;&quot;);
			if (ref) observationReferences.push(ref.substring(&quot;Observation/&quot;.length, ref.length));
		}		
	}


	// ORC.12 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticReport.performer != undefined) ? obj.resource.DiagnosticReport.performer.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(&quot;Practitioner/&quot;.length, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) orc[&apos;ORC.12&apos;][&apos;ORC.12.1&apos;] = id;
	
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) orc[&apos;ORC.12&apos;][&apos;ORC.12.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			orc[&apos;ORC.12&apos;][&apos;ORC.12.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) orc[&apos;ORC.12&apos;][&apos;ORC.12.4&apos;] = nameParts.given2;				
		}
	}
	

	// Store the segment to be later compiled into a message
	commonOrderMap.put(groupCount.toString(), orc.toString());

	// Store the array of diagnosis to be later compiled into a message
	if (conditions.length &gt; 0) diagnosisMap.put(groupCount.toString(), conditions);

	// Store the array of Observations to be later compiled into a message
	if (observationReferences.length &gt; 0) observationReferencesMap.put(groupCount.toString(), observationReferences);


	return;
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>7</sequenceNumber>
            <name>TQ1 segment</name>
            <script>/**
	Populates TQ1 [Timing/Quantity] segment with data from the DiagnosticReport extension
	@param {Integer} count - Common Order group count
	@param {Object} valueTiming - valueTiming extension
	@return - nothing, uses global map
*/
function processTimingQuantity(count, valueTiming) {
	
	// TQ1 [Timing/Quantity] segment
	if (valueTiming != null &amp;&amp; valueTiming != undefined) {

		var tq1 = &lt;TQ1&gt;&lt;TQ1.1&gt;&lt;TQ1.1.1&gt;1&lt;/TQ1.1.1&gt;&lt;/TQ1.1&gt;&lt;/TQ1&gt;;

		tq1[&apos;TQ1.1&apos;][&apos;TQ1.1.1&apos;] = count;
			
		var startDateTime = ((valueTiming.event) ? valueTiming.event.value.toString() : &quot;&quot;);
		if (startDateTime)
			tq1[&apos;TQ1.7&apos;] = convertJSONDateTime(startDateTime);

		var priorityCode = ((valueTiming.code) ? valueTiming.code.coding.code.value.toString() : &quot;&quot;);
		if (priorityCode)
			tq1[&apos;TQ1.9&apos;][&apos;TQ1.9.1&apos;] = priorityCode;
	}

	// Store the segment to be later compiled into a message
	timingQuantityMap.put(count.toString(), tq1.toString());

	return;
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>/**
	Populates TQ1 [Timing/Quantity] segment with data from the DiagnosticReport extension
	@param {Integer} count - Common Order group count
	@param {Object} valueTiming - valueTiming extension
	@return - nothing, uses global map
*/
function processTimingQuantity(count, valueTiming) {
	
	// TQ1 [Timing/Quantity] segment
	if (valueTiming != null &amp;&amp; valueTiming != undefined) {

		var tq1 = &lt;TQ1&gt;&lt;TQ1.1&gt;&lt;TQ1.1.1&gt;1&lt;/TQ1.1.1&gt;&lt;/TQ1.1&gt;&lt;/TQ1&gt;;

		tq1[&apos;TQ1.1&apos;][&apos;TQ1.1.1&apos;] = count;
			
		var startDateTime = ((valueTiming.event) ? valueTiming.event.value.toString() : &quot;&quot;);
		if (startDateTime)
			tq1[&apos;TQ1.7&apos;] = convertJSONDateTime(startDateTime);

		var priorityCode = ((valueTiming.code) ? valueTiming.code.coding.code.value.toString() : &quot;&quot;);
		if (priorityCode)
			tq1[&apos;TQ1.9&apos;][&apos;TQ1.9.1&apos;] = priorityCode;
	}

	// Store the segment to be later compiled into a message
	timingQuantityMap.put(count.toString(), tq1.toString());

	return;
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>8</sequenceNumber>
            <name>OBR segment</name>
            <script>/**
	Populates OBR [Observation Request] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticOrder object resource
	@return - nothing, uses global HL7v2 message object
*/
function processObservationRequest(obj) {

	var comments = [];

	var obr = &lt;OBR&gt;&lt;OBR.1&gt;&lt;OBR.1.1&gt;1&lt;/OBR.1.1&gt;&lt;/OBR.1&gt;
				&lt;OBR.2/&gt;&lt;OBR.3/&gt;
				&lt;OBR.4&gt;&lt;OBR.4.1/&gt;&lt;OBR.4.2/&gt;&lt;OBR.4.3/&gt;&lt;OBR.4.4/&gt;&lt;OBR.4.5/&gt;&lt;/OBR.4&gt;
				&lt;OBR.5/&gt;&lt;OBR.6/&gt;&lt;OBR.7/&gt;&lt;OBR.8/&gt;&lt;OBR.9/&gt;
				&lt;OBR.10/&gt;&lt;OBR.11/&gt;&lt;OBR.12/&gt;&lt;OBR.13/&gt;&lt;OBR.14/&gt;&lt;OBR.15/&gt;
				&lt;OBR.16&gt;&lt;OBR.16.1/&gt;&lt;OBR.16.2/&gt;&lt;OBR.16.3/&gt;&lt;OBR.16.4/&gt;&lt;OBR.16.5/&gt;&lt;OBR.16.6/&gt;&lt;OBR.16.7/&gt;&lt;OBR.16.8/&gt;&lt;/OBR.16&gt;
			&lt;/OBR&gt;;


	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticOrder.id) ? obj.resource.DiagnosticOrder.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);
		
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticOrder.id element is undefined or not properly formatted, expected: OBR-observation-request-n, where n identifies the order group&quot;);
	}


	// OBR.2 [Placer Order Number] is stored during the DiagnosticReport resource processing	
	var resourceID = obj.resource.DiagnosticOrder.id.value.toString();
	// Extracts the following object - placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};
	var placedOrderNumber = placedOrderNumberMap.get(resourceID);
	if (placedOrderNumber) {
		if (placedOrderNumber.id) obr[&apos;OBR.2&apos;][&apos;OBR.2.1&apos;] = placedOrderNumber.id.toString();
		if (placedOrderNumber.namespaceID) obr[&apos;OBR.2&apos;][&apos;OBR.2.2&apos;] = placedOrderNumber.namespaceID.toStrign();
		if (placedOrderNumber.universalID) obr[&apos;OBR.2&apos;][&apos;OBR.2.3&apos;] = placedOrderNumber.universalID.toString();
	}
	

	// Universal Service Identifier	
	var alternateID = obj.resource.DiagnosticOrder.item.code.coding.code.value.toString();
	if (alternateID)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.4&apos;] = alternateID;

	var alternateText = obj.resource.DiagnosticOrder.item.code.coding.display.value.toString();
	if (alternateText)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.5&apos;] = alternateText;

	// Observation Date/Time	
	var observationDateTime = obj.resource.DiagnosticOrder.event.dateTime.value.toString();
	if (observationDateTime) {
		// Format : yyyymmddhhmm
		var specimenCollectionDate = convertJSONDateTime(observationDateTime);
		obr[&apos;OBR.7&apos;] = specimenCollectionDate.substring(0, 12);
	}

	// Specimen Action Code
	var actionCode = ((obj.resource.DiagnosticOrder.item.specimen) ? obj.resource.DiagnosticOrder.item.specimen.display.value.toString() : &quot;&quot;);
	if (actionCode)
		obr[&apos;OBR.11&apos;] = actionCode;

	// OBR.16 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticOrder.event.actor.reference != undefined) ? obj.resource.DiagnosticOrder.event.actor.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(13, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) obr[&apos;OBR.16&apos;][&apos;OBR.16.1&apos;] = id;
				
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) obr[&apos;OBR.16&apos;][&apos;OBR.16.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			obr[&apos;OBR.16&apos;][&apos;OBR.16.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.4&apos;] = nameParts.given2;			
		}
	}

	// Store the segment to be later compiled into a message
	observationRequestMap.put(groupCount.toString(), obr.toString());




	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.DiagnosticOrder.text &amp;&amp; obj.resource.DiagnosticOrder.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.DiagnosticOrder.text.div.p.length &amp;&amp; obj.resource.DiagnosticOrder.text.div.p.length &gt; 0) {
			obj.resource.DiagnosticOrder.text.div.p.forEach(function(item){
				// For internal (I) and report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
						
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
						// If the comment is other than internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.DiagnosticOrder.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.DiagnosticOrder.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.DiagnosticOrder.text.div.p, countNTE++));			
		}

		// Store the comments array to be later compiled into a message
		observationRequestCommentsMap.put(groupCount.toString(), comments);

	}


	return;
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>/**
	Populates OBR [Observation Request] segment from the DiagnosticReport resource
	@param {Object} obj - DiagnosticOrder object resource
	@return - nothing, uses global HL7v2 message object
*/
function processObservationRequest(obj) {

	var comments = [];

	var obr = &lt;OBR&gt;&lt;OBR.1&gt;&lt;OBR.1.1&gt;1&lt;/OBR.1.1&gt;&lt;/OBR.1&gt;
				&lt;OBR.2/&gt;&lt;OBR.3/&gt;
				&lt;OBR.4&gt;&lt;OBR.4.1/&gt;&lt;OBR.4.2/&gt;&lt;OBR.4.3/&gt;&lt;OBR.4.4/&gt;&lt;OBR.4.5/&gt;&lt;/OBR.4&gt;
				&lt;OBR.5/&gt;&lt;OBR.6/&gt;&lt;OBR.7/&gt;&lt;OBR.8/&gt;&lt;OBR.9/&gt;
				&lt;OBR.10/&gt;&lt;OBR.11/&gt;&lt;OBR.12/&gt;&lt;OBR.13/&gt;&lt;OBR.14/&gt;&lt;OBR.15/&gt;
				&lt;OBR.16&gt;&lt;OBR.16.1/&gt;&lt;OBR.16.2/&gt;&lt;OBR.16.3/&gt;&lt;OBR.16.4/&gt;&lt;OBR.16.5/&gt;&lt;OBR.16.6/&gt;&lt;OBR.16.7/&gt;&lt;OBR.16.8/&gt;&lt;/OBR.16&gt;
			&lt;/OBR&gt;;


	// Count ORDER groups
	var groupID = ((obj.resource.DiagnosticOrder.id) ? obj.resource.DiagnosticOrder.id.value.toString() : &quot;&quot;);
	var groupCount = groupID.match(/\d+/);
		
	if (groupCount == null) {
		groupCount = 1;
		error.push(&quot;resource.DiagnosticOrder.id element is undefined or not properly formatted, expected: OBR-observation-request-n, where n identifies the order group&quot;);
	}


	// OBR.2 [Placer Order Number] is stored during the DiagnosticReport resource processing	
	var resourceID = obj.resource.DiagnosticOrder.id.value.toString();
	// Extracts the following object - placedOrderNumber = {id:&quot;&quot;, namespaceID:&quot;&quot;, universalID:&quot;&quot;};
	var placedOrderNumber = placedOrderNumberMap.get(resourceID);
	if (placedOrderNumber) {
		if (placedOrderNumber.id) obr[&apos;OBR.2&apos;][&apos;OBR.2.1&apos;] = placedOrderNumber.id.toString();
		if (placedOrderNumber.namespaceID) obr[&apos;OBR.2&apos;][&apos;OBR.2.2&apos;] = placedOrderNumber.namespaceID.toStrign();
		if (placedOrderNumber.universalID) obr[&apos;OBR.2&apos;][&apos;OBR.2.3&apos;] = placedOrderNumber.universalID.toString();
	}
	

	// Universal Service Identifier	
	var alternateID = obj.resource.DiagnosticOrder.item.code.coding.code.value.toString();
	if (alternateID)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.4&apos;] = alternateID;

	var alternateText = obj.resource.DiagnosticOrder.item.code.coding.display.value.toString();
	if (alternateText)
		obr[&apos;OBR.4&apos;][&apos;OBR.4.5&apos;] = alternateText;

	// Observation Date/Time	
	var observationDateTime = obj.resource.DiagnosticOrder.event.dateTime.value.toString();
	if (observationDateTime) {
		// Format : yyyymmddhhmm
		var specimenCollectionDate = convertJSONDateTime(observationDateTime);
		obr[&apos;OBR.7&apos;] = specimenCollectionDate.substring(0, 12);
	}

	// Specimen Action Code
	var actionCode = ((obj.resource.DiagnosticOrder.item.specimen) ? obj.resource.DiagnosticOrder.item.specimen.display.value.toString() : &quot;&quot;);
	if (actionCode)
		obr[&apos;OBR.11&apos;] = actionCode;

	// OBR.16 [Ordering Provider] is filled when resource.Practitioner is processed (see &quot;Provider field&quot; step)
	var orderingProviderReferenceID = ((obj.resource.DiagnosticOrder.event.actor.reference != undefined) ? obj.resource.DiagnosticOrder.event.actor.reference.value.toString() : &quot;&quot;);
	if (orderingProviderReferenceID.indexOf(&quot;Practitioner/&quot;) &gt; -1) {
		orderingProviderReferenceID = orderingProviderReferenceID.substring(13, orderingProviderReferenceID.length);
		var objOrderingProvider = practitionerMap.get(orderingProviderReferenceID.toString());

		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.identifier != undefined) {
			var id = objOrderingProvider.resource.Practitioner.identifier.value.value.toString();
			if (id) obr[&apos;OBR.16&apos;][&apos;OBR.16.1&apos;] = id;
				
			var assigner = objOrderingProvider.resource.Practitioner.identifier.assigner.display.value.toString();
			if (assigner) obr[&apos;OBR.16&apos;][&apos;OBR.16.9&apos;] = assigner;
		}

		// Process ordering provider&apos;s name, DEX name length limitation does NOT apply
		if (objOrderingProvider != null &amp;&amp; objOrderingProvider.resource.Practitioner.name != undefined) {
			var nameParts = processPersonName(objOrderingProvider.resource.Practitioner.name, false);
			obr[&apos;OBR.16&apos;][&apos;OBR.16.2&apos;] = nameParts.family;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.3&apos;] = nameParts.given1;		
			if (nameParts.given1.length &gt; 0) obr[&apos;OBR.16&apos;][&apos;OBR.16.4&apos;] = nameParts.given2;			
		}
	}

	// Store the segment to be later compiled into a message
	observationRequestMap.put(groupCount.toString(), obr.toString());




	// Iterate over all possible comment entries in /text/div/p  (#CS20 certification test case)
	if (obj.resource.DiagnosticOrder.text &amp;&amp; obj.resource.DiagnosticOrder.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;]; // Optional source of comments

		if (obj.resource.DiagnosticOrder.text.div.p.length &amp;&amp; obj.resource.DiagnosticOrder.text.div.p.length &gt; 0) {
			obj.resource.DiagnosticOrder.text.div.p.forEach(function(item){
				// For internal (I) and report (R) comments restriction applies
				if ((item.class.toString() == &quot;I&quot; &amp;&amp; internalCommentsCount++ &lt; 5) || 
					(item.class.toString() == &quot;R&quot; &amp;&amp; reportCommentsCount++ &lt; 2)) {
						comments.push(getNTESegment(item, countNTE++));
						
				} else if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
						// If the comment is other than internal (I) or report (R) then accept
						comments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.DiagnosticOrder.text.div.p) {
			// A single comment from any acceptable source
			sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;, &quot;&quot;];
			if (sourceOfComment.indexOf(obj.resource.DiagnosticOrder.text.div.p.class.toString()) &gt; -1)
				comments.push(getNTESegment(obj.resource.DiagnosticOrder.text.div.p, countNTE++));			
		}

		// Store the comments array to be later compiled into a message
		observationRequestCommentsMap.put(groupCount.toString(), comments);

	}


	return;
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>9</sequenceNumber>
            <name>DG1 segment</name>
            <script>/**
	Populates DG1 [Diagnosis] segment from the Condition resource
	@param {Object} obj - Condition object resource
	@return {String} dg1 - DG1 segment serialized to string
*/
function processCondition(obj, setID) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);

	var dg1 = &lt;DG1&gt;
				&lt;DG1.1&gt;&lt;DG1.1.1&gt;1&lt;/DG1.1.1&gt;&lt;/DG1.1&gt;
				&lt;DG1.3&gt;&lt;DG1.3.1/&gt;&lt;DG1.3.2/&gt;&lt;DG1.3.3/&gt;&lt;DG1.3.4/&gt;&lt;/DG1.3&gt;
				&lt;DG1.6&gt;&lt;DG1.6.1&gt;F&lt;/DG1.6.1&gt;&lt;/DG1.6&gt;
			&lt;/DG1&gt;;

	dg1[&apos;DG1.1&apos;][&apos;DG1.1.1&apos;] = setID;

	// Diagnosis Code
	if (obj.coding) {
		if (obj.coding.length &gt; 0) {
			obj.coding.forEach(function(item){
	
				var code = ((item.code) ? item.code.value.toString() : &quot;&quot;);
				var system = item.system.value.toString().toLowerCase();
			
				if (system)
					if (system.indexOf(&quot;icd-10&quot;) &gt; -1) {
	
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
	
					var text = ((item.display) ? item.display.value.toString() : &quot;&quot;);
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
									
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
				} else {
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;] = code;
				}
			});
		} else {
			var code = ((obj.coding.code) ? obj.coding.code.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
			var text = ((obj.coding.display) ? obj.coding.display.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
		}
	}

	
	// DG1.6 [Diagnosis Type] - hard-coded, required by HL7v2.5.1, F - Final
	//dg1[&apos;DG1.6&apos;][&apos;DG1.6.1&apos;] = &quot;F&quot;;

	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;].toString() == &quot;&quot;) 
			error.push(&quot;resource.Condition.code for DG1.3[Diagnosis Code] is required if IN1.47[Coverage Type] is P or T&quot;);
	}

	return dg1.toString();
	
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>/**
	Populates DG1 [Diagnosis] segment from the Condition resource
	@param {Object} obj - Condition object resource
	@return {String} dg1 - DG1 segment serialized to string
*/
function processCondition(obj, setID) {

	// Retrieve stored coverage type (T, P or C)
	var coverage = channelMap.get(&quot;CoverageType&quot;);

	var dg1 = &lt;DG1&gt;
				&lt;DG1.1&gt;&lt;DG1.1.1&gt;1&lt;/DG1.1.1&gt;&lt;/DG1.1&gt;
				&lt;DG1.3&gt;&lt;DG1.3.1/&gt;&lt;DG1.3.2/&gt;&lt;DG1.3.3/&gt;&lt;DG1.3.4/&gt;&lt;/DG1.3&gt;
				&lt;DG1.6&gt;&lt;DG1.6.1&gt;F&lt;/DG1.6.1&gt;&lt;/DG1.6&gt;
			&lt;/DG1&gt;;

	dg1[&apos;DG1.1&apos;][&apos;DG1.1.1&apos;] = setID;

	// Diagnosis Code
	if (obj.coding) {
		if (obj.coding.length &gt; 0) {
			obj.coding.forEach(function(item){
	
				var code = ((item.code) ? item.code.value.toString() : &quot;&quot;);
				var system = item.system.value.toString().toLowerCase();
			
				if (system)
					if (system.indexOf(&quot;icd-10&quot;) &gt; -1) {
	
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
	
					var text = ((item.display) ? item.display.value.toString() : &quot;&quot;);
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
									
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
				} else {
					dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;] = code;
				}
			});
		} else {
			var code = ((obj.coding.code) ? obj.coding.code.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;] = code;
			var text = ((obj.coding.display) ? obj.coding.display.value.toString() : &quot;&quot;);
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;] = text;
			dg1[&apos;DG1.3&apos;][&apos;DG1.3.3&apos;] = &quot;ICD&quot;;
		}
	}

	
	// DG1.6 [Diagnosis Type] - hard-coded, required by HL7v2.5.1, F - Final
	//dg1[&apos;DG1.6&apos;][&apos;DG1.6.1&apos;] = &quot;F&quot;;

	if (coverage == &quot;P&quot; || coverage == &quot;T&quot;) {
		if (dg1[&apos;DG1.3&apos;][&apos;DG1.3.1&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.2&apos;].toString() == &quot;&quot; || dg1[&apos;DG1.3&apos;][&apos;DG1.3.4&apos;].toString() == &quot;&quot;) 
			error.push(&quot;resource.Condition.code for DG1.3[Diagnosis Code] is required if IN1.47[Coverage Type] is P or T&quot;);
	}

	return dg1.toString();
	
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>10</sequenceNumber>
            <name>OBX segment</name>
            <script>/**
	Populates OBX [Observation/Result] segment from the Observation resource
	@param {Object} obj - Observation object resource
	@return {String} obx - OBX segment serialized to string
*/
function processObservation(obj) {

	var obx =	&lt;OBX&gt;
				&lt;OBX.1&gt;&lt;OBX.1.1/&gt;&lt;/OBX.1&gt;
				&lt;OBX.2&gt;&lt;OBX.2.1/&gt;&lt;/OBX.2&gt;
				&lt;OBX.3&gt;&lt;OBX.3.1/&gt;&lt;OBX.3.2/&gt;&lt;OBX.3.3/&gt;&lt;OBX.3.4/&gt;&lt;OBX.3.5/&gt;&lt;OBX.3.6/&gt;&lt;/OBX.3&gt;
				&lt;OBX.4/&gt;
				&lt;OBX.5&gt;&lt;OBX.5.1/&gt;&lt;/OBX.5&gt;
				&lt;OBX.11&gt;&lt;OBX.11.1&gt;P&lt;/OBX.11.1&gt;&lt;/OBX.11&gt;
			&lt;/OBX&gt;;


	var id = obj.resource.Observation.id.value.toString();
	obx[&apos;OBX.1&apos;][&apos;OBX.1.1&apos;] = id.substring(&quot;OBX-observation-&quot;.length, id.length);

	// Contains a value that reports the results for an AOE
	if (obj.resource.Observation.code) {
		// local code
		var code = obj.resource.Observation.code.coding.code.value.toString();		
		obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;] = code;
		
		// Local description
		var description = obj.resource.Observation.code.coding.display.value.toString();
		obx[&apos;OBX.3&apos;][&apos;OBX.3.5&apos;] = description;

		// Code system - Optional
		if (obj.resource.Observation.code.coding.system != undefined) {
			var codeSystem = obj.resource.Observation.code.coding.system.value.toString();
			if (codeSystem.toLowerCase().indexOf(&quot;snomed&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;SCT&quot;;
			else if (codeSystem.toLowerCase().indexOf(&quot;loinc&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;LN&quot;;
			else 
				delete obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;];
		}
		
	}


	// If valueString is used, expected that the answer is always a string, therefore OBX.2 [Value Type] is hard-coded to &quot;ST&quot;
	if (obj.resource.Observation.valueString) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;ST&quot;;

		var aoe = obj.resource.Observation.valueString.value.toString();
		if (aoe) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = aoe;		

	// If valueQuantity is used the OBX.2 [Value Type] is hard-coded to &quot;NM&quot;	
	} else if (obj.resource.Observation.valueQuantity) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;NM&quot;;		
		var quantity = obj.resource.Observation.valueQuantity.value.value.toString();
		if (quantity) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = quantity;
	}
	

	// Observation Result Status - not required by Quest
	// Hard-coded to &quot;P&quot; - Preliminary


	// OBX level comments (Issue #17)
	var observationComments = [];

	// Iterate over all possible comment entries in /text/div/p  (also see Issue #17)
	if (obj.resource.Observation.text &amp;&amp; obj.resource.Observation.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;,&quot;&quot;]; // Optional source of comment

		if (obj.resource.Observation.text.div.p.length != undefined &amp;&amp; obj.resource.Observation.text.div.p.length &gt; 0) {
			// Several comments from any acceptable sources
			obj.resource.Observation.text.div.p.forEach(function(item){
				if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					observationComments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.Observation.text.div.p) {
			// A single comment from any acceptable source
			if (sourceOfComment.indexOf(obj.resource.Observation.text.div.p.class.toString()) &gt; -1) {
				observationComments.push(getNTESegment(obj.resource.Observation.text.div.p, countNTE++));
			}			
		}
	}

	observationMap.put(id, obx.toString());
	observationCommentsMap.put(id, observationComments);
	
	return;
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>/**
	Populates OBX [Observation/Result] segment from the Observation resource
	@param {Object} obj - Observation object resource
	@return {String} obx - OBX segment serialized to string
*/
function processObservation(obj) {

	var obx =	&lt;OBX&gt;
				&lt;OBX.1&gt;&lt;OBX.1.1/&gt;&lt;/OBX.1&gt;
				&lt;OBX.2&gt;&lt;OBX.2.1/&gt;&lt;/OBX.2&gt;
				&lt;OBX.3&gt;&lt;OBX.3.1/&gt;&lt;OBX.3.2/&gt;&lt;OBX.3.3/&gt;&lt;OBX.3.4/&gt;&lt;OBX.3.5/&gt;&lt;OBX.3.6/&gt;&lt;/OBX.3&gt;
				&lt;OBX.4/&gt;
				&lt;OBX.5&gt;&lt;OBX.5.1/&gt;&lt;/OBX.5&gt;
				&lt;OBX.11&gt;&lt;OBX.11.1&gt;P&lt;/OBX.11.1&gt;&lt;/OBX.11&gt;
			&lt;/OBX&gt;;


	var id = obj.resource.Observation.id.value.toString();
	obx[&apos;OBX.1&apos;][&apos;OBX.1.1&apos;] = id.substring(&quot;OBX-observation-&quot;.length, id.length);

	// Contains a value that reports the results for an AOE
	if (obj.resource.Observation.code) {
		// local code
		var code = obj.resource.Observation.code.coding.code.value.toString();		
		obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;] = code;
		
		// Local description
		var description = obj.resource.Observation.code.coding.display.value.toString();
		obx[&apos;OBX.3&apos;][&apos;OBX.3.5&apos;] = description;

		// Code system - Optional
		if (obj.resource.Observation.code.coding.system != undefined) {
			var codeSystem = obj.resource.Observation.code.coding.system.value.toString();
			if (codeSystem.toLowerCase().indexOf(&quot;snomed&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;SCT&quot;;
			else if (codeSystem.toLowerCase().indexOf(&quot;loinc&quot;) &gt; -1)
				obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;] = &quot;LN&quot;;
			else 
				delete obx[&apos;OBX.3&apos;][&apos;OBX.3.6&apos;];
		}
		
	}


	// If valueString is used, expected that the answer is always a string, therefore OBX.2 [Value Type] is hard-coded to &quot;ST&quot;
	if (obj.resource.Observation.valueString) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;ST&quot;;

		var aoe = obj.resource.Observation.valueString.value.toString();
		if (aoe) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = aoe;		

	// If valueQuantity is used the OBX.2 [Value Type] is hard-coded to &quot;NM&quot;	
	} else if (obj.resource.Observation.valueQuantity) {
		obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;] = &quot;NM&quot;;		
		var quantity = obj.resource.Observation.valueQuantity.value.value.toString();
		if (quantity) obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;] = quantity;
	}
	

	// Observation Result Status - not required by Quest
	// Hard-coded to &quot;P&quot; - Preliminary


	// OBX level comments (Issue #17)
	var observationComments = [];

	// Iterate over all possible comment entries in /text/div/p  (also see Issue #17)
	if (obj.resource.Observation.text &amp;&amp; obj.resource.Observation.text.div) {	
		
		var internalCommentsCount = 0; // only 5 NTE segments of 60 characters each
		var reportCommentsCount = 0; // only 2 NTE segments of 60 characters each
		var sourceOfComment = [&quot;I&quot;,&quot;R&quot;,&quot;L&quot;,&quot;P&quot;,&quot;O&quot;,&quot;&quot;]; // Optional source of comment

		if (obj.resource.Observation.text.div.p.length != undefined &amp;&amp; obj.resource.Observation.text.div.p.length &gt; 0) {
			// Several comments from any acceptable sources
			obj.resource.Observation.text.div.p.forEach(function(item){
				if (sourceOfComment.indexOf(item.class.toString()) &gt; -1) {
					observationComments.push(getNTESegment(item, countNTE++));
				}
			});	
		} else if (obj.resource.Observation.text.div.p) {
			// A single comment from any acceptable source
			if (sourceOfComment.indexOf(obj.resource.Observation.text.div.p.class.toString()) &gt; -1) {
				observationComments.push(getNTESegment(obj.resource.Observation.text.div.p, countNTE++));
			}			
		}
	}

	observationMap.put(id, obx.toString());
	observationCommentsMap.put(id, observationComments);
	
	return;
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>11</sequenceNumber>
            <name>Check for issues</name>
            <script>// Use fixHL7NodeOrder() to fix a possible node order issue 
// see http://www.mirthcorp.com/community/issues/browse/MIRTH-625

var messages = {request: &quot;&quot;, resp: &quot;&quot;};
messages.request = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(fixHL7NodeOrder(oml));

channelMap.put(&quot;omlHL7&quot;, messages.request); // testing
channelMap.put(&quot;error&quot;, error); // testing

logger.debug(&quot;SubmitOrder: Destination - &quot; + messages.request);


// Verify for errors 
if (error.length &gt; 0) {

	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));

	// To be sent to original feed submitter
	responseMap.put(&quot;Outcome&quot;, outcome);

	// Nothing to send to DEX
	channelMap.put(&quot;RequestMessage&quot;, null);
	
} else {

	// Temporary save the OML_O21 message for the next destination to process

//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!	
	channelMap.put(&quot;RequestMessage&quot;, null);
	//var info = {severity: &quot;Information&quot;, code: &quot;Information&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	//(AM) operation outcome mapping expects lowercase; code is &apos;informational&apos; not &apos;information&apos;
	var info = {severity: &quot;information&quot;, code: &quot;informational&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	outcome = getOperationOutcome(error, info, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));	
	responseMap.put(&quot;Outcome&quot;, outcome);

	logger.info(&quot;sent done&quot;);
//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!

	// (SN) Enable this line to actually submit the SubmitOrder request
	channelMap.put(&quot;RequestMessage&quot;, messages.request);
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>// Use fixHL7NodeOrder() to fix a possible node order issue 
// see http://www.mirthcorp.com/community/issues/browse/MIRTH-625

var messages = {request: &quot;&quot;, resp: &quot;&quot;};
messages.request = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(fixHL7NodeOrder(oml));

channelMap.put(&quot;omlHL7&quot;, messages.request); // testing
channelMap.put(&quot;error&quot;, error); // testing

logger.debug(&quot;SubmitOrder: Destination - &quot; + messages.request);


// Verify for errors 
if (error.length &gt; 0) {

	var issue = {severity: &quot;error&quot;, code: &quot;required&quot;, details: &quot;&quot;};
	issue.details = &quot;Submit Order request is not sent. OML_O21 is missing required element&quot; + ((error.length == 1) ? &quot;&quot; : &quot;s&quot;);
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));

	// To be sent to original feed submitter
	responseMap.put(&quot;Outcome&quot;, outcome);

	// Nothing to send to DEX
	channelMap.put(&quot;RequestMessage&quot;, null);
	
} else {

	// Temporary save the OML_O21 message for the next destination to process

//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!	
	channelMap.put(&quot;RequestMessage&quot;, null);
	//var info = {severity: &quot;Information&quot;, code: &quot;Information&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	//(AM) operation outcome mapping expects lowercase; code is &apos;informational&apos; not &apos;information&apos;
	var info = {severity: &quot;information&quot;, code: &quot;informational&quot;, details: &quot;If you see this then the HL7 message is successfully created&quot;};
	outcome = getOperationOutcome(error, info, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));	
	responseMap.put(&quot;Outcome&quot;, outcome);

	logger.info(&quot;sent done&quot;);
//// !!!!!!!!!! TEST ONLY !!!!!!!!!!!!!!

	// (SN) Enable this line to actually submit the SubmitOrder request
	channelMap.put(&quot;RequestMessage&quot;, messages.request);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>JSON</inboundDataType>
        <outboundDataType>XML</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
            <stripNamespaces>true</stripNamespaces>
          </serializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
            <splitType>Element_Name</splitType>
            <elementName></elementName>
            <level>1</level>
            <query></query>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.4.2">
        <steps/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.4.2">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.4.2">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.4.2">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.4.2">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.4.2">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.4.2">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.4.2">
        <rules/>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
    <connector version="3.4.2">
      <metaDataId>1</metaDataId>
      <name>Submit Order WS</name>
      <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.4.2">
        <pluginProperties/>
        <destinationConnectorProperties version="3.4.2">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
        </destinationConnectorProperties>
        <channelId>none</channelId>
        <channelTemplate>${message.encodedData}</channelTemplate>
        <mapVariables/>
      </properties>
      <transformer version="3.4.2">
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>SOAP query</name>
            <script>var 	submitOrderSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
				   &lt;soapenv:Header/&gt;
				   &lt;soapenv:Body&gt;
				      &lt;ord:submitOrder&gt;
				         &lt;ord:SubmitOrderRequest&gt;
				            &lt;hl7Order&gt;OML_O21&lt;/hl7Order&gt;
				         &lt;/ord:SubmitOrderRequest&gt;
				      &lt;/ord:submitOrder&gt;
				   &lt;/soapenv:Body&gt;
				&lt;/soapenv:Envelope&gt;;

var oml = channelMap.get(&quot;RequestMessage&quot;);
if (oml != null &amp;&amp; oml.toString().length() &gt; 0) {
		
	var bytes = new java.lang.String(oml.toString()).getBytes();
	submitOrderSoap.*::Body.*::submitOrder.*::SubmitOrderRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

} else {
	submitOrderSoap = &quot;&quot;;
	return;
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>var 	submitOrderSoap = &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ord=&quot;http://medplus.com/orders&quot;&gt;
				   &lt;soapenv:Header/&gt;
				   &lt;soapenv:Body&gt;
				      &lt;ord:submitOrder&gt;
				         &lt;ord:SubmitOrderRequest&gt;
				            &lt;hl7Order&gt;OML_O21&lt;/hl7Order&gt;
				         &lt;/ord:SubmitOrderRequest&gt;
				      &lt;/ord:submitOrder&gt;
				   &lt;/soapenv:Body&gt;
				&lt;/soapenv:Envelope&gt;;

var oml = channelMap.get(&quot;RequestMessage&quot;);
if (oml != null &amp;&amp; oml.toString().length() &gt; 0) {
		
	var bytes = new java.lang.String(oml.toString()).getBytes();
	submitOrderSoap.*::Body.*::submitOrder.*::SubmitOrderRequest.hl7Order = FileUtil.encode(bytes).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

} else {
	submitOrderSoap = &quot;&quot;;
	return;
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>1</sequenceNumber>
            <name>POST request</name>
            <script>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null &amp;&amp; submitOrderSoap.toString().length &gt; 0) try {
	var error = [];
	var messages = {request: submitOrderSoap.toString(), resp: &quot;&quot;};
	var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};
	sslClient.setURL( $cfg(&quot;submitOrderURL&quot;) );
	sslClient.setSOAPRequest(submitOrderSoap);
	// Submit the request
	var httpCode = sslClient.doPost();

logger.debug (&quot;httpCode is &quot; + httpCode);
	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));
logger.debug (&quot;soapResp is &quot; + soapResp);
	if (200 == httpCode) {

		var orderACK = soapResp.*::Body.*::submitOrderResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String(FileUtil.decode(orderACK));
		messages.resp = ackHL7;
		
		var ack = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(ackHL7));
		channelMap.put(&quot;HL7ACK&quot;, ackHL7);
		// Check Acknowledgment Code: AA - Accept, AE - Error
		if (ack[&apos;MSA&apos;][&apos;MSA.1&apos;][&apos;MSA.1.1&apos;].toString() == &quot;AA&quot;) {
			issue.severity = &quot;information&quot;;
			issue.code = &quot;informational&quot;;
			issue.details = &quot;SUCCESS&quot;;			
		} else {
			// Acknowledgment Code == AE or anything else 
			issue.severity = &quot;error&quot;;
			issue.code = &quot;processing&quot;;
			issue.details = &quot;Order was not successfully processed&quot;;		
			error = ack[&apos;MSA&apos;][&apos;MSA.6&apos;][&apos;MSA.6.2&apos;].toString().split(&quot;,&quot;);	
		} 
		 
	} else {
		// HTTP code is not 200 OK
		issue.severity = &quot;error&quot;;
		issue.code = &quot;processing&quot;;
		issue.details = &quot;HTTP Code: &quot; + httpCode;
	}	
	
} catch(ex) {
	
	issue.severity = &quot;fatal&quot;;
	issue.code = &quot;exception&quot;;
	issue.details = &quot;SubmitOrder WS Transformer: &quot; + ex;
		
} finally {

	// Return submission results
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	responseMap.put(&quot;Outcome&quot;, outcome);
//	logger.debug(&quot;Outcome (Submit Order WS): &quot; + outcome);
}</script>
            <type>JavaScript</type>
            <data>
              <entry>
                <string>Script</string>
                <string>var sslClient = globalChannelMap.get(&quot;sslClientClass&quot;);

if (sslClient != null &amp;&amp; submitOrderSoap.toString().length &gt; 0) try {
	var error = [];
	var messages = {request: submitOrderSoap.toString(), resp: &quot;&quot;};
	var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};
	sslClient.setURL( $cfg(&quot;submitOrderURL&quot;) );
	sslClient.setSOAPRequest(submitOrderSoap);
	// Submit the request
	var httpCode = sslClient.doPost();

logger.debug (&quot;httpCode is &quot; + httpCode);
	// Get the response with all namespeces preserved
	var soapResp = new XML(sslClient.getSOAPResponse(true));
logger.debug (&quot;soapResp is &quot; + soapResp);
	if (200 == httpCode) {

		var orderACK = soapResp.*::Body.*::submitOrderResponse.*::Result.hl7OrderAck.toString();
		var ackHL7 = new java.lang.String(FileUtil.decode(orderACK));
		messages.resp = ackHL7;
		
		var ack = new XML(SerializerFactory.getSerializer(&apos;HL7V2&apos;).toXML(ackHL7));
		channelMap.put(&quot;HL7ACK&quot;, ackHL7);
		// Check Acknowledgment Code: AA - Accept, AE - Error
		if (ack[&apos;MSA&apos;][&apos;MSA.1&apos;][&apos;MSA.1.1&apos;].toString() == &quot;AA&quot;) {
			issue.severity = &quot;information&quot;;
			issue.code = &quot;informational&quot;;
			issue.details = &quot;SUCCESS&quot;;			
		} else {
			// Acknowledgment Code == AE or anything else 
			issue.severity = &quot;error&quot;;
			issue.code = &quot;processing&quot;;
			issue.details = &quot;Order was not successfully processed&quot;;		
			error = ack[&apos;MSA&apos;][&apos;MSA.6&apos;][&apos;MSA.6.2&apos;].toString().split(&quot;,&quot;);	
		} 
		 
	} else {
		// HTTP code is not 200 OK
		issue.severity = &quot;error&quot;;
		issue.code = &quot;processing&quot;;
		issue.details = &quot;HTTP Code: &quot; + httpCode;
	}	
	
} catch(ex) {
	
	issue.severity = &quot;fatal&quot;;
	issue.code = &quot;exception&quot;;
	issue.details = &quot;SubmitOrder WS Transformer: &quot; + ex;
		
} finally {

	// Return submission results
	var outcome = getOperationOutcome(error, issue, messages, channelMap.get(&quot;FeedUUID&quot;), globalChannelMap.get(&quot;outcomeFormat&quot;));
	responseMap.put(&quot;Outcome&quot;, outcome);
//	logger.debug(&quot;Outcome (Submit Order WS): &quot; + outcome);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>JSON</inboundDataType>
        <outboundDataType>XML</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.4.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.4.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
            <stripNamespaces>false</stripNamespaces>
          </serializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
            <splitType>Element_Name</splitType>
            <elementName></elementName>
            <level>1</level>
            <query></query>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.4.2">
        <steps/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>XML</inboundDataType>
        <outboundDataType>XML</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
            <stripNamespaces>false</stripNamespaces>
          </serializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
            <splitType>Element_Name</splitType>
            <elementName></elementName>
            <level>1</level>
            <query></query>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="3.4.2">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="3.4.2">
            <stripNamespaces>false</stripNamespaces>
          </serializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="3.4.2">
            <splitType>Element_Name</splitType>
            <elementName></elementName>
            <level>1</level>
            <query></query>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.4.2">
        <rules/>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
  </destinationConnectors>
  <preprocessingScript>// Modify the message variable below to pre process data

// Delete some characters that may break JSON to XML parsing
message = message.replace(/null/g,&apos;&quot;&quot;&apos;);
message = message.replace(/&amp;/g,&quot;&amp;amp;&quot;); // ampersand
message = message.replace(/&lt;/g,&quot;&amp;lt;&quot;);  // less than
message = message.replace(/&gt;/g,&quot;&amp;gt;&quot;);  // greater than
message = message.replace(/&quot;&quot;&quot;&quot;/g,&apos;&quot;&quot;&apos;); // quotes around quotes

return message;</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data

// Format of the OperationOutcome. Supported: &quot;XML&quot; or &quot;JSON&quot;
globalChannelMap.put(&quot;outcomeFormat&quot;, &quot;XML&quot;);

// Prepare SSL Client to access submitOrder Conformance Environment
if (globalMap.containsKey(&quot;sslClient&quot;) &amp;&amp; globalMap.get(&quot;sslClient&quot;)) 
	try {

		var sslClient = new Packages.org.safemovement.DEXSSLClient();		
		sslClient.setAuthorizationType(org.safemovement.DEXSSLClient.Authorization.BASIC);
		sslClient.setContentType(&quot;text/xml;charset=UTF-8&quot;);
		sslClient.setUserName($(&quot;username&quot;));
		sslClient.setUserPassword($(&quot;userpsw&quot;));		
		sslClient.setConnectionType(&quot;Close&quot;);
		
		globalChannelMap.put(&quot;sslClientClass&quot;, sslClient);
		
	} catch(ex) {
		logger.error(&quot;SubmitOrder: Deploy - cannot initialize SSLClient - &quot; + ex);
		
		// Stop this channel to resolve the problem
		ChannelUtil.stopChannel(channelId);
		throw (&quot;SubmitOrder: Deploy - cannot initialize SSLClient - &quot; + ex);		
	}



return;</deployScript>
  <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data

if (globalChannelMap.containsKey(&quot;sslClientClass&quot;)){
	globalChannelMap.remove(&quot;sslClientClass&quot;);
}


return;</undeployScript>
  <properties version="3.4.2">
    <clearGlobalChannelMap>true</clearGlobalChannelMap>
    <messageStorageMode>DEVELOPMENT</messageStorageMode>
    <encryptData>false</encryptData>
    <removeContentOnCompletion>false</removeContentOnCompletion>
    <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
    <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
    <initialState>STARTED</initialState>
    <storeAttachments>false</storeAttachments>
    <tags class="linked-hash-set"/>
    <metaDataColumns>
      <metaDataColumn>
        <name>SOURCE</name>
        <type>STRING</type>
        <mappingName>mirth_source</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>TYPE</name>
        <type>STRING</type>
        <mappingName>mirth_type</mappingName>
      </metaDataColumn>
    </metaDataColumns>
    <attachmentProperties version="3.4.2">
      <type>None</type>
      <properties/>
    </attachmentProperties>
    <archiveEnabled>true</archiveEnabled>
    <resourceIds class="linked-hash-map">
      <entry>
        <string>Default Resource</string>
        <string>[Default Resource]</string>
      </entry>
    </resourceIds>
  </properties>
  <codeTemplateLibraries>
    <codeTemplateLibrary version="3.4.2">
      <id>aa9b2404-fbde-4bbe-851f-a0a19ca6ae36</id>
      <name>DEX Library</name>
      <revision>5</revision>
      <lastModified>
        <time>1493415645281</time>
        <timezone>UTC</timezone>
      </lastModified>
      <description>Last updated: March 25, 2017</description>
      <includeNewChannels>true</includeNewChannels>
      <enabledChannelIds>
        <string>b73a73d9-b589-4dd7-8a5b-d24fe9ed522d</string>
        <string>afa52ba3-bd0a-4634-8ae5-b9c91c4dc3b9</string>
        <string>9eeed45d-4613-4501-86f1-236e91808742</string>
        <string>4c7bc0bd-aede-4e90-9ce8-cde50750f1e8</string>
        <string>041540bc-16e7-43fe-a9eb-1ca3c5ea17db</string>
        <string>ae149084-1aaa-4867-a7e3-b66860874f05</string>
        <string>829fe0c9-9229-4cb3-9cc3-1250213f284f</string>
        <string>e0f422e1-0550-40f1-8a37-e148e0b5f636</string>
      </enabledChannelIds>
      <disabledChannelIds>
        <string>f24a2bfd-8f45-4170-b6d6-6410f426ec66</string>
      </disabledChannelIds>
      <codeTemplates>
        <codeTemplate version="3.4.2">
          <id>5e2f9cc3-3b23-4967-9fd1-6a9c602dd29e</id>
          <name>Convert FHIR to HL7v2 code</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077779</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts FHIR code to HL7v2 code as defined by the conversion table according to the HL7v2 specification

	@param {String} table - HL7v2 Table code as per specification
	@param {String] value - value to convert
	@return {String} return code according to conversion table
*/
function convertTable(table, value) {

	switch(table) {
		
		// Table 0001 - Administrative Sex
		case &quot;0001&quot;:
			if (value.toString() == &quot;male&quot;) return &quot;M&quot;
			else if (value.toString() == &quot;female&quot;) return &quot;F&quot;
			else if (value.toString() == &quot;other&quot;) return &quot;O&quot;
			else return &quot;U&quot;;
			break;
	}

	return &quot;&quot;;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>025ece06-d4ad-47d7-8047-67acaf3072a5</id>
          <name>Convert HL7 Date Time</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077689</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts date, time and time zone from HL7v2 to ISO 8601 (JSON) format.
	Possible input string format: yyyymmddhhmm[ss[.s[s[s[s]]]]][+/-zzzz]

	@param {String} date - datetime to be converted
	@return {String} return JSON representation of the datetime
*/
function convertHL7DateTime(datetime) {

/*
	Format: yyyymmddhhmm[ss[.s[s[s[s]]]]][+/-zzzz]
	The date and time elements are populated as follows:
	yyyy = Required
	mm = Required if yyyy is not 0000.
	dd = Required if yyyy is not 0000.
	hh = Required if yyyy is not 0000.
	mm = Required if yyyy is not 0000.
	[ss[.s[s[s[s]]]]] = Conditional. Optional if yyyy is not 0000.
	[+/-zzzz] = Optional
*/


	if (datetime == null || datetime.length == 0 || typeof datetime === &quot;undefined&quot;) return &quot;&quot;;

	try {
		var strDateTime = new Packages.java.lang.StringBuffer(datetime.toString());
	
		// Extract time zone
		var index;
		var symbol;
		var timeZone;
		
		if (strDateTime.indexOf(&quot;-&quot;) &gt; 0) {
			index = strDateTime.indexOf(&quot;-&quot;);
		} else if (strDateTime.indexOf(&quot;+&quot;) &gt; 0) {
			index = strDateTime.indexOf(&quot;+&quot;);
		} else
			index = -1;
	
		if (index &gt; 0) {		
			symbol = strDateTime.substring(index, index+1);
			timeZone = new Packages.java.lang.StringBuffer(strDateTime.substring(index+1));
			if (timeZone.length() &gt; 2)
				timeZone.insert(2,&quot;:&quot;);
			strDateTime.delete(index, strDateTime.length());		
		} else {
			symbol = &quot;&quot;;
			timeZone = &quot;&quot;;
		}
	
		// Extract decimal fraction of a second
		var fraction = strDateTime.indexOf(&quot;.&quot;);
		var milliseconds;
		if (fraction &gt; 0) {
			milliseconds = strDateTime.substring(fraction, strDateTime.length());
			strDateTime.delete(fraction, strDateTime.length());
		} else {
			milliseconds = &quot;&quot;;
		}
	
		// Convert the main part
		var jsonDateTime = new Packages.java.lang.StringBuffer(strDateTime);
		
		// yyyyMMdd
		if (strDateTime.length() &gt;= &quot;yyyyMMdd&quot;.length) {
			jsonDateTime.insert(4,&quot;-&quot;);
			jsonDateTime.insert(7,&quot;-&quot;);
		}
	
		// yyyyMMddhh
		if (strDateTime.length() &gt;= &quot;yyyyMMddhh&quot;.length) {
			jsonDateTime.insert(10,&quot;T&quot;);
		}
	
		// yyyyMMddhhmm
		if (strDateTime.length() &gt;= &quot;yyyyMMddhhmm&quot;.length) {
			jsonDateTime.insert(13,&quot;:&quot;);
			
		}
		
		// yyyymmddhhmmss
		if (strDateTime.length() &gt;= &quot;yyyymmddhhmmss&quot;.length) {
			jsonDateTime.insert(16,&quot;:&quot;);		
		}
	
	} catch(ex) {
		jsonDateTime = &quot;0000-00-00&quot;
		milliseconds = &quot;&quot;;
		symbol = &quot;&quot;;
		timeZone = &quot;&quot;;
		logger.error(&quot;convertHL7DateTime(&quot; + datetime + &quot;) exception: &quot; + ex);	
	} finally {
		return jsonDateTime.toString() + milliseconds.toString() + symbol.toString() + timeZone.toString();
	}
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>3d9a32c6-2d37-49d2-afe4-e309356085b7</id>
          <name>Convert JSON Date Time</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609078075</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts date, time and time zone from ISO 8601 (JSON) to HL7v2 format.
	Possible input string format: yyyy-mm-ddThh:mm:ss.nnnnnn+|-hh:mm

	@param {String} date - datetime to be converted
	@return {String} return HL7v2 representation of the datetime
*/
function convertJSONDateTime(datetime) {

/*
	Format: yyyy-mm-dd[Thh:mm[:ss[.nnnnnn[+|-hh:mm]]]]
*/

	var date;
	var time;
	
	var arrDateTime = datetime.split(&quot;T&quot;);
	
	if (arrDateTime.length == 1) {
		date = arrDateTime[0];
		time = &quot;&quot;;
	} else if (arrDateTime.length == 2) {
		date = arrDateTime[0];
		time = arrDateTime[1];
	} else 
		return &quot;&quot;;

	date = date.replace(/\-/g, &quot;&quot;);
	time = time.replace(/\:/g, &quot;&quot;);

	return date + time;

}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>a758235b-06a9-4c9d-8256-e9cd70d38bb1</id>
          <name>Convert Phone</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077936</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Inserts hyphens into the phone number if it is 7 digits in length

	@param {String} phone - initial string to convert
	@return {String} return phone number
*/
function convertPhone(phone) {

	try {
		var strPhone = new Packages.java.lang.StringBuffer(phone.toString());	
		
		if (strPhone.length() == 7) {			
			strPhone.insert(3,&quot;-&quot;);
			strPhone.insert(6,&quot;-&quot;);
			return strPhone.toString();			
		} else 
			return phone.toString();
		
	} catch(ex) {
		return phone.toString();		
	} 
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>dc6049ce-02d8-4022-b10e-6bc9978ab3bd</id>
          <name>Convert XML to JSON</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077867</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts a string in XML format into its JSON representation.
	This function requires org.json.jar to be deployed to the /custom-lib folder on Mirth

	@param {String} input - A string in XML format
	@return {String} return a string representing initial XML feed but in JSON format
*/
function convertXMLtoJSON(input) {
	var strJSON = Packages.org.json.XML.toJSONObject(input.toString());
	return strJSON.toString(2);	
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>2f174050-3927-4c30-a984-26c98e29bd61</id>
          <name>Converts Administrative Gender</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609078148</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Verifies and converts HL7v2 administrative gender value to FHIR value set defined by
	http://hl7.org/fhir/administrative-gender
	
	@param {String} code - HL7v2 PID.8 [Administrative Sex] code
	@return {String} return FHIR value set code
*/
function getGenderValue(code) {

	var gender;

	switch(code) {
		case &quot;M&quot;:
			gender = &quot;male&quot;;
			break;
		case &quot;F&quot;:
			gender = &quot;female&quot;;
		 	break;
		case &quot;O&quot;:
		case &quot;A&quot;:
		case &quot;N&quot;:
			gender = &quot;other&quot;;
			break; 	
		default:
			gender = &quot;unknown&quot;;		 	
	}

	return gender;	
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>943f9793-83e0-403a-84e9-40ea3fcd92d6</id>
          <name>Converts Phone string to XTN</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609078031</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Converts phone number string with caret dividers into XTN data type.
	Supported formats: 1-314-8727127 or 314-8727127
	Returned formats: ^^PH^^1^314^8727127 or ^^PH^^^314^8727127 or ^^PH^^^^8727127

	@param {String} phone - Phone string in one of the supported format
	@return {String} return Phone string as per XTN data type
*/
function convertPhoneXTN(phone) {

	phone = phone.replace(/\+/g,&quot;&quot;);

	// XTN data type example: ^^PH^^^734^6777777

	//	    916-3000		\d{3}-\d{4}			^^PH^^^^9163000
	//	    9163000		\d{7}				^^PH^^^^9163000
	//   972-9163000		\d{3}-\d{7}			^^PH^^^972^9163000
	//   972-916-3000  		\d{3}-\d{3}-\d{4}		^^PH^^^972^9163000
	// 1-972-9163000 		\d{1}-\d{3}-\d{7}		^^PH^^1^972^9163000
	// 1-972-916-3000 		\d{1}-\d{3}-\d{3}-\d{4}	^^PH^^1^972^9163000

	var arrPhone = phone.split(&quot;-&quot;);
	if (arrPhone.length &lt;= 1) return &quot;^^^^^^^^&quot; + phone;

	// 1-972-9163000
	if (phone.match(/\d{1}-\d{3}-\d{7}/) != null) {
		// ^^PH^^1^734^6777777
		return &quot;^^PH^^&quot; + arrPhone[0] + &quot;^&quot; + arrPhone[1] + &quot;^&quot; + arrPhone[2];

	// 1-972-916-3000	
	} else if (phone.match(/\d{1}-\d{3}-\d{3}-\d{4}/) != null) {
		// ^^PH^^1^734^6777777
		return &quot;^^PH^^&quot; + arrPhone[0] + &quot;^&quot; + arrPhone[1] + &quot;^&quot; + arrPhone[2] + arrPhone[3];

	// 972-9163000	
	} else if (phone.match(/\d{3}-\d{7}/) != null) {
		// ^^PH^^^734^6777777
		return &quot;^^PH^^^&quot; + arrPhone[0] + &quot;^&quot; + arrPhone[1];

	// 972-916-3000
	} else if (phone.match(/\d{3}-\d{3}-\d{4}/) != null) {
		// ^^PH^^^972^9163000
		return &quot;^^PH^^^&quot; + arrPhone[0] + &quot;^&quot; + arrPhone[1] + arrPhone[2];

	// 9163000
	} else if (phone.match(/\d{7}/) != null) {
		// ^^PH^^^^9163000
		return &quot;^^PH^^^^&quot; + arrPhone[0];

	// 916-3000
	} else if (phone.match(/\d{3}-\d{4}/) != null) {
		// ^^PH^^^^9163000
		return &quot;^^PH^^^^&quot; + arrPhone[0] + arrPhone[1];
		
	} else
		return &quot;^^^^^^^^&quot; + phone; 

}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>58a19daa-aada-46ac-ae7f-2b5e5848405b</id>
          <name>Create OperationOutcome resource</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077663</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Creates OperationOutcome resource to inform about validation errors
	
	@param {Array} error - A list of errors or comments
	@param {Object} issue - An object with severity, code and details associated with outcome
	@param {Object} messages - An object with inbounb and outbound messages to be logged
	@param {String} uuid - A string with uuid to pair request and response FHIR feeds	
	@param {String} format - A resource output format (xml | json)	
	@return {String} outcome - OperationOutcome resource in required format
*/
function getOperationOutcome(error, issue, messages, uuid, format) {

	// Expected issue object format:
	// var issue = {severity: &quot;&quot;, code: &quot;&quot;, details: &quot;&quot;};

	// Expected messages object format:
	// var messages = {request: &quot;&quot;, resp: &quot;&quot;};

	// Namespaces are required to validate against FHIR XML Schema
	if (format.toUpperCase() != &quot;JSON&quot;) 
		default xml namespace = &quot;http://hl7.org/fhir&quot;;
		
	var outcome = &lt;OperationOutcome&gt;
				&lt;id value=&quot;responsestatus&quot;/&gt;
				&lt;extension url=&quot;request&quot;&gt;
					&lt;valueBase64Binary value=&quot;&quot;/&gt;
				&lt;/extension&gt;
				&lt;extension url=&quot;response&quot;&gt;
					&lt;valueBase64Binary value=&quot;&quot;/&gt;
				&lt;/extension&gt;
				&lt;issue&gt;
					&lt;severity value=&quot;&quot;/&gt;
					&lt;code value=&quot;&quot;/&gt;
					&lt;details&gt;
						&lt;text value=&quot;&quot;/&gt;
					&lt;/details&gt;
				&lt;/issue&gt;
			&lt;/OperationOutcome&gt;;

	if (uuid != null &amp;&amp; uuid != undefined &amp;&amp; uuid.toString() != &quot;&quot;) 
		outcome.id.@value = &quot;responsestatus&quot; + uuid;
		
	outcome.issue.severity.@value = issue.severity;
	outcome.issue.code.@value = issue.code;
	outcome.issue.details.text.@value = issue.details;

	// xhtml namespace is intentionally removed
	var text = &lt;text&gt;
			    	&lt;status value=&quot;generated&quot;/&gt;
			    	&lt;div/&gt;
			  &lt;/text&gt;;

	text.div.* = new XMLList();
	error.forEach(function(n){
	  text.div.* += new XML(&quot;&lt;p&gt;&quot; + n +&quot;&lt;/p&gt;&quot;);
	});

	outcome.id += text;

	// If request or response messages are available, encode them
	if (messages.request != undefined &amp;&amp; messages.request.toString() != &quot;&quot;) 
		outcome.extension.(@url == &quot;request&quot;)[0].valueBase64Binary.@value = getBase64Encoded(messages.request.toString());	
	else
		delete outcome.extension.(@url == &quot;request&quot;)[0];


	if (messages.resp != undefined &amp;&amp; messages.resp.toString() != &quot;&quot;) 	
		outcome.extension.(@url == &quot;response&quot;)[0].valueBase64Binary.@value = getBase64Encoded(messages.resp.toString());
	else
		delete outcome.extension.(@url == &quot;response&quot;)[0];

	// Convert to a requested format
	if (format.toUpperCase() == &quot;JSON&quot;) {
		return convertXMLtoJSON(outcome.toString());		
	} else {
		// Namespace is required to validate FHIR XML
		outcome = outcome.toString().replace(&apos;&lt;div&gt;&apos;, &apos;&lt;div  xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&apos;);
		return outcome.toString();
	}
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>52360391-d3f2-4714-8bd3-98c53c85c387</id>
          <name>Fix HL7v2 node order</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077814</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Returns a new E4X node where the order of all siblings and descendants have been fixed as per the Mirth HL7 dot notation convention.
	@param {String} node - The node to be fixed
	@return {String} return - E4X node
*/
/*
	Author: Nick Rupley
	Date Modified: 4/18/2012
*/
function fixHL7NodeOrder(node) {
	// Create output node
	var newNode = new XML();
	// In case the node is an XMLList of multiple siblings, loop through each sibling
	for each (sibling in node) {
		// Create new sibling node
		var newSibling = new XML(&apos;&lt;&apos;+sibling.name().toString()+&apos;/&gt;&apos;);
		// Iterate through each child node
		for each (child in sibling.children())
			// If the child has its own children, then recursively fix the node order of the child
			if (child.hasComplexContent())
				newSibling.appendChild(fixHL7NodeOrder(child));
			// If the child doesn&apos;t have its own children, then just add the child to the new sibling node
			else
				newSibling.appendChild(child);
		// After recursively fixing all of the child nodes, now we&apos;ll fix the current node
		newNode += sortHL7Node(newSibling);
	}
	// Return the fixed node
	return newNode;
}

// Helper function for fixHL7NodeOrder
function sortHL7Node(node) {
	// If the node has no children, then there&apos;s nothing to sort
	if (node.hasSimpleContent())
		return node;
	// Create new output node
	var newNode = new XML(&apos;&lt;&apos;+node.name().toString()+&apos;/&gt;&apos;);
	// Iterate through each child in the node
	for each (child in node.children()) {
		// If the child has a QName, then we can sort on it
		if (child.name()) {
			// Get the current &quot;index&quot; of the child. Id est, if the QName is PID.3.1, then the index is 1
			curChildIndex = parseInt(child.name().toString().substring(child.name().toString().lastIndexOf(&apos;.&apos;)+1),10);
			// Boolean placeholder
			var inserted = false;
			// Iterate through each child currently in the NEW node
			for (var i = 0; i &lt;= newNode.children().length()-1; i++) {
				// Get the index of the child of the new node
				loopChildIndex = parseInt(newNode.child(i).name().toString().substring(newNode.child(i).name().toString().lastIndexOf(&apos;.&apos;)+1),10);
				// If the child we want to insert has a lower index then the current child of the new node, then we&apos;re going to insert the child 
				// right before the current newNode child
				if (curChildIndex &lt; loopChildIndex) {
					// Insert the child
					newNode.insertChildBefore(newNode.children()[i],child);
					// Set our flag, indicating that an insertion was made
					inserted = true;
					// No need to continue iteration
					break;
				}
			}
			// If no insertion was made, then the index of the child we want to insert is greater than or equal to all of the
			// indices of the children that have already been inserted in newNode. So, we&apos;ll just append the child to the end.
			if (!inserted)
				newNode.appendChild(child);
		}
	}
	// Return the sorted HL7 node
	return newNode;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>711f9e92-9872-4718-83aa-f8e62e3885b2</id>
          <name>Get Base64 encoded string</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077840</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Encodes given string into a Base64 string.

	@param {String} strData - String to be encoded
	@return {String} return Base64 encoded string
*/
function getBase64Encoded(strData) {
	
	try {
		
		if (null == strData) strData = &apos;&apos;;
		var byteData = new Packages.java.lang.String(strData).getBytes();
		return FileUtil.encode(byteData).replaceAll(&apos;\r\n|\r|\n&apos;, &apos;&apos;);

	} catch(err) {
		logger.error(err);
		return &quot;&quot;;
	}
}
</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>872dae30-3381-458c-a4e5-4f412e21b1fa</id>
          <name>Get HL7v2 Code Description</name>
          <revision>1</revision>
          <lastModified>
            <time>1490476779449</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Retrieve code description for a given HL7v2 table (to be used for ORC, OBR and OBX segments)

	@param {String} table - HL7v2 Table code as per specification
	@param {String] value - value to convert
	@return {String} return code description
*/
function getHL7v2CodeDescription(table, value) {

	switch(table) {
		
		// Table 0038 - Order Status
		case &quot;0038&quot;:
			if (&quot;CM&quot; === value.toString()) return &quot;Order complete&quot;
			else if (&quot;IP&quot; === value.toString()) return &quot;Order incomplete, or contains pending items&quot;
			else if (&quot;CA&quot; === value.toString()) return &quot;Order was canceled&quot;
			else if (&quot;DC&quot; === value.toString()) return &quot;Order was discontinued&quot;
			else if (&quot;ER&quot; === value.toString()) return &quot;Error, order not found&quot;
			else if (&quot;HD&quot; === value.toString()) return &quot;Order is on hold&quot;
			else if (&quot;RP&quot; === value.toString()) return &quot;Order has been replaced&quot;
			else if (&quot;SC&quot; === value.toString()) return &quot;In process, scheduled&quot;
			else if (&quot;&quot; === value.toString()) return &quot;&quot;
			else return &quot;&quot;;
			break;

		// Table 0123 - Result Status
		case &quot;0123&quot;:
			if (&quot;F&quot; === value.toString()) return &quot;Final results&quot;
			else if (&quot;A&quot; === value.toString()) return &quot;Partial results&quot;
			else if (&quot;C&quot; === value.toString()) return &quot;Correction to results&quot;
			else if (&quot;I&quot; === value.toString()) return &quot;No results available. The specimen was received, but the procedure is incomplete.&quot;
			else if (&quot;O&quot; === value.toString()) return &quot;Specimen not yet received&quot;
			else if (&quot;P&quot; === value.toString()) return &quot;Preliminary results&quot;
			else if (&quot;R&quot; === value.toString()) return &quot;Results stored&quot;
			else if (&quot;S&quot; === value.toString()) return &quot;No results available. The procedure is scheduled, but has not been performed.&quot;
			else if (&quot;X&quot; === value.toString()) return &quot;No results available. The order was canceled.&quot;
			else return &quot;&quot;;		
			break;

		// Table 0085 - Observation Result Status
		case &quot;0085&quot;:
			if (&quot;F&quot; === value.toString()) return &quot;Final results; can only be changed with a corrected result.&quot;
			else if (&quot;D&quot; === value.toString()) return &quot;Deletes the OBX record&quot;
			else if (&quot;I&quot; === value.toString()) return &quot;Specimen in lab; results pending.&quot;
			else if (&quot;N&quot; === value.toString()) return &quot;Not asked; used to affirmatively document that the observation identified in the OBX was not sought when the universal service ID in OBR.04 implies that it would be sought.&quot;
			else if (&quot;O&quot; === value.toString()) return &quot;Order detail description only (no result)&quot;
			else if (&quot;P&quot; === value.toString()) return &quot;Preliminary results&quot;
			else if (&quot;R&quot; === value.toString()) return &quot;Results entered but not verified&quot;
			else if (&quot;X&quot; === value.toString()) return &quot;Results cannot be obtained for this observation&quot;
			else if (&quot;U&quot; === value.toString()) return &quot;Results status change to final without retransmitting results already sent as preliminary. For example, radiology changes status from preliminary to final.&quot;
			else if (&quot;W&quot; === value.toString()) return &quot;Post original as wrong. For example, transmitted for wrong patient.&quot;
			else return &quot;&quot;;
			break;
	}

	return &quot;&quot;;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>53e03352-fda6-455a-bc6a-54f1b3287838</id>
          <name>Get NTE segment</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077721</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Builds NTE segment with the comment entry from a single /text/div/p resource element
	Expected comment entry object is {&quot;class&quot;:&quot;&quot;,&quot;content&quot;:&quot;&quot;}

	// TODO: may require a flag to NOT restrict comment line longer than 60 chars as required for the Order message

	@param {String} entry - JSON object with comment entries
	@param {String} count - total NTE segment count i.e., NTE.1 [Set ID]	
	@return {String} return NTE segment string in XML format
*/
function getNTESegment(entry, count) {

	if (entry != undefined) {

		var nte = &lt;NTE&gt;
					&lt;NTE.1&gt;
						&lt;NTE.1.1&gt;&lt;/NTE.1.1&gt;
					&lt;/NTE.1&gt;
					&lt;NTE.2&gt;
						&lt;NTE.2.1&gt;&lt;/NTE.2.1&gt;
					&lt;/NTE.2&gt;
					&lt;NTE.3&gt;
						&lt;NTE.3.1&gt;&lt;/NTE.3.1&gt;
					&lt;/NTE.3&gt;
				&lt;/NTE&gt;;

		// NTE.1 [Set ID]		
		nte[&apos;NTE.1&apos;][&apos;NTE.1.1&apos;] = count;
			
		// NTE.2 [Source of Comment]
		nte[&apos;NTE.2&apos;][&apos;NTE.2.1&apos;] = entry.class.toString();

		// NTE.3 [Comment]
		// Comment shall be no longer than 60 characters for the OML_O21 Submit Order message
		if (entry.content.toString().length &gt; 60)
			entry.content = entry.content.toString().substring(0,60);
			
		nte[&apos;NTE.3&apos;][&apos;NTE.3.1&apos;] = entry.content.toString();

		return nte.toString();
		
	} else 
		return &quot;&quot;;
		
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>0f2c8346-d098-49b3-8e97-184eef9fc7b4</id>
          <name>HTTP Response Code indications</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077971</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Add the HTTP response status code description to the HTTP code

	@param {Integer} code - HTTP response status code
	@return {String} return HTTP response status code and its description
*/
function getHttpCodeDescription(code) {

	var text;
	
	switch(code) {
		case 200:
			text = &quot;OK&quot;;
			break;
		case 400:
			text = &quot;The request was not properly constructed&quot;;
			break;
		case 401:
			text = &quot;The user credentials submitted are not authorized&quot;;
			break;
		case 403:
			text = &quot;The user name submitted does not have permission to access the Results RESTful web service&quot;;
			break;
		case 404:
			text = &quot;The user credentials submitted are not authorized&quot;;
			break;
		case 500:
			text = &quot;An internal server error occurred&quot;;
			break;	        
		default:
			text = &quot;This response status code is undefined in the DEX spec&quot;;
	}

	return (code + &quot; - &quot; + text);
	
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>5032a64e-7da6-4885-83e2-348e5ab75600</id>
          <name>Parse person&apos;s name node</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077624</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Process Person.name element with zero or multiple given names with possible DEX name length limitation

	@param {Object} item - JSON representation of /resource/Person/name node
	@param {Boolean} lengthLimit - If person&apos;s name limitation applies according to DEX spec (true - apply, false - does not)	
	@return {Object} return name parts object with family and given names
*/
function processPersonName(item, lengthLimit) {

	var nameParts = {family: &quot;&quot;, given1: &quot;&quot;, given2: &quot;&quot;};

	if (item.family != null &amp;&amp; item.family != undefined) {
		
		// Last name of the person
		var family = item.family.value.toString();
		
		// If Quest&apos;s length limit applies
		if (lengthLimit) {
			// The last name can be a maximum of 20 characters. (p.201)
			if (family.length &gt; 20) 
				family = family.substring(0, 20);
			// The entire patient name cannot exceed 24 characters (p.201)
			var limit = 24 - family.length;
		}
		nameParts.family = family;
	}

	if (item.given == null || item.given == undefined) return nameParts;
		
	if (item.given.length != undefined) {
		
		var count = 0;
		item.given.forEach(function(entry){
			var given = entry.value.toString();
			
			if (given.length &gt; 0) {					
				if (0 == count) {
					// The first name is limited to the difference between the number of characters in the last name and 24.				
					if (given.length &gt; limit &amp;&amp; lengthLimit) given = given.substring(0, limit);
					nameParts.given1 = given;
					limit -= given.length;
				} else {
					// if the limit is exceeded, a minimum of the first character of the middle initial is always returned in the result message.
					if (given.length &gt; limit &amp;&amp; lengthLimit) given = given.substring(0, 1);
					nameParts.given2 = given;
				}
			}
			count++;
		});			
	} else {
		var given = item.given.value.toString();
		if (given.length &gt; limit &amp;&amp; lengthLimit) given = given.substring(0, limit);
		nameParts.given1 = given;
	}

	return nameParts;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>08f30179-5465-4895-a2d3-4933f182035e</id>
          <name>Remove illegal XML chanracters</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609078114</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Strip non valid XML characters from a given text string.
	CAUTION: This is not a full-fledged function for XML input sanitization 

	@param {String} text - text string that may contain illegal XML characters
	@return {String} return text string with illegal XML characters replaced
*/
function stripNonValidXMLChars(text) {

	if (text == null || text == undefined || text.toString().length == 0) return &quot;&quot;;

	//text = comment.replace(/&amp;/g,&quot;&amp;amp;&quot;);// ampersand - (SN) temporary disabled
	text = text.replace(/&lt;/g,&quot;&amp;lt;&quot;); // less than
	text = text.replace(/&gt;/g,&quot;&amp;gt;&quot;); // greater than
	text = text.replace(/&apos;/g,&quot;&amp;apos;&quot;); // single quotes
	text = text.replace(/&quot;/g,&quot;&amp;apos;&quot;); // double quotes

	// (SN) Issue #6, #11: unexpected &quot;%&quot; in field
	text = text.replace(/\|%/g, &quot;|&quot;);

	return text;
}</code>
        </codeTemplate>
        <codeTemplate version="3.4.2">
          <id>15559e88-2f64-415a-8544-9cbbc2742c79</id>
          <name>Verifies if Lab test is STD</name>
          <revision>1</revision>
          <lastModified>
            <time>1489609077902</time>
            <timezone>UTC</timezone>
          </lastModified>
          <type>FUNCTION</type>
          <contextSet>
            <delegate>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
            </delegate>
          </contextSet>
          <code>/**
	Verifies if the submitted Lab test code is in the list of STD lab tests

	@param {String} code - Lab test code
	@return {String} return true if Lab test code in the list of STD codes, false otherwise
*/
function isSTDLabTest(code) {

	// Check for LOINC codes
	switch(code) {
		// 86631, 86632 Chlamydia trachomatis Antibodies 
		case &quot;1833274&quot;:
		case &quot;1832970&quot;:
		case &quot;1833579&quot;:
		case &quot;44079-2&quot;:
		// 87591 Neisseria gonorrhoeae
		case &quot;43305-2&quot;:
		// 86704	Hepatitis A
		case &quot;13951-9&quot;:
		// 87340	Hepatitis B
		case &quot;1203841&quot;:
		case &quot;2193342&quot;:
		case &quot;10900-9&quot;:
		case &quot;13952-7&quot;:
		// 81001	Hepatitis C (Urinalysis, Complete)
		case &quot;13955-0&quot;:
		case &quot;48159-8&quot;:
		// 86695	Herpes Simplex Virus 1 (IgG)
		case &quot;1207706&quot;:
		// 86696	Herpes Simplex Virus 2 (IgG)
		case &quot;1208621&quot;:
		// 86592	VDRL, Serum (Syphilis)
		case &quot;1239118&quot;:
		// 86701	HIV-1 Antibody
		case &quot;29893-5&quot;:
		// 86702	HIV-2 Antibody
		case &quot;30361-0&quot;:
		// 87389	HIV-1/2 Antig. and Antib.,4th Gen
		case &quot;56888-1&quot;:
			return true;
			break;
	}

	return false;
	
}</code>
        </codeTemplate>
      </codeTemplates>
    </codeTemplateLibrary>
  </codeTemplateLibraries>
</channel>